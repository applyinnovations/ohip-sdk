/*
OPERA Cloud Event Configuration API

This API caters for Event Configuration in OPERA Cloud. <br /><There are operations to post, update, fetch and delete codes such as item inventory, function spaces, menu items and many more.<br /><br /> Compatible with OPERA Cloud release 24.4.<br /><br /><p> This document and all content within is available under the Universal Permissive License v 1.0 (https://oss.oracle.com/licenses/upl). Copyright (c) 2020, 2024 Oracle and/or its affiliates.</p>

API version: 24.4
Contact: hospitality_apis_ww_grp@oracle.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package evmcfg

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// ResourceConfigAPIService ResourceConfigAPI service
type ResourceConfigAPIService service

type ResourceConfigAPICheckDiscountAvailableRequest struct {
	ctx context.Context
	ApiService *ResourceConfigAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ResourceConfigAPICheckDiscountAvailableRequest) Authorization(authorization string) ResourceConfigAPICheckDiscountAvailableRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ResourceConfigAPICheckDiscountAvailableRequest) XAppKey(xAppKey string) ResourceConfigAPICheckDiscountAvailableRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ResourceConfigAPICheckDiscountAvailableRequest) XHotelid(xHotelid string) ResourceConfigAPICheckDiscountAvailableRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ResourceConfigAPICheckDiscountAvailableRequest) XExternalsystem(xExternalsystem string) ResourceConfigAPICheckDiscountAvailableRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ResourceConfigAPICheckDiscountAvailableRequest) AcceptLanguage(acceptLanguage string) ResourceConfigAPICheckDiscountAvailableRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ResourceConfigAPICheckDiscountAvailableRequest) Execute() (*CheckedDiscountAvailable, *http.Response, error) {
	return r.ApiService.CheckDiscountAvailableExecute(r)
}

/*
CheckDiscountAvailable Check if discount is available

Check if discount is available <p><strong>OperationId:</strong>checkDiscountAvailable</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique OPERA Hotel Id
 @return ResourceConfigAPICheckDiscountAvailableRequest
*/
func (a *ResourceConfigAPIService) CheckDiscountAvailable(ctx context.Context, hotelId string) ResourceConfigAPICheckDiscountAvailableRequest {
	return ResourceConfigAPICheckDiscountAvailableRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CheckedDiscountAvailable
func (a *ResourceConfigAPIService) CheckDiscountAvailableExecute(r ResourceConfigAPICheckDiscountAvailableRequest) (*CheckedDiscountAvailable, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CheckedDiscountAvailable
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResourceConfigAPIService.CheckDiscountAvailable")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/discountAvailable/check"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ResourceConfigAPICopyCateringMenuItemClassesRequest struct {
	ctx context.Context
	ApiService *ResourceConfigAPIService
	cateringMenuItemClassesCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	cateringMenuItemClassesCopy *CateringMenuItemClassesCopy
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ResourceConfigAPICopyCateringMenuItemClassesRequest) Authorization(authorization string) ResourceConfigAPICopyCateringMenuItemClassesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ResourceConfigAPICopyCateringMenuItemClassesRequest) XAppKey(xAppKey string) ResourceConfigAPICopyCateringMenuItemClassesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ResourceConfigAPICopyCateringMenuItemClassesRequest) XHotelid(xHotelid string) ResourceConfigAPICopyCateringMenuItemClassesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for Copying Menu Item Classes.
func (r ResourceConfigAPICopyCateringMenuItemClassesRequest) CateringMenuItemClassesCopy(cateringMenuItemClassesCopy CateringMenuItemClassesCopy) ResourceConfigAPICopyCateringMenuItemClassesRequest {
	r.cateringMenuItemClassesCopy = &cateringMenuItemClassesCopy
	return r
}

// External system code.
func (r ResourceConfigAPICopyCateringMenuItemClassesRequest) XExternalsystem(xExternalsystem string) ResourceConfigAPICopyCateringMenuItemClassesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ResourceConfigAPICopyCateringMenuItemClassesRequest) AcceptLanguage(acceptLanguage string) ResourceConfigAPICopyCateringMenuItemClassesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ResourceConfigAPICopyCateringMenuItemClassesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.CopyCateringMenuItemClassesExecute(r)
}

/*
CopyCateringMenuItemClasses Copy menu item classes

You can use this API to copy menu item classes. <p><strong>OperationId:</strong>copyCateringMenuItemClasses</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cateringMenuItemClassesCode Unique Menu Item Class Id
 @return ResourceConfigAPICopyCateringMenuItemClassesRequest
*/
func (a *ResourceConfigAPIService) CopyCateringMenuItemClasses(ctx context.Context, cateringMenuItemClassesCode string) ResourceConfigAPICopyCateringMenuItemClassesRequest {
	return ResourceConfigAPICopyCateringMenuItemClassesRequest{
		ApiService: a,
		ctx: ctx,
		cateringMenuItemClassesCode: cateringMenuItemClassesCode,
	}
}

// Execute executes the request
//  @return Status
func (a *ResourceConfigAPIService) CopyCateringMenuItemClassesExecute(r ResourceConfigAPICopyCateringMenuItemClassesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResourceConfigAPIService.CopyCateringMenuItemClasses")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cateringMenuItemClasses/{cateringMenuItemClassesCode}/copy"
	localVarPath = strings.Replace(localVarPath, "{"+"cateringMenuItemClassesCode"+"}", url.PathEscape(parameterValueToString(r.cateringMenuItemClassesCode, "cateringMenuItemClassesCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.cateringMenuItemClassesCode) < 1 {
		return localVarReturnValue, nil, reportError("cateringMenuItemClassesCode must have at least 1 elements")
	}
	if strlen(r.cateringMenuItemClassesCode) > 2000 {
		return localVarReturnValue, nil, reportError("cateringMenuItemClassesCode must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.cateringMenuItemClassesCopy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ResourceConfigAPICopyCateringMenuItemsRequest struct {
	ctx context.Context
	ApiService *ResourceConfigAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	cateringMenuItemsCopy *CateringMenuItemsCopy
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ResourceConfigAPICopyCateringMenuItemsRequest) Authorization(authorization string) ResourceConfigAPICopyCateringMenuItemsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ResourceConfigAPICopyCateringMenuItemsRequest) XAppKey(xAppKey string) ResourceConfigAPICopyCateringMenuItemsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ResourceConfigAPICopyCateringMenuItemsRequest) XHotelid(xHotelid string) ResourceConfigAPICopyCateringMenuItemsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for Copying Menu Items.
func (r ResourceConfigAPICopyCateringMenuItemsRequest) CateringMenuItemsCopy(cateringMenuItemsCopy CateringMenuItemsCopy) ResourceConfigAPICopyCateringMenuItemsRequest {
	r.cateringMenuItemsCopy = &cateringMenuItemsCopy
	return r
}

// External system code.
func (r ResourceConfigAPICopyCateringMenuItemsRequest) XExternalsystem(xExternalsystem string) ResourceConfigAPICopyCateringMenuItemsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ResourceConfigAPICopyCateringMenuItemsRequest) AcceptLanguage(acceptLanguage string) ResourceConfigAPICopyCateringMenuItemsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ResourceConfigAPICopyCateringMenuItemsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.CopyCateringMenuItemsExecute(r)
}

/*
CopyCateringMenuItems Operation to copy catering menu items.

 <p><strong>OperationId:</strong>copyCateringMenuItems</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique OPERA Hotel Id
 @return ResourceConfigAPICopyCateringMenuItemsRequest
*/
func (a *ResourceConfigAPIService) CopyCateringMenuItems(ctx context.Context, hotelId string) ResourceConfigAPICopyCateringMenuItemsRequest {
	return ResourceConfigAPICopyCateringMenuItemsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ResourceConfigAPIService) CopyCateringMenuItemsExecute(r ResourceConfigAPICopyCateringMenuItemsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResourceConfigAPIService.CopyCateringMenuItems")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/cateringMenuItems/copy"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.cateringMenuItemsCopy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ResourceConfigAPICopyCateringMenusRequest struct {
	ctx context.Context
	ApiService *ResourceConfigAPIService
	cateringMenuId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	cateringMenusCopy *CateringMenusCopy
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ResourceConfigAPICopyCateringMenusRequest) Authorization(authorization string) ResourceConfigAPICopyCateringMenusRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ResourceConfigAPICopyCateringMenusRequest) XAppKey(xAppKey string) ResourceConfigAPICopyCateringMenusRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ResourceConfigAPICopyCateringMenusRequest) XHotelid(xHotelid string) ResourceConfigAPICopyCateringMenusRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for copying a Menu.
func (r ResourceConfigAPICopyCateringMenusRequest) CateringMenusCopy(cateringMenusCopy CateringMenusCopy) ResourceConfigAPICopyCateringMenusRequest {
	r.cateringMenusCopy = &cateringMenusCopy
	return r
}

// External system code.
func (r ResourceConfigAPICopyCateringMenusRequest) XExternalsystem(xExternalsystem string) ResourceConfigAPICopyCateringMenusRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ResourceConfigAPICopyCateringMenusRequest) AcceptLanguage(acceptLanguage string) ResourceConfigAPICopyCateringMenusRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ResourceConfigAPICopyCateringMenusRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.CopyCateringMenusExecute(r)
}

/*
CopyCateringMenus Copy a menu

Copy a menu for a property. <p><strong>OperationId:</strong>copyCateringMenus</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cateringMenuId Unique ID of Catering Menu
 @param hotelId Unique OPERA Hotel Id
 @return ResourceConfigAPICopyCateringMenusRequest
*/
func (a *ResourceConfigAPIService) CopyCateringMenus(ctx context.Context, cateringMenuId string, hotelId string) ResourceConfigAPICopyCateringMenusRequest {
	return ResourceConfigAPICopyCateringMenusRequest{
		ApiService: a,
		ctx: ctx,
		cateringMenuId: cateringMenuId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ResourceConfigAPIService) CopyCateringMenusExecute(r ResourceConfigAPICopyCateringMenusRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResourceConfigAPIService.CopyCateringMenus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/cateringMenus/{cateringMenuId}/copy"
	localVarPath = strings.Replace(localVarPath, "{"+"cateringMenuId"+"}", url.PathEscape(parameterValueToString(r.cateringMenuId, "cateringMenuId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.cateringMenuId) < 1 {
		return localVarReturnValue, nil, reportError("cateringMenuId must have at least 1 elements")
	}
	if strlen(r.cateringMenuId) > 2000 {
		return localVarReturnValue, nil, reportError("cateringMenuId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.cateringMenusCopy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ResourceConfigAPICopyCateringPackageRequest struct {
	ctx context.Context
	ApiService *ResourceConfigAPIService
	hotelId string
	cateringPackageId string
	authorization *string
	xAppKey *string
	xHotelid *string
	copyCateringPackageType *CopyCateringPackageType
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ResourceConfigAPICopyCateringPackageRequest) Authorization(authorization string) ResourceConfigAPICopyCateringPackageRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ResourceConfigAPICopyCateringPackageRequest) XAppKey(xAppKey string) ResourceConfigAPICopyCateringPackageRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ResourceConfigAPICopyCateringPackageRequest) XHotelid(xHotelid string) ResourceConfigAPICopyCateringPackageRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for Copying Catering Package/Template.
func (r ResourceConfigAPICopyCateringPackageRequest) CopyCateringPackageType(copyCateringPackageType CopyCateringPackageType) ResourceConfigAPICopyCateringPackageRequest {
	r.copyCateringPackageType = &copyCateringPackageType
	return r
}

// External system code.
func (r ResourceConfigAPICopyCateringPackageRequest) XExternalsystem(xExternalsystem string) ResourceConfigAPICopyCateringPackageRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ResourceConfigAPICopyCateringPackageRequest) AcceptLanguage(acceptLanguage string) ResourceConfigAPICopyCateringPackageRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ResourceConfigAPICopyCateringPackageRequest) Execute() (*ResourceCodeInfo, *http.Response, error) {
	return r.ApiService.CopyCateringPackageExecute(r)
}

/*
CopyCateringPackage Operation to copy catering package or template.

Use this API to copy catering package or template. <p><strong>OperationId:</strong>copyCateringPackage</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique OPERA Hotel code.
 @param cateringPackageId Unique Catering Package or Template ID.
 @return ResourceConfigAPICopyCateringPackageRequest
*/
func (a *ResourceConfigAPIService) CopyCateringPackage(ctx context.Context, hotelId string, cateringPackageId string) ResourceConfigAPICopyCateringPackageRequest {
	return ResourceConfigAPICopyCateringPackageRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
		cateringPackageId: cateringPackageId,
	}
}

// Execute executes the request
//  @return ResourceCodeInfo
func (a *ResourceConfigAPIService) CopyCateringPackageExecute(r ResourceConfigAPICopyCateringPackageRequest) (*ResourceCodeInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResourceCodeInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResourceConfigAPIService.CopyCateringPackage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/cateringPackages/{cateringPackageId}/copy"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"cateringPackageId"+"}", url.PathEscape(parameterValueToString(r.cateringPackageId, "cateringPackageId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 20 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 20 elements")
	}
	if strlen(r.cateringPackageId) < 1 {
		return localVarReturnValue, nil, reportError("cateringPackageId must have at least 1 elements")
	}
	if strlen(r.cateringPackageId) > 38 {
		return localVarReturnValue, nil, reportError("cateringPackageId must have less than 38 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.copyCateringPackageType
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ResourceConfigAPICopyCateringPackagePriceRequest struct {
	ctx context.Context
	ApiService *ResourceConfigAPIService
	pricesId string
	cateringPackageId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	copyCateringPackagePriceType *CopyCateringPackagePriceType
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ResourceConfigAPICopyCateringPackagePriceRequest) Authorization(authorization string) ResourceConfigAPICopyCateringPackagePriceRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ResourceConfigAPICopyCateringPackagePriceRequest) XAppKey(xAppKey string) ResourceConfigAPICopyCateringPackagePriceRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ResourceConfigAPICopyCateringPackagePriceRequest) XHotelid(xHotelid string) ResourceConfigAPICopyCateringPackagePriceRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for Copying Catering Package Price.
func (r ResourceConfigAPICopyCateringPackagePriceRequest) CopyCateringPackagePriceType(copyCateringPackagePriceType CopyCateringPackagePriceType) ResourceConfigAPICopyCateringPackagePriceRequest {
	r.copyCateringPackagePriceType = &copyCateringPackagePriceType
	return r
}

// External system code.
func (r ResourceConfigAPICopyCateringPackagePriceRequest) XExternalsystem(xExternalsystem string) ResourceConfigAPICopyCateringPackagePriceRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ResourceConfigAPICopyCateringPackagePriceRequest) AcceptLanguage(acceptLanguage string) ResourceConfigAPICopyCateringPackagePriceRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ResourceConfigAPICopyCateringPackagePriceRequest) Execute() (*ResourceCodeInfo, *http.Response, error) {
	return r.ApiService.CopyCateringPackagePriceExecute(r)
}

/*
CopyCateringPackagePrice Operation to copy catering package price.

Use this API to copy catering package price. <p><strong>OperationId:</strong>copyCateringPackagePrice</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pricesId Unique Catering Package Prices ID
 @param cateringPackageId Unique Catering Package ID.
 @param hotelId Unique OPERA Hotel ID
 @return ResourceConfigAPICopyCateringPackagePriceRequest
*/
func (a *ResourceConfigAPIService) CopyCateringPackagePrice(ctx context.Context, pricesId string, cateringPackageId string, hotelId string) ResourceConfigAPICopyCateringPackagePriceRequest {
	return ResourceConfigAPICopyCateringPackagePriceRequest{
		ApiService: a,
		ctx: ctx,
		pricesId: pricesId,
		cateringPackageId: cateringPackageId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ResourceCodeInfo
func (a *ResourceConfigAPIService) CopyCateringPackagePriceExecute(r ResourceConfigAPICopyCateringPackagePriceRequest) (*ResourceCodeInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResourceCodeInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResourceConfigAPIService.CopyCateringPackagePrice")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/cateringPackages/{cateringPackageId}/prices/{pricesId}/copy"
	localVarPath = strings.Replace(localVarPath, "{"+"pricesId"+"}", url.PathEscape(parameterValueToString(r.pricesId, "pricesId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"cateringPackageId"+"}", url.PathEscape(parameterValueToString(r.cateringPackageId, "cateringPackageId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.pricesId) < 1 {
		return localVarReturnValue, nil, reportError("pricesId must have at least 1 elements")
	}
	if strlen(r.pricesId) > 38 {
		return localVarReturnValue, nil, reportError("pricesId must have less than 38 elements")
	}
	if strlen(r.cateringPackageId) < 1 {
		return localVarReturnValue, nil, reportError("cateringPackageId must have at least 1 elements")
	}
	if strlen(r.cateringPackageId) > 38 {
		return localVarReturnValue, nil, reportError("cateringPackageId must have less than 38 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 20 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 20 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.copyCateringPackagePriceType
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ResourceConfigAPICopyEventForecastsRequest struct {
	ctx context.Context
	ApiService *ResourceConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	eventForecastsCopy *EventForecastsCopy
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ResourceConfigAPICopyEventForecastsRequest) Authorization(authorization string) ResourceConfigAPICopyEventForecastsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ResourceConfigAPICopyEventForecastsRequest) XAppKey(xAppKey string) ResourceConfigAPICopyEventForecastsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ResourceConfigAPICopyEventForecastsRequest) XHotelid(xHotelid string) ResourceConfigAPICopyEventForecastsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for Copying Event Forecasts to multiple hotels.
func (r ResourceConfigAPICopyEventForecastsRequest) EventForecastsCopy(eventForecastsCopy EventForecastsCopy) ResourceConfigAPICopyEventForecastsRequest {
	r.eventForecastsCopy = &eventForecastsCopy
	return r
}

// External system code.
func (r ResourceConfigAPICopyEventForecastsRequest) XExternalsystem(xExternalsystem string) ResourceConfigAPICopyEventForecastsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ResourceConfigAPICopyEventForecastsRequest) AcceptLanguage(acceptLanguage string) ResourceConfigAPICopyEventForecastsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ResourceConfigAPICopyEventForecastsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.CopyEventForecastsExecute(r)
}

/*
CopyEventForecasts Copy event forecasts

This API will allow you to copy an Event Forecast from a property to another. <p><strong>OperationId:</strong>copyEventForecasts</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ResourceConfigAPICopyEventForecastsRequest
*/
func (a *ResourceConfigAPIService) CopyEventForecasts(ctx context.Context) ResourceConfigAPICopyEventForecastsRequest {
	return ResourceConfigAPICopyEventForecastsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ResourceConfigAPIService) CopyEventForecastsExecute(r ResourceConfigAPICopyEventForecastsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResourceConfigAPIService.CopyEventForecasts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/EventForecasts/copy"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.eventForecastsCopy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ResourceConfigAPICopyInventoryItemsRequest struct {
	ctx context.Context
	ApiService *ResourceConfigAPIService
	sourceHotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	inventoryItemsCopy *InventoryItemsCopy
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ResourceConfigAPICopyInventoryItemsRequest) Authorization(authorization string) ResourceConfigAPICopyInventoryItemsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ResourceConfigAPICopyInventoryItemsRequest) XAppKey(xAppKey string) ResourceConfigAPICopyInventoryItemsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ResourceConfigAPICopyInventoryItemsRequest) XHotelid(xHotelid string) ResourceConfigAPICopyInventoryItemsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for copying Inventory Items Setup configuration
func (r ResourceConfigAPICopyInventoryItemsRequest) InventoryItemsCopy(inventoryItemsCopy InventoryItemsCopy) ResourceConfigAPICopyInventoryItemsRequest {
	r.inventoryItemsCopy = &inventoryItemsCopy
	return r
}

// External system code.
func (r ResourceConfigAPICopyInventoryItemsRequest) XExternalsystem(xExternalsystem string) ResourceConfigAPICopyInventoryItemsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ResourceConfigAPICopyInventoryItemsRequest) AcceptLanguage(acceptLanguage string) ResourceConfigAPICopyInventoryItemsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ResourceConfigAPICopyInventoryItemsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.CopyInventoryItemsExecute(r)
}

/*
CopyInventoryItems Copy Item Inventories

This API will allow you to select multiple Item Inventories from the Source Property and copy to the Target Property. <p><strong>OperationId:</strong>copyInventoryItems</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sourceHotelId Unique ID of source hotel.
 @return ResourceConfigAPICopyInventoryItemsRequest
*/
func (a *ResourceConfigAPIService) CopyInventoryItems(ctx context.Context, sourceHotelId string) ResourceConfigAPICopyInventoryItemsRequest {
	return ResourceConfigAPICopyInventoryItemsRequest{
		ApiService: a,
		ctx: ctx,
		sourceHotelId: sourceHotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ResourceConfigAPIService) CopyInventoryItemsExecute(r ResourceConfigAPICopyInventoryItemsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResourceConfigAPIService.CopyInventoryItems")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{sourceHotelId}/inventoryItems/copy"
	localVarPath = strings.Replace(localVarPath, "{"+"sourceHotelId"+"}", url.PathEscape(parameterValueToString(r.sourceHotelId, "sourceHotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.sourceHotelId) < 1 {
		return localVarReturnValue, nil, reportError("sourceHotelId must have at least 1 elements")
	}
	if strlen(r.sourceHotelId) > 2000 {
		return localVarReturnValue, nil, reportError("sourceHotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.inventoryItemsCopy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ResourceConfigAPICopyItemClassesRequest struct {
	ctx context.Context
	ApiService *ResourceConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	itemClassesCopy *[]CopyConfigurationCodeType
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ResourceConfigAPICopyItemClassesRequest) Authorization(authorization string) ResourceConfigAPICopyItemClassesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ResourceConfigAPICopyItemClassesRequest) XAppKey(xAppKey string) ResourceConfigAPICopyItemClassesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ResourceConfigAPICopyItemClassesRequest) XHotelid(xHotelid string) ResourceConfigAPICopyItemClassesRequest {
	r.xHotelid = &xHotelid
	return r
}

// List of the Item Class to be copied.
func (r ResourceConfigAPICopyItemClassesRequest) ItemClassesCopy(itemClassesCopy []CopyConfigurationCodeType) ResourceConfigAPICopyItemClassesRequest {
	r.itemClassesCopy = &itemClassesCopy
	return r
}

// External system code.
func (r ResourceConfigAPICopyItemClassesRequest) XExternalsystem(xExternalsystem string) ResourceConfigAPICopyItemClassesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ResourceConfigAPICopyItemClassesRequest) AcceptLanguage(acceptLanguage string) ResourceConfigAPICopyItemClassesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ResourceConfigAPICopyItemClassesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.CopyItemClassesExecute(r)
}

/*
CopyItemClasses Copy item classes

You can use this API to copy item classes. <p><strong>OperationId:</strong>copyItemClasses</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ResourceConfigAPICopyItemClassesRequest
*/
func (a *ResourceConfigAPIService) CopyItemClasses(ctx context.Context) ResourceConfigAPICopyItemClassesRequest {
	return ResourceConfigAPICopyItemClassesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ResourceConfigAPIService) CopyItemClassesExecute(r ResourceConfigAPICopyItemClassesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResourceConfigAPIService.CopyItemClasses")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/itemClasses/copy"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.itemClassesCopy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ResourceConfigAPIDeleteCateringContainersRequest struct {
	ctx context.Context
	ApiService *ResourceConfigAPIService
	cateringContainersCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ResourceConfigAPIDeleteCateringContainersRequest) Authorization(authorization string) ResourceConfigAPIDeleteCateringContainersRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ResourceConfigAPIDeleteCateringContainersRequest) XAppKey(xAppKey string) ResourceConfigAPIDeleteCateringContainersRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ResourceConfigAPIDeleteCateringContainersRequest) XHotelid(xHotelid string) ResourceConfigAPIDeleteCateringContainersRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ResourceConfigAPIDeleteCateringContainersRequest) XExternalsystem(xExternalsystem string) ResourceConfigAPIDeleteCateringContainersRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ResourceConfigAPIDeleteCateringContainersRequest) AcceptLanguage(acceptLanguage string) ResourceConfigAPIDeleteCateringContainersRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ResourceConfigAPIDeleteCateringContainersRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteCateringContainersExecute(r)
}

/*
DeleteCateringContainers Delete Catering container

This API allows you to delete an existing Menu Item Catering Container code. <p><strong>OperationId:</strong>deleteCateringContainers</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cateringContainersCode Unique Catering Container Code
 @return ResourceConfigAPIDeleteCateringContainersRequest
*/
func (a *ResourceConfigAPIService) DeleteCateringContainers(ctx context.Context, cateringContainersCode string) ResourceConfigAPIDeleteCateringContainersRequest {
	return ResourceConfigAPIDeleteCateringContainersRequest{
		ApiService: a,
		ctx: ctx,
		cateringContainersCode: cateringContainersCode,
	}
}

// Execute executes the request
//  @return Status
func (a *ResourceConfigAPIService) DeleteCateringContainersExecute(r ResourceConfigAPIDeleteCateringContainersRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResourceConfigAPIService.DeleteCateringContainers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cateringContainers/{cateringContainersCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"cateringContainersCode"+"}", url.PathEscape(parameterValueToString(r.cateringContainersCode, "cateringContainersCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.cateringContainersCode) < 1 {
		return localVarReturnValue, nil, reportError("cateringContainersCode must have at least 1 elements")
	}
	if strlen(r.cateringContainersCode) > 2000 {
		return localVarReturnValue, nil, reportError("cateringContainersCode must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ResourceConfigAPIDeleteCateringItemRatesRequest struct {
	ctx context.Context
	ApiService *ResourceConfigAPIService
	cateringItemRatesCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ResourceConfigAPIDeleteCateringItemRatesRequest) Authorization(authorization string) ResourceConfigAPIDeleteCateringItemRatesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ResourceConfigAPIDeleteCateringItemRatesRequest) XAppKey(xAppKey string) ResourceConfigAPIDeleteCateringItemRatesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ResourceConfigAPIDeleteCateringItemRatesRequest) XHotelid(xHotelid string) ResourceConfigAPIDeleteCateringItemRatesRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ResourceConfigAPIDeleteCateringItemRatesRequest) XExternalsystem(xExternalsystem string) ResourceConfigAPIDeleteCateringItemRatesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ResourceConfigAPIDeleteCateringItemRatesRequest) AcceptLanguage(acceptLanguage string) ResourceConfigAPIDeleteCateringItemRatesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ResourceConfigAPIDeleteCateringItemRatesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteCateringItemRatesExecute(r)
}

/*
DeleteCateringItemRates Remove catering item rates

Remove catering item rates code <p><strong>OperationId:</strong>deleteCateringItemRates</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cateringItemRatesCode Unique Catering Item Rates Codes
 @return ResourceConfigAPIDeleteCateringItemRatesRequest
*/
func (a *ResourceConfigAPIService) DeleteCateringItemRates(ctx context.Context, cateringItemRatesCode string) ResourceConfigAPIDeleteCateringItemRatesRequest {
	return ResourceConfigAPIDeleteCateringItemRatesRequest{
		ApiService: a,
		ctx: ctx,
		cateringItemRatesCode: cateringItemRatesCode,
	}
}

// Execute executes the request
//  @return Status
func (a *ResourceConfigAPIService) DeleteCateringItemRatesExecute(r ResourceConfigAPIDeleteCateringItemRatesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResourceConfigAPIService.DeleteCateringItemRates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cateringItemRates/{cateringItemRatesCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"cateringItemRatesCode"+"}", url.PathEscape(parameterValueToString(r.cateringItemRatesCode, "cateringItemRatesCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.cateringItemRatesCode) < 1 {
		return localVarReturnValue, nil, reportError("cateringItemRatesCode must have at least 1 elements")
	}
	if strlen(r.cateringItemRatesCode) > 2000 {
		return localVarReturnValue, nil, reportError("cateringItemRatesCode must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ResourceConfigAPIDeleteCateringMenuClassesRequest struct {
	ctx context.Context
	ApiService *ResourceConfigAPIService
	menuClassesId string
	authorization *string
	xAppKey *string
	xHotelid *string
	menuClassListIDExtension *[]int32
	menuClassListIdContext *[]string
	menuClassListUniqueIdType *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ResourceConfigAPIDeleteCateringMenuClassesRequest) Authorization(authorization string) ResourceConfigAPIDeleteCateringMenuClassesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ResourceConfigAPIDeleteCateringMenuClassesRequest) XAppKey(xAppKey string) ResourceConfigAPIDeleteCateringMenuClassesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ResourceConfigAPIDeleteCateringMenuClassesRequest) XHotelid(xHotelid string) ResourceConfigAPIDeleteCateringMenuClassesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Additional identifying value assigned by the creating system.
func (r ResourceConfigAPIDeleteCateringMenuClassesRequest) MenuClassListIDExtension(menuClassListIDExtension []int32) ResourceConfigAPIDeleteCateringMenuClassesRequest {
	r.menuClassListIDExtension = &menuClassListIDExtension
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ResourceConfigAPIDeleteCateringMenuClassesRequest) MenuClassListIdContext(menuClassListIdContext []string) ResourceConfigAPIDeleteCateringMenuClassesRequest {
	r.menuClassListIdContext = &menuClassListIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ResourceConfigAPIDeleteCateringMenuClassesRequest) MenuClassListUniqueIdType(menuClassListUniqueIdType []string) ResourceConfigAPIDeleteCateringMenuClassesRequest {
	r.menuClassListUniqueIdType = &menuClassListUniqueIdType
	return r
}

// External system code.
func (r ResourceConfigAPIDeleteCateringMenuClassesRequest) XExternalsystem(xExternalsystem string) ResourceConfigAPIDeleteCateringMenuClassesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ResourceConfigAPIDeleteCateringMenuClassesRequest) AcceptLanguage(acceptLanguage string) ResourceConfigAPIDeleteCateringMenuClassesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ResourceConfigAPIDeleteCateringMenuClassesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteCateringMenuClassesExecute(r)
}

/*
DeleteCateringMenuClasses Delete menu classes

You can use this API to delete menu classes. <p><strong>OperationId:</strong>deleteCateringMenuClasses</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param menuClassesId Unique Catering Menu Class ID
 @return ResourceConfigAPIDeleteCateringMenuClassesRequest
*/
func (a *ResourceConfigAPIService) DeleteCateringMenuClasses(ctx context.Context, menuClassesId string) ResourceConfigAPIDeleteCateringMenuClassesRequest {
	return ResourceConfigAPIDeleteCateringMenuClassesRequest{
		ApiService: a,
		ctx: ctx,
		menuClassesId: menuClassesId,
	}
}

// Execute executes the request
//  @return Status
func (a *ResourceConfigAPIService) DeleteCateringMenuClassesExecute(r ResourceConfigAPIDeleteCateringMenuClassesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResourceConfigAPIService.DeleteCateringMenuClasses")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/menuClasses/{menuClassesId}/cateringMenuClasses"
	localVarPath = strings.Replace(localVarPath, "{"+"menuClassesId"+"}", url.PathEscape(parameterValueToString(r.menuClassesId, "menuClassesId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.menuClassesId) < 1 {
		return localVarReturnValue, nil, reportError("menuClassesId must have at least 1 elements")
	}
	if strlen(r.menuClassesId) > 2000 {
		return localVarReturnValue, nil, reportError("menuClassesId must have less than 2000 elements")
	}

	if r.menuClassListIDExtension != nil {
		t := *r.menuClassListIDExtension
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "menuClassListIDExtension", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "menuClassListIDExtension", t, "multi")
		}
  }
	if r.menuClassListIdContext != nil {
		t := *r.menuClassListIdContext
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "menuClassListIdContext", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "menuClassListIdContext", t, "multi")
		}
  }
	if r.menuClassListUniqueIdType != nil {
		t := *r.menuClassListUniqueIdType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "menuClassListUniqueIdType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "menuClassListUniqueIdType", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ResourceConfigAPIDeleteCateringMenuItemClassesRequest struct {
	ctx context.Context
	ApiService *ResourceConfigAPIService
	cateringMenuItemClassesCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	menuItemClassesIdExtension *[]int32
	menuItemClassesIdContext *[]string
	menuItemClassesUniqueIdType *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ResourceConfigAPIDeleteCateringMenuItemClassesRequest) Authorization(authorization string) ResourceConfigAPIDeleteCateringMenuItemClassesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ResourceConfigAPIDeleteCateringMenuItemClassesRequest) XAppKey(xAppKey string) ResourceConfigAPIDeleteCateringMenuItemClassesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ResourceConfigAPIDeleteCateringMenuItemClassesRequest) XHotelid(xHotelid string) ResourceConfigAPIDeleteCateringMenuItemClassesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Additional identifying value assigned by the creating system.
func (r ResourceConfigAPIDeleteCateringMenuItemClassesRequest) MenuItemClassesIdExtension(menuItemClassesIdExtension []int32) ResourceConfigAPIDeleteCateringMenuItemClassesRequest {
	r.menuItemClassesIdExtension = &menuItemClassesIdExtension
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ResourceConfigAPIDeleteCateringMenuItemClassesRequest) MenuItemClassesIdContext(menuItemClassesIdContext []string) ResourceConfigAPIDeleteCateringMenuItemClassesRequest {
	r.menuItemClassesIdContext = &menuItemClassesIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ResourceConfigAPIDeleteCateringMenuItemClassesRequest) MenuItemClassesUniqueIdType(menuItemClassesUniqueIdType []string) ResourceConfigAPIDeleteCateringMenuItemClassesRequest {
	r.menuItemClassesUniqueIdType = &menuItemClassesUniqueIdType
	return r
}

// External system code.
func (r ResourceConfigAPIDeleteCateringMenuItemClassesRequest) XExternalsystem(xExternalsystem string) ResourceConfigAPIDeleteCateringMenuItemClassesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ResourceConfigAPIDeleteCateringMenuItemClassesRequest) AcceptLanguage(acceptLanguage string) ResourceConfigAPIDeleteCateringMenuItemClassesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ResourceConfigAPIDeleteCateringMenuItemClassesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteCateringMenuItemClassesExecute(r)
}

/*
DeleteCateringMenuItemClasses Delete menu item classes

You can use this API to delete menu item classes. <p><strong>OperationId:</strong>deleteCateringMenuItemClasses</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cateringMenuItemClassesCode Unique Menu Item Class ID
 @return ResourceConfigAPIDeleteCateringMenuItemClassesRequest
*/
func (a *ResourceConfigAPIService) DeleteCateringMenuItemClasses(ctx context.Context, cateringMenuItemClassesCode string) ResourceConfigAPIDeleteCateringMenuItemClassesRequest {
	return ResourceConfigAPIDeleteCateringMenuItemClassesRequest{
		ApiService: a,
		ctx: ctx,
		cateringMenuItemClassesCode: cateringMenuItemClassesCode,
	}
}

// Execute executes the request
//  @return Status
func (a *ResourceConfigAPIService) DeleteCateringMenuItemClassesExecute(r ResourceConfigAPIDeleteCateringMenuItemClassesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResourceConfigAPIService.DeleteCateringMenuItemClasses")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cateringMenuItemClasses/{cateringMenuItemClassesCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"cateringMenuItemClassesCode"+"}", url.PathEscape(parameterValueToString(r.cateringMenuItemClassesCode, "cateringMenuItemClassesCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.cateringMenuItemClassesCode) < 1 {
		return localVarReturnValue, nil, reportError("cateringMenuItemClassesCode must have at least 1 elements")
	}
	if strlen(r.cateringMenuItemClassesCode) > 2000 {
		return localVarReturnValue, nil, reportError("cateringMenuItemClassesCode must have less than 2000 elements")
	}

	if r.menuItemClassesIdExtension != nil {
		t := *r.menuItemClassesIdExtension
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "menuItemClassesIdExtension", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "menuItemClassesIdExtension", t, "multi")
		}
  }
	if r.menuItemClassesIdContext != nil {
		t := *r.menuItemClassesIdContext
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "menuItemClassesIdContext", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "menuItemClassesIdContext", t, "multi")
		}
  }
	if r.menuItemClassesUniqueIdType != nil {
		t := *r.menuItemClassesUniqueIdType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "menuItemClassesUniqueIdType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "menuItemClassesUniqueIdType", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ResourceConfigAPIDeleteCateringMenuItemsRequest struct {
	ctx context.Context
	ApiService *ResourceConfigAPIService
	cateringMenuItemId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ResourceConfigAPIDeleteCateringMenuItemsRequest) Authorization(authorization string) ResourceConfigAPIDeleteCateringMenuItemsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ResourceConfigAPIDeleteCateringMenuItemsRequest) XAppKey(xAppKey string) ResourceConfigAPIDeleteCateringMenuItemsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ResourceConfigAPIDeleteCateringMenuItemsRequest) XHotelid(xHotelid string) ResourceConfigAPIDeleteCateringMenuItemsRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ResourceConfigAPIDeleteCateringMenuItemsRequest) XExternalsystem(xExternalsystem string) ResourceConfigAPIDeleteCateringMenuItemsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ResourceConfigAPIDeleteCateringMenuItemsRequest) AcceptLanguage(acceptLanguage string) ResourceConfigAPIDeleteCateringMenuItemsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ResourceConfigAPIDeleteCateringMenuItemsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteCateringMenuItemsExecute(r)
}

/*
DeleteCateringMenuItems Operation to remove catering menu items.

 <p><strong>OperationId:</strong>deleteCateringMenuItems</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cateringMenuItemId Unique Catering Menu Item Id
 @param hotelId Unique OPERA Hotel Id
 @return ResourceConfigAPIDeleteCateringMenuItemsRequest
*/
func (a *ResourceConfigAPIService) DeleteCateringMenuItems(ctx context.Context, cateringMenuItemId string, hotelId string) ResourceConfigAPIDeleteCateringMenuItemsRequest {
	return ResourceConfigAPIDeleteCateringMenuItemsRequest{
		ApiService: a,
		ctx: ctx,
		cateringMenuItemId: cateringMenuItemId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ResourceConfigAPIService) DeleteCateringMenuItemsExecute(r ResourceConfigAPIDeleteCateringMenuItemsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResourceConfigAPIService.DeleteCateringMenuItems")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/cateringMenuItems/{cateringMenuItemId}"
	localVarPath = strings.Replace(localVarPath, "{"+"cateringMenuItemId"+"}", url.PathEscape(parameterValueToString(r.cateringMenuItemId, "cateringMenuItemId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.cateringMenuItemId) < 1 {
		return localVarReturnValue, nil, reportError("cateringMenuItemId must have at least 1 elements")
	}
	if strlen(r.cateringMenuItemId) > 2000 {
		return localVarReturnValue, nil, reportError("cateringMenuItemId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ResourceConfigAPIDeleteCateringMenuItemsByChainRequest struct {
	ctx context.Context
	ApiService *ResourceConfigAPIService
	cateringMenuItemId string
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelId *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ResourceConfigAPIDeleteCateringMenuItemsByChainRequest) Authorization(authorization string) ResourceConfigAPIDeleteCateringMenuItemsByChainRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ResourceConfigAPIDeleteCateringMenuItemsByChainRequest) XAppKey(xAppKey string) ResourceConfigAPIDeleteCateringMenuItemsByChainRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ResourceConfigAPIDeleteCateringMenuItemsByChainRequest) XHotelid(xHotelid string) ResourceConfigAPIDeleteCateringMenuItemsByChainRequest {
	r.xHotelid = &xHotelid
	return r
}

// The Hotel code which the Catering Menu Items belongs to.
func (r ResourceConfigAPIDeleteCateringMenuItemsByChainRequest) HotelId(hotelId string) ResourceConfigAPIDeleteCateringMenuItemsByChainRequest {
	r.hotelId = &hotelId
	return r
}

// External system code.
func (r ResourceConfigAPIDeleteCateringMenuItemsByChainRequest) XExternalsystem(xExternalsystem string) ResourceConfigAPIDeleteCateringMenuItemsByChainRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ResourceConfigAPIDeleteCateringMenuItemsByChainRequest) AcceptLanguage(acceptLanguage string) ResourceConfigAPIDeleteCateringMenuItemsByChainRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ResourceConfigAPIDeleteCateringMenuItemsByChainRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteCateringMenuItemsByChainExecute(r)
}

/*
DeleteCateringMenuItemsByChain Operation to remove catering menu items by chain.

 <p><strong>OperationId:</strong>deleteCateringMenuItemsByChain</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cateringMenuItemId Unique Catering Menu Item Id
 @return ResourceConfigAPIDeleteCateringMenuItemsByChainRequest
*/
func (a *ResourceConfigAPIService) DeleteCateringMenuItemsByChain(ctx context.Context, cateringMenuItemId string) ResourceConfigAPIDeleteCateringMenuItemsByChainRequest {
	return ResourceConfigAPIDeleteCateringMenuItemsByChainRequest{
		ApiService: a,
		ctx: ctx,
		cateringMenuItemId: cateringMenuItemId,
	}
}

// Execute executes the request
//  @return Status
func (a *ResourceConfigAPIService) DeleteCateringMenuItemsByChainExecute(r ResourceConfigAPIDeleteCateringMenuItemsByChainRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResourceConfigAPIService.DeleteCateringMenuItemsByChain")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cateringMenuItems/{cateringMenuItemId}"
	localVarPath = strings.Replace(localVarPath, "{"+"cateringMenuItemId"+"}", url.PathEscape(parameterValueToString(r.cateringMenuItemId, "cateringMenuItemId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.cateringMenuItemId) < 1 {
		return localVarReturnValue, nil, reportError("cateringMenuItemId must have at least 1 elements")
	}
	if strlen(r.cateringMenuItemId) > 2000 {
		return localVarReturnValue, nil, reportError("cateringMenuItemId must have less than 2000 elements")
	}

	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ResourceConfigAPIDeleteCateringMenuMultiCoursesRequest struct {
	ctx context.Context
	ApiService *ResourceConfigAPIService
	coursesId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	courseIdListUniqueIdExtension *[]int32
	courseIdListUniqueIdContext *[]string
	courseIdListUniqueIdType *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ResourceConfigAPIDeleteCateringMenuMultiCoursesRequest) Authorization(authorization string) ResourceConfigAPIDeleteCateringMenuMultiCoursesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ResourceConfigAPIDeleteCateringMenuMultiCoursesRequest) XAppKey(xAppKey string) ResourceConfigAPIDeleteCateringMenuMultiCoursesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ResourceConfigAPIDeleteCateringMenuMultiCoursesRequest) XHotelid(xHotelid string) ResourceConfigAPIDeleteCateringMenuMultiCoursesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Additional identifying value assigned by the creating system.
func (r ResourceConfigAPIDeleteCateringMenuMultiCoursesRequest) CourseIdListUniqueIdExtension(courseIdListUniqueIdExtension []int32) ResourceConfigAPIDeleteCateringMenuMultiCoursesRequest {
	r.courseIdListUniqueIdExtension = &courseIdListUniqueIdExtension
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ResourceConfigAPIDeleteCateringMenuMultiCoursesRequest) CourseIdListUniqueIdContext(courseIdListUniqueIdContext []string) ResourceConfigAPIDeleteCateringMenuMultiCoursesRequest {
	r.courseIdListUniqueIdContext = &courseIdListUniqueIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ResourceConfigAPIDeleteCateringMenuMultiCoursesRequest) CourseIdListUniqueIdType(courseIdListUniqueIdType []string) ResourceConfigAPIDeleteCateringMenuMultiCoursesRequest {
	r.courseIdListUniqueIdType = &courseIdListUniqueIdType
	return r
}

// External system code.
func (r ResourceConfigAPIDeleteCateringMenuMultiCoursesRequest) XExternalsystem(xExternalsystem string) ResourceConfigAPIDeleteCateringMenuMultiCoursesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ResourceConfigAPIDeleteCateringMenuMultiCoursesRequest) AcceptLanguage(acceptLanguage string) ResourceConfigAPIDeleteCateringMenuMultiCoursesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ResourceConfigAPIDeleteCateringMenuMultiCoursesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteCateringMenuMultiCoursesExecute(r)
}

/*
DeleteCateringMenuMultiCourses Remove menu multi courses

Use this API to remove Menu Multi Courses. <p><strong>OperationId:</strong>deleteCateringMenuMultiCourses</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param coursesId Unique Menu Multi Course ID
 @param hotelId Unique OPERA Hotel ID
 @return ResourceConfigAPIDeleteCateringMenuMultiCoursesRequest
*/
func (a *ResourceConfigAPIService) DeleteCateringMenuMultiCourses(ctx context.Context, coursesId string, hotelId string) ResourceConfigAPIDeleteCateringMenuMultiCoursesRequest {
	return ResourceConfigAPIDeleteCateringMenuMultiCoursesRequest{
		ApiService: a,
		ctx: ctx,
		coursesId: coursesId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ResourceConfigAPIService) DeleteCateringMenuMultiCoursesExecute(r ResourceConfigAPIDeleteCateringMenuMultiCoursesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResourceConfigAPIService.DeleteCateringMenuMultiCourses")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/courses/{coursesId}/menuMultiCourses"
	localVarPath = strings.Replace(localVarPath, "{"+"coursesId"+"}", url.PathEscape(parameterValueToString(r.coursesId, "coursesId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.coursesId) < 1 {
		return localVarReturnValue, nil, reportError("coursesId must have at least 1 elements")
	}
	if strlen(r.coursesId) > 2000 {
		return localVarReturnValue, nil, reportError("coursesId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.courseIdListUniqueIdExtension != nil {
		t := *r.courseIdListUniqueIdExtension
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "courseIdListUniqueIdExtension", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "courseIdListUniqueIdExtension", t, "multi")
		}
  }
	if r.courseIdListUniqueIdContext != nil {
		t := *r.courseIdListUniqueIdContext
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "courseIdListUniqueIdContext", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "courseIdListUniqueIdContext", t, "multi")
		}
  }
	if r.courseIdListUniqueIdType != nil {
		t := *r.courseIdListUniqueIdType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "courseIdListUniqueIdType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "courseIdListUniqueIdType", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ResourceConfigAPIDeleteCateringMenusRequest struct {
	ctx context.Context
	ApiService *ResourceConfigAPIService
	cateringMenuId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ResourceConfigAPIDeleteCateringMenusRequest) Authorization(authorization string) ResourceConfigAPIDeleteCateringMenusRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ResourceConfigAPIDeleteCateringMenusRequest) XAppKey(xAppKey string) ResourceConfigAPIDeleteCateringMenusRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ResourceConfigAPIDeleteCateringMenusRequest) XHotelid(xHotelid string) ResourceConfigAPIDeleteCateringMenusRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ResourceConfigAPIDeleteCateringMenusRequest) XExternalsystem(xExternalsystem string) ResourceConfigAPIDeleteCateringMenusRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ResourceConfigAPIDeleteCateringMenusRequest) AcceptLanguage(acceptLanguage string) ResourceConfigAPIDeleteCateringMenusRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ResourceConfigAPIDeleteCateringMenusRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteCateringMenusExecute(r)
}

/*
DeleteCateringMenus Delete a menu

Delete a menu from a property. <p><strong>OperationId:</strong>deleteCateringMenus</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cateringMenuId Unique ID of Catering Menu
 @param hotelId Unique OPERA Hotel ID
 @return ResourceConfigAPIDeleteCateringMenusRequest
*/
func (a *ResourceConfigAPIService) DeleteCateringMenus(ctx context.Context, cateringMenuId string, hotelId string) ResourceConfigAPIDeleteCateringMenusRequest {
	return ResourceConfigAPIDeleteCateringMenusRequest{
		ApiService: a,
		ctx: ctx,
		cateringMenuId: cateringMenuId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ResourceConfigAPIService) DeleteCateringMenusExecute(r ResourceConfigAPIDeleteCateringMenusRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResourceConfigAPIService.DeleteCateringMenus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/cateringMenus/{cateringMenuId}"
	localVarPath = strings.Replace(localVarPath, "{"+"cateringMenuId"+"}", url.PathEscape(parameterValueToString(r.cateringMenuId, "cateringMenuId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.cateringMenuId) < 1 {
		return localVarReturnValue, nil, reportError("cateringMenuId must have at least 1 elements")
	}
	if strlen(r.cateringMenuId) > 2000 {
		return localVarReturnValue, nil, reportError("cateringMenuId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ResourceConfigAPIDeleteCateringPackageEventNotesRequest struct {
	ctx context.Context
	ApiService *ResourceConfigAPIService
	notedId string
	eventId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	pkgEventIdExtension *int32
	pkgEventIdContext *string
	pkgEventIdType *string
	noteIdExtension *int32
	noteIdContext *string
	noteIdType *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ResourceConfigAPIDeleteCateringPackageEventNotesRequest) Authorization(authorization string) ResourceConfigAPIDeleteCateringPackageEventNotesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ResourceConfigAPIDeleteCateringPackageEventNotesRequest) XAppKey(xAppKey string) ResourceConfigAPIDeleteCateringPackageEventNotesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ResourceConfigAPIDeleteCateringPackageEventNotesRequest) XHotelid(xHotelid string) ResourceConfigAPIDeleteCateringPackageEventNotesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Additional identifying value assigned by the creating system.
func (r ResourceConfigAPIDeleteCateringPackageEventNotesRequest) PkgEventIdExtension(pkgEventIdExtension int32) ResourceConfigAPIDeleteCateringPackageEventNotesRequest {
	r.pkgEventIdExtension = &pkgEventIdExtension
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ResourceConfigAPIDeleteCateringPackageEventNotesRequest) PkgEventIdContext(pkgEventIdContext string) ResourceConfigAPIDeleteCateringPackageEventNotesRequest {
	r.pkgEventIdContext = &pkgEventIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ResourceConfigAPIDeleteCateringPackageEventNotesRequest) PkgEventIdType(pkgEventIdType string) ResourceConfigAPIDeleteCateringPackageEventNotesRequest {
	r.pkgEventIdType = &pkgEventIdType
	return r
}

// Additional identifying value assigned by the creating system.
func (r ResourceConfigAPIDeleteCateringPackageEventNotesRequest) NoteIdExtension(noteIdExtension int32) ResourceConfigAPIDeleteCateringPackageEventNotesRequest {
	r.noteIdExtension = &noteIdExtension
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ResourceConfigAPIDeleteCateringPackageEventNotesRequest) NoteIdContext(noteIdContext string) ResourceConfigAPIDeleteCateringPackageEventNotesRequest {
	r.noteIdContext = &noteIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ResourceConfigAPIDeleteCateringPackageEventNotesRequest) NoteIdType(noteIdType string) ResourceConfigAPIDeleteCateringPackageEventNotesRequest {
	r.noteIdType = &noteIdType
	return r
}

// External system code.
func (r ResourceConfigAPIDeleteCateringPackageEventNotesRequest) XExternalsystem(xExternalsystem string) ResourceConfigAPIDeleteCateringPackageEventNotesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ResourceConfigAPIDeleteCateringPackageEventNotesRequest) AcceptLanguage(acceptLanguage string) ResourceConfigAPIDeleteCateringPackageEventNotesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ResourceConfigAPIDeleteCateringPackageEventNotesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteCateringPackageEventNotesExecute(r)
}

/*
DeleteCateringPackageEventNotes Delete catering package event notes

Use this API to delete catering package event notes. <p><strong>OperationId:</strong>deleteCateringPackageEventNotes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param notedId Unique Catering Package Event Notes ID
 @param eventId Unique Catering Package Event ID
 @param hotelId Unique OPERA Hotel ID
 @return ResourceConfigAPIDeleteCateringPackageEventNotesRequest
*/
func (a *ResourceConfigAPIService) DeleteCateringPackageEventNotes(ctx context.Context, notedId string, eventId string, hotelId string) ResourceConfigAPIDeleteCateringPackageEventNotesRequest {
	return ResourceConfigAPIDeleteCateringPackageEventNotesRequest{
		ApiService: a,
		ctx: ctx,
		notedId: notedId,
		eventId: eventId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ResourceConfigAPIService) DeleteCateringPackageEventNotesExecute(r ResourceConfigAPIDeleteCateringPackageEventNotesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResourceConfigAPIService.DeleteCateringPackageEventNotes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/packages/{eventId}/notes/{notedId}/cateringPackageEventNotes"
	localVarPath = strings.Replace(localVarPath, "{"+"notedId"+"}", url.PathEscape(parameterValueToString(r.notedId, "notedId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eventId"+"}", url.PathEscape(parameterValueToString(r.eventId, "eventId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.notedId) < 1 {
		return localVarReturnValue, nil, reportError("notedId must have at least 1 elements")
	}
	if strlen(r.notedId) > 2000 {
		return localVarReturnValue, nil, reportError("notedId must have less than 2000 elements")
	}
	if strlen(r.eventId) < 1 {
		return localVarReturnValue, nil, reportError("eventId must have at least 1 elements")
	}
	if strlen(r.eventId) > 2000 {
		return localVarReturnValue, nil, reportError("eventId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.pkgEventIdExtension != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pkgEventIdExtension", r.pkgEventIdExtension, "")
  }
	if r.pkgEventIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pkgEventIdContext", r.pkgEventIdContext, "")
  }
	if r.pkgEventIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pkgEventIdType", r.pkgEventIdType, "")
  }
	if r.noteIdExtension != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "noteIdExtension", r.noteIdExtension, "")
  }
	if r.noteIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "noteIdContext", r.noteIdContext, "")
  }
	if r.noteIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "noteIdType", r.noteIdType, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ResourceConfigAPIDeleteCateringPackageEventsRequest struct {
	ctx context.Context
	ApiService *ResourceConfigAPIService
	packageEventsId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	pkgEventIdExtension *int32
	pkgEventIdContext *string
	pkgEventIdType *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ResourceConfigAPIDeleteCateringPackageEventsRequest) Authorization(authorization string) ResourceConfigAPIDeleteCateringPackageEventsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ResourceConfigAPIDeleteCateringPackageEventsRequest) XAppKey(xAppKey string) ResourceConfigAPIDeleteCateringPackageEventsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ResourceConfigAPIDeleteCateringPackageEventsRequest) XHotelid(xHotelid string) ResourceConfigAPIDeleteCateringPackageEventsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Additional identifying value assigned by the creating system.
func (r ResourceConfigAPIDeleteCateringPackageEventsRequest) PkgEventIdExtension(pkgEventIdExtension int32) ResourceConfigAPIDeleteCateringPackageEventsRequest {
	r.pkgEventIdExtension = &pkgEventIdExtension
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ResourceConfigAPIDeleteCateringPackageEventsRequest) PkgEventIdContext(pkgEventIdContext string) ResourceConfigAPIDeleteCateringPackageEventsRequest {
	r.pkgEventIdContext = &pkgEventIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ResourceConfigAPIDeleteCateringPackageEventsRequest) PkgEventIdType(pkgEventIdType string) ResourceConfigAPIDeleteCateringPackageEventsRequest {
	r.pkgEventIdType = &pkgEventIdType
	return r
}

// External system code.
func (r ResourceConfigAPIDeleteCateringPackageEventsRequest) XExternalsystem(xExternalsystem string) ResourceConfigAPIDeleteCateringPackageEventsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ResourceConfigAPIDeleteCateringPackageEventsRequest) AcceptLanguage(acceptLanguage string) ResourceConfigAPIDeleteCateringPackageEventsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ResourceConfigAPIDeleteCateringPackageEventsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteCateringPackageEventsExecute(r)
}

/*
DeleteCateringPackageEvents Delete catering package events

Use this API to delete catering package events. <p><strong>OperationId:</strong>deleteCateringPackageEvents</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param packageEventsId Unique Package Events ID
 @param hotelId Unique OPERA Hotel ID
 @return ResourceConfigAPIDeleteCateringPackageEventsRequest
*/
func (a *ResourceConfigAPIService) DeleteCateringPackageEvents(ctx context.Context, packageEventsId string, hotelId string) ResourceConfigAPIDeleteCateringPackageEventsRequest {
	return ResourceConfigAPIDeleteCateringPackageEventsRequest{
		ApiService: a,
		ctx: ctx,
		packageEventsId: packageEventsId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ResourceConfigAPIService) DeleteCateringPackageEventsExecute(r ResourceConfigAPIDeleteCateringPackageEventsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResourceConfigAPIService.DeleteCateringPackageEvents")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/packageEvents/{packageEventsId}/cateringPackageEvents"
	localVarPath = strings.Replace(localVarPath, "{"+"packageEventsId"+"}", url.PathEscape(parameterValueToString(r.packageEventsId, "packageEventsId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.packageEventsId) < 1 {
		return localVarReturnValue, nil, reportError("packageEventsId must have at least 1 elements")
	}
	if strlen(r.packageEventsId) > 2000 {
		return localVarReturnValue, nil, reportError("packageEventsId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.pkgEventIdExtension != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pkgEventIdExtension", r.pkgEventIdExtension, "")
  }
	if r.pkgEventIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pkgEventIdContext", r.pkgEventIdContext, "")
  }
	if r.pkgEventIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pkgEventIdType", r.pkgEventIdType, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ResourceConfigAPIDeleteCateringPackagePricesRequest struct {
	ctx context.Context
	ApiService *ResourceConfigAPIService
	pricesId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	packagPriceIdExtension *int32
	packagPriceIdContext *string
	packagPriceIdType *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ResourceConfigAPIDeleteCateringPackagePricesRequest) Authorization(authorization string) ResourceConfigAPIDeleteCateringPackagePricesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ResourceConfigAPIDeleteCateringPackagePricesRequest) XAppKey(xAppKey string) ResourceConfigAPIDeleteCateringPackagePricesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ResourceConfigAPIDeleteCateringPackagePricesRequest) XHotelid(xHotelid string) ResourceConfigAPIDeleteCateringPackagePricesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Additional identifying value assigned by the creating system.
func (r ResourceConfigAPIDeleteCateringPackagePricesRequest) PackagPriceIdExtension(packagPriceIdExtension int32) ResourceConfigAPIDeleteCateringPackagePricesRequest {
	r.packagPriceIdExtension = &packagPriceIdExtension
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ResourceConfigAPIDeleteCateringPackagePricesRequest) PackagPriceIdContext(packagPriceIdContext string) ResourceConfigAPIDeleteCateringPackagePricesRequest {
	r.packagPriceIdContext = &packagPriceIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ResourceConfigAPIDeleteCateringPackagePricesRequest) PackagPriceIdType(packagPriceIdType string) ResourceConfigAPIDeleteCateringPackagePricesRequest {
	r.packagPriceIdType = &packagPriceIdType
	return r
}

// External system code.
func (r ResourceConfigAPIDeleteCateringPackagePricesRequest) XExternalsystem(xExternalsystem string) ResourceConfigAPIDeleteCateringPackagePricesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ResourceConfigAPIDeleteCateringPackagePricesRequest) AcceptLanguage(acceptLanguage string) ResourceConfigAPIDeleteCateringPackagePricesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ResourceConfigAPIDeleteCateringPackagePricesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteCateringPackagePricesExecute(r)
}

/*
DeleteCateringPackagePrices Delete Catering package prices

Use this API to delete Catering package prices. <p><strong>OperationId:</strong>deleteCateringPackagePrices</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pricesId Unique Catering Package Prices ID
 @param hotelId Unique OPERA Hotel ID
 @return ResourceConfigAPIDeleteCateringPackagePricesRequest
*/
func (a *ResourceConfigAPIService) DeleteCateringPackagePrices(ctx context.Context, pricesId string, hotelId string) ResourceConfigAPIDeleteCateringPackagePricesRequest {
	return ResourceConfigAPIDeleteCateringPackagePricesRequest{
		ApiService: a,
		ctx: ctx,
		pricesId: pricesId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ResourceConfigAPIService) DeleteCateringPackagePricesExecute(r ResourceConfigAPIDeleteCateringPackagePricesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResourceConfigAPIService.DeleteCateringPackagePrices")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/packagePrices/{pricesId}/cateringPackagePrices"
	localVarPath = strings.Replace(localVarPath, "{"+"pricesId"+"}", url.PathEscape(parameterValueToString(r.pricesId, "pricesId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.pricesId) < 1 {
		return localVarReturnValue, nil, reportError("pricesId must have at least 1 elements")
	}
	if strlen(r.pricesId) > 2000 {
		return localVarReturnValue, nil, reportError("pricesId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.packagPriceIdExtension != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "packagPriceIdExtension", r.packagPriceIdExtension, "")
  }
	if r.packagPriceIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "packagPriceIdContext", r.packagPriceIdContext, "")
  }
	if r.packagPriceIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "packagPriceIdType", r.packagPriceIdType, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ResourceConfigAPIDeleteCateringPackageResourceNotesRequest struct {
	ctx context.Context
	ApiService *ResourceConfigAPIService
	notesId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ResourceConfigAPIDeleteCateringPackageResourceNotesRequest) Authorization(authorization string) ResourceConfigAPIDeleteCateringPackageResourceNotesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ResourceConfigAPIDeleteCateringPackageResourceNotesRequest) XAppKey(xAppKey string) ResourceConfigAPIDeleteCateringPackageResourceNotesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ResourceConfigAPIDeleteCateringPackageResourceNotesRequest) XHotelid(xHotelid string) ResourceConfigAPIDeleteCateringPackageResourceNotesRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ResourceConfigAPIDeleteCateringPackageResourceNotesRequest) XExternalsystem(xExternalsystem string) ResourceConfigAPIDeleteCateringPackageResourceNotesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ResourceConfigAPIDeleteCateringPackageResourceNotesRequest) AcceptLanguage(acceptLanguage string) ResourceConfigAPIDeleteCateringPackageResourceNotesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ResourceConfigAPIDeleteCateringPackageResourceNotesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteCateringPackageResourceNotesExecute(r)
}

/*
DeleteCateringPackageResourceNotes Delete catering package resource notes

Use this API to delete catering package resource notes. <p><strong>OperationId:</strong>deleteCateringPackageResourceNotes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param notesId Unique Catering Package Resource Notes ID
 @param hotelId Unique OPERA Hotel ID
 @return ResourceConfigAPIDeleteCateringPackageResourceNotesRequest
*/
func (a *ResourceConfigAPIService) DeleteCateringPackageResourceNotes(ctx context.Context, notesId string, hotelId string) ResourceConfigAPIDeleteCateringPackageResourceNotesRequest {
	return ResourceConfigAPIDeleteCateringPackageResourceNotesRequest{
		ApiService: a,
		ctx: ctx,
		notesId: notesId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ResourceConfigAPIService) DeleteCateringPackageResourceNotesExecute(r ResourceConfigAPIDeleteCateringPackageResourceNotesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResourceConfigAPIService.DeleteCateringPackageResourceNotes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/notes/{notesId}/cateringPackageResourceNotes"
	localVarPath = strings.Replace(localVarPath, "{"+"notesId"+"}", url.PathEscape(parameterValueToString(r.notesId, "notesId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.notesId) < 1 {
		return localVarReturnValue, nil, reportError("notesId must have at least 1 elements")
	}
	if strlen(r.notesId) > 2000 {
		return localVarReturnValue, nil, reportError("notesId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ResourceConfigAPIDeleteCateringPackageResourcesRequest struct {
	ctx context.Context
	ApiService *ResourceConfigAPIService
	hotelId *[]string
	pkgEventId *[]string
	pkgEventIdType *[]string
	resourceId *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	pkgEventIdExtension *int32
	pkgEventIdContext *string
	pkgEventType *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// The Hotel code which the Catering Package Event belongs to.
func (r ResourceConfigAPIDeleteCateringPackageResourcesRequest) HotelId(hotelId []string) ResourceConfigAPIDeleteCateringPackageResourcesRequest {
	r.hotelId = &hotelId
	return r
}

// Unique Packages Event ID
func (r ResourceConfigAPIDeleteCateringPackageResourcesRequest) PkgEventId(pkgEventId []string) ResourceConfigAPIDeleteCateringPackageResourcesRequest {
	r.pkgEventId = &pkgEventId
	return r
}

// Unique Packages Event Type
func (r ResourceConfigAPIDeleteCateringPackageResourcesRequest) PkgEventIdType(pkgEventIdType []string) ResourceConfigAPIDeleteCateringPackageResourcesRequest {
	r.pkgEventIdType = &pkgEventIdType
	return r
}

// Unique Resources ID
func (r ResourceConfigAPIDeleteCateringPackageResourcesRequest) ResourceId(resourceId []string) ResourceConfigAPIDeleteCateringPackageResourcesRequest {
	r.resourceId = &resourceId
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ResourceConfigAPIDeleteCateringPackageResourcesRequest) Authorization(authorization string) ResourceConfigAPIDeleteCateringPackageResourcesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ResourceConfigAPIDeleteCateringPackageResourcesRequest) XAppKey(xAppKey string) ResourceConfigAPIDeleteCateringPackageResourcesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ResourceConfigAPIDeleteCateringPackageResourcesRequest) XHotelid(xHotelid string) ResourceConfigAPIDeleteCateringPackageResourcesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Additional identifying value assigned by the creating system.
func (r ResourceConfigAPIDeleteCateringPackageResourcesRequest) PkgEventIdExtension(pkgEventIdExtension int32) ResourceConfigAPIDeleteCateringPackageResourcesRequest {
	r.pkgEventIdExtension = &pkgEventIdExtension
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ResourceConfigAPIDeleteCateringPackageResourcesRequest) PkgEventIdContext(pkgEventIdContext string) ResourceConfigAPIDeleteCateringPackageResourcesRequest {
	r.pkgEventIdContext = &pkgEventIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ResourceConfigAPIDeleteCateringPackageResourcesRequest) PkgEventType(pkgEventType []string) ResourceConfigAPIDeleteCateringPackageResourcesRequest {
	r.pkgEventType = &pkgEventType
	return r
}

// External system code.
func (r ResourceConfigAPIDeleteCateringPackageResourcesRequest) XExternalsystem(xExternalsystem string) ResourceConfigAPIDeleteCateringPackageResourcesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ResourceConfigAPIDeleteCateringPackageResourcesRequest) AcceptLanguage(acceptLanguage string) ResourceConfigAPIDeleteCateringPackageResourcesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ResourceConfigAPIDeleteCateringPackageResourcesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteCateringPackageResourcesExecute(r)
}

/*
DeleteCateringPackageResources Delete catering package resources

Use this API to delete catering package resources. <p><strong>OperationId:</strong>deleteCateringPackageResources</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ResourceConfigAPIDeleteCateringPackageResourcesRequest
*/
func (a *ResourceConfigAPIService) DeleteCateringPackageResources(ctx context.Context) ResourceConfigAPIDeleteCateringPackageResourcesRequest {
	return ResourceConfigAPIDeleteCateringPackageResourcesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ResourceConfigAPIService) DeleteCateringPackageResourcesExecute(r ResourceConfigAPIDeleteCateringPackageResourcesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResourceConfigAPIService.DeleteCateringPackageResources")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cateringPackageResources"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	{
		t := *r.hotelId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", t, "multi")
		}
	}
	{
		t := *r.pkgEventId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "pkgEventId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "pkgEventId", t, "multi")
		}
	}
	{
		t := *r.pkgEventIdType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "pkgEventIdType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "pkgEventIdType", t, "multi")
		}
	}
	{
		t := *r.resourceId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "resourceId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "resourceId", t, "multi")
		}
	}
	if r.pkgEventIdExtension != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pkgEventIdExtension", r.pkgEventIdExtension, "")
  }
	if r.pkgEventIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pkgEventIdContext", r.pkgEventIdContext, "")
  }
	if r.pkgEventType != nil {
		t := *r.pkgEventType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "pkgEventType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "pkgEventType", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ResourceConfigAPIDeleteCateringPackageRevenuesRequest struct {
	ctx context.Context
	ApiService *ResourceConfigAPIService
	priceId string
	revenueType string
	eventsId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	packagePriceIdExtension *int32
	packagePriceIdContext *string
	packagePriceIdType *string
	eventIdExtension *int32
	eventIdContext *string
	eventIdType *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ResourceConfigAPIDeleteCateringPackageRevenuesRequest) Authorization(authorization string) ResourceConfigAPIDeleteCateringPackageRevenuesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ResourceConfigAPIDeleteCateringPackageRevenuesRequest) XAppKey(xAppKey string) ResourceConfigAPIDeleteCateringPackageRevenuesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ResourceConfigAPIDeleteCateringPackageRevenuesRequest) XHotelid(xHotelid string) ResourceConfigAPIDeleteCateringPackageRevenuesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Additional identifying value assigned by the creating system.
func (r ResourceConfigAPIDeleteCateringPackageRevenuesRequest) PackagePriceIdExtension(packagePriceIdExtension int32) ResourceConfigAPIDeleteCateringPackageRevenuesRequest {
	r.packagePriceIdExtension = &packagePriceIdExtension
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ResourceConfigAPIDeleteCateringPackageRevenuesRequest) PackagePriceIdContext(packagePriceIdContext string) ResourceConfigAPIDeleteCateringPackageRevenuesRequest {
	r.packagePriceIdContext = &packagePriceIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ResourceConfigAPIDeleteCateringPackageRevenuesRequest) PackagePriceIdType(packagePriceIdType string) ResourceConfigAPIDeleteCateringPackageRevenuesRequest {
	r.packagePriceIdType = &packagePriceIdType
	return r
}

// Additional identifying value assigned by the creating system.
func (r ResourceConfigAPIDeleteCateringPackageRevenuesRequest) EventIdExtension(eventIdExtension int32) ResourceConfigAPIDeleteCateringPackageRevenuesRequest {
	r.eventIdExtension = &eventIdExtension
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ResourceConfigAPIDeleteCateringPackageRevenuesRequest) EventIdContext(eventIdContext string) ResourceConfigAPIDeleteCateringPackageRevenuesRequest {
	r.eventIdContext = &eventIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ResourceConfigAPIDeleteCateringPackageRevenuesRequest) EventIdType(eventIdType string) ResourceConfigAPIDeleteCateringPackageRevenuesRequest {
	r.eventIdType = &eventIdType
	return r
}

// External system code.
func (r ResourceConfigAPIDeleteCateringPackageRevenuesRequest) XExternalsystem(xExternalsystem string) ResourceConfigAPIDeleteCateringPackageRevenuesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ResourceConfigAPIDeleteCateringPackageRevenuesRequest) AcceptLanguage(acceptLanguage string) ResourceConfigAPIDeleteCateringPackageRevenuesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ResourceConfigAPIDeleteCateringPackageRevenuesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteCateringPackageRevenuesExecute(r)
}

/*
DeleteCateringPackageRevenues Delete catering package revenues

Use this API to delete catering package revenues. <p><strong>OperationId:</strong>deleteCateringPackageRevenues</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param priceId Unique Catering Packages Revenue Price ID
 @param revenueType Unique Catering Packages Revenue Type
 @param eventsId Unique Catering Packages Revenue Event ID
 @param hotelId Unique OPERA Hotel ID
 @return ResourceConfigAPIDeleteCateringPackageRevenuesRequest
*/
func (a *ResourceConfigAPIService) DeleteCateringPackageRevenues(ctx context.Context, priceId string, revenueType string, eventsId string, hotelId string) ResourceConfigAPIDeleteCateringPackageRevenuesRequest {
	return ResourceConfigAPIDeleteCateringPackageRevenuesRequest{
		ApiService: a,
		ctx: ctx,
		priceId: priceId,
		revenueType: revenueType,
		eventsId: eventsId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ResourceConfigAPIService) DeleteCateringPackageRevenuesExecute(r ResourceConfigAPIDeleteCateringPackageRevenuesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResourceConfigAPIService.DeleteCateringPackageRevenues")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/events/{eventsId}/revenues/{revenueType}/packages/{priceId}/cateringPackageRevenues"
	localVarPath = strings.Replace(localVarPath, "{"+"priceId"+"}", url.PathEscape(parameterValueToString(r.priceId, "priceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"revenueType"+"}", url.PathEscape(parameterValueToString(r.revenueType, "revenueType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eventsId"+"}", url.PathEscape(parameterValueToString(r.eventsId, "eventsId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.priceId) < 1 {
		return localVarReturnValue, nil, reportError("priceId must have at least 1 elements")
	}
	if strlen(r.priceId) > 2000 {
		return localVarReturnValue, nil, reportError("priceId must have less than 2000 elements")
	}
	if strlen(r.revenueType) < 1 {
		return localVarReturnValue, nil, reportError("revenueType must have at least 1 elements")
	}
	if strlen(r.revenueType) > 2000 {
		return localVarReturnValue, nil, reportError("revenueType must have less than 2000 elements")
	}
	if strlen(r.eventsId) < 1 {
		return localVarReturnValue, nil, reportError("eventsId must have at least 1 elements")
	}
	if strlen(r.eventsId) > 2000 {
		return localVarReturnValue, nil, reportError("eventsId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.packagePriceIdExtension != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "packagePriceIdExtension", r.packagePriceIdExtension, "")
  }
	if r.packagePriceIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "packagePriceIdContext", r.packagePriceIdContext, "")
  }
	if r.packagePriceIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "packagePriceIdType", r.packagePriceIdType, "")
  }
	if r.eventIdExtension != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "eventIdExtension", r.eventIdExtension, "")
  }
	if r.eventIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "eventIdContext", r.eventIdContext, "")
  }
	if r.eventIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "eventIdType", r.eventIdType, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ResourceConfigAPIDeleteCateringPackagesRequest struct {
	ctx context.Context
	ApiService *ResourceConfigAPIService
	cateringPackageId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ResourceConfigAPIDeleteCateringPackagesRequest) Authorization(authorization string) ResourceConfigAPIDeleteCateringPackagesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ResourceConfigAPIDeleteCateringPackagesRequest) XAppKey(xAppKey string) ResourceConfigAPIDeleteCateringPackagesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ResourceConfigAPIDeleteCateringPackagesRequest) XHotelid(xHotelid string) ResourceConfigAPIDeleteCateringPackagesRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ResourceConfigAPIDeleteCateringPackagesRequest) XExternalsystem(xExternalsystem string) ResourceConfigAPIDeleteCateringPackagesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ResourceConfigAPIDeleteCateringPackagesRequest) AcceptLanguage(acceptLanguage string) ResourceConfigAPIDeleteCateringPackagesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ResourceConfigAPIDeleteCateringPackagesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteCateringPackagesExecute(r)
}

/*
DeleteCateringPackages Delete catering packages

Use this API to delete catering packages. <p><strong>OperationId:</strong>deleteCateringPackages</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cateringPackageId Unique Package Id
 @param hotelId Unique Hotel Code
 @return ResourceConfigAPIDeleteCateringPackagesRequest
*/
func (a *ResourceConfigAPIService) DeleteCateringPackages(ctx context.Context, cateringPackageId string, hotelId string) ResourceConfigAPIDeleteCateringPackagesRequest {
	return ResourceConfigAPIDeleteCateringPackagesRequest{
		ApiService: a,
		ctx: ctx,
		cateringPackageId: cateringPackageId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ResourceConfigAPIService) DeleteCateringPackagesExecute(r ResourceConfigAPIDeleteCateringPackagesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResourceConfigAPIService.DeleteCateringPackages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/cateringPackages/{cateringPackageId}"
	localVarPath = strings.Replace(localVarPath, "{"+"cateringPackageId"+"}", url.PathEscape(parameterValueToString(r.cateringPackageId, "cateringPackageId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.cateringPackageId) < 1 {
		return localVarReturnValue, nil, reportError("cateringPackageId must have at least 1 elements")
	}
	if strlen(r.cateringPackageId) > 2000 {
		return localVarReturnValue, nil, reportError("cateringPackageId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ResourceConfigAPIDeleteEventForecastsRequest struct {
	ctx context.Context
	ApiService *ResourceConfigAPIService
	eventTypesCode string
	forecastsId string
	authorization *string
	xAppKey *string
	xHotelid *string
	forecastIdExtension *int32
	forecastIdContext *string
	forecastIdType *string
	hotelId *[]string
	revenueTypeCode *string
	revenueTypeDescription *string
	amount *float32
	currencyCode *string
	amountType *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ResourceConfigAPIDeleteEventForecastsRequest) Authorization(authorization string) ResourceConfigAPIDeleteEventForecastsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ResourceConfigAPIDeleteEventForecastsRequest) XAppKey(xAppKey string) ResourceConfigAPIDeleteEventForecastsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ResourceConfigAPIDeleteEventForecastsRequest) XHotelid(xHotelid string) ResourceConfigAPIDeleteEventForecastsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Additional identifying value assigned by the creating system.
func (r ResourceConfigAPIDeleteEventForecastsRequest) ForecastIdExtension(forecastIdExtension int32) ResourceConfigAPIDeleteEventForecastsRequest {
	r.forecastIdExtension = &forecastIdExtension
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ResourceConfigAPIDeleteEventForecastsRequest) ForecastIdContext(forecastIdContext string) ResourceConfigAPIDeleteEventForecastsRequest {
	r.forecastIdContext = &forecastIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ResourceConfigAPIDeleteEventForecastsRequest) ForecastIdType(forecastIdType string) ResourceConfigAPIDeleteEventForecastsRequest {
	r.forecastIdType = &forecastIdType
	return r
}

// Hotel Code to which the Event Forecast belongs to.
func (r ResourceConfigAPIDeleteEventForecastsRequest) HotelId(hotelId []string) ResourceConfigAPIDeleteEventForecastsRequest {
	r.hotelId = &hotelId
	return r
}

// Code.
func (r ResourceConfigAPIDeleteEventForecastsRequest) RevenueTypeCode(revenueTypeCode string) ResourceConfigAPIDeleteEventForecastsRequest {
	r.revenueTypeCode = &revenueTypeCode
	return r
}

// description.
func (r ResourceConfigAPIDeleteEventForecastsRequest) RevenueTypeDescription(revenueTypeDescription string) ResourceConfigAPIDeleteEventForecastsRequest {
	r.revenueTypeDescription = &revenueTypeDescription
	return r
}

// A monetary amount.
func (r ResourceConfigAPIDeleteEventForecastsRequest) Amount(amount float32) ResourceConfigAPIDeleteEventForecastsRequest {
	r.amount = &amount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r ResourceConfigAPIDeleteEventForecastsRequest) CurrencyCode(currencyCode string) ResourceConfigAPIDeleteEventForecastsRequest {
	r.currencyCode = &currencyCode
	return r
}

// Defines values for Amount Type of an event forecast revenue.
func (r ResourceConfigAPIDeleteEventForecastsRequest) AmountType(amountType []string) ResourceConfigAPIDeleteEventForecastsRequest {
	r.amountType = &amountType
	return r
}

// External system code.
func (r ResourceConfigAPIDeleteEventForecastsRequest) XExternalsystem(xExternalsystem string) ResourceConfigAPIDeleteEventForecastsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ResourceConfigAPIDeleteEventForecastsRequest) AcceptLanguage(acceptLanguage string) ResourceConfigAPIDeleteEventForecastsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ResourceConfigAPIDeleteEventForecastsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteEventForecastsExecute(r)
}

/*
DeleteEventForecasts Delete event forecasts

This API will allow you to delete an Event Forecast for a property. <p><strong>OperationId:</strong>deleteEventForecasts</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventTypesCode Unique Event Type Code
 @param forecastsId Unique Forecast Id
 @return ResourceConfigAPIDeleteEventForecastsRequest
*/
func (a *ResourceConfigAPIService) DeleteEventForecasts(ctx context.Context, eventTypesCode string, forecastsId string) ResourceConfigAPIDeleteEventForecastsRequest {
	return ResourceConfigAPIDeleteEventForecastsRequest{
		ApiService: a,
		ctx: ctx,
		eventTypesCode: eventTypesCode,
		forecastsId: forecastsId,
	}
}

// Execute executes the request
//  @return Status
func (a *ResourceConfigAPIService) DeleteEventForecastsExecute(r ResourceConfigAPIDeleteEventForecastsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResourceConfigAPIService.DeleteEventForecasts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/eventForecasts/{forecastsId}/eventTypes/{eventTypesCode}/eventForecasts"
	localVarPath = strings.Replace(localVarPath, "{"+"eventTypesCode"+"}", url.PathEscape(parameterValueToString(r.eventTypesCode, "eventTypesCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"forecastsId"+"}", url.PathEscape(parameterValueToString(r.forecastsId, "forecastsId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.eventTypesCode) < 1 {
		return localVarReturnValue, nil, reportError("eventTypesCode must have at least 1 elements")
	}
	if strlen(r.eventTypesCode) > 2000 {
		return localVarReturnValue, nil, reportError("eventTypesCode must have less than 2000 elements")
	}
	if strlen(r.forecastsId) < 1 {
		return localVarReturnValue, nil, reportError("forecastsId must have at least 1 elements")
	}
	if strlen(r.forecastsId) > 2000 {
		return localVarReturnValue, nil, reportError("forecastsId must have less than 2000 elements")
	}

	if r.forecastIdExtension != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "forecastIdExtension", r.forecastIdExtension, "")
  }
	if r.forecastIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "forecastIdContext", r.forecastIdContext, "")
  }
	if r.forecastIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "forecastIdType", r.forecastIdType, "")
  }
	if r.hotelId != nil {
		t := *r.hotelId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", t, "multi")
		}
  }
	if r.revenueTypeCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "revenueTypeCode", r.revenueTypeCode, "")
  }
	if r.revenueTypeDescription != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "revenueTypeDescription", r.revenueTypeDescription, "")
  }
	if r.amount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "amount", r.amount, "")
  }
	if r.currencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currencyCode", r.currencyCode, "")
  }
	if r.amountType != nil {
		t := *r.amountType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "amountType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "amountType", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ResourceConfigAPIDeleteInventoryItemTemplatesRequest struct {
	ctx context.Context
	ApiService *ResourceConfigAPIService
	inventoryItemId string
	authorization *string
	xAppKey *string
	xHotelid *string
	inventoryItemTemplatesIdExtension *[]int32
	inventoryItemTemplatesContext *[]string
	inventoryItemTemplatesType *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ResourceConfigAPIDeleteInventoryItemTemplatesRequest) Authorization(authorization string) ResourceConfigAPIDeleteInventoryItemTemplatesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ResourceConfigAPIDeleteInventoryItemTemplatesRequest) XAppKey(xAppKey string) ResourceConfigAPIDeleteInventoryItemTemplatesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ResourceConfigAPIDeleteInventoryItemTemplatesRequest) XHotelid(xHotelid string) ResourceConfigAPIDeleteInventoryItemTemplatesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Additional identifying value assigned by the creating system.
func (r ResourceConfigAPIDeleteInventoryItemTemplatesRequest) InventoryItemTemplatesIdExtension(inventoryItemTemplatesIdExtension []int32) ResourceConfigAPIDeleteInventoryItemTemplatesRequest {
	r.inventoryItemTemplatesIdExtension = &inventoryItemTemplatesIdExtension
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ResourceConfigAPIDeleteInventoryItemTemplatesRequest) InventoryItemTemplatesContext(inventoryItemTemplatesContext []string) ResourceConfigAPIDeleteInventoryItemTemplatesRequest {
	r.inventoryItemTemplatesContext = &inventoryItemTemplatesContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ResourceConfigAPIDeleteInventoryItemTemplatesRequest) InventoryItemTemplatesType(inventoryItemTemplatesType []string) ResourceConfigAPIDeleteInventoryItemTemplatesRequest {
	r.inventoryItemTemplatesType = &inventoryItemTemplatesType
	return r
}

// External system code.
func (r ResourceConfigAPIDeleteInventoryItemTemplatesRequest) XExternalsystem(xExternalsystem string) ResourceConfigAPIDeleteInventoryItemTemplatesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ResourceConfigAPIDeleteInventoryItemTemplatesRequest) AcceptLanguage(acceptLanguage string) ResourceConfigAPIDeleteInventoryItemTemplatesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ResourceConfigAPIDeleteInventoryItemTemplatesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteInventoryItemTemplatesExecute(r)
}

/*
DeleteInventoryItemTemplates Delete Item Inventory templates

Delete Item Inventory template. <p><strong>OperationId:</strong>deleteInventoryItemTemplates</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param inventoryItemId Unique Inventory Item Template code
 @return ResourceConfigAPIDeleteInventoryItemTemplatesRequest
*/
func (a *ResourceConfigAPIService) DeleteInventoryItemTemplates(ctx context.Context, inventoryItemId string) ResourceConfigAPIDeleteInventoryItemTemplatesRequest {
	return ResourceConfigAPIDeleteInventoryItemTemplatesRequest{
		ApiService: a,
		ctx: ctx,
		inventoryItemId: inventoryItemId,
	}
}

// Execute executes the request
//  @return Status
func (a *ResourceConfigAPIService) DeleteInventoryItemTemplatesExecute(r ResourceConfigAPIDeleteInventoryItemTemplatesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResourceConfigAPIService.DeleteInventoryItemTemplates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/inventoryItems/{inventoryItemId}"
	localVarPath = strings.Replace(localVarPath, "{"+"inventoryItemId"+"}", url.PathEscape(parameterValueToString(r.inventoryItemId, "inventoryItemId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.inventoryItemId) < 1 {
		return localVarReturnValue, nil, reportError("inventoryItemId must have at least 1 elements")
	}
	if strlen(r.inventoryItemId) > 2000 {
		return localVarReturnValue, nil, reportError("inventoryItemId must have less than 2000 elements")
	}

	if r.inventoryItemTemplatesIdExtension != nil {
		t := *r.inventoryItemTemplatesIdExtension
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "inventoryItemTemplatesIdExtension", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "inventoryItemTemplatesIdExtension", t, "multi")
		}
  }
	if r.inventoryItemTemplatesContext != nil {
		t := *r.inventoryItemTemplatesContext
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "inventoryItemTemplatesContext", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "inventoryItemTemplatesContext", t, "multi")
		}
  }
	if r.inventoryItemTemplatesType != nil {
		t := *r.inventoryItemTemplatesType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "inventoryItemTemplatesType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "inventoryItemTemplatesType", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ResourceConfigAPIDeleteInventoryItemsRequest struct {
	ctx context.Context
	ApiService *ResourceConfigAPIService
	inventoryItemId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	itemIDExtension *int32
	idContext *string
	itemIDType *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ResourceConfigAPIDeleteInventoryItemsRequest) Authorization(authorization string) ResourceConfigAPIDeleteInventoryItemsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ResourceConfigAPIDeleteInventoryItemsRequest) XAppKey(xAppKey string) ResourceConfigAPIDeleteInventoryItemsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ResourceConfigAPIDeleteInventoryItemsRequest) XHotelid(xHotelid string) ResourceConfigAPIDeleteInventoryItemsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Additional identifying value assigned by the creating system.
func (r ResourceConfigAPIDeleteInventoryItemsRequest) ItemIDExtension(itemIDExtension int32) ResourceConfigAPIDeleteInventoryItemsRequest {
	r.itemIDExtension = &itemIDExtension
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ResourceConfigAPIDeleteInventoryItemsRequest) IdContext(idContext string) ResourceConfigAPIDeleteInventoryItemsRequest {
	r.idContext = &idContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ResourceConfigAPIDeleteInventoryItemsRequest) ItemIDType(itemIDType string) ResourceConfigAPIDeleteInventoryItemsRequest {
	r.itemIDType = &itemIDType
	return r
}

// External system code.
func (r ResourceConfigAPIDeleteInventoryItemsRequest) XExternalsystem(xExternalsystem string) ResourceConfigAPIDeleteInventoryItemsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ResourceConfigAPIDeleteInventoryItemsRequest) AcceptLanguage(acceptLanguage string) ResourceConfigAPIDeleteInventoryItemsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ResourceConfigAPIDeleteInventoryItemsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteInventoryItemsExecute(r)
}

/*
DeleteInventoryItems Delete Item Inventory

Use this API to delete an existing Item Inventory Code  <p><strong>OperationId:</strong>deleteInventoryItems</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param inventoryItemId Unique Inventory Item Id
 @param hotelId Unique OPERA Hotel code
 @return ResourceConfigAPIDeleteInventoryItemsRequest
*/
func (a *ResourceConfigAPIService) DeleteInventoryItems(ctx context.Context, inventoryItemId string, hotelId string) ResourceConfigAPIDeleteInventoryItemsRequest {
	return ResourceConfigAPIDeleteInventoryItemsRequest{
		ApiService: a,
		ctx: ctx,
		inventoryItemId: inventoryItemId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ResourceConfigAPIService) DeleteInventoryItemsExecute(r ResourceConfigAPIDeleteInventoryItemsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResourceConfigAPIService.DeleteInventoryItems")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/inventoryItems/{inventoryItemId}"
	localVarPath = strings.Replace(localVarPath, "{"+"inventoryItemId"+"}", url.PathEscape(parameterValueToString(r.inventoryItemId, "inventoryItemId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.inventoryItemId) < 1 {
		return localVarReturnValue, nil, reportError("inventoryItemId must have at least 1 elements")
	}
	if strlen(r.inventoryItemId) > 2000 {
		return localVarReturnValue, nil, reportError("inventoryItemId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.itemIDExtension != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "itemIDExtension", r.itemIDExtension, "")
  }
	if r.idContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", r.idContext, "")
  }
	if r.itemIDType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "itemIDType", r.itemIDType, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ResourceConfigAPIDeleteItemClassesRequest struct {
	ctx context.Context
	ApiService *ResourceConfigAPIService
	itemClassesCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ResourceConfigAPIDeleteItemClassesRequest) Authorization(authorization string) ResourceConfigAPIDeleteItemClassesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ResourceConfigAPIDeleteItemClassesRequest) XAppKey(xAppKey string) ResourceConfigAPIDeleteItemClassesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ResourceConfigAPIDeleteItemClassesRequest) XHotelid(xHotelid string) ResourceConfigAPIDeleteItemClassesRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ResourceConfigAPIDeleteItemClassesRequest) XExternalsystem(xExternalsystem string) ResourceConfigAPIDeleteItemClassesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ResourceConfigAPIDeleteItemClassesRequest) AcceptLanguage(acceptLanguage string) ResourceConfigAPIDeleteItemClassesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ResourceConfigAPIDeleteItemClassesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteItemClassesExecute(r)
}

/*
DeleteItemClasses Delete Item classes

This API allows you to delete an existing Item Classes for a property. <p><strong>OperationId:</strong>deleteItemClasses</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param itemClassesCode Unique Item Class Code
 @return ResourceConfigAPIDeleteItemClassesRequest
*/
func (a *ResourceConfigAPIService) DeleteItemClasses(ctx context.Context, itemClassesCode string) ResourceConfigAPIDeleteItemClassesRequest {
	return ResourceConfigAPIDeleteItemClassesRequest{
		ApiService: a,
		ctx: ctx,
		itemClassesCode: itemClassesCode,
	}
}

// Execute executes the request
//  @return Status
func (a *ResourceConfigAPIService) DeleteItemClassesExecute(r ResourceConfigAPIDeleteItemClassesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResourceConfigAPIService.DeleteItemClasses")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/itemClasses/{itemClassesCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"itemClassesCode"+"}", url.PathEscape(parameterValueToString(r.itemClassesCode, "itemClassesCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.itemClassesCode) < 1 {
		return localVarReturnValue, nil, reportError("itemClassesCode must have at least 1 elements")
	}
	if strlen(r.itemClassesCode) > 2000 {
		return localVarReturnValue, nil, reportError("itemClassesCode must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ResourceConfigAPIDeleteItemPoolsRequest struct {
	ctx context.Context
	ApiService *ResourceConfigAPIService
	itemPoolsCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ResourceConfigAPIDeleteItemPoolsRequest) Authorization(authorization string) ResourceConfigAPIDeleteItemPoolsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ResourceConfigAPIDeleteItemPoolsRequest) XAppKey(xAppKey string) ResourceConfigAPIDeleteItemPoolsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ResourceConfigAPIDeleteItemPoolsRequest) XHotelid(xHotelid string) ResourceConfigAPIDeleteItemPoolsRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ResourceConfigAPIDeleteItemPoolsRequest) XExternalsystem(xExternalsystem string) ResourceConfigAPIDeleteItemPoolsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ResourceConfigAPIDeleteItemPoolsRequest) AcceptLanguage(acceptLanguage string) ResourceConfigAPIDeleteItemPoolsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ResourceConfigAPIDeleteItemPoolsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteItemPoolsExecute(r)
}

/*
DeleteItemPools Delete Item Pools

Delete Item Pool for a property. <p><strong>OperationId:</strong>deleteItemPools</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param itemPoolsCode Unique Item Pool code
 @param hotelId Unique OPERA Hotel code
 @return ResourceConfigAPIDeleteItemPoolsRequest
*/
func (a *ResourceConfigAPIService) DeleteItemPools(ctx context.Context, itemPoolsCode string, hotelId string) ResourceConfigAPIDeleteItemPoolsRequest {
	return ResourceConfigAPIDeleteItemPoolsRequest{
		ApiService: a,
		ctx: ctx,
		itemPoolsCode: itemPoolsCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ResourceConfigAPIService) DeleteItemPoolsExecute(r ResourceConfigAPIDeleteItemPoolsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResourceConfigAPIService.DeleteItemPools")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/itemPools/{itemPoolsCode}/itemPools"
	localVarPath = strings.Replace(localVarPath, "{"+"itemPoolsCode"+"}", url.PathEscape(parameterValueToString(r.itemPoolsCode, "itemPoolsCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.itemPoolsCode) < 1 {
		return localVarReturnValue, nil, reportError("itemPoolsCode must have at least 1 elements")
	}
	if strlen(r.itemPoolsCode) > 2000 {
		return localVarReturnValue, nil, reportError("itemPoolsCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ResourceConfigAPIDeleteResourceConfigServiceCacheRequest struct {
	ctx context.Context
	ApiService *ResourceConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	operaClearInput *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ResourceConfigAPIDeleteResourceConfigServiceCacheRequest) Authorization(authorization string) ResourceConfigAPIDeleteResourceConfigServiceCacheRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ResourceConfigAPIDeleteResourceConfigServiceCacheRequest) XAppKey(xAppKey string) ResourceConfigAPIDeleteResourceConfigServiceCacheRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ResourceConfigAPIDeleteResourceConfigServiceCacheRequest) XHotelid(xHotelid string) ResourceConfigAPIDeleteResourceConfigServiceCacheRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for cleaning WS cache input type
func (r ResourceConfigAPIDeleteResourceConfigServiceCacheRequest) OperaClearInput(operaClearInput string) ResourceConfigAPIDeleteResourceConfigServiceCacheRequest {
	r.operaClearInput = &operaClearInput
	return r
}

// External system code.
func (r ResourceConfigAPIDeleteResourceConfigServiceCacheRequest) XExternalsystem(xExternalsystem string) ResourceConfigAPIDeleteResourceConfigServiceCacheRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ResourceConfigAPIDeleteResourceConfigServiceCacheRequest) AcceptLanguage(acceptLanguage string) ResourceConfigAPIDeleteResourceConfigServiceCacheRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ResourceConfigAPIDeleteResourceConfigServiceCacheRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteResourceConfigServiceCacheExecute(r)
}

/*
DeleteResourceConfigServiceCache ClearCache

You can use this API to delete the Resource Configuration Service Status Cache. <p><strong>OperationId:</strong>deleteResourceConfigServiceCache</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ResourceConfigAPIDeleteResourceConfigServiceCacheRequest
*/
func (a *ResourceConfigAPIService) DeleteResourceConfigServiceCache(ctx context.Context) ResourceConfigAPIDeleteResourceConfigServiceCacheRequest {
	return ResourceConfigAPIDeleteResourceConfigServiceCacheRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ResourceConfigAPIService) DeleteResourceConfigServiceCacheExecute(r ResourceConfigAPIDeleteResourceConfigServiceCacheRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResourceConfigAPIService.DeleteResourceConfigServiceCache")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/services/resources/cache"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.operaClearInput != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "operaClearInput", r.operaClearInput, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ResourceConfigAPIDeleteRevenueGroupsRequest struct {
	ctx context.Context
	ApiService *ResourceConfigAPIService
	revenueGroupsCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ResourceConfigAPIDeleteRevenueGroupsRequest) Authorization(authorization string) ResourceConfigAPIDeleteRevenueGroupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ResourceConfigAPIDeleteRevenueGroupsRequest) XAppKey(xAppKey string) ResourceConfigAPIDeleteRevenueGroupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ResourceConfigAPIDeleteRevenueGroupsRequest) XHotelid(xHotelid string) ResourceConfigAPIDeleteRevenueGroupsRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ResourceConfigAPIDeleteRevenueGroupsRequest) XExternalsystem(xExternalsystem string) ResourceConfigAPIDeleteRevenueGroupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ResourceConfigAPIDeleteRevenueGroupsRequest) AcceptLanguage(acceptLanguage string) ResourceConfigAPIDeleteRevenueGroupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ResourceConfigAPIDeleteRevenueGroupsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteRevenueGroupsExecute(r)
}

/*
DeleteRevenueGroups Delete Catering Revenue Groups

You can use this API to delete a catering revenue group code. <p><strong>OperationId:</strong>deleteRevenueGroups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param revenueGroupsCode Unique Revenue Group Code
 @return ResourceConfigAPIDeleteRevenueGroupsRequest
*/
func (a *ResourceConfigAPIService) DeleteRevenueGroups(ctx context.Context, revenueGroupsCode string) ResourceConfigAPIDeleteRevenueGroupsRequest {
	return ResourceConfigAPIDeleteRevenueGroupsRequest{
		ApiService: a,
		ctx: ctx,
		revenueGroupsCode: revenueGroupsCode,
	}
}

// Execute executes the request
//  @return Status
func (a *ResourceConfigAPIService) DeleteRevenueGroupsExecute(r ResourceConfigAPIDeleteRevenueGroupsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResourceConfigAPIService.DeleteRevenueGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/revenueGroups/{revenueGroupsCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"revenueGroupsCode"+"}", url.PathEscape(parameterValueToString(r.revenueGroupsCode, "revenueGroupsCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.revenueGroupsCode) < 1 {
		return localVarReturnValue, nil, reportError("revenueGroupsCode must have at least 1 elements")
	}
	if strlen(r.revenueGroupsCode) > 2000 {
		return localVarReturnValue, nil, reportError("revenueGroupsCode must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ResourceConfigAPIGetCateringContainersRequest struct {
	ctx context.Context
	ApiService *ResourceConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	fetchInactive *bool
	codes *[]string
	wildCard *string
	description *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ResourceConfigAPIGetCateringContainersRequest) Authorization(authorization string) ResourceConfigAPIGetCateringContainersRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ResourceConfigAPIGetCateringContainersRequest) XAppKey(xAppKey string) ResourceConfigAPIGetCateringContainersRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ResourceConfigAPIGetCateringContainersRequest) XHotelid(xHotelid string) ResourceConfigAPIGetCateringContainersRequest {
	r.xHotelid = &xHotelid
	return r
}

// Determines wether to fetch inactive records or not.
func (r ResourceConfigAPIGetCateringContainersRequest) FetchInactive(fetchInactive bool) ResourceConfigAPIGetCateringContainersRequest {
	r.fetchInactive = &fetchInactive
	return r
}

// Codes to be searched.
func (r ResourceConfigAPIGetCateringContainersRequest) Codes(codes []string) ResourceConfigAPIGetCateringContainersRequest {
	r.codes = &codes
	return r
}

// Wildcard search on the code.
func (r ResourceConfigAPIGetCateringContainersRequest) WildCard(wildCard string) ResourceConfigAPIGetCateringContainersRequest {
	r.wildCard = &wildCard
	return r
}

// Description of the code.
func (r ResourceConfigAPIGetCateringContainersRequest) Description(description string) ResourceConfigAPIGetCateringContainersRequest {
	r.description = &description
	return r
}

// External system code.
func (r ResourceConfigAPIGetCateringContainersRequest) XExternalsystem(xExternalsystem string) ResourceConfigAPIGetCateringContainersRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ResourceConfigAPIGetCateringContainersRequest) AcceptLanguage(acceptLanguage string) ResourceConfigAPIGetCateringContainersRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ResourceConfigAPIGetCateringContainersRequest) Execute() (*CateringContainersInfo, *http.Response, error) {
	return r.ApiService.GetCateringContainersExecute(r)
}

/*
GetCateringContainers Get catering containers

This API allows you to retrieve all existing Menu Item Catering Container codes. <p><strong>OperationId:</strong>getCateringContainers</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ResourceConfigAPIGetCateringContainersRequest
*/
func (a *ResourceConfigAPIService) GetCateringContainers(ctx context.Context) ResourceConfigAPIGetCateringContainersRequest {
	return ResourceConfigAPIGetCateringContainersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CateringContainersInfo
func (a *ResourceConfigAPIService) GetCateringContainersExecute(r ResourceConfigAPIGetCateringContainersRequest) (*CateringContainersInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CateringContainersInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResourceConfigAPIService.GetCateringContainers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cateringContainers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fetchInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInactive", r.fetchInactive, "")
  }
	if r.codes != nil {
		t := *r.codes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "codes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "codes", t, "multi")
		}
  }
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
  }
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ResourceConfigAPIGetCateringItemRatesRequest struct {
	ctx context.Context
	ApiService *ResourceConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	fetchInactive *bool
	codes *[]string
	wildCard *string
	description *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ResourceConfigAPIGetCateringItemRatesRequest) Authorization(authorization string) ResourceConfigAPIGetCateringItemRatesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ResourceConfigAPIGetCateringItemRatesRequest) XAppKey(xAppKey string) ResourceConfigAPIGetCateringItemRatesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ResourceConfigAPIGetCateringItemRatesRequest) XHotelid(xHotelid string) ResourceConfigAPIGetCateringItemRatesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Determines wether to fetch inactive records or not.
func (r ResourceConfigAPIGetCateringItemRatesRequest) FetchInactive(fetchInactive bool) ResourceConfigAPIGetCateringItemRatesRequest {
	r.fetchInactive = &fetchInactive
	return r
}

// Codes to be searched.
func (r ResourceConfigAPIGetCateringItemRatesRequest) Codes(codes []string) ResourceConfigAPIGetCateringItemRatesRequest {
	r.codes = &codes
	return r
}

// Wildcard search on the code.
func (r ResourceConfigAPIGetCateringItemRatesRequest) WildCard(wildCard string) ResourceConfigAPIGetCateringItemRatesRequest {
	r.wildCard = &wildCard
	return r
}

// Description of the code.
func (r ResourceConfigAPIGetCateringItemRatesRequest) Description(description string) ResourceConfigAPIGetCateringItemRatesRequest {
	r.description = &description
	return r
}

// External system code.
func (r ResourceConfigAPIGetCateringItemRatesRequest) XExternalsystem(xExternalsystem string) ResourceConfigAPIGetCateringItemRatesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ResourceConfigAPIGetCateringItemRatesRequest) AcceptLanguage(acceptLanguage string) ResourceConfigAPIGetCateringItemRatesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ResourceConfigAPIGetCateringItemRatesRequest) Execute() (*CateringItemRatesInfo, *http.Response, error) {
	return r.ApiService.GetCateringItemRatesExecute(r)
}

/*
GetCateringItemRates Get catering item rates

Retrieve catering item rates <p><strong>OperationId:</strong>getCateringItemRates</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ResourceConfigAPIGetCateringItemRatesRequest
*/
func (a *ResourceConfigAPIService) GetCateringItemRates(ctx context.Context) ResourceConfigAPIGetCateringItemRatesRequest {
	return ResourceConfigAPIGetCateringItemRatesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CateringItemRatesInfo
func (a *ResourceConfigAPIService) GetCateringItemRatesExecute(r ResourceConfigAPIGetCateringItemRatesRequest) (*CateringItemRatesInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CateringItemRatesInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResourceConfigAPIService.GetCateringItemRates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cateringItemRates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fetchInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInactive", r.fetchInactive, "")
  }
	if r.codes != nil {
		t := *r.codes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "codes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "codes", t, "multi")
		}
  }
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
  }
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ResourceConfigAPIGetCateringMenuRequest struct {
	ctx context.Context
	ApiService *ResourceConfigAPIService
	cateringMenuId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	inactive *bool
	fetchInstructions *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ResourceConfigAPIGetCateringMenuRequest) Authorization(authorization string) ResourceConfigAPIGetCateringMenuRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ResourceConfigAPIGetCateringMenuRequest) XAppKey(xAppKey string) ResourceConfigAPIGetCateringMenuRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ResourceConfigAPIGetCateringMenuRequest) XHotelid(xHotelid string) ResourceConfigAPIGetCateringMenuRequest {
	r.xHotelid = &xHotelid
	return r
}

// If true, only Composed Menu&#39;s marked as Inactive in Menu Configuration will be returned.
func (r ResourceConfigAPIGetCateringMenuRequest) Inactive(inactive bool) ResourceConfigAPIGetCateringMenuRequest {
	r.inactive = &inactive
	return r
}

// Fetch instructions that can be used in Catering Menus maintenance.
func (r ResourceConfigAPIGetCateringMenuRequest) FetchInstructions(fetchInstructions []string) ResourceConfigAPIGetCateringMenuRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// External system code.
func (r ResourceConfigAPIGetCateringMenuRequest) XExternalsystem(xExternalsystem string) ResourceConfigAPIGetCateringMenuRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ResourceConfigAPIGetCateringMenuRequest) AcceptLanguage(acceptLanguage string) ResourceConfigAPIGetCateringMenuRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ResourceConfigAPIGetCateringMenuRequest) Execute() (*CateringMenusInfo, *http.Response, error) {
	return r.ApiService.GetCateringMenuExecute(r)
}

/*
GetCateringMenu Get menu

Retrieve details of a Catering menu <p><strong>OperationId:</strong>getCateringMenu</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cateringMenuId Unique ID of Catering Menu
 @param hotelId Unique OPERA Hotel ID
 @return ResourceConfigAPIGetCateringMenuRequest
*/
func (a *ResourceConfigAPIService) GetCateringMenu(ctx context.Context, cateringMenuId string, hotelId string) ResourceConfigAPIGetCateringMenuRequest {
	return ResourceConfigAPIGetCateringMenuRequest{
		ApiService: a,
		ctx: ctx,
		cateringMenuId: cateringMenuId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CateringMenusInfo
func (a *ResourceConfigAPIService) GetCateringMenuExecute(r ResourceConfigAPIGetCateringMenuRequest) (*CateringMenusInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CateringMenusInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResourceConfigAPIService.GetCateringMenu")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/cateringMenus/{cateringMenuId}"
	localVarPath = strings.Replace(localVarPath, "{"+"cateringMenuId"+"}", url.PathEscape(parameterValueToString(r.cateringMenuId, "cateringMenuId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.cateringMenuId) < 1 {
		return localVarReturnValue, nil, reportError("cateringMenuId must have at least 1 elements")
	}
	if strlen(r.cateringMenuId) > 2000 {
		return localVarReturnValue, nil, reportError("cateringMenuId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.inactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inactive", r.inactive, "")
  }
	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ResourceConfigAPIGetCateringMenuClassesRequest struct {
	ctx context.Context
	ApiService *ResourceConfigAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	className *string
	webBookable *bool
	includeMenus *bool
	inactive *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ResourceConfigAPIGetCateringMenuClassesRequest) Authorization(authorization string) ResourceConfigAPIGetCateringMenuClassesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ResourceConfigAPIGetCateringMenuClassesRequest) XAppKey(xAppKey string) ResourceConfigAPIGetCateringMenuClassesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ResourceConfigAPIGetCateringMenuClassesRequest) XHotelid(xHotelid string) ResourceConfigAPIGetCateringMenuClassesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ResourceConfigAPIGetCateringMenuClassesRequest) Limit(limit int32) ResourceConfigAPIGetCateringMenuClassesRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ResourceConfigAPIGetCateringMenuClassesRequest) Offset(offset int32) ResourceConfigAPIGetCateringMenuClassesRequest {
	r.offset = &offset
	return r
}

// The name of Menu Class.
func (r ResourceConfigAPIGetCateringMenuClassesRequest) ClassName(className string) ResourceConfigAPIGetCateringMenuClassesRequest {
	r.className = &className
	return r
}

// If true this boolean will set the criteria to only return Menu Classes configured as Web Bookable.
func (r ResourceConfigAPIGetCateringMenuClassesRequest) WebBookable(webBookable bool) ResourceConfigAPIGetCateringMenuClassesRequest {
	r.webBookable = &webBookable
	return r
}

// If true this boolean will set the criteria to fetch associated menu for the menu classes.
func (r ResourceConfigAPIGetCateringMenuClassesRequest) IncludeMenus(includeMenus bool) ResourceConfigAPIGetCateringMenuClassesRequest {
	r.includeMenus = &includeMenus
	return r
}

// If true this boolean will set the criteria to only return Menu Classes configured as Inactive.
func (r ResourceConfigAPIGetCateringMenuClassesRequest) Inactive(inactive bool) ResourceConfigAPIGetCateringMenuClassesRequest {
	r.inactive = &inactive
	return r
}

// External system code.
func (r ResourceConfigAPIGetCateringMenuClassesRequest) XExternalsystem(xExternalsystem string) ResourceConfigAPIGetCateringMenuClassesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ResourceConfigAPIGetCateringMenuClassesRequest) AcceptLanguage(acceptLanguage string) ResourceConfigAPIGetCateringMenuClassesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ResourceConfigAPIGetCateringMenuClassesRequest) Execute() (*CateringMenuClassesInfo, *http.Response, error) {
	return r.ApiService.GetCateringMenuClassesExecute(r)
}

/*
GetCateringMenuClasses Get menu classes

Get menu classes for a property. <p><strong>OperationId:</strong>getCateringMenuClasses</p> <p>The maximum allowable limit for this API is <strong>25</strong>.</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique OPERA Hotel ID
 @return ResourceConfigAPIGetCateringMenuClassesRequest
*/
func (a *ResourceConfigAPIService) GetCateringMenuClasses(ctx context.Context, hotelId string) ResourceConfigAPIGetCateringMenuClassesRequest {
	return ResourceConfigAPIGetCateringMenuClassesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CateringMenuClassesInfo
func (a *ResourceConfigAPIService) GetCateringMenuClassesExecute(r ResourceConfigAPIGetCateringMenuClassesRequest) (*CateringMenuClassesInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CateringMenuClassesInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResourceConfigAPIService.GetCateringMenuClasses")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/cateringMenuClasses"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
  }
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
  }
	if r.className != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "className", r.className, "")
  }
	if r.webBookable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "webBookable", r.webBookable, "")
  }
	if r.includeMenus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeMenus", r.includeMenus, "")
  }
	if r.inactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inactive", r.inactive, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ResourceConfigAPIGetCateringMenuItemClassesRequest struct {
	ctx context.Context
	ApiService *ResourceConfigAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	className *string
	menuTypes *[]string
	webBookable *bool
	includeMenuItems *bool
	inactive *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ResourceConfigAPIGetCateringMenuItemClassesRequest) Authorization(authorization string) ResourceConfigAPIGetCateringMenuItemClassesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ResourceConfigAPIGetCateringMenuItemClassesRequest) XAppKey(xAppKey string) ResourceConfigAPIGetCateringMenuItemClassesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ResourceConfigAPIGetCateringMenuItemClassesRequest) XHotelid(xHotelid string) ResourceConfigAPIGetCateringMenuItemClassesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ResourceConfigAPIGetCateringMenuItemClassesRequest) Limit(limit int32) ResourceConfigAPIGetCateringMenuItemClassesRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ResourceConfigAPIGetCateringMenuItemClassesRequest) Offset(offset int32) ResourceConfigAPIGetCateringMenuItemClassesRequest {
	r.offset = &offset
	return r
}

// Menu Item class name search filter.
func (r ResourceConfigAPIGetCateringMenuItemClassesRequest) ClassName(className string) ResourceConfigAPIGetCateringMenuItemClassesRequest {
	r.className = &className
	return r
}

// Defines values for Menu Type
func (r ResourceConfigAPIGetCateringMenuItemClassesRequest) MenuTypes(menuTypes []string) ResourceConfigAPIGetCateringMenuItemClassesRequest {
	r.menuTypes = &menuTypes
	return r
}

// Indicates if web bookable.
func (r ResourceConfigAPIGetCateringMenuItemClassesRequest) WebBookable(webBookable bool) ResourceConfigAPIGetCateringMenuItemClassesRequest {
	r.webBookable = &webBookable
	return r
}

// MenuItemClassInfo MenuItemInfo values can be passed as per requirement
func (r ResourceConfigAPIGetCateringMenuItemClassesRequest) IncludeMenuItems(includeMenuItems bool) ResourceConfigAPIGetCateringMenuItemClassesRequest {
	r.includeMenuItems = &includeMenuItems
	return r
}

// If true this boolean will set the criteria to only return Menu Item Classes configured as Inactive.
func (r ResourceConfigAPIGetCateringMenuItemClassesRequest) Inactive(inactive bool) ResourceConfigAPIGetCateringMenuItemClassesRequest {
	r.inactive = &inactive
	return r
}

// External system code.
func (r ResourceConfigAPIGetCateringMenuItemClassesRequest) XExternalsystem(xExternalsystem string) ResourceConfigAPIGetCateringMenuItemClassesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ResourceConfigAPIGetCateringMenuItemClassesRequest) AcceptLanguage(acceptLanguage string) ResourceConfigAPIGetCateringMenuItemClassesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ResourceConfigAPIGetCateringMenuItemClassesRequest) Execute() (*CateringMenuItemClassesInfo, *http.Response, error) {
	return r.ApiService.GetCateringMenuItemClassesExecute(r)
}

/*
GetCateringMenuItemClasses Get menu item classes

Get menu item classes for a property. <p><strong>OperationId:</strong>getCateringMenuItemClasses</p> <p>The maximum allowable limit for this API is <strong>25</strong>.</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique OPERA Hotel Id
 @return ResourceConfigAPIGetCateringMenuItemClassesRequest
*/
func (a *ResourceConfigAPIService) GetCateringMenuItemClasses(ctx context.Context, hotelId string) ResourceConfigAPIGetCateringMenuItemClassesRequest {
	return ResourceConfigAPIGetCateringMenuItemClassesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CateringMenuItemClassesInfo
func (a *ResourceConfigAPIService) GetCateringMenuItemClassesExecute(r ResourceConfigAPIGetCateringMenuItemClassesRequest) (*CateringMenuItemClassesInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CateringMenuItemClassesInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResourceConfigAPIService.GetCateringMenuItemClasses")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/cateringMenuItemClasses"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
  }
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
  }
	if r.className != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "className", r.className, "")
  }
	if r.menuTypes != nil {
		t := *r.menuTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "menuTypes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "menuTypes", t, "multi")
		}
  }
	if r.webBookable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "webBookable", r.webBookable, "")
  }
	if r.includeMenuItems != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeMenuItems", r.includeMenuItems, "")
  }
	if r.inactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inactive", r.inactive, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ResourceConfigAPIGetCateringMenuItemsRequest struct {
	ctx context.Context
	ApiService *ResourceConfigAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	name *string
	codes *[]string
	quickInsertCode *string
	listTypeCodes *[]string
	inactive *bool
	eventTypesCodes *[]string
	fetchInstructions *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ResourceConfigAPIGetCateringMenuItemsRequest) Authorization(authorization string) ResourceConfigAPIGetCateringMenuItemsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ResourceConfigAPIGetCateringMenuItemsRequest) XAppKey(xAppKey string) ResourceConfigAPIGetCateringMenuItemsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ResourceConfigAPIGetCateringMenuItemsRequest) XHotelid(xHotelid string) ResourceConfigAPIGetCateringMenuItemsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ResourceConfigAPIGetCateringMenuItemsRequest) Limit(limit int32) ResourceConfigAPIGetCateringMenuItemsRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ResourceConfigAPIGetCateringMenuItemsRequest) Offset(offset int32) ResourceConfigAPIGetCateringMenuItemsRequest {
	r.offset = &offset
	return r
}

// Menu item name of string lentgth 30
func (r ResourceConfigAPIGetCateringMenuItemsRequest) Name(name string) ResourceConfigAPIGetCateringMenuItemsRequest {
	r.name = &name
	return r
}

func (r ResourceConfigAPIGetCateringMenuItemsRequest) Codes(codes []string) ResourceConfigAPIGetCateringMenuItemsRequest {
	r.codes = &codes
	return r
}

// Article number of Menu Item in Caps
func (r ResourceConfigAPIGetCateringMenuItemsRequest) QuickInsertCode(quickInsertCode string) ResourceConfigAPIGetCateringMenuItemsRequest {
	r.quickInsertCode = &quickInsertCode
	return r
}

func (r ResourceConfigAPIGetCateringMenuItemsRequest) ListTypeCodes(listTypeCodes []string) ResourceConfigAPIGetCateringMenuItemsRequest {
	r.listTypeCodes = &listTypeCodes
	return r
}

// If true this boolean will set the criteria to only return Menu Items configured as Inactive.
func (r ResourceConfigAPIGetCateringMenuItemsRequest) Inactive(inactive bool) ResourceConfigAPIGetCateringMenuItemsRequest {
	r.inactive = &inactive
	return r
}

func (r ResourceConfigAPIGetCateringMenuItemsRequest) EventTypesCodes(eventTypesCodes []string) ResourceConfigAPIGetCateringMenuItemsRequest {
	r.eventTypesCodes = &eventTypesCodes
	return r
}

// Fetch instructions that can be used in Fetching Catering Menus Items. SummaryInfo fetchInstruction is used to fetch limited set of Menu Item information required for Menu Items Panel Drawer and DetailsInfo returns detailed information required for Menu Items listing screen.
func (r ResourceConfigAPIGetCateringMenuItemsRequest) FetchInstructions(fetchInstructions []string) ResourceConfigAPIGetCateringMenuItemsRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// External system code.
func (r ResourceConfigAPIGetCateringMenuItemsRequest) XExternalsystem(xExternalsystem string) ResourceConfigAPIGetCateringMenuItemsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ResourceConfigAPIGetCateringMenuItemsRequest) AcceptLanguage(acceptLanguage string) ResourceConfigAPIGetCateringMenuItemsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ResourceConfigAPIGetCateringMenuItemsRequest) Execute() (*CateringMenuItemsInfo, *http.Response, error) {
	return r.ApiService.GetCateringMenuItemsExecute(r)
}

/*
GetCateringMenuItems Get Menu items

Get Menu items for a property. <p><strong>OperationId:</strong>getCateringMenuItems</p> <p>The maximum allowable limit for this API is <strong>200</strong>.</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique OPERA Hotel Id
 @return ResourceConfigAPIGetCateringMenuItemsRequest
*/
func (a *ResourceConfigAPIService) GetCateringMenuItems(ctx context.Context, hotelId string) ResourceConfigAPIGetCateringMenuItemsRequest {
	return ResourceConfigAPIGetCateringMenuItemsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CateringMenuItemsInfo
func (a *ResourceConfigAPIService) GetCateringMenuItemsExecute(r ResourceConfigAPIGetCateringMenuItemsRequest) (*CateringMenuItemsInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CateringMenuItemsInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResourceConfigAPIService.GetCateringMenuItems")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/cateringMenuItems"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
  }
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
  }
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
  }
	if r.codes != nil {
		t := *r.codes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "codes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "codes", t, "multi")
		}
  }
	if r.quickInsertCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "quickInsertCode", r.quickInsertCode, "")
  }
	if r.listTypeCodes != nil {
		t := *r.listTypeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "listTypeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "listTypeCodes", t, "multi")
		}
  }
	if r.inactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inactive", r.inactive, "")
  }
	if r.eventTypesCodes != nil {
		t := *r.eventTypesCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "eventTypesCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "eventTypesCodes", t, "multi")
		}
  }
	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ResourceConfigAPIGetCateringMenusRequest struct {
	ctx context.Context
	ApiService *ResourceConfigAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	menuId *string
	iDExtension *int32
	idContext *string
	menuIDType *string
	name *string
	classNameListCodes *[]string
	eventTypesCodes *[]string
	menuTypes *[]string
	dietaryListCodes *[]string
	inactive *bool
	multiChoice *bool
	webBookable *bool
	end *string
	start *string
	fetchInstructions *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ResourceConfigAPIGetCateringMenusRequest) Authorization(authorization string) ResourceConfigAPIGetCateringMenusRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ResourceConfigAPIGetCateringMenusRequest) XAppKey(xAppKey string) ResourceConfigAPIGetCateringMenusRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ResourceConfigAPIGetCateringMenusRequest) XHotelid(xHotelid string) ResourceConfigAPIGetCateringMenusRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ResourceConfigAPIGetCateringMenusRequest) Limit(limit int32) ResourceConfigAPIGetCateringMenusRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ResourceConfigAPIGetCateringMenusRequest) Offset(offset int32) ResourceConfigAPIGetCateringMenusRequest {
	r.offset = &offset
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ResourceConfigAPIGetCateringMenusRequest) MenuId(menuId string) ResourceConfigAPIGetCateringMenusRequest {
	r.menuId = &menuId
	return r
}

// Additional identifying value assigned by the creating system.
func (r ResourceConfigAPIGetCateringMenusRequest) IDExtension(iDExtension int32) ResourceConfigAPIGetCateringMenusRequest {
	r.iDExtension = &iDExtension
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ResourceConfigAPIGetCateringMenusRequest) IdContext(idContext string) ResourceConfigAPIGetCateringMenusRequest {
	r.idContext = &idContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ResourceConfigAPIGetCateringMenusRequest) MenuIDType(menuIDType string) ResourceConfigAPIGetCateringMenusRequest {
	r.menuIDType = &menuIDType
	return r
}

// This type holds name of Menu Class.
func (r ResourceConfigAPIGetCateringMenusRequest) Name(name string) ResourceConfigAPIGetCateringMenusRequest {
	r.name = &name
	return r
}

func (r ResourceConfigAPIGetCateringMenusRequest) ClassNameListCodes(classNameListCodes []string) ResourceConfigAPIGetCateringMenusRequest {
	r.classNameListCodes = &classNameListCodes
	return r
}

func (r ResourceConfigAPIGetCateringMenusRequest) EventTypesCodes(eventTypesCodes []string) ResourceConfigAPIGetCateringMenusRequest {
	r.eventTypesCodes = &eventTypesCodes
	return r
}

// Defines values for Menu Type
func (r ResourceConfigAPIGetCateringMenusRequest) MenuTypes(menuTypes []string) ResourceConfigAPIGetCateringMenusRequest {
	r.menuTypes = &menuTypes
	return r
}

func (r ResourceConfigAPIGetCateringMenusRequest) DietaryListCodes(dietaryListCodes []string) ResourceConfigAPIGetCateringMenusRequest {
	r.dietaryListCodes = &dietaryListCodes
	return r
}

// If true, only Composed Menu&#39;s marked as Inactive in Menu Configuration will be returned.
func (r ResourceConfigAPIGetCateringMenusRequest) Inactive(inactive bool) ResourceConfigAPIGetCateringMenusRequest {
	r.inactive = &inactive
	return r
}

// When selected Only Composed Menu&#39;s noted as Multi Choice in Menu Configuration will be returned.
func (r ResourceConfigAPIGetCateringMenusRequest) MultiChoice(multiChoice bool) ResourceConfigAPIGetCateringMenusRequest {
	r.multiChoice = &multiChoice
	return r
}

// Check of Menu if it is web bookable
func (r ResourceConfigAPIGetCateringMenusRequest) WebBookable(webBookable bool) ResourceConfigAPIGetCateringMenusRequest {
	r.webBookable = &webBookable
	return r
}

// The ending value of the date range.
func (r ResourceConfigAPIGetCateringMenusRequest) End(end string) ResourceConfigAPIGetCateringMenusRequest {
	r.end = &end
	return r
}

// The starting value of the date range.
func (r ResourceConfigAPIGetCateringMenusRequest) Start(start string) ResourceConfigAPIGetCateringMenusRequest {
	r.start = &start
	return r
}

// Fetch instructions that can be used in Catering Menus maintenance.
func (r ResourceConfigAPIGetCateringMenusRequest) FetchInstructions(fetchInstructions []string) ResourceConfigAPIGetCateringMenusRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// External system code.
func (r ResourceConfigAPIGetCateringMenusRequest) XExternalsystem(xExternalsystem string) ResourceConfigAPIGetCateringMenusRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ResourceConfigAPIGetCateringMenusRequest) AcceptLanguage(acceptLanguage string) ResourceConfigAPIGetCateringMenusRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ResourceConfigAPIGetCateringMenusRequest) Execute() (*CateringMenusInfo, *http.Response, error) {
	return r.ApiService.GetCateringMenusExecute(r)
}

/*
GetCateringMenus Get menus

Retrieve a list of menus for a property. <p><strong>OperationId:</strong>getCateringMenus</p> <p>The maximum allowable limit for this API is <strong>200</strong>.</p> <p>This API allows a time span of <strong>90</strong> days.</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique OPERA Hotel ID
 @return ResourceConfigAPIGetCateringMenusRequest
*/
func (a *ResourceConfigAPIService) GetCateringMenus(ctx context.Context, hotelId string) ResourceConfigAPIGetCateringMenusRequest {
	return ResourceConfigAPIGetCateringMenusRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CateringMenusInfo
func (a *ResourceConfigAPIService) GetCateringMenusExecute(r ResourceConfigAPIGetCateringMenusRequest) (*CateringMenusInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CateringMenusInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResourceConfigAPIService.GetCateringMenus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/cateringMenus"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
  }
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
  }
	if r.menuId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "menuId", r.menuId, "")
  }
	if r.iDExtension != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "iDExtension", r.iDExtension, "")
  }
	if r.idContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", r.idContext, "")
  }
	if r.menuIDType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "menuIDType", r.menuIDType, "")
  }
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
  }
	if r.classNameListCodes != nil {
		t := *r.classNameListCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "classNameListCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "classNameListCodes", t, "multi")
		}
  }
	if r.eventTypesCodes != nil {
		t := *r.eventTypesCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "eventTypesCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "eventTypesCodes", t, "multi")
		}
  }
	if r.menuTypes != nil {
		t := *r.menuTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "menuTypes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "menuTypes", t, "multi")
		}
  }
	if r.dietaryListCodes != nil {
		t := *r.dietaryListCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "dietaryListCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "dietaryListCodes", t, "multi")
		}
  }
	if r.inactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inactive", r.inactive, "")
  }
	if r.multiChoice != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "multiChoice", r.multiChoice, "")
  }
	if r.webBookable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "webBookable", r.webBookable, "")
  }
	if r.end != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end", r.end, "")
  }
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "")
  }
	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ResourceConfigAPIGetCateringPackageRequest struct {
	ctx context.Context
	ApiService *ResourceConfigAPIService
	cateringPackageId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	idExtension *int32
	idContext *string
	pkgIDType *string
	fetchInstructions *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ResourceConfigAPIGetCateringPackageRequest) Authorization(authorization string) ResourceConfigAPIGetCateringPackageRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ResourceConfigAPIGetCateringPackageRequest) XAppKey(xAppKey string) ResourceConfigAPIGetCateringPackageRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ResourceConfigAPIGetCateringPackageRequest) XHotelid(xHotelid string) ResourceConfigAPIGetCateringPackageRequest {
	r.xHotelid = &xHotelid
	return r
}

// Additional identifying value assigned by the creating system.
func (r ResourceConfigAPIGetCateringPackageRequest) IdExtension(idExtension int32) ResourceConfigAPIGetCateringPackageRequest {
	r.idExtension = &idExtension
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ResourceConfigAPIGetCateringPackageRequest) IdContext(idContext string) ResourceConfigAPIGetCateringPackageRequest {
	r.idContext = &idContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ResourceConfigAPIGetCateringPackageRequest) PkgIDType(pkgIDType string) ResourceConfigAPIGetCateringPackageRequest {
	r.pkgIDType = &pkgIDType
	return r
}

// Fetch instructions that can be used in Catering Packages maintenance.
func (r ResourceConfigAPIGetCateringPackageRequest) FetchInstructions(fetchInstructions []string) ResourceConfigAPIGetCateringPackageRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// External system code.
func (r ResourceConfigAPIGetCateringPackageRequest) XExternalsystem(xExternalsystem string) ResourceConfigAPIGetCateringPackageRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ResourceConfigAPIGetCateringPackageRequest) AcceptLanguage(acceptLanguage string) ResourceConfigAPIGetCateringPackageRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ResourceConfigAPIGetCateringPackageRequest) Execute() (*CateringPackage, *http.Response, error) {
	return r.ApiService.GetCateringPackageExecute(r)
}

/*
GetCateringPackage Get catering package

Use this API to get catering package. <p><strong>OperationId:</strong>getCateringPackage</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cateringPackageId Unique Catering Package ID
 @param hotelId Unique OPERA Hotel ID
 @return ResourceConfigAPIGetCateringPackageRequest
*/
func (a *ResourceConfigAPIService) GetCateringPackage(ctx context.Context, cateringPackageId string, hotelId string) ResourceConfigAPIGetCateringPackageRequest {
	return ResourceConfigAPIGetCateringPackageRequest{
		ApiService: a,
		ctx: ctx,
		cateringPackageId: cateringPackageId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CateringPackage
func (a *ResourceConfigAPIService) GetCateringPackageExecute(r ResourceConfigAPIGetCateringPackageRequest) (*CateringPackage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CateringPackage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResourceConfigAPIService.GetCateringPackage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/cateringPackages/{cateringPackageId}"
	localVarPath = strings.Replace(localVarPath, "{"+"cateringPackageId"+"}", url.PathEscape(parameterValueToString(r.cateringPackageId, "cateringPackageId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.cateringPackageId) < 1 {
		return localVarReturnValue, nil, reportError("cateringPackageId must have at least 1 elements")
	}
	if strlen(r.cateringPackageId) > 2000 {
		return localVarReturnValue, nil, reportError("cateringPackageId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.idExtension != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idExtension", r.idExtension, "")
  }
	if r.idContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", r.idContext, "")
  }
	if r.pkgIDType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pkgIDType", r.pkgIDType, "")
  }
	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ResourceConfigAPIGetCateringPackageByChainRequest struct {
	ctx context.Context
	ApiService *ResourceConfigAPIService
	cateringPackageId string
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelId *string
	idExtension *int32
	idContext *string
	pkgIDType *string
	fetchInstructions *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ResourceConfigAPIGetCateringPackageByChainRequest) Authorization(authorization string) ResourceConfigAPIGetCateringPackageByChainRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ResourceConfigAPIGetCateringPackageByChainRequest) XAppKey(xAppKey string) ResourceConfigAPIGetCateringPackageByChainRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ResourceConfigAPIGetCateringPackageByChainRequest) XHotelid(xHotelid string) ResourceConfigAPIGetCateringPackageByChainRequest {
	r.xHotelid = &xHotelid
	return r
}

// Hotel code of Catering Package to be fetched.
func (r ResourceConfigAPIGetCateringPackageByChainRequest) HotelId(hotelId string) ResourceConfigAPIGetCateringPackageByChainRequest {
	r.hotelId = &hotelId
	return r
}

// Additional identifying value assigned by the creating system.
func (r ResourceConfigAPIGetCateringPackageByChainRequest) IdExtension(idExtension int32) ResourceConfigAPIGetCateringPackageByChainRequest {
	r.idExtension = &idExtension
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ResourceConfigAPIGetCateringPackageByChainRequest) IdContext(idContext string) ResourceConfigAPIGetCateringPackageByChainRequest {
	r.idContext = &idContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ResourceConfigAPIGetCateringPackageByChainRequest) PkgIDType(pkgIDType string) ResourceConfigAPIGetCateringPackageByChainRequest {
	r.pkgIDType = &pkgIDType
	return r
}

// Fetch instructions that can be used in Catering Packages maintenance.
func (r ResourceConfigAPIGetCateringPackageByChainRequest) FetchInstructions(fetchInstructions []string) ResourceConfigAPIGetCateringPackageByChainRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// External system code.
func (r ResourceConfigAPIGetCateringPackageByChainRequest) XExternalsystem(xExternalsystem string) ResourceConfigAPIGetCateringPackageByChainRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ResourceConfigAPIGetCateringPackageByChainRequest) AcceptLanguage(acceptLanguage string) ResourceConfigAPIGetCateringPackageByChainRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ResourceConfigAPIGetCateringPackageByChainRequest) Execute() (*CateringPackage, *http.Response, error) {
	return r.ApiService.GetCateringPackageByChainExecute(r)
}

/*
GetCateringPackageByChain Get catering package by chain

Use this API to get catering package. <p><strong>OperationId:</strong>getCateringPackageByChain</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cateringPackageId Unique Catering Package ID
 @return ResourceConfigAPIGetCateringPackageByChainRequest
*/
func (a *ResourceConfigAPIService) GetCateringPackageByChain(ctx context.Context, cateringPackageId string) ResourceConfigAPIGetCateringPackageByChainRequest {
	return ResourceConfigAPIGetCateringPackageByChainRequest{
		ApiService: a,
		ctx: ctx,
		cateringPackageId: cateringPackageId,
	}
}

// Execute executes the request
//  @return CateringPackage
func (a *ResourceConfigAPIService) GetCateringPackageByChainExecute(r ResourceConfigAPIGetCateringPackageByChainRequest) (*CateringPackage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CateringPackage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResourceConfigAPIService.GetCateringPackageByChain")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cateringPackages/{cateringPackageId}"
	localVarPath = strings.Replace(localVarPath, "{"+"cateringPackageId"+"}", url.PathEscape(parameterValueToString(r.cateringPackageId, "cateringPackageId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.cateringPackageId) < 1 {
		return localVarReturnValue, nil, reportError("cateringPackageId must have at least 1 elements")
	}
	if strlen(r.cateringPackageId) > 2000 {
		return localVarReturnValue, nil, reportError("cateringPackageId must have less than 2000 elements")
	}

	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
  }
	if r.idExtension != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idExtension", r.idExtension, "")
  }
	if r.idContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", r.idContext, "")
  }
	if r.pkgIDType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pkgIDType", r.pkgIDType, "")
  }
	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ResourceConfigAPIGetCateringPackagesRequest struct {
	ctx context.Context
	ApiService *ResourceConfigAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	packageCode *[]string
	description *string
	duration *int32
	webBookable *bool
	pkgTmpltType *string
	marketCode *string
	priceCode *string
	minAttendees *int32
	maxAttendees *int32
	sellDate *string
	startDateTime *string
	endDateTime *string
	bookingType *string
	fetchInstructions *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ResourceConfigAPIGetCateringPackagesRequest) Authorization(authorization string) ResourceConfigAPIGetCateringPackagesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ResourceConfigAPIGetCateringPackagesRequest) XAppKey(xAppKey string) ResourceConfigAPIGetCateringPackagesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ResourceConfigAPIGetCateringPackagesRequest) XHotelid(xHotelid string) ResourceConfigAPIGetCateringPackagesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ResourceConfigAPIGetCateringPackagesRequest) Limit(limit int32) ResourceConfigAPIGetCateringPackagesRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ResourceConfigAPIGetCateringPackagesRequest) Offset(offset int32) ResourceConfigAPIGetCateringPackagesRequest {
	r.offset = &offset
	return r
}

func (r ResourceConfigAPIGetCateringPackagesRequest) PackageCode(packageCode []string) ResourceConfigAPIGetCateringPackagesRequest {
	r.packageCode = &packageCode
	return r
}

// Revenue Types for which details are to be fetched.
func (r ResourceConfigAPIGetCateringPackagesRequest) Description(description string) ResourceConfigAPIGetCateringPackagesRequest {
	r.description = &description
	return r
}

// Duration for which the event is scheduled.
func (r ResourceConfigAPIGetCateringPackagesRequest) Duration(duration int32) ResourceConfigAPIGetCateringPackagesRequest {
	r.duration = &duration
	return r
}

// Defines if web booking is allowed.
func (r ResourceConfigAPIGetCateringPackagesRequest) WebBookable(webBookable bool) ResourceConfigAPIGetCateringPackagesRequest {
	r.webBookable = &webBookable
	return r
}

// It represents Catering Packages and Templates both.
func (r ResourceConfigAPIGetCateringPackagesRequest) PkgTmpltType(pkgTmpltType string) ResourceConfigAPIGetCateringPackagesRequest {
	r.pkgTmpltType = &pkgTmpltType
	return r
}

// Market Code associated with the price details of the Package.
func (r ResourceConfigAPIGetCateringPackagesRequest) MarketCode(marketCode string) ResourceConfigAPIGetCateringPackagesRequest {
	r.marketCode = &marketCode
	return r
}

// Price Code for which details are to be fetched.
func (r ResourceConfigAPIGetCateringPackagesRequest) PriceCode(priceCode string) ResourceConfigAPIGetCateringPackagesRequest {
	r.priceCode = &priceCode
	return r
}

// Minimum Attendees.
func (r ResourceConfigAPIGetCateringPackagesRequest) MinAttendees(minAttendees int32) ResourceConfigAPIGetCateringPackagesRequest {
	r.minAttendees = &minAttendees
	return r
}

// Maximum Attendees.
func (r ResourceConfigAPIGetCateringPackagesRequest) MaxAttendees(maxAttendees int32) ResourceConfigAPIGetCateringPackagesRequest {
	r.maxAttendees = &maxAttendees
	return r
}

// Selling Date associated with the Price Details.
func (r ResourceConfigAPIGetCateringPackagesRequest) SellDate(sellDate string) ResourceConfigAPIGetCateringPackagesRequest {
	r.sellDate = &sellDate
	return r
}

func (r ResourceConfigAPIGetCateringPackagesRequest) StartDateTime(startDateTime string) ResourceConfigAPIGetCateringPackagesRequest {
	r.startDateTime = &startDateTime
	return r
}

func (r ResourceConfigAPIGetCateringPackagesRequest) EndDateTime(endDateTime string) ResourceConfigAPIGetCateringPackagesRequest {
	r.endDateTime = &endDateTime
	return r
}

// Collection of configured Booking Types for the package property.
func (r ResourceConfigAPIGetCateringPackagesRequest) BookingType(bookingType string) ResourceConfigAPIGetCateringPackagesRequest {
	r.bookingType = &bookingType
	return r
}

// Fetch instructions that can be used in Catering Packages maintenance.
func (r ResourceConfigAPIGetCateringPackagesRequest) FetchInstructions(fetchInstructions []string) ResourceConfigAPIGetCateringPackagesRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// External system code.
func (r ResourceConfigAPIGetCateringPackagesRequest) XExternalsystem(xExternalsystem string) ResourceConfigAPIGetCateringPackagesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ResourceConfigAPIGetCateringPackagesRequest) AcceptLanguage(acceptLanguage string) ResourceConfigAPIGetCateringPackagesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ResourceConfigAPIGetCateringPackagesRequest) Execute() (*CateringPackagesInfo, *http.Response, error) {
	return r.ApiService.GetCateringPackagesExecute(r)
}

/*
GetCateringPackages Fetch catering packages for a property.

Fetch existing Catering Packages for a property. <p><strong>OperationId:</strong>getCateringPackages</p> <p>The maximum allowable limit for this API is <strong>25</strong>.</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique OPERA Hotel ID
 @return ResourceConfigAPIGetCateringPackagesRequest
*/
func (a *ResourceConfigAPIService) GetCateringPackages(ctx context.Context, hotelId string) ResourceConfigAPIGetCateringPackagesRequest {
	return ResourceConfigAPIGetCateringPackagesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CateringPackagesInfo
func (a *ResourceConfigAPIService) GetCateringPackagesExecute(r ResourceConfigAPIGetCateringPackagesRequest) (*CateringPackagesInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CateringPackagesInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResourceConfigAPIService.GetCateringPackages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/cateringPackages"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
  }
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
  }
	if r.packageCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "packageCode", r.packageCode, "csv")
  }
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
  }
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration", r.duration, "")
  }
	if r.webBookable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "webBookable", r.webBookable, "")
  }
	if r.pkgTmpltType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pkgTmpltType", r.pkgTmpltType, "")
  }
	if r.marketCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "marketCode", r.marketCode, "")
  }
	if r.priceCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "priceCode", r.priceCode, "")
  }
	if r.minAttendees != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "minAttendees", r.minAttendees, "")
  }
	if r.maxAttendees != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxAttendees", r.maxAttendees, "")
  }
	if r.sellDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sellDate", r.sellDate, "")
  }
	if r.startDateTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDateTime", r.startDateTime, "")
  }
	if r.endDateTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDateTime", r.endDateTime, "")
  }
	if r.bookingType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bookingType", r.bookingType, "")
  }
	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ResourceConfigAPIGetCateringPackagesMultiPropertiesRequest struct {
	ctx context.Context
	ApiService *ResourceConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	hotelIds *[]string
	packageCode *[]string
	description *string
	duration *int32
	webBookable *bool
	pkgTmpltType *string
	marketCode *string
	priceCode *string
	minAttendees *int32
	maxAttendees *int32
	sellDate *string
	startDateTime *string
	endDateTime *string
	bookingType *string
	fetchInstructions *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ResourceConfigAPIGetCateringPackagesMultiPropertiesRequest) Authorization(authorization string) ResourceConfigAPIGetCateringPackagesMultiPropertiesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ResourceConfigAPIGetCateringPackagesMultiPropertiesRequest) XAppKey(xAppKey string) ResourceConfigAPIGetCateringPackagesMultiPropertiesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ResourceConfigAPIGetCateringPackagesMultiPropertiesRequest) XHotelid(xHotelid string) ResourceConfigAPIGetCateringPackagesMultiPropertiesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ResourceConfigAPIGetCateringPackagesMultiPropertiesRequest) Limit(limit int32) ResourceConfigAPIGetCateringPackagesMultiPropertiesRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ResourceConfigAPIGetCateringPackagesMultiPropertiesRequest) Offset(offset int32) ResourceConfigAPIGetCateringPackagesMultiPropertiesRequest {
	r.offset = &offset
	return r
}

func (r ResourceConfigAPIGetCateringPackagesMultiPropertiesRequest) HotelIds(hotelIds []string) ResourceConfigAPIGetCateringPackagesMultiPropertiesRequest {
	r.hotelIds = &hotelIds
	return r
}

func (r ResourceConfigAPIGetCateringPackagesMultiPropertiesRequest) PackageCode(packageCode []string) ResourceConfigAPIGetCateringPackagesMultiPropertiesRequest {
	r.packageCode = &packageCode
	return r
}

// Revenue Types for which details are to be fetched.
func (r ResourceConfigAPIGetCateringPackagesMultiPropertiesRequest) Description(description string) ResourceConfigAPIGetCateringPackagesMultiPropertiesRequest {
	r.description = &description
	return r
}

// Duration for which the event is scheduled.
func (r ResourceConfigAPIGetCateringPackagesMultiPropertiesRequest) Duration(duration int32) ResourceConfigAPIGetCateringPackagesMultiPropertiesRequest {
	r.duration = &duration
	return r
}

// Defines if web booking is allowed.
func (r ResourceConfigAPIGetCateringPackagesMultiPropertiesRequest) WebBookable(webBookable bool) ResourceConfigAPIGetCateringPackagesMultiPropertiesRequest {
	r.webBookable = &webBookable
	return r
}

// It represents Catering Packages and Templates both.
func (r ResourceConfigAPIGetCateringPackagesMultiPropertiesRequest) PkgTmpltType(pkgTmpltType string) ResourceConfigAPIGetCateringPackagesMultiPropertiesRequest {
	r.pkgTmpltType = &pkgTmpltType
	return r
}

// Market Code associated with the price details of the Package.
func (r ResourceConfigAPIGetCateringPackagesMultiPropertiesRequest) MarketCode(marketCode string) ResourceConfigAPIGetCateringPackagesMultiPropertiesRequest {
	r.marketCode = &marketCode
	return r
}

// Price Code for which details are to be fetched.
func (r ResourceConfigAPIGetCateringPackagesMultiPropertiesRequest) PriceCode(priceCode string) ResourceConfigAPIGetCateringPackagesMultiPropertiesRequest {
	r.priceCode = &priceCode
	return r
}

// Minimum Attendees.
func (r ResourceConfigAPIGetCateringPackagesMultiPropertiesRequest) MinAttendees(minAttendees int32) ResourceConfigAPIGetCateringPackagesMultiPropertiesRequest {
	r.minAttendees = &minAttendees
	return r
}

// Maximum Attendees.
func (r ResourceConfigAPIGetCateringPackagesMultiPropertiesRequest) MaxAttendees(maxAttendees int32) ResourceConfigAPIGetCateringPackagesMultiPropertiesRequest {
	r.maxAttendees = &maxAttendees
	return r
}

// Selling Date associated with the Price Details.
func (r ResourceConfigAPIGetCateringPackagesMultiPropertiesRequest) SellDate(sellDate string) ResourceConfigAPIGetCateringPackagesMultiPropertiesRequest {
	r.sellDate = &sellDate
	return r
}

func (r ResourceConfigAPIGetCateringPackagesMultiPropertiesRequest) StartDateTime(startDateTime string) ResourceConfigAPIGetCateringPackagesMultiPropertiesRequest {
	r.startDateTime = &startDateTime
	return r
}

func (r ResourceConfigAPIGetCateringPackagesMultiPropertiesRequest) EndDateTime(endDateTime string) ResourceConfigAPIGetCateringPackagesMultiPropertiesRequest {
	r.endDateTime = &endDateTime
	return r
}

// Collection of configured Booking Types for the package property.
func (r ResourceConfigAPIGetCateringPackagesMultiPropertiesRequest) BookingType(bookingType string) ResourceConfigAPIGetCateringPackagesMultiPropertiesRequest {
	r.bookingType = &bookingType
	return r
}

// Fetch instructions that can be used in Catering Packages maintenance.
func (r ResourceConfigAPIGetCateringPackagesMultiPropertiesRequest) FetchInstructions(fetchInstructions []string) ResourceConfigAPIGetCateringPackagesMultiPropertiesRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// External system code.
func (r ResourceConfigAPIGetCateringPackagesMultiPropertiesRequest) XExternalsystem(xExternalsystem string) ResourceConfigAPIGetCateringPackagesMultiPropertiesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ResourceConfigAPIGetCateringPackagesMultiPropertiesRequest) AcceptLanguage(acceptLanguage string) ResourceConfigAPIGetCateringPackagesMultiPropertiesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ResourceConfigAPIGetCateringPackagesMultiPropertiesRequest) Execute() (*CateringPackagesInfo, *http.Response, error) {
	return r.ApiService.GetCateringPackagesMultiPropertiesExecute(r)
}

/*
GetCateringPackagesMultiProperties Fetch catering packages

Fetch existing Catering Packages. <p><strong>OperationId:</strong>getCateringPackagesMultiProperties</p> <p>The maximum allowable limit for this API is <strong>25</strong>.</p> <p>This API allows a time span of <strong>90</strong> days.</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ResourceConfigAPIGetCateringPackagesMultiPropertiesRequest
*/
func (a *ResourceConfigAPIService) GetCateringPackagesMultiProperties(ctx context.Context) ResourceConfigAPIGetCateringPackagesMultiPropertiesRequest {
	return ResourceConfigAPIGetCateringPackagesMultiPropertiesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CateringPackagesInfo
func (a *ResourceConfigAPIService) GetCateringPackagesMultiPropertiesExecute(r ResourceConfigAPIGetCateringPackagesMultiPropertiesRequest) (*CateringPackagesInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CateringPackagesInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResourceConfigAPIService.GetCateringPackagesMultiProperties")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cateringPackages"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
  }
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
  }
	if r.hotelIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", r.hotelIds, "csv")
  }
	if r.packageCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "packageCode", r.packageCode, "csv")
  }
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
  }
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration", r.duration, "")
  }
	if r.webBookable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "webBookable", r.webBookable, "")
  }
	if r.pkgTmpltType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pkgTmpltType", r.pkgTmpltType, "")
  }
	if r.marketCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "marketCode", r.marketCode, "")
  }
	if r.priceCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "priceCode", r.priceCode, "")
  }
	if r.minAttendees != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "minAttendees", r.minAttendees, "")
  }
	if r.maxAttendees != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxAttendees", r.maxAttendees, "")
  }
	if r.sellDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sellDate", r.sellDate, "")
  }
	if r.startDateTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDateTime", r.startDateTime, "")
  }
	if r.endDateTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDateTime", r.endDateTime, "")
  }
	if r.bookingType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bookingType", r.bookingType, "")
  }
	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ResourceConfigAPIGetCateringServingsRequest struct {
	ctx context.Context
	ApiService *ResourceConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	fetchInactive *bool
	servingCodes *[]string
	wildCard *string
	description *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ResourceConfigAPIGetCateringServingsRequest) Authorization(authorization string) ResourceConfigAPIGetCateringServingsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ResourceConfigAPIGetCateringServingsRequest) XAppKey(xAppKey string) ResourceConfigAPIGetCateringServingsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ResourceConfigAPIGetCateringServingsRequest) XHotelid(xHotelid string) ResourceConfigAPIGetCateringServingsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Determines wether to fetch inactive records or not.
func (r ResourceConfigAPIGetCateringServingsRequest) FetchInactive(fetchInactive bool) ResourceConfigAPIGetCateringServingsRequest {
	r.fetchInactive = &fetchInactive
	return r
}

// Codes to be searched.
func (r ResourceConfigAPIGetCateringServingsRequest) ServingCodes(servingCodes []string) ResourceConfigAPIGetCateringServingsRequest {
	r.servingCodes = &servingCodes
	return r
}

// Wildcard search on the code.
func (r ResourceConfigAPIGetCateringServingsRequest) WildCard(wildCard string) ResourceConfigAPIGetCateringServingsRequest {
	r.wildCard = &wildCard
	return r
}

// Description of the code.
func (r ResourceConfigAPIGetCateringServingsRequest) Description(description string) ResourceConfigAPIGetCateringServingsRequest {
	r.description = &description
	return r
}

// External system code.
func (r ResourceConfigAPIGetCateringServingsRequest) XExternalsystem(xExternalsystem string) ResourceConfigAPIGetCateringServingsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ResourceConfigAPIGetCateringServingsRequest) AcceptLanguage(acceptLanguage string) ResourceConfigAPIGetCateringServingsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ResourceConfigAPIGetCateringServingsRequest) Execute() (*CateringServingsInfo, *http.Response, error) {
	return r.ApiService.GetCateringServingsExecute(r)
}

/*
GetCateringServings Get catering servings

Get catering servings <p><strong>OperationId:</strong>getCateringServings</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ResourceConfigAPIGetCateringServingsRequest
*/
func (a *ResourceConfigAPIService) GetCateringServings(ctx context.Context) ResourceConfigAPIGetCateringServingsRequest {
	return ResourceConfigAPIGetCateringServingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CateringServingsInfo
func (a *ResourceConfigAPIService) GetCateringServingsExecute(r ResourceConfigAPIGetCateringServingsRequest) (*CateringServingsInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CateringServingsInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResourceConfigAPIService.GetCateringServings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cateringServings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fetchInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInactive", r.fetchInactive, "")
  }
	if r.servingCodes != nil {
		t := *r.servingCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "servingCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "servingCodes", t, "multi")
		}
  }
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
  }
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ResourceConfigAPIGetDailyInventoryItemsRequest struct {
	ctx context.Context
	ApiService *ResourceConfigAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	itemClassCode *string
	itemName *string
	friday *bool
	monday *bool
	saturday *bool
	sunday *bool
	thursday *bool
	tuesday *bool
	wednesday *bool
	startDate *string
	endDate *string
	duration *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ResourceConfigAPIGetDailyInventoryItemsRequest) Authorization(authorization string) ResourceConfigAPIGetDailyInventoryItemsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ResourceConfigAPIGetDailyInventoryItemsRequest) XAppKey(xAppKey string) ResourceConfigAPIGetDailyInventoryItemsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ResourceConfigAPIGetDailyInventoryItemsRequest) XHotelid(xHotelid string) ResourceConfigAPIGetDailyInventoryItemsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Item Class ID which daily item belongs to.
func (r ResourceConfigAPIGetDailyInventoryItemsRequest) ItemClassCode(itemClassCode string) ResourceConfigAPIGetDailyInventoryItemsRequest {
	r.itemClassCode = &itemClassCode
	return r
}

// Item name which daily item belongs to.
func (r ResourceConfigAPIGetDailyInventoryItemsRequest) ItemName(itemName string) ResourceConfigAPIGetDailyInventoryItemsRequest {
	r.itemName = &itemName
	return r
}

func (r ResourceConfigAPIGetDailyInventoryItemsRequest) Friday(friday bool) ResourceConfigAPIGetDailyInventoryItemsRequest {
	r.friday = &friday
	return r
}

func (r ResourceConfigAPIGetDailyInventoryItemsRequest) Monday(monday bool) ResourceConfigAPIGetDailyInventoryItemsRequest {
	r.monday = &monday
	return r
}

func (r ResourceConfigAPIGetDailyInventoryItemsRequest) Saturday(saturday bool) ResourceConfigAPIGetDailyInventoryItemsRequest {
	r.saturday = &saturday
	return r
}

func (r ResourceConfigAPIGetDailyInventoryItemsRequest) Sunday(sunday bool) ResourceConfigAPIGetDailyInventoryItemsRequest {
	r.sunday = &sunday
	return r
}

func (r ResourceConfigAPIGetDailyInventoryItemsRequest) Thursday(thursday bool) ResourceConfigAPIGetDailyInventoryItemsRequest {
	r.thursday = &thursday
	return r
}

func (r ResourceConfigAPIGetDailyInventoryItemsRequest) Tuesday(tuesday bool) ResourceConfigAPIGetDailyInventoryItemsRequest {
	r.tuesday = &tuesday
	return r
}

func (r ResourceConfigAPIGetDailyInventoryItemsRequest) Wednesday(wednesday bool) ResourceConfigAPIGetDailyInventoryItemsRequest {
	r.wednesday = &wednesday
	return r
}

func (r ResourceConfigAPIGetDailyInventoryItemsRequest) StartDate(startDate string) ResourceConfigAPIGetDailyInventoryItemsRequest {
	r.startDate = &startDate
	return r
}

func (r ResourceConfigAPIGetDailyInventoryItemsRequest) EndDate(endDate string) ResourceConfigAPIGetDailyInventoryItemsRequest {
	r.endDate = &endDate
	return r
}

func (r ResourceConfigAPIGetDailyInventoryItemsRequest) Duration(duration string) ResourceConfigAPIGetDailyInventoryItemsRequest {
	r.duration = &duration
	return r
}

// External system code.
func (r ResourceConfigAPIGetDailyInventoryItemsRequest) XExternalsystem(xExternalsystem string) ResourceConfigAPIGetDailyInventoryItemsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ResourceConfigAPIGetDailyInventoryItemsRequest) AcceptLanguage(acceptLanguage string) ResourceConfigAPIGetDailyInventoryItemsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ResourceConfigAPIGetDailyInventoryItemsRequest) Execute() (*DailyInventoryItems, *http.Response, error) {
	return r.ApiService.GetDailyInventoryItemsExecute(r)
}

/*
GetDailyInventoryItems Get Daily Item Inventory

Retrieve a list of Daily Item Inventories that exist for a property.  Examples of Item Inventory in a property could be Crib, Roll Away beds, Microwave etc. API will fetch daily quantity configured for the particular item.  <p><strong>OperationId:</strong>getDailyInventoryItems</p> <p>This API allows a time span of <strong>7</strong> days.</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique OPERA Hotel code
 @return ResourceConfigAPIGetDailyInventoryItemsRequest
*/
func (a *ResourceConfigAPIService) GetDailyInventoryItems(ctx context.Context, hotelId string) ResourceConfigAPIGetDailyInventoryItemsRequest {
	return ResourceConfigAPIGetDailyInventoryItemsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return DailyInventoryItems
func (a *ResourceConfigAPIService) GetDailyInventoryItemsExecute(r ResourceConfigAPIGetDailyInventoryItemsRequest) (*DailyInventoryItems, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DailyInventoryItems
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResourceConfigAPIService.GetDailyInventoryItems")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/dailyInventoryItems"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.itemClassCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "itemClassCode", r.itemClassCode, "")
  }
	if r.itemName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "itemName", r.itemName, "")
  }
	if r.friday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "friday", r.friday, "")
  }
	if r.monday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "monday", r.monday, "")
  }
	if r.saturday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "saturday", r.saturday, "")
  }
	if r.sunday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sunday", r.sunday, "")
  }
	if r.thursday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "thursday", r.thursday, "")
  }
	if r.tuesday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tuesday", r.tuesday, "")
  }
	if r.wednesday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wednesday", r.wednesday, "")
  }
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
  }
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
  }
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration", r.duration, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ResourceConfigAPIGetEventForecastsRequest struct {
	ctx context.Context
	ApiService *ResourceConfigAPIService
	hotelId string
	fetchInstructions *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	eventTypeCodes *[]string
	eventTypeWildCard *string
	revenueTypeCodes *[]string
	revenueTypeWildCard *string
	eventDate *string
	blockTypeCodes *[]string
	marketCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Fetch instructions that can be used in event forecast maintenance.
func (r ResourceConfigAPIGetEventForecastsRequest) FetchInstructions(fetchInstructions []string) ResourceConfigAPIGetEventForecastsRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ResourceConfigAPIGetEventForecastsRequest) Authorization(authorization string) ResourceConfigAPIGetEventForecastsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ResourceConfigAPIGetEventForecastsRequest) XAppKey(xAppKey string) ResourceConfigAPIGetEventForecastsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ResourceConfigAPIGetEventForecastsRequest) XHotelid(xHotelid string) ResourceConfigAPIGetEventForecastsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ResourceConfigAPIGetEventForecastsRequest) Limit(limit int32) ResourceConfigAPIGetEventForecastsRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ResourceConfigAPIGetEventForecastsRequest) Offset(offset int32) ResourceConfigAPIGetEventForecastsRequest {
	r.offset = &offset
	return r
}

// Codes to be searched.
func (r ResourceConfigAPIGetEventForecastsRequest) EventTypeCodes(eventTypeCodes []string) ResourceConfigAPIGetEventForecastsRequest {
	r.eventTypeCodes = &eventTypeCodes
	return r
}

// Wildcard search on the code.
func (r ResourceConfigAPIGetEventForecastsRequest) EventTypeWildCard(eventTypeWildCard string) ResourceConfigAPIGetEventForecastsRequest {
	r.eventTypeWildCard = &eventTypeWildCard
	return r
}

// Codes to be searched.
func (r ResourceConfigAPIGetEventForecastsRequest) RevenueTypeCodes(revenueTypeCodes []string) ResourceConfigAPIGetEventForecastsRequest {
	r.revenueTypeCodes = &revenueTypeCodes
	return r
}

// Wildcard search on the code.
func (r ResourceConfigAPIGetEventForecastsRequest) RevenueTypeWildCard(revenueTypeWildCard string) ResourceConfigAPIGetEventForecastsRequest {
	r.revenueTypeWildCard = &revenueTypeWildCard
	return r
}

// Date for which the event is scheduled.
func (r ResourceConfigAPIGetEventForecastsRequest) EventDate(eventDate string) ResourceConfigAPIGetEventForecastsRequest {
	r.eventDate = &eventDate
	return r
}

func (r ResourceConfigAPIGetEventForecastsRequest) BlockTypeCodes(blockTypeCodes []string) ResourceConfigAPIGetEventForecastsRequest {
	r.blockTypeCodes = &blockTypeCodes
	return r
}

func (r ResourceConfigAPIGetEventForecastsRequest) MarketCodes(marketCodes []string) ResourceConfigAPIGetEventForecastsRequest {
	r.marketCodes = &marketCodes
	return r
}

// External system code.
func (r ResourceConfigAPIGetEventForecastsRequest) XExternalsystem(xExternalsystem string) ResourceConfigAPIGetEventForecastsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ResourceConfigAPIGetEventForecastsRequest) AcceptLanguage(acceptLanguage string) ResourceConfigAPIGetEventForecastsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ResourceConfigAPIGetEventForecastsRequest) Execute() (*EventForecastsInfo, *http.Response, error) {
	return r.ApiService.GetEventForecastsExecute(r)
}

/*
GetEventForecasts Get Event Forecasts

This API will allow you to retrieve all Event Forecast for a property. <p><strong>OperationId:</strong>getEventForecasts</p> <p>The maximum allowable limit for this API is <strong>200</strong>.</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique OPERA Hotel ID
 @return ResourceConfigAPIGetEventForecastsRequest
*/
func (a *ResourceConfigAPIService) GetEventForecasts(ctx context.Context, hotelId string) ResourceConfigAPIGetEventForecastsRequest {
	return ResourceConfigAPIGetEventForecastsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return EventForecastsInfo
func (a *ResourceConfigAPIService) GetEventForecastsExecute(r ResourceConfigAPIGetEventForecastsRequest) (*EventForecastsInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EventForecastsInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResourceConfigAPIService.GetEventForecasts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/eventForecasts"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	{
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
  }
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
  }
	if r.eventTypeCodes != nil {
		t := *r.eventTypeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "eventTypeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "eventTypeCodes", t, "multi")
		}
  }
	if r.eventTypeWildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "eventTypeWildCard", r.eventTypeWildCard, "")
  }
	if r.revenueTypeCodes != nil {
		t := *r.revenueTypeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "revenueTypeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "revenueTypeCodes", t, "multi")
		}
  }
	if r.revenueTypeWildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "revenueTypeWildCard", r.revenueTypeWildCard, "")
  }
	if r.eventDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "eventDate", r.eventDate, "")
  }
	if r.blockTypeCodes != nil {
		t := *r.blockTypeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "blockTypeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "blockTypeCodes", t, "multi")
		}
  }
	if r.marketCodes != nil {
		t := *r.marketCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "marketCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "marketCodes", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ResourceConfigAPIGetInventoryItemTemplatesRequest struct {
	ctx context.Context
	ApiService *ResourceConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelId *string
	inventoryItemTemplateName *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ResourceConfigAPIGetInventoryItemTemplatesRequest) Authorization(authorization string) ResourceConfigAPIGetInventoryItemTemplatesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ResourceConfigAPIGetInventoryItemTemplatesRequest) XAppKey(xAppKey string) ResourceConfigAPIGetInventoryItemTemplatesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ResourceConfigAPIGetInventoryItemTemplatesRequest) XHotelid(xHotelid string) ResourceConfigAPIGetInventoryItemTemplatesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Specifies the hotel code to be searched.
func (r ResourceConfigAPIGetInventoryItemTemplatesRequest) HotelId(hotelId string) ResourceConfigAPIGetInventoryItemTemplatesRequest {
	r.hotelId = &hotelId
	return r
}

// Wildcard search for the inventory item template.
func (r ResourceConfigAPIGetInventoryItemTemplatesRequest) InventoryItemTemplateName(inventoryItemTemplateName string) ResourceConfigAPIGetInventoryItemTemplatesRequest {
	r.inventoryItemTemplateName = &inventoryItemTemplateName
	return r
}

// External system code.
func (r ResourceConfigAPIGetInventoryItemTemplatesRequest) XExternalsystem(xExternalsystem string) ResourceConfigAPIGetInventoryItemTemplatesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ResourceConfigAPIGetInventoryItemTemplatesRequest) AcceptLanguage(acceptLanguage string) ResourceConfigAPIGetInventoryItemTemplatesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ResourceConfigAPIGetInventoryItemTemplatesRequest) Execute() (*InventoryItemTemplates, *http.Response, error) {
	return r.ApiService.GetInventoryItemTemplatesExecute(r)
}

/*
GetInventoryItemTemplates Get Item Inventory templates

Retrieve a list of Item Inventory templates that exist for a property. <p><strong>OperationId:</strong>getInventoryItemTemplates</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ResourceConfigAPIGetInventoryItemTemplatesRequest
*/
func (a *ResourceConfigAPIService) GetInventoryItemTemplates(ctx context.Context) ResourceConfigAPIGetInventoryItemTemplatesRequest {
	return ResourceConfigAPIGetInventoryItemTemplatesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InventoryItemTemplates
func (a *ResourceConfigAPIService) GetInventoryItemTemplatesExecute(r ResourceConfigAPIGetInventoryItemTemplatesRequest) (*InventoryItemTemplates, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InventoryItemTemplates
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResourceConfigAPIService.GetInventoryItemTemplates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/inventoryItems"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
  }
	if r.inventoryItemTemplateName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inventoryItemTemplateName", r.inventoryItemTemplateName, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ResourceConfigAPIGetInventoryItemsRequest struct {
	ctx context.Context
	ApiService *ResourceConfigAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	itemClassCode *string
	itemName *string
	itemCode *string
	eventTypecodes *[]string
	usedForEvents *bool
	includeItemsFromTemplates *bool
	startDateTime *string
	endDateTime *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ResourceConfigAPIGetInventoryItemsRequest) Authorization(authorization string) ResourceConfigAPIGetInventoryItemsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ResourceConfigAPIGetInventoryItemsRequest) XAppKey(xAppKey string) ResourceConfigAPIGetInventoryItemsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ResourceConfigAPIGetInventoryItemsRequest) XHotelid(xHotelid string) ResourceConfigAPIGetInventoryItemsRequest {
	r.xHotelid = &xHotelid
	return r
}

// The Item Class ID which the item belongs to.
func (r ResourceConfigAPIGetInventoryItemsRequest) ItemClassCode(itemClassCode string) ResourceConfigAPIGetInventoryItemsRequest {
	r.itemClassCode = &itemClassCode
	return r
}

// The name of Inventory Item.
func (r ResourceConfigAPIGetInventoryItemsRequest) ItemName(itemName string) ResourceConfigAPIGetInventoryItemsRequest {
	r.itemName = &itemName
	return r
}

// The code of Inventory Item, also known as Quick Insert.
func (r ResourceConfigAPIGetInventoryItemsRequest) ItemCode(itemCode string) ResourceConfigAPIGetInventoryItemsRequest {
	r.itemCode = &itemCode
	return r
}

func (r ResourceConfigAPIGetInventoryItemsRequest) EventTypecodes(eventTypecodes []string) ResourceConfigAPIGetInventoryItemsRequest {
	r.eventTypecodes = &eventTypecodes
	return r
}

// Flag to indicate whether the item is used for events.
func (r ResourceConfigAPIGetInventoryItemsRequest) UsedForEvents(usedForEvents bool) ResourceConfigAPIGetInventoryItemsRequest {
	r.usedForEvents = &usedForEvents
	return r
}

// Indicates whether to include Items from Templates or not.
func (r ResourceConfigAPIGetInventoryItemsRequest) IncludeItemsFromTemplates(includeItemsFromTemplates bool) ResourceConfigAPIGetInventoryItemsRequest {
	r.includeItemsFromTemplates = &includeItemsFromTemplates
	return r
}

func (r ResourceConfigAPIGetInventoryItemsRequest) StartDateTime(startDateTime string) ResourceConfigAPIGetInventoryItemsRequest {
	r.startDateTime = &startDateTime
	return r
}

func (r ResourceConfigAPIGetInventoryItemsRequest) EndDateTime(endDateTime string) ResourceConfigAPIGetInventoryItemsRequest {
	r.endDateTime = &endDateTime
	return r
}

// External system code.
func (r ResourceConfigAPIGetInventoryItemsRequest) XExternalsystem(xExternalsystem string) ResourceConfigAPIGetInventoryItemsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ResourceConfigAPIGetInventoryItemsRequest) AcceptLanguage(acceptLanguage string) ResourceConfigAPIGetInventoryItemsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ResourceConfigAPIGetInventoryItemsRequest) Execute() (*InventoryItems, *http.Response, error) {
	return r.ApiService.GetInventoryItemsExecute(r)
}

/*
GetInventoryItems Get Item Inventory

Retrieve a list of Item Inventories that exist for a property.  Examples of Item Inventory in a property could be Crib, Roll Away beds, Microwave etc.  There is typically a quantity configured for each item, such as 5 Roll Away beds.  <p><strong>OperationId:</strong>getInventoryItems</p> <p>The maximum allowable limit for this API is <strong>200</strong>.</p> <p>This API allows a time span of <strong>7</strong> days.</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique OPERA Hotel code
 @return ResourceConfigAPIGetInventoryItemsRequest
*/
func (a *ResourceConfigAPIService) GetInventoryItems(ctx context.Context, hotelId string) ResourceConfigAPIGetInventoryItemsRequest {
	return ResourceConfigAPIGetInventoryItemsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return InventoryItems
func (a *ResourceConfigAPIService) GetInventoryItemsExecute(r ResourceConfigAPIGetInventoryItemsRequest) (*InventoryItems, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InventoryItems
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResourceConfigAPIService.GetInventoryItems")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/inventoryItems"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.itemClassCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "itemClassCode", r.itemClassCode, "")
  }
	if r.itemName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "itemName", r.itemName, "")
  }
	if r.itemCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "itemCode", r.itemCode, "")
  }
	if r.eventTypecodes != nil {
		t := *r.eventTypecodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "eventTypecodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "eventTypecodes", t, "multi")
		}
  }
	if r.usedForEvents != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usedForEvents", r.usedForEvents, "")
  }
	if r.includeItemsFromTemplates != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeItemsFromTemplates", r.includeItemsFromTemplates, "")
  }
	if r.startDateTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDateTime", r.startDateTime, "")
  }
	if r.endDateTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDateTime", r.endDateTime, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ResourceConfigAPIGetItemClassesRequest struct {
	ctx context.Context
	ApiService *ResourceConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelId *[]string
	itemClassesCode *[]string
	wildCard *string
	criteria *string
	classId *float32
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ResourceConfigAPIGetItemClassesRequest) Authorization(authorization string) ResourceConfigAPIGetItemClassesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ResourceConfigAPIGetItemClassesRequest) XAppKey(xAppKey string) ResourceConfigAPIGetItemClassesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ResourceConfigAPIGetItemClassesRequest) XHotelid(xHotelid string) ResourceConfigAPIGetItemClassesRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r ResourceConfigAPIGetItemClassesRequest) HotelId(hotelId []string) ResourceConfigAPIGetItemClassesRequest {
	r.hotelId = &hotelId
	return r
}

// Codes to be searched.
func (r ResourceConfigAPIGetItemClassesRequest) ItemClassesCode(itemClassesCode []string) ResourceConfigAPIGetItemClassesRequest {
	r.itemClassesCode = &itemClassesCode
	return r
}

// Wildcard search on the code.
func (r ResourceConfigAPIGetItemClassesRequest) WildCard(wildCard string) ResourceConfigAPIGetItemClassesRequest {
	r.wildCard = &wildCard
	return r
}

// Defines values for Item Class Type.
func (r ResourceConfigAPIGetItemClassesRequest) Criteria(criteria string) ResourceConfigAPIGetItemClassesRequest {
	r.criteria = &criteria
	return r
}

func (r ResourceConfigAPIGetItemClassesRequest) ClassId(classId float32) ResourceConfigAPIGetItemClassesRequest {
	r.classId = &classId
	return r
}

// External system code.
func (r ResourceConfigAPIGetItemClassesRequest) XExternalsystem(xExternalsystem string) ResourceConfigAPIGetItemClassesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ResourceConfigAPIGetItemClassesRequest) AcceptLanguage(acceptLanguage string) ResourceConfigAPIGetItemClassesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ResourceConfigAPIGetItemClassesRequest) Execute() (*ItemClassesInfo, *http.Response, error) {
	return r.ApiService.GetItemClassesExecute(r)
}

/*
GetItemClasses Get item classes

This API will allow you to fetch all existing Item Classes for a property. Items are categorized into logical entities called Item Classes. Item Classes assist you in filtering when selecting and grouping items on the Banquet Event Order (BEO). For example, you might have an item class for different kinds of audio visual equipment, for floral decorations, for recreational equipment, and so on.  <p><strong>OperationId:</strong>getItemClasses</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ResourceConfigAPIGetItemClassesRequest
*/
func (a *ResourceConfigAPIService) GetItemClasses(ctx context.Context) ResourceConfigAPIGetItemClassesRequest {
	return ResourceConfigAPIGetItemClassesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ItemClassesInfo
func (a *ResourceConfigAPIService) GetItemClassesExecute(r ResourceConfigAPIGetItemClassesRequest) (*ItemClassesInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ItemClassesInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResourceConfigAPIService.GetItemClasses")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/itemClasses"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "csv")
  }
	if r.itemClassesCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "itemClassesCode", r.itemClassesCode, "csv")
  }
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
  }
	if r.criteria != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "criteria", r.criteria, "")
  }
	if r.classId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "classId", r.classId, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ResourceConfigAPIGetItemPoolsRequest struct {
	ctx context.Context
	ApiService *ResourceConfigAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelIds *[]string
	itemClasseCodes *[]string
	wildCard *string
	itemPoolCodes *[]string
	itemPoolsWildCard *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ResourceConfigAPIGetItemPoolsRequest) Authorization(authorization string) ResourceConfigAPIGetItemPoolsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ResourceConfigAPIGetItemPoolsRequest) XAppKey(xAppKey string) ResourceConfigAPIGetItemPoolsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ResourceConfigAPIGetItemPoolsRequest) XHotelid(xHotelid string) ResourceConfigAPIGetItemPoolsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Hotel code.
func (r ResourceConfigAPIGetItemPoolsRequest) HotelIds(hotelIds []string) ResourceConfigAPIGetItemPoolsRequest {
	r.hotelIds = &hotelIds
	return r
}

// Codes to be searched.
func (r ResourceConfigAPIGetItemPoolsRequest) ItemClasseCodes(itemClasseCodes []string) ResourceConfigAPIGetItemPoolsRequest {
	r.itemClasseCodes = &itemClasseCodes
	return r
}

// Wildcard search on the code.
func (r ResourceConfigAPIGetItemPoolsRequest) WildCard(wildCard string) ResourceConfigAPIGetItemPoolsRequest {
	r.wildCard = &wildCard
	return r
}

// Codes to be searched.
func (r ResourceConfigAPIGetItemPoolsRequest) ItemPoolCodes(itemPoolCodes []string) ResourceConfigAPIGetItemPoolsRequest {
	r.itemPoolCodes = &itemPoolCodes
	return r
}

// Wildcard search on the code.
func (r ResourceConfigAPIGetItemPoolsRequest) ItemPoolsWildCard(itemPoolsWildCard string) ResourceConfigAPIGetItemPoolsRequest {
	r.itemPoolsWildCard = &itemPoolsWildCard
	return r
}

// External system code.
func (r ResourceConfigAPIGetItemPoolsRequest) XExternalsystem(xExternalsystem string) ResourceConfigAPIGetItemPoolsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ResourceConfigAPIGetItemPoolsRequest) AcceptLanguage(acceptLanguage string) ResourceConfigAPIGetItemPoolsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ResourceConfigAPIGetItemPoolsRequest) Execute() (*ItemPoolsInfo, *http.Response, error) {
	return r.ApiService.GetItemPoolsExecute(r)
}

/*
GetItemPools Get Item Pools

Get Item Pools that are configured for a property. <p><strong>OperationId:</strong>getItemPools</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique OPERA Hotel code
 @return ResourceConfigAPIGetItemPoolsRequest
*/
func (a *ResourceConfigAPIService) GetItemPools(ctx context.Context, hotelId string) ResourceConfigAPIGetItemPoolsRequest {
	return ResourceConfigAPIGetItemPoolsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ItemPoolsInfo
func (a *ResourceConfigAPIService) GetItemPoolsExecute(r ResourceConfigAPIGetItemPoolsRequest) (*ItemPoolsInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ItemPoolsInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResourceConfigAPIService.GetItemPools")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/itemPools"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.hotelIds != nil {
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
  }
	if r.itemClasseCodes != nil {
		t := *r.itemClasseCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "itemClasseCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "itemClasseCodes", t, "multi")
		}
  }
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
  }
	if r.itemPoolCodes != nil {
		t := *r.itemPoolCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "itemPoolCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "itemPoolCodes", t, "multi")
		}
  }
	if r.itemPoolsWildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "itemPoolsWildCard", r.itemPoolsWildCard, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ResourceConfigAPIGetRevenueGroupsRequest struct {
	ctx context.Context
	ApiService *ResourceConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	fetchInactive *bool
	revenueGroupCodes *[]string
	wildCard *string
	description *string
	includeRevenueType *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ResourceConfigAPIGetRevenueGroupsRequest) Authorization(authorization string) ResourceConfigAPIGetRevenueGroupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ResourceConfigAPIGetRevenueGroupsRequest) XAppKey(xAppKey string) ResourceConfigAPIGetRevenueGroupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ResourceConfigAPIGetRevenueGroupsRequest) XHotelid(xHotelid string) ResourceConfigAPIGetRevenueGroupsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Determines wether to fetch inactive records or not.
func (r ResourceConfigAPIGetRevenueGroupsRequest) FetchInactive(fetchInactive bool) ResourceConfigAPIGetRevenueGroupsRequest {
	r.fetchInactive = &fetchInactive
	return r
}

// Codes to be searched.
func (r ResourceConfigAPIGetRevenueGroupsRequest) RevenueGroupCodes(revenueGroupCodes []string) ResourceConfigAPIGetRevenueGroupsRequest {
	r.revenueGroupCodes = &revenueGroupCodes
	return r
}

// Wildcard search on the code.
func (r ResourceConfigAPIGetRevenueGroupsRequest) WildCard(wildCard string) ResourceConfigAPIGetRevenueGroupsRequest {
	r.wildCard = &wildCard
	return r
}

// Description of the code.
func (r ResourceConfigAPIGetRevenueGroupsRequest) Description(description string) ResourceConfigAPIGetRevenueGroupsRequest {
	r.description = &description
	return r
}

// Boolean flag to fetch revenue groups with/without revenue types. &#39;True&#39; indicates including revenue types information for corresponding revenue groups.
func (r ResourceConfigAPIGetRevenueGroupsRequest) IncludeRevenueType(includeRevenueType bool) ResourceConfigAPIGetRevenueGroupsRequest {
	r.includeRevenueType = &includeRevenueType
	return r
}

// External system code.
func (r ResourceConfigAPIGetRevenueGroupsRequest) XExternalsystem(xExternalsystem string) ResourceConfigAPIGetRevenueGroupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ResourceConfigAPIGetRevenueGroupsRequest) AcceptLanguage(acceptLanguage string) ResourceConfigAPIGetRevenueGroupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ResourceConfigAPIGetRevenueGroupsRequest) Execute() (*RevenueGroupsInfo, *http.Response, error) {
	return r.ApiService.GetRevenueGroupsExecute(r)
}

/*
GetRevenueGroups Get Catering Revenue Groups

You can use this API to retrieve all catering revenue group codes. <p><strong>OperationId:</strong>getRevenueGroups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ResourceConfigAPIGetRevenueGroupsRequest
*/
func (a *ResourceConfigAPIService) GetRevenueGroups(ctx context.Context) ResourceConfigAPIGetRevenueGroupsRequest {
	return ResourceConfigAPIGetRevenueGroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RevenueGroupsInfo
func (a *ResourceConfigAPIService) GetRevenueGroupsExecute(r ResourceConfigAPIGetRevenueGroupsRequest) (*RevenueGroupsInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RevenueGroupsInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResourceConfigAPIService.GetRevenueGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/revenueGroups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fetchInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInactive", r.fetchInactive, "")
  }
	if r.revenueGroupCodes != nil {
		t := *r.revenueGroupCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "revenueGroupCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "revenueGroupCodes", t, "multi")
		}
  }
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
  }
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
  }
	if r.includeRevenueType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeRevenueType", r.includeRevenueType, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ResourceConfigAPIGetRevenueTypesRequest struct {
	ctx context.Context
	ApiService *ResourceConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	revenueGroupCodes *[]string
	revenueGroupWildCard *string
	revenueTypeCodes *[]string
	revenueTypeWildCard *string
	includeInactive *bool
	includeRevenueTypeDetail *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ResourceConfigAPIGetRevenueTypesRequest) Authorization(authorization string) ResourceConfigAPIGetRevenueTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ResourceConfigAPIGetRevenueTypesRequest) XAppKey(xAppKey string) ResourceConfigAPIGetRevenueTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ResourceConfigAPIGetRevenueTypesRequest) XHotelid(xHotelid string) ResourceConfigAPIGetRevenueTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Codes to be searched.
func (r ResourceConfigAPIGetRevenueTypesRequest) RevenueGroupCodes(revenueGroupCodes []string) ResourceConfigAPIGetRevenueTypesRequest {
	r.revenueGroupCodes = &revenueGroupCodes
	return r
}

// Wildcard search on the code.
func (r ResourceConfigAPIGetRevenueTypesRequest) RevenueGroupWildCard(revenueGroupWildCard string) ResourceConfigAPIGetRevenueTypesRequest {
	r.revenueGroupWildCard = &revenueGroupWildCard
	return r
}

// Codes to be searched.
func (r ResourceConfigAPIGetRevenueTypesRequest) RevenueTypeCodes(revenueTypeCodes []string) ResourceConfigAPIGetRevenueTypesRequest {
	r.revenueTypeCodes = &revenueTypeCodes
	return r
}

// Wildcard search on the code.
func (r ResourceConfigAPIGetRevenueTypesRequest) RevenueTypeWildCard(revenueTypeWildCard string) ResourceConfigAPIGetRevenueTypesRequest {
	r.revenueTypeWildCard = &revenueTypeWildCard
	return r
}

// If true this boolean will set the criteria to only return Inactive records.
func (r ResourceConfigAPIGetRevenueTypesRequest) IncludeInactive(includeInactive bool) ResourceConfigAPIGetRevenueTypesRequest {
	r.includeInactive = &includeInactive
	return r
}

// Boolean flag to fetch revenue groups/types with/without associated revenue types/revenue type details. &#39;True&#39; indicates including revenue types/revenue type details information for corresponding revenue groups/revenue types. (Revenue Type is assoicated to Revenue groups and Revenue Type details are assoicated to Revenue Types)
func (r ResourceConfigAPIGetRevenueTypesRequest) IncludeRevenueTypeDetail(includeRevenueTypeDetail bool) ResourceConfigAPIGetRevenueTypesRequest {
	r.includeRevenueTypeDetail = &includeRevenueTypeDetail
	return r
}

// External system code.
func (r ResourceConfigAPIGetRevenueTypesRequest) XExternalsystem(xExternalsystem string) ResourceConfigAPIGetRevenueTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ResourceConfigAPIGetRevenueTypesRequest) AcceptLanguage(acceptLanguage string) ResourceConfigAPIGetRevenueTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ResourceConfigAPIGetRevenueTypesRequest) Execute() (*RevenueTypesInfo, *http.Response, error) {
	return r.ApiService.GetRevenueTypesExecute(r)
}

/*
GetRevenueTypes Get Catering Revenue Types

You can use this API to retrieve all Catering Revenue Type codes configured. <p><strong>OperationId:</strong>getRevenueTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ResourceConfigAPIGetRevenueTypesRequest
*/
func (a *ResourceConfigAPIService) GetRevenueTypes(ctx context.Context) ResourceConfigAPIGetRevenueTypesRequest {
	return ResourceConfigAPIGetRevenueTypesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RevenueTypesInfo
func (a *ResourceConfigAPIService) GetRevenueTypesExecute(r ResourceConfigAPIGetRevenueTypesRequest) (*RevenueTypesInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RevenueTypesInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResourceConfigAPIService.GetRevenueTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/revenueTypes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.revenueGroupCodes != nil {
		t := *r.revenueGroupCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "revenueGroupCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "revenueGroupCodes", t, "multi")
		}
  }
	if r.revenueGroupWildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "revenueGroupWildCard", r.revenueGroupWildCard, "")
  }
	if r.revenueTypeCodes != nil {
		t := *r.revenueTypeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "revenueTypeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "revenueTypeCodes", t, "multi")
		}
  }
	if r.revenueTypeWildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "revenueTypeWildCard", r.revenueTypeWildCard, "")
  }
	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
  }
	if r.includeRevenueTypeDetail != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeRevenueTypeDetail", r.includeRevenueTypeDetail, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ResourceConfigAPIPostCateringContainersRequest struct {
	ctx context.Context
	ApiService *ResourceConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	cateringContainers *CateringContainers
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ResourceConfigAPIPostCateringContainersRequest) Authorization(authorization string) ResourceConfigAPIPostCateringContainersRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ResourceConfigAPIPostCateringContainersRequest) XAppKey(xAppKey string) ResourceConfigAPIPostCateringContainersRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ResourceConfigAPIPostCateringContainersRequest) XHotelid(xHotelid string) ResourceConfigAPIPostCateringContainersRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object which holds new Catering Code Containers.
func (r ResourceConfigAPIPostCateringContainersRequest) CateringContainers(cateringContainers CateringContainers) ResourceConfigAPIPostCateringContainersRequest {
	r.cateringContainers = &cateringContainers
	return r
}

// External system code.
func (r ResourceConfigAPIPostCateringContainersRequest) XExternalsystem(xExternalsystem string) ResourceConfigAPIPostCateringContainersRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ResourceConfigAPIPostCateringContainersRequest) AcceptLanguage(acceptLanguage string) ResourceConfigAPIPostCateringContainersRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ResourceConfigAPIPostCateringContainersRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostCateringContainersExecute(r)
}

/*
PostCateringContainers Create catering containers

Menu Item Catering Containers describe how individual menu item are sold (for example, per piece, per dozen, or each) when they are not included in the price of the menu. The description prints on reports such as the Banquet Event Order (BEO) and Proforma Invoice.  This API allows you to create a new Menu Item Catering Container code and description. <p><strong>OperationId:</strong>postCateringContainers</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ResourceConfigAPIPostCateringContainersRequest
*/
func (a *ResourceConfigAPIService) PostCateringContainers(ctx context.Context) ResourceConfigAPIPostCateringContainersRequest {
	return ResourceConfigAPIPostCateringContainersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ResourceConfigAPIService) PostCateringContainersExecute(r ResourceConfigAPIPostCateringContainersRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResourceConfigAPIService.PostCateringContainers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cateringContainers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.cateringContainers
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ResourceConfigAPIPostCateringItemRatesRequest struct {
	ctx context.Context
	ApiService *ResourceConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	cateringItemRates *CateringItemRates
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ResourceConfigAPIPostCateringItemRatesRequest) Authorization(authorization string) ResourceConfigAPIPostCateringItemRatesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ResourceConfigAPIPostCateringItemRatesRequest) XAppKey(xAppKey string) ResourceConfigAPIPostCateringItemRatesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ResourceConfigAPIPostCateringItemRatesRequest) XHotelid(xHotelid string) ResourceConfigAPIPostCateringItemRatesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object which holds new Catering Code&#39;s Item Rates.
func (r ResourceConfigAPIPostCateringItemRatesRequest) CateringItemRates(cateringItemRates CateringItemRates) ResourceConfigAPIPostCateringItemRatesRequest {
	r.cateringItemRates = &cateringItemRates
	return r
}

// External system code.
func (r ResourceConfigAPIPostCateringItemRatesRequest) XExternalsystem(xExternalsystem string) ResourceConfigAPIPostCateringItemRatesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ResourceConfigAPIPostCateringItemRatesRequest) AcceptLanguage(acceptLanguage string) ResourceConfigAPIPostCateringItemRatesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ResourceConfigAPIPostCateringItemRatesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostCateringItemRatesExecute(r)
}

/*
PostCateringItemRates Create Catering Item rates

Create Catering Item rates <p><strong>OperationId:</strong>postCateringItemRates</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ResourceConfigAPIPostCateringItemRatesRequest
*/
func (a *ResourceConfigAPIService) PostCateringItemRates(ctx context.Context) ResourceConfigAPIPostCateringItemRatesRequest {
	return ResourceConfigAPIPostCateringItemRatesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ResourceConfigAPIService) PostCateringItemRatesExecute(r ResourceConfigAPIPostCateringItemRatesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResourceConfigAPIService.PostCateringItemRates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cateringItemRates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.cateringItemRates
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ResourceConfigAPIPostCateringMenuClassesRequest struct {
	ctx context.Context
	ApiService *ResourceConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	cateringMenuClasses *CateringMenuClasses
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ResourceConfigAPIPostCateringMenuClassesRequest) Authorization(authorization string) ResourceConfigAPIPostCateringMenuClassesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ResourceConfigAPIPostCateringMenuClassesRequest) XAppKey(xAppKey string) ResourceConfigAPIPostCateringMenuClassesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ResourceConfigAPIPostCateringMenuClassesRequest) XHotelid(xHotelid string) ResourceConfigAPIPostCateringMenuClassesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Requestion object for creating new Menu Classes.
func (r ResourceConfigAPIPostCateringMenuClassesRequest) CateringMenuClasses(cateringMenuClasses CateringMenuClasses) ResourceConfigAPIPostCateringMenuClassesRequest {
	r.cateringMenuClasses = &cateringMenuClasses
	return r
}

// External system code.
func (r ResourceConfigAPIPostCateringMenuClassesRequest) XExternalsystem(xExternalsystem string) ResourceConfigAPIPostCateringMenuClassesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ResourceConfigAPIPostCateringMenuClassesRequest) AcceptLanguage(acceptLanguage string) ResourceConfigAPIPostCateringMenuClassesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ResourceConfigAPIPostCateringMenuClassesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostCateringMenuClassesExecute(r)
}

/*
PostCateringMenuClasses Create menu classes

You can use this API to create menu classes. <p><strong>OperationId:</strong>postCateringMenuClasses</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ResourceConfigAPIPostCateringMenuClassesRequest
*/
func (a *ResourceConfigAPIService) PostCateringMenuClasses(ctx context.Context) ResourceConfigAPIPostCateringMenuClassesRequest {
	return ResourceConfigAPIPostCateringMenuClassesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ResourceConfigAPIService) PostCateringMenuClassesExecute(r ResourceConfigAPIPostCateringMenuClassesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResourceConfigAPIService.PostCateringMenuClasses")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cateringMenuClasses"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.cateringMenuClasses
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ResourceConfigAPIPostCateringMenuItemClassesRequest struct {
	ctx context.Context
	ApiService *ResourceConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	cateringMenuItemClasses *CateringMenuItemClasses
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ResourceConfigAPIPostCateringMenuItemClassesRequest) Authorization(authorization string) ResourceConfigAPIPostCateringMenuItemClassesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ResourceConfigAPIPostCateringMenuItemClassesRequest) XAppKey(xAppKey string) ResourceConfigAPIPostCateringMenuItemClassesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ResourceConfigAPIPostCateringMenuItemClassesRequest) XHotelid(xHotelid string) ResourceConfigAPIPostCateringMenuItemClassesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for Creating Menu Item Classes.
func (r ResourceConfigAPIPostCateringMenuItemClassesRequest) CateringMenuItemClasses(cateringMenuItemClasses CateringMenuItemClasses) ResourceConfigAPIPostCateringMenuItemClassesRequest {
	r.cateringMenuItemClasses = &cateringMenuItemClasses
	return r
}

// External system code.
func (r ResourceConfigAPIPostCateringMenuItemClassesRequest) XExternalsystem(xExternalsystem string) ResourceConfigAPIPostCateringMenuItemClassesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ResourceConfigAPIPostCateringMenuItemClassesRequest) AcceptLanguage(acceptLanguage string) ResourceConfigAPIPostCateringMenuItemClassesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ResourceConfigAPIPostCateringMenuItemClassesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostCateringMenuItemClassesExecute(r)
}

/*
PostCateringMenuItemClasses Create menu item classes

You can use this API to create menu item classes. <p><strong>OperationId:</strong>postCateringMenuItemClasses</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ResourceConfigAPIPostCateringMenuItemClassesRequest
*/
func (a *ResourceConfigAPIService) PostCateringMenuItemClasses(ctx context.Context) ResourceConfigAPIPostCateringMenuItemClassesRequest {
	return ResourceConfigAPIPostCateringMenuItemClassesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ResourceConfigAPIService) PostCateringMenuItemClassesExecute(r ResourceConfigAPIPostCateringMenuItemClassesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResourceConfigAPIService.PostCateringMenuItemClasses")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cateringMenuItemClasses"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.cateringMenuItemClasses
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ResourceConfigAPIPostCateringMenuItemsRequest struct {
	ctx context.Context
	ApiService *ResourceConfigAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	cateringMenuItems *CateringMenuItems
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ResourceConfigAPIPostCateringMenuItemsRequest) Authorization(authorization string) ResourceConfigAPIPostCateringMenuItemsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ResourceConfigAPIPostCateringMenuItemsRequest) XAppKey(xAppKey string) ResourceConfigAPIPostCateringMenuItemsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ResourceConfigAPIPostCateringMenuItemsRequest) XHotelid(xHotelid string) ResourceConfigAPIPostCateringMenuItemsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating Menu Items.
func (r ResourceConfigAPIPostCateringMenuItemsRequest) CateringMenuItems(cateringMenuItems CateringMenuItems) ResourceConfigAPIPostCateringMenuItemsRequest {
	r.cateringMenuItems = &cateringMenuItems
	return r
}

// External system code.
func (r ResourceConfigAPIPostCateringMenuItemsRequest) XExternalsystem(xExternalsystem string) ResourceConfigAPIPostCateringMenuItemsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ResourceConfigAPIPostCateringMenuItemsRequest) AcceptLanguage(acceptLanguage string) ResourceConfigAPIPostCateringMenuItemsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ResourceConfigAPIPostCateringMenuItemsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostCateringMenuItemsExecute(r)
}

/*
PostCateringMenuItems Create menu items

You can use this API to create menu items. <p><strong>OperationId:</strong>postCateringMenuItems</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique OPERA Hotel Id
 @return ResourceConfigAPIPostCateringMenuItemsRequest
*/
func (a *ResourceConfigAPIService) PostCateringMenuItems(ctx context.Context, hotelId string) ResourceConfigAPIPostCateringMenuItemsRequest {
	return ResourceConfigAPIPostCateringMenuItemsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ResourceConfigAPIService) PostCateringMenuItemsExecute(r ResourceConfigAPIPostCateringMenuItemsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResourceConfigAPIService.PostCateringMenuItems")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/cateringMenuItems"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.cateringMenuItems
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ResourceConfigAPIPostCateringMenusRequest struct {
	ctx context.Context
	ApiService *ResourceConfigAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	cateringMenus *CateringMenus
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ResourceConfigAPIPostCateringMenusRequest) Authorization(authorization string) ResourceConfigAPIPostCateringMenusRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ResourceConfigAPIPostCateringMenusRequest) XAppKey(xAppKey string) ResourceConfigAPIPostCateringMenusRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ResourceConfigAPIPostCateringMenusRequest) XHotelid(xHotelid string) ResourceConfigAPIPostCateringMenusRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating new Menu .
func (r ResourceConfigAPIPostCateringMenusRequest) CateringMenus(cateringMenus CateringMenus) ResourceConfigAPIPostCateringMenusRequest {
	r.cateringMenus = &cateringMenus
	return r
}

// External system code.
func (r ResourceConfigAPIPostCateringMenusRequest) XExternalsystem(xExternalsystem string) ResourceConfigAPIPostCateringMenusRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ResourceConfigAPIPostCateringMenusRequest) AcceptLanguage(acceptLanguage string) ResourceConfigAPIPostCateringMenusRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ResourceConfigAPIPostCateringMenusRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostCateringMenusExecute(r)
}

/*
PostCateringMenus Create menus

Create menus for a property. <p><strong>OperationId:</strong>postCateringMenus</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique OPERA Hotel ID
 @return ResourceConfigAPIPostCateringMenusRequest
*/
func (a *ResourceConfigAPIService) PostCateringMenus(ctx context.Context, hotelId string) ResourceConfigAPIPostCateringMenusRequest {
	return ResourceConfigAPIPostCateringMenusRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ResourceConfigAPIService) PostCateringMenusExecute(r ResourceConfigAPIPostCateringMenusRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResourceConfigAPIService.PostCateringMenus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/cateringMenus"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.cateringMenus
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ResourceConfigAPIPostCateringPackagesRequest struct {
	ctx context.Context
	ApiService *ResourceConfigAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	cateringPackages *CateringPackages
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ResourceConfigAPIPostCateringPackagesRequest) Authorization(authorization string) ResourceConfigAPIPostCateringPackagesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ResourceConfigAPIPostCateringPackagesRequest) XAppKey(xAppKey string) ResourceConfigAPIPostCateringPackagesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ResourceConfigAPIPostCateringPackagesRequest) XHotelid(xHotelid string) ResourceConfigAPIPostCateringPackagesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating new Catering Packages.
func (r ResourceConfigAPIPostCateringPackagesRequest) CateringPackages(cateringPackages CateringPackages) ResourceConfigAPIPostCateringPackagesRequest {
	r.cateringPackages = &cateringPackages
	return r
}

// External system code.
func (r ResourceConfigAPIPostCateringPackagesRequest) XExternalsystem(xExternalsystem string) ResourceConfigAPIPostCateringPackagesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ResourceConfigAPIPostCateringPackagesRequest) AcceptLanguage(acceptLanguage string) ResourceConfigAPIPostCateringPackagesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ResourceConfigAPIPostCateringPackagesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostCateringPackagesExecute(r)
}

/*
PostCateringPackages Create catering packages

Catering packages and templates are designed to make it easier for you to set up Events. They provide pre-configured resources typically used for Events. Templates and packages are similar except that templates do not include prices. <p><strong>OperationId:</strong>postCateringPackages</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique OPERA Hotel ID
 @return ResourceConfigAPIPostCateringPackagesRequest
*/
func (a *ResourceConfigAPIService) PostCateringPackages(ctx context.Context, hotelId string) ResourceConfigAPIPostCateringPackagesRequest {
	return ResourceConfigAPIPostCateringPackagesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ResourceConfigAPIService) PostCateringPackagesExecute(r ResourceConfigAPIPostCateringPackagesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResourceConfigAPIService.PostCateringPackages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/cateringPackages"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.cateringPackages
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ResourceConfigAPIPostEventForecastsRequest struct {
	ctx context.Context
	ApiService *ResourceConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	eventForecasts *EventForecasts
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ResourceConfigAPIPostEventForecastsRequest) Authorization(authorization string) ResourceConfigAPIPostEventForecastsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ResourceConfigAPIPostEventForecastsRequest) XAppKey(xAppKey string) ResourceConfigAPIPostEventForecastsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ResourceConfigAPIPostEventForecastsRequest) XHotelid(xHotelid string) ResourceConfigAPIPostEventForecastsRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r ResourceConfigAPIPostEventForecastsRequest) EventForecasts(eventForecasts EventForecasts) ResourceConfigAPIPostEventForecastsRequest {
	r.eventForecasts = &eventForecasts
	return r
}

// External system code.
func (r ResourceConfigAPIPostEventForecastsRequest) XExternalsystem(xExternalsystem string) ResourceConfigAPIPostEventForecastsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ResourceConfigAPIPostEventForecastsRequest) AcceptLanguage(acceptLanguage string) ResourceConfigAPIPostEventForecastsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ResourceConfigAPIPostEventForecastsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostEventForecastsExecute(r)
}

/*
PostEventForecasts Create event forecasts

You can define Event Forecasts, with or without a market code or a block type, to manage different revenue forecasts for different types of bookings, such as corporate versus social. This API will allow you to create a new Event Forecast. <p><strong>OperationId:</strong>postEventForecasts</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ResourceConfigAPIPostEventForecastsRequest
*/
func (a *ResourceConfigAPIService) PostEventForecasts(ctx context.Context) ResourceConfigAPIPostEventForecastsRequest {
	return ResourceConfigAPIPostEventForecastsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ResourceConfigAPIService) PostEventForecastsExecute(r ResourceConfigAPIPostEventForecastsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResourceConfigAPIService.PostEventForecasts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/eventForecasts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.eventForecasts
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ResourceConfigAPIPostInventoryItemTemplatesRequest struct {
	ctx context.Context
	ApiService *ResourceConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	inventoryItemTemplates *InventoryItemTemplates
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ResourceConfigAPIPostInventoryItemTemplatesRequest) Authorization(authorization string) ResourceConfigAPIPostInventoryItemTemplatesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ResourceConfigAPIPostInventoryItemTemplatesRequest) XAppKey(xAppKey string) ResourceConfigAPIPostInventoryItemTemplatesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ResourceConfigAPIPostInventoryItemTemplatesRequest) XHotelid(xHotelid string) ResourceConfigAPIPostInventoryItemTemplatesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating new inventory item templates.
func (r ResourceConfigAPIPostInventoryItemTemplatesRequest) InventoryItemTemplates(inventoryItemTemplates InventoryItemTemplates) ResourceConfigAPIPostInventoryItemTemplatesRequest {
	r.inventoryItemTemplates = &inventoryItemTemplates
	return r
}

// External system code.
func (r ResourceConfigAPIPostInventoryItemTemplatesRequest) XExternalsystem(xExternalsystem string) ResourceConfigAPIPostInventoryItemTemplatesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ResourceConfigAPIPostInventoryItemTemplatesRequest) AcceptLanguage(acceptLanguage string) ResourceConfigAPIPostInventoryItemTemplatesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ResourceConfigAPIPostInventoryItemTemplatesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostInventoryItemTemplatesExecute(r)
}

/*
PostInventoryItemTemplates Create Item Inventory template

Create an Item Inventory template. <p><strong>OperationId:</strong>postInventoryItemTemplates</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ResourceConfigAPIPostInventoryItemTemplatesRequest
*/
func (a *ResourceConfigAPIService) PostInventoryItemTemplates(ctx context.Context) ResourceConfigAPIPostInventoryItemTemplatesRequest {
	return ResourceConfigAPIPostInventoryItemTemplatesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ResourceConfigAPIService) PostInventoryItemTemplatesExecute(r ResourceConfigAPIPostInventoryItemTemplatesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResourceConfigAPIService.PostInventoryItemTemplates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/inventoryItems"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.inventoryItemTemplates
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ResourceConfigAPIPostInventoryItemsRequest struct {
	ctx context.Context
	ApiService *ResourceConfigAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	inventoryItems *InventoryItems
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ResourceConfigAPIPostInventoryItemsRequest) Authorization(authorization string) ResourceConfigAPIPostInventoryItemsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ResourceConfigAPIPostInventoryItemsRequest) XAppKey(xAppKey string) ResourceConfigAPIPostInventoryItemsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ResourceConfigAPIPostInventoryItemsRequest) XHotelid(xHotelid string) ResourceConfigAPIPostInventoryItemsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Requestion object for creating new Inventory Items Setup configurations
func (r ResourceConfigAPIPostInventoryItemsRequest) InventoryItems(inventoryItems InventoryItems) ResourceConfigAPIPostInventoryItemsRequest {
	r.inventoryItems = &inventoryItems
	return r
}

// External system code.
func (r ResourceConfigAPIPostInventoryItemsRequest) XExternalsystem(xExternalsystem string) ResourceConfigAPIPostInventoryItemsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ResourceConfigAPIPostInventoryItemsRequest) AcceptLanguage(acceptLanguage string) ResourceConfigAPIPostInventoryItemsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ResourceConfigAPIPostInventoryItemsRequest) Execute() (*InventoryItemsCreated, *http.Response, error) {
	return r.ApiService.PostInventoryItemsExecute(r)
}

/*
PostInventoryItems Create an Item Inventory

You can use this API to create a new Item Inventory Code for a property. <p><strong>OperationId:</strong>postInventoryItems</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique OPERA Hotel code
 @return ResourceConfigAPIPostInventoryItemsRequest
*/
func (a *ResourceConfigAPIService) PostInventoryItems(ctx context.Context, hotelId string) ResourceConfigAPIPostInventoryItemsRequest {
	return ResourceConfigAPIPostInventoryItemsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return InventoryItemsCreated
func (a *ResourceConfigAPIService) PostInventoryItemsExecute(r ResourceConfigAPIPostInventoryItemsRequest) (*InventoryItemsCreated, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InventoryItemsCreated
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResourceConfigAPIService.PostInventoryItems")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/inventoryItems"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.inventoryItems
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ResourceConfigAPIPostItemClassesRequest struct {
	ctx context.Context
	ApiService *ResourceConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	itemClasses *ItemClasses
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ResourceConfigAPIPostItemClassesRequest) Authorization(authorization string) ResourceConfigAPIPostItemClassesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ResourceConfigAPIPostItemClassesRequest) XAppKey(xAppKey string) ResourceConfigAPIPostItemClassesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ResourceConfigAPIPostItemClassesRequest) XHotelid(xHotelid string) ResourceConfigAPIPostItemClassesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating new item class.
func (r ResourceConfigAPIPostItemClassesRequest) ItemClasses(itemClasses ItemClasses) ResourceConfigAPIPostItemClassesRequest {
	r.itemClasses = &itemClasses
	return r
}

// External system code.
func (r ResourceConfigAPIPostItemClassesRequest) XExternalsystem(xExternalsystem string) ResourceConfigAPIPostItemClassesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ResourceConfigAPIPostItemClassesRequest) AcceptLanguage(acceptLanguage string) ResourceConfigAPIPostItemClassesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ResourceConfigAPIPostItemClassesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostItemClassesExecute(r)
}

/*
PostItemClasses Create item classes

You can use this API to create item classes. <p><strong>OperationId:</strong>postItemClasses</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ResourceConfigAPIPostItemClassesRequest
*/
func (a *ResourceConfigAPIService) PostItemClasses(ctx context.Context) ResourceConfigAPIPostItemClassesRequest {
	return ResourceConfigAPIPostItemClassesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ResourceConfigAPIService) PostItemClassesExecute(r ResourceConfigAPIPostItemClassesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResourceConfigAPIService.PostItemClasses")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/itemClasses"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.itemClasses
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ResourceConfigAPIPostItemPoolsRequest struct {
	ctx context.Context
	ApiService *ResourceConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	itemPools *ItemPools
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ResourceConfigAPIPostItemPoolsRequest) Authorization(authorization string) ResourceConfigAPIPostItemPoolsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ResourceConfigAPIPostItemPoolsRequest) XAppKey(xAppKey string) ResourceConfigAPIPostItemPoolsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ResourceConfigAPIPostItemPoolsRequest) XHotelid(xHotelid string) ResourceConfigAPIPostItemPoolsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object which holds new Item Pools.
func (r ResourceConfigAPIPostItemPoolsRequest) ItemPools(itemPools ItemPools) ResourceConfigAPIPostItemPoolsRequest {
	r.itemPools = &itemPools
	return r
}

// External system code.
func (r ResourceConfigAPIPostItemPoolsRequest) XExternalsystem(xExternalsystem string) ResourceConfigAPIPostItemPoolsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ResourceConfigAPIPostItemPoolsRequest) AcceptLanguage(acceptLanguage string) ResourceConfigAPIPostItemPoolsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ResourceConfigAPIPostItemPoolsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostItemPoolsExecute(r)
}

/*
PostItemPools Create Item Pools

You can create Item Pools, whereby you are grouping Item Inventories into a group.  For example you might have a Item Pool for a Promotional Package where the guest receives a number of Item Inventories; thus creating a group enables you to easily manage this. <p><strong>OperationId:</strong>postItemPools</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ResourceConfigAPIPostItemPoolsRequest
*/
func (a *ResourceConfigAPIService) PostItemPools(ctx context.Context) ResourceConfigAPIPostItemPoolsRequest {
	return ResourceConfigAPIPostItemPoolsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ResourceConfigAPIService) PostItemPoolsExecute(r ResourceConfigAPIPostItemPoolsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResourceConfigAPIService.PostItemPools")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/itemPools"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.itemPools
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ResourceConfigAPIPostRevenueGroupsRequest struct {
	ctx context.Context
	ApiService *ResourceConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	revenueGroups *RevenueGroups
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ResourceConfigAPIPostRevenueGroupsRequest) Authorization(authorization string) ResourceConfigAPIPostRevenueGroupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ResourceConfigAPIPostRevenueGroupsRequest) XAppKey(xAppKey string) ResourceConfigAPIPostRevenueGroupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ResourceConfigAPIPostRevenueGroupsRequest) XHotelid(xHotelid string) ResourceConfigAPIPostRevenueGroupsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating new Catering Revenue Groups Configurations.
func (r ResourceConfigAPIPostRevenueGroupsRequest) RevenueGroups(revenueGroups RevenueGroups) ResourceConfigAPIPostRevenueGroupsRequest {
	r.revenueGroups = &revenueGroups
	return r
}

// External system code.
func (r ResourceConfigAPIPostRevenueGroupsRequest) XExternalsystem(xExternalsystem string) ResourceConfigAPIPostRevenueGroupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ResourceConfigAPIPostRevenueGroupsRequest) AcceptLanguage(acceptLanguage string) ResourceConfigAPIPostRevenueGroupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ResourceConfigAPIPostRevenueGroupsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostRevenueGroupsExecute(r)
}

/*
PostRevenueGroups Create Catering Revenue Groups

You can use this API to create a new catering revenue group code. <p><strong>OperationId:</strong>postRevenueGroups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ResourceConfigAPIPostRevenueGroupsRequest
*/
func (a *ResourceConfigAPIService) PostRevenueGroups(ctx context.Context) ResourceConfigAPIPostRevenueGroupsRequest {
	return ResourceConfigAPIPostRevenueGroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ResourceConfigAPIService) PostRevenueGroupsExecute(r ResourceConfigAPIPostRevenueGroupsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResourceConfigAPIService.PostRevenueGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/revenueGroups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.revenueGroups
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ResourceConfigAPIPostRevenueTypesRequest struct {
	ctx context.Context
	ApiService *ResourceConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	revenueTypes *RevenueTypes
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ResourceConfigAPIPostRevenueTypesRequest) Authorization(authorization string) ResourceConfigAPIPostRevenueTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ResourceConfigAPIPostRevenueTypesRequest) XAppKey(xAppKey string) ResourceConfigAPIPostRevenueTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ResourceConfigAPIPostRevenueTypesRequest) XHotelid(xHotelid string) ResourceConfigAPIPostRevenueTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating new Revenue Types Setup Configurations.
func (r ResourceConfigAPIPostRevenueTypesRequest) RevenueTypes(revenueTypes RevenueTypes) ResourceConfigAPIPostRevenueTypesRequest {
	r.revenueTypes = &revenueTypes
	return r
}

// External system code.
func (r ResourceConfigAPIPostRevenueTypesRequest) XExternalsystem(xExternalsystem string) ResourceConfigAPIPostRevenueTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ResourceConfigAPIPostRevenueTypesRequest) AcceptLanguage(acceptLanguage string) ResourceConfigAPIPostRevenueTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ResourceConfigAPIPostRevenueTypesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostRevenueTypesExecute(r)
}

/*
PostRevenueTypes Create Catering Revenue Types

You can use this API to create a new Catering Revenue Type code. <p><strong>OperationId:</strong>postRevenueTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ResourceConfigAPIPostRevenueTypesRequest
*/
func (a *ResourceConfigAPIService) PostRevenueTypes(ctx context.Context) ResourceConfigAPIPostRevenueTypesRequest {
	return ResourceConfigAPIPostRevenueTypesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ResourceConfigAPIService) PostRevenueTypesExecute(r ResourceConfigAPIPostRevenueTypesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResourceConfigAPIService.PostRevenueTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/revenueTypes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.revenueTypes
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ResourceConfigAPIPutCateringContainersRequest struct {
	ctx context.Context
	ApiService *ResourceConfigAPIService
	cateringContainersCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	cateringContainers *CateringContainers
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ResourceConfigAPIPutCateringContainersRequest) Authorization(authorization string) ResourceConfigAPIPutCateringContainersRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ResourceConfigAPIPutCateringContainersRequest) XAppKey(xAppKey string) ResourceConfigAPIPutCateringContainersRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ResourceConfigAPIPutCateringContainersRequest) XHotelid(xHotelid string) ResourceConfigAPIPutCateringContainersRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object which holds modified Catering Code Containers.
func (r ResourceConfigAPIPutCateringContainersRequest) CateringContainers(cateringContainers CateringContainers) ResourceConfigAPIPutCateringContainersRequest {
	r.cateringContainers = &cateringContainers
	return r
}

// External system code.
func (r ResourceConfigAPIPutCateringContainersRequest) XExternalsystem(xExternalsystem string) ResourceConfigAPIPutCateringContainersRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ResourceConfigAPIPutCateringContainersRequest) AcceptLanguage(acceptLanguage string) ResourceConfigAPIPutCateringContainersRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ResourceConfigAPIPutCateringContainersRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutCateringContainersExecute(r)
}

/*
PutCateringContainers Change catering containers

This API allows you to update an existing Menu Item Catering Container code. <p><strong>OperationId:</strong>putCateringContainers</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cateringContainersCode Unique Catering Container Code
 @return ResourceConfigAPIPutCateringContainersRequest
*/
func (a *ResourceConfigAPIService) PutCateringContainers(ctx context.Context, cateringContainersCode string) ResourceConfigAPIPutCateringContainersRequest {
	return ResourceConfigAPIPutCateringContainersRequest{
		ApiService: a,
		ctx: ctx,
		cateringContainersCode: cateringContainersCode,
	}
}

// Execute executes the request
//  @return Status
func (a *ResourceConfigAPIService) PutCateringContainersExecute(r ResourceConfigAPIPutCateringContainersRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResourceConfigAPIService.PutCateringContainers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cateringContainers/{cateringContainersCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"cateringContainersCode"+"}", url.PathEscape(parameterValueToString(r.cateringContainersCode, "cateringContainersCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.cateringContainersCode) < 1 {
		return localVarReturnValue, nil, reportError("cateringContainersCode must have at least 1 elements")
	}
	if strlen(r.cateringContainersCode) > 2000 {
		return localVarReturnValue, nil, reportError("cateringContainersCode must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.cateringContainers
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ResourceConfigAPIPutCateringItemRatesRequest struct {
	ctx context.Context
	ApiService *ResourceConfigAPIService
	cateringItemRatesCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	cateringItemRates *CateringItemRates
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ResourceConfigAPIPutCateringItemRatesRequest) Authorization(authorization string) ResourceConfigAPIPutCateringItemRatesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ResourceConfigAPIPutCateringItemRatesRequest) XAppKey(xAppKey string) ResourceConfigAPIPutCateringItemRatesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ResourceConfigAPIPutCateringItemRatesRequest) XHotelid(xHotelid string) ResourceConfigAPIPutCateringItemRatesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object which holds modified Catering Code&#39;s Item Rate.
func (r ResourceConfigAPIPutCateringItemRatesRequest) CateringItemRates(cateringItemRates CateringItemRates) ResourceConfigAPIPutCateringItemRatesRequest {
	r.cateringItemRates = &cateringItemRates
	return r
}

// External system code.
func (r ResourceConfigAPIPutCateringItemRatesRequest) XExternalsystem(xExternalsystem string) ResourceConfigAPIPutCateringItemRatesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ResourceConfigAPIPutCateringItemRatesRequest) AcceptLanguage(acceptLanguage string) ResourceConfigAPIPutCateringItemRatesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ResourceConfigAPIPutCateringItemRatesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutCateringItemRatesExecute(r)
}

/*
PutCateringItemRates Change catering item rates

Change catering item rates code <p><strong>OperationId:</strong>putCateringItemRates</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cateringItemRatesCode Unique Catering Item Rates Codes
 @return ResourceConfigAPIPutCateringItemRatesRequest
*/
func (a *ResourceConfigAPIService) PutCateringItemRates(ctx context.Context, cateringItemRatesCode string) ResourceConfigAPIPutCateringItemRatesRequest {
	return ResourceConfigAPIPutCateringItemRatesRequest{
		ApiService: a,
		ctx: ctx,
		cateringItemRatesCode: cateringItemRatesCode,
	}
}

// Execute executes the request
//  @return Status
func (a *ResourceConfigAPIService) PutCateringItemRatesExecute(r ResourceConfigAPIPutCateringItemRatesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResourceConfigAPIService.PutCateringItemRates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cateringItemRates/{cateringItemRatesCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"cateringItemRatesCode"+"}", url.PathEscape(parameterValueToString(r.cateringItemRatesCode, "cateringItemRatesCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.cateringItemRatesCode) < 1 {
		return localVarReturnValue, nil, reportError("cateringItemRatesCode must have at least 1 elements")
	}
	if strlen(r.cateringItemRatesCode) > 2000 {
		return localVarReturnValue, nil, reportError("cateringItemRatesCode must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.cateringItemRates
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ResourceConfigAPIPutCateringMenuClassesRequest struct {
	ctx context.Context
	ApiService *ResourceConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	cateringMenuClasses *CateringMenuClasses
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ResourceConfigAPIPutCateringMenuClassesRequest) Authorization(authorization string) ResourceConfigAPIPutCateringMenuClassesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ResourceConfigAPIPutCateringMenuClassesRequest) XAppKey(xAppKey string) ResourceConfigAPIPutCateringMenuClassesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ResourceConfigAPIPutCateringMenuClassesRequest) XHotelid(xHotelid string) ResourceConfigAPIPutCateringMenuClassesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing Menu Classes.
func (r ResourceConfigAPIPutCateringMenuClassesRequest) CateringMenuClasses(cateringMenuClasses CateringMenuClasses) ResourceConfigAPIPutCateringMenuClassesRequest {
	r.cateringMenuClasses = &cateringMenuClasses
	return r
}

// External system code.
func (r ResourceConfigAPIPutCateringMenuClassesRequest) XExternalsystem(xExternalsystem string) ResourceConfigAPIPutCateringMenuClassesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ResourceConfigAPIPutCateringMenuClassesRequest) AcceptLanguage(acceptLanguage string) ResourceConfigAPIPutCateringMenuClassesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ResourceConfigAPIPutCateringMenuClassesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutCateringMenuClassesExecute(r)
}

/*
PutCateringMenuClasses Update catering menu classes

Update catering menu classes <p><strong>OperationId:</strong>putCateringMenuClasses</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ResourceConfigAPIPutCateringMenuClassesRequest
*/
func (a *ResourceConfigAPIService) PutCateringMenuClasses(ctx context.Context) ResourceConfigAPIPutCateringMenuClassesRequest {
	return ResourceConfigAPIPutCateringMenuClassesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ResourceConfigAPIService) PutCateringMenuClassesExecute(r ResourceConfigAPIPutCateringMenuClassesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResourceConfigAPIService.PutCateringMenuClasses")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cateringMenuClasses"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.cateringMenuClasses
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ResourceConfigAPIPutCateringMenuItemClassesRequest struct {
	ctx context.Context
	ApiService *ResourceConfigAPIService
	cateringMenuItemClassesCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	cateringMenuItemClasses *CateringMenuItemClasses
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ResourceConfigAPIPutCateringMenuItemClassesRequest) Authorization(authorization string) ResourceConfigAPIPutCateringMenuItemClassesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ResourceConfigAPIPutCateringMenuItemClassesRequest) XAppKey(xAppKey string) ResourceConfigAPIPutCateringMenuItemClassesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ResourceConfigAPIPutCateringMenuItemClassesRequest) XHotelid(xHotelid string) ResourceConfigAPIPutCateringMenuItemClassesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for updating Menu Item Classes.
func (r ResourceConfigAPIPutCateringMenuItemClassesRequest) CateringMenuItemClasses(cateringMenuItemClasses CateringMenuItemClasses) ResourceConfigAPIPutCateringMenuItemClassesRequest {
	r.cateringMenuItemClasses = &cateringMenuItemClasses
	return r
}

// External system code.
func (r ResourceConfigAPIPutCateringMenuItemClassesRequest) XExternalsystem(xExternalsystem string) ResourceConfigAPIPutCateringMenuItemClassesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ResourceConfigAPIPutCateringMenuItemClassesRequest) AcceptLanguage(acceptLanguage string) ResourceConfigAPIPutCateringMenuItemClassesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ResourceConfigAPIPutCateringMenuItemClassesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutCateringMenuItemClassesExecute(r)
}

/*
PutCateringMenuItemClasses Update menu item classes

You can use this API to update menu item classes. <p><strong>OperationId:</strong>putCateringMenuItemClasses</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cateringMenuItemClassesCode Unique Menu Item Class Id
 @return ResourceConfigAPIPutCateringMenuItemClassesRequest
*/
func (a *ResourceConfigAPIService) PutCateringMenuItemClasses(ctx context.Context, cateringMenuItemClassesCode string) ResourceConfigAPIPutCateringMenuItemClassesRequest {
	return ResourceConfigAPIPutCateringMenuItemClassesRequest{
		ApiService: a,
		ctx: ctx,
		cateringMenuItemClassesCode: cateringMenuItemClassesCode,
	}
}

// Execute executes the request
//  @return Status
func (a *ResourceConfigAPIService) PutCateringMenuItemClassesExecute(r ResourceConfigAPIPutCateringMenuItemClassesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResourceConfigAPIService.PutCateringMenuItemClasses")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cateringMenuItemClasses/{cateringMenuItemClassesCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"cateringMenuItemClassesCode"+"}", url.PathEscape(parameterValueToString(r.cateringMenuItemClassesCode, "cateringMenuItemClassesCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.cateringMenuItemClassesCode) < 1 {
		return localVarReturnValue, nil, reportError("cateringMenuItemClassesCode must have at least 1 elements")
	}
	if strlen(r.cateringMenuItemClassesCode) > 2000 {
		return localVarReturnValue, nil, reportError("cateringMenuItemClassesCode must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.cateringMenuItemClasses
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ResourceConfigAPIPutCateringMenuItemsRequest struct {
	ctx context.Context
	ApiService *ResourceConfigAPIService
	cateringMenuItemId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	cateringMenuItems *CateringMenuItems
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ResourceConfigAPIPutCateringMenuItemsRequest) Authorization(authorization string) ResourceConfigAPIPutCateringMenuItemsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ResourceConfigAPIPutCateringMenuItemsRequest) XAppKey(xAppKey string) ResourceConfigAPIPutCateringMenuItemsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ResourceConfigAPIPutCateringMenuItemsRequest) XHotelid(xHotelid string) ResourceConfigAPIPutCateringMenuItemsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing Menu Items.
func (r ResourceConfigAPIPutCateringMenuItemsRequest) CateringMenuItems(cateringMenuItems CateringMenuItems) ResourceConfigAPIPutCateringMenuItemsRequest {
	r.cateringMenuItems = &cateringMenuItems
	return r
}

// External system code.
func (r ResourceConfigAPIPutCateringMenuItemsRequest) XExternalsystem(xExternalsystem string) ResourceConfigAPIPutCateringMenuItemsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ResourceConfigAPIPutCateringMenuItemsRequest) AcceptLanguage(acceptLanguage string) ResourceConfigAPIPutCateringMenuItemsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ResourceConfigAPIPutCateringMenuItemsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutCateringMenuItemsExecute(r)
}

/*
PutCateringMenuItems Update menu items

You can use this API to update menu items. <p><strong>OperationId:</strong>putCateringMenuItems</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cateringMenuItemId Unique Catering Menu Item Id
 @param hotelId Unique OPERA Hotel Id
 @return ResourceConfigAPIPutCateringMenuItemsRequest
*/
func (a *ResourceConfigAPIService) PutCateringMenuItems(ctx context.Context, cateringMenuItemId string, hotelId string) ResourceConfigAPIPutCateringMenuItemsRequest {
	return ResourceConfigAPIPutCateringMenuItemsRequest{
		ApiService: a,
		ctx: ctx,
		cateringMenuItemId: cateringMenuItemId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ResourceConfigAPIService) PutCateringMenuItemsExecute(r ResourceConfigAPIPutCateringMenuItemsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResourceConfigAPIService.PutCateringMenuItems")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/cateringMenuItems/{cateringMenuItemId}"
	localVarPath = strings.Replace(localVarPath, "{"+"cateringMenuItemId"+"}", url.PathEscape(parameterValueToString(r.cateringMenuItemId, "cateringMenuItemId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.cateringMenuItemId) < 1 {
		return localVarReturnValue, nil, reportError("cateringMenuItemId must have at least 1 elements")
	}
	if strlen(r.cateringMenuItemId) > 2000 {
		return localVarReturnValue, nil, reportError("cateringMenuItemId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.cateringMenuItems
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ResourceConfigAPIPutCateringMenusRequest struct {
	ctx context.Context
	ApiService *ResourceConfigAPIService
	cateringMenuId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	cateringMenus *CateringMenus
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ResourceConfigAPIPutCateringMenusRequest) Authorization(authorization string) ResourceConfigAPIPutCateringMenusRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ResourceConfigAPIPutCateringMenusRequest) XAppKey(xAppKey string) ResourceConfigAPIPutCateringMenusRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ResourceConfigAPIPutCateringMenusRequest) XHotelid(xHotelid string) ResourceConfigAPIPutCateringMenusRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing Menu .
func (r ResourceConfigAPIPutCateringMenusRequest) CateringMenus(cateringMenus CateringMenus) ResourceConfigAPIPutCateringMenusRequest {
	r.cateringMenus = &cateringMenus
	return r
}

// External system code.
func (r ResourceConfigAPIPutCateringMenusRequest) XExternalsystem(xExternalsystem string) ResourceConfigAPIPutCateringMenusRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ResourceConfigAPIPutCateringMenusRequest) AcceptLanguage(acceptLanguage string) ResourceConfigAPIPutCateringMenusRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ResourceConfigAPIPutCateringMenusRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutCateringMenusExecute(r)
}

/*
PutCateringMenus Operation to change catering menus.

 <p><strong>OperationId:</strong>putCateringMenus</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cateringMenuId Unique ID of Catering Menu
 @param hotelId Unique OPERA Hotel ID
 @return ResourceConfigAPIPutCateringMenusRequest
*/
func (a *ResourceConfigAPIService) PutCateringMenus(ctx context.Context, cateringMenuId string, hotelId string) ResourceConfigAPIPutCateringMenusRequest {
	return ResourceConfigAPIPutCateringMenusRequest{
		ApiService: a,
		ctx: ctx,
		cateringMenuId: cateringMenuId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ResourceConfigAPIService) PutCateringMenusExecute(r ResourceConfigAPIPutCateringMenusRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResourceConfigAPIService.PutCateringMenus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/cateringMenus/{cateringMenuId}"
	localVarPath = strings.Replace(localVarPath, "{"+"cateringMenuId"+"}", url.PathEscape(parameterValueToString(r.cateringMenuId, "cateringMenuId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.cateringMenuId) < 1 {
		return localVarReturnValue, nil, reportError("cateringMenuId must have at least 1 elements")
	}
	if strlen(r.cateringMenuId) > 2000 {
		return localVarReturnValue, nil, reportError("cateringMenuId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.cateringMenus
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ResourceConfigAPIPutCateringPackagesRequest struct {
	ctx context.Context
	ApiService *ResourceConfigAPIService
	cateringPackageId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	cateringPackages *CateringPackages
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ResourceConfigAPIPutCateringPackagesRequest) Authorization(authorization string) ResourceConfigAPIPutCateringPackagesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ResourceConfigAPIPutCateringPackagesRequest) XAppKey(xAppKey string) ResourceConfigAPIPutCateringPackagesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ResourceConfigAPIPutCateringPackagesRequest) XHotelid(xHotelid string) ResourceConfigAPIPutCateringPackagesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing Catering Packages.
func (r ResourceConfigAPIPutCateringPackagesRequest) CateringPackages(cateringPackages CateringPackages) ResourceConfigAPIPutCateringPackagesRequest {
	r.cateringPackages = &cateringPackages
	return r
}

// External system code.
func (r ResourceConfigAPIPutCateringPackagesRequest) XExternalsystem(xExternalsystem string) ResourceConfigAPIPutCateringPackagesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ResourceConfigAPIPutCateringPackagesRequest) AcceptLanguage(acceptLanguage string) ResourceConfigAPIPutCateringPackagesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ResourceConfigAPIPutCateringPackagesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutCateringPackagesExecute(r)
}

/*
PutCateringPackages Update Catering packages

Update an existing Catering Package for a property. <p><strong>OperationId:</strong>putCateringPackages</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cateringPackageId Unique Catering Package ID
 @param hotelId Unique OPERA Hotel ID
 @return ResourceConfigAPIPutCateringPackagesRequest
*/
func (a *ResourceConfigAPIService) PutCateringPackages(ctx context.Context, cateringPackageId string, hotelId string) ResourceConfigAPIPutCateringPackagesRequest {
	return ResourceConfigAPIPutCateringPackagesRequest{
		ApiService: a,
		ctx: ctx,
		cateringPackageId: cateringPackageId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ResourceConfigAPIService) PutCateringPackagesExecute(r ResourceConfigAPIPutCateringPackagesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResourceConfigAPIService.PutCateringPackages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/cateringPackages/{cateringPackageId}"
	localVarPath = strings.Replace(localVarPath, "{"+"cateringPackageId"+"}", url.PathEscape(parameterValueToString(r.cateringPackageId, "cateringPackageId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.cateringPackageId) < 1 {
		return localVarReturnValue, nil, reportError("cateringPackageId must have at least 1 elements")
	}
	if strlen(r.cateringPackageId) > 2000 {
		return localVarReturnValue, nil, reportError("cateringPackageId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.cateringPackages
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ResourceConfigAPIPutCateringServingsRequest struct {
	ctx context.Context
	ApiService *ResourceConfigAPIService
	cateringServingsCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	cateringServings *CateringServings
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ResourceConfigAPIPutCateringServingsRequest) Authorization(authorization string) ResourceConfigAPIPutCateringServingsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ResourceConfigAPIPutCateringServingsRequest) XAppKey(xAppKey string) ResourceConfigAPIPutCateringServingsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ResourceConfigAPIPutCateringServingsRequest) XHotelid(xHotelid string) ResourceConfigAPIPutCateringServingsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object which holds modified Catering Code&#39;s Serving.
func (r ResourceConfigAPIPutCateringServingsRequest) CateringServings(cateringServings CateringServings) ResourceConfigAPIPutCateringServingsRequest {
	r.cateringServings = &cateringServings
	return r
}

// External system code.
func (r ResourceConfigAPIPutCateringServingsRequest) XExternalsystem(xExternalsystem string) ResourceConfigAPIPutCateringServingsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ResourceConfigAPIPutCateringServingsRequest) AcceptLanguage(acceptLanguage string) ResourceConfigAPIPutCateringServingsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ResourceConfigAPIPutCateringServingsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutCateringServingsExecute(r)
}

/*
PutCateringServings Update catering servings

Update catering servings <p><strong>OperationId:</strong>putCateringServings</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cateringServingsCode Unique Catering Sevrings Code
 @return ResourceConfigAPIPutCateringServingsRequest
*/
func (a *ResourceConfigAPIService) PutCateringServings(ctx context.Context, cateringServingsCode string) ResourceConfigAPIPutCateringServingsRequest {
	return ResourceConfigAPIPutCateringServingsRequest{
		ApiService: a,
		ctx: ctx,
		cateringServingsCode: cateringServingsCode,
	}
}

// Execute executes the request
//  @return Status
func (a *ResourceConfigAPIService) PutCateringServingsExecute(r ResourceConfigAPIPutCateringServingsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResourceConfigAPIService.PutCateringServings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cateringServings/{cateringServingsCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"cateringServingsCode"+"}", url.PathEscape(parameterValueToString(r.cateringServingsCode, "cateringServingsCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.cateringServingsCode) < 1 {
		return localVarReturnValue, nil, reportError("cateringServingsCode must have at least 1 elements")
	}
	if strlen(r.cateringServingsCode) > 2000 {
		return localVarReturnValue, nil, reportError("cateringServingsCode must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.cateringServings
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ResourceConfigAPIPutEventForecastsRequest struct {
	ctx context.Context
	ApiService *ResourceConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	eventForecasts *EventForecasts
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ResourceConfigAPIPutEventForecastsRequest) Authorization(authorization string) ResourceConfigAPIPutEventForecastsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ResourceConfigAPIPutEventForecastsRequest) XAppKey(xAppKey string) ResourceConfigAPIPutEventForecastsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ResourceConfigAPIPutEventForecastsRequest) XHotelid(xHotelid string) ResourceConfigAPIPutEventForecastsRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r ResourceConfigAPIPutEventForecastsRequest) EventForecasts(eventForecasts EventForecasts) ResourceConfigAPIPutEventForecastsRequest {
	r.eventForecasts = &eventForecasts
	return r
}

// External system code.
func (r ResourceConfigAPIPutEventForecastsRequest) XExternalsystem(xExternalsystem string) ResourceConfigAPIPutEventForecastsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ResourceConfigAPIPutEventForecastsRequest) AcceptLanguage(acceptLanguage string) ResourceConfigAPIPutEventForecastsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ResourceConfigAPIPutEventForecastsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutEventForecastsExecute(r)
}

/*
PutEventForecasts Update Event forecasts

This API will allow you to update an Event Forecast for a property. <p><strong>OperationId:</strong>putEventForecasts</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ResourceConfigAPIPutEventForecastsRequest
*/
func (a *ResourceConfigAPIService) PutEventForecasts(ctx context.Context) ResourceConfigAPIPutEventForecastsRequest {
	return ResourceConfigAPIPutEventForecastsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ResourceConfigAPIService) PutEventForecastsExecute(r ResourceConfigAPIPutEventForecastsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResourceConfigAPIService.PutEventForecasts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/eventForecasts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.eventForecasts
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ResourceConfigAPIPutInventoryItemTemplatesRequest struct {
	ctx context.Context
	ApiService *ResourceConfigAPIService
	inventoryItemId string
	authorization *string
	xAppKey *string
	xHotelid *string
	inventoryItemTemplates *InventoryItemTemplates
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ResourceConfigAPIPutInventoryItemTemplatesRequest) Authorization(authorization string) ResourceConfigAPIPutInventoryItemTemplatesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ResourceConfigAPIPutInventoryItemTemplatesRequest) XAppKey(xAppKey string) ResourceConfigAPIPutInventoryItemTemplatesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ResourceConfigAPIPutInventoryItemTemplatesRequest) XHotelid(xHotelid string) ResourceConfigAPIPutInventoryItemTemplatesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing existing inventory item templates.
func (r ResourceConfigAPIPutInventoryItemTemplatesRequest) InventoryItemTemplates(inventoryItemTemplates InventoryItemTemplates) ResourceConfigAPIPutInventoryItemTemplatesRequest {
	r.inventoryItemTemplates = &inventoryItemTemplates
	return r
}

// External system code.
func (r ResourceConfigAPIPutInventoryItemTemplatesRequest) XExternalsystem(xExternalsystem string) ResourceConfigAPIPutInventoryItemTemplatesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ResourceConfigAPIPutInventoryItemTemplatesRequest) AcceptLanguage(acceptLanguage string) ResourceConfigAPIPutInventoryItemTemplatesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ResourceConfigAPIPutInventoryItemTemplatesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutInventoryItemTemplatesExecute(r)
}

/*
PutInventoryItemTemplates Change Item Inventory templates

Change Item Inventory template. <p><strong>OperationId:</strong>putInventoryItemTemplates</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param inventoryItemId Unique Inventory Item Template code
 @return ResourceConfigAPIPutInventoryItemTemplatesRequest
*/
func (a *ResourceConfigAPIService) PutInventoryItemTemplates(ctx context.Context, inventoryItemId string) ResourceConfigAPIPutInventoryItemTemplatesRequest {
	return ResourceConfigAPIPutInventoryItemTemplatesRequest{
		ApiService: a,
		ctx: ctx,
		inventoryItemId: inventoryItemId,
	}
}

// Execute executes the request
//  @return Status
func (a *ResourceConfigAPIService) PutInventoryItemTemplatesExecute(r ResourceConfigAPIPutInventoryItemTemplatesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResourceConfigAPIService.PutInventoryItemTemplates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/inventoryItems/{inventoryItemId}"
	localVarPath = strings.Replace(localVarPath, "{"+"inventoryItemId"+"}", url.PathEscape(parameterValueToString(r.inventoryItemId, "inventoryItemId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.inventoryItemId) < 1 {
		return localVarReturnValue, nil, reportError("inventoryItemId must have at least 1 elements")
	}
	if strlen(r.inventoryItemId) > 2000 {
		return localVarReturnValue, nil, reportError("inventoryItemId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.inventoryItemTemplates
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ResourceConfigAPIPutInventoryItemsRequest struct {
	ctx context.Context
	ApiService *ResourceConfigAPIService
	inventoryItemId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	inventoryItems *InventoryItems
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ResourceConfigAPIPutInventoryItemsRequest) Authorization(authorization string) ResourceConfigAPIPutInventoryItemsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ResourceConfigAPIPutInventoryItemsRequest) XAppKey(xAppKey string) ResourceConfigAPIPutInventoryItemsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ResourceConfigAPIPutInventoryItemsRequest) XHotelid(xHotelid string) ResourceConfigAPIPutInventoryItemsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing Inventory Items Setup configuration
func (r ResourceConfigAPIPutInventoryItemsRequest) InventoryItems(inventoryItems InventoryItems) ResourceConfigAPIPutInventoryItemsRequest {
	r.inventoryItems = &inventoryItems
	return r
}

// External system code.
func (r ResourceConfigAPIPutInventoryItemsRequest) XExternalsystem(xExternalsystem string) ResourceConfigAPIPutInventoryItemsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ResourceConfigAPIPutInventoryItemsRequest) AcceptLanguage(acceptLanguage string) ResourceConfigAPIPutInventoryItemsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ResourceConfigAPIPutInventoryItemsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutInventoryItemsExecute(r)
}

/*
PutInventoryItems Update Item Inventory

Use this API to update an existing Item Inventory Code  <p><strong>OperationId:</strong>putInventoryItems</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param inventoryItemId Unique Inventory Item id
 @param hotelId Unique OPERA Hotel code
 @return ResourceConfigAPIPutInventoryItemsRequest
*/
func (a *ResourceConfigAPIService) PutInventoryItems(ctx context.Context, inventoryItemId string, hotelId string) ResourceConfigAPIPutInventoryItemsRequest {
	return ResourceConfigAPIPutInventoryItemsRequest{
		ApiService: a,
		ctx: ctx,
		inventoryItemId: inventoryItemId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ResourceConfigAPIService) PutInventoryItemsExecute(r ResourceConfigAPIPutInventoryItemsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResourceConfigAPIService.PutInventoryItems")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/inventoryItems/{inventoryItemId}"
	localVarPath = strings.Replace(localVarPath, "{"+"inventoryItemId"+"}", url.PathEscape(parameterValueToString(r.inventoryItemId, "inventoryItemId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.inventoryItemId) < 1 {
		return localVarReturnValue, nil, reportError("inventoryItemId must have at least 1 elements")
	}
	if strlen(r.inventoryItemId) > 2000 {
		return localVarReturnValue, nil, reportError("inventoryItemId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.inventoryItems
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ResourceConfigAPIPutItemClassesRequest struct {
	ctx context.Context
	ApiService *ResourceConfigAPIService
	itemClassesCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	itemClasses *ItemClasses
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ResourceConfigAPIPutItemClassesRequest) Authorization(authorization string) ResourceConfigAPIPutItemClassesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ResourceConfigAPIPutItemClassesRequest) XAppKey(xAppKey string) ResourceConfigAPIPutItemClassesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ResourceConfigAPIPutItemClassesRequest) XHotelid(xHotelid string) ResourceConfigAPIPutItemClassesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for modifying item class.
func (r ResourceConfigAPIPutItemClassesRequest) ItemClasses(itemClasses ItemClasses) ResourceConfigAPIPutItemClassesRequest {
	r.itemClasses = &itemClasses
	return r
}

// External system code.
func (r ResourceConfigAPIPutItemClassesRequest) XExternalsystem(xExternalsystem string) ResourceConfigAPIPutItemClassesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ResourceConfigAPIPutItemClassesRequest) AcceptLanguage(acceptLanguage string) ResourceConfigAPIPutItemClassesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ResourceConfigAPIPutItemClassesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutItemClassesExecute(r)
}

/*
PutItemClasses Update item classes

This API allows you to update existing Item Classes for a property. <p><strong>OperationId:</strong>putItemClasses</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param itemClassesCode Unique Item Class Code
 @return ResourceConfigAPIPutItemClassesRequest
*/
func (a *ResourceConfigAPIService) PutItemClasses(ctx context.Context, itemClassesCode string) ResourceConfigAPIPutItemClassesRequest {
	return ResourceConfigAPIPutItemClassesRequest{
		ApiService: a,
		ctx: ctx,
		itemClassesCode: itemClassesCode,
	}
}

// Execute executes the request
//  @return Status
func (a *ResourceConfigAPIService) PutItemClassesExecute(r ResourceConfigAPIPutItemClassesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResourceConfigAPIService.PutItemClasses")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/itemClasses/{itemClassesCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"itemClassesCode"+"}", url.PathEscape(parameterValueToString(r.itemClassesCode, "itemClassesCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.itemClassesCode) < 1 {
		return localVarReturnValue, nil, reportError("itemClassesCode must have at least 1 elements")
	}
	if strlen(r.itemClassesCode) > 2000 {
		return localVarReturnValue, nil, reportError("itemClassesCode must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.itemClasses
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ResourceConfigAPIPutItemPoolsRequest struct {
	ctx context.Context
	ApiService *ResourceConfigAPIService
	itemPoolsCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	itemPools *ItemPools
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ResourceConfigAPIPutItemPoolsRequest) Authorization(authorization string) ResourceConfigAPIPutItemPoolsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ResourceConfigAPIPutItemPoolsRequest) XAppKey(xAppKey string) ResourceConfigAPIPutItemPoolsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ResourceConfigAPIPutItemPoolsRequest) XHotelid(xHotelid string) ResourceConfigAPIPutItemPoolsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object which holds modified Item Pools.
func (r ResourceConfigAPIPutItemPoolsRequest) ItemPools(itemPools ItemPools) ResourceConfigAPIPutItemPoolsRequest {
	r.itemPools = &itemPools
	return r
}

// External system code.
func (r ResourceConfigAPIPutItemPoolsRequest) XExternalsystem(xExternalsystem string) ResourceConfigAPIPutItemPoolsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ResourceConfigAPIPutItemPoolsRequest) AcceptLanguage(acceptLanguage string) ResourceConfigAPIPutItemPoolsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ResourceConfigAPIPutItemPoolsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutItemPoolsExecute(r)
}

/*
PutItemPools Change Item Pools

Change/update an Item Pool that is already configured for a property. <p><strong>OperationId:</strong>putItemPools</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param itemPoolsCode Unique Item Pool code
 @return ResourceConfigAPIPutItemPoolsRequest
*/
func (a *ResourceConfigAPIService) PutItemPools(ctx context.Context, itemPoolsCode string) ResourceConfigAPIPutItemPoolsRequest {
	return ResourceConfigAPIPutItemPoolsRequest{
		ApiService: a,
		ctx: ctx,
		itemPoolsCode: itemPoolsCode,
	}
}

// Execute executes the request
//  @return Status
func (a *ResourceConfigAPIService) PutItemPoolsExecute(r ResourceConfigAPIPutItemPoolsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResourceConfigAPIService.PutItemPools")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/itemPools/{itemPoolsCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"itemPoolsCode"+"}", url.PathEscape(parameterValueToString(r.itemPoolsCode, "itemPoolsCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.itemPoolsCode) < 1 {
		return localVarReturnValue, nil, reportError("itemPoolsCode must have at least 1 elements")
	}
	if strlen(r.itemPoolsCode) > 2000 {
		return localVarReturnValue, nil, reportError("itemPoolsCode must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.itemPools
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ResourceConfigAPIPutRevenueGroupsRequest struct {
	ctx context.Context
	ApiService *ResourceConfigAPIService
	revenueGroupsCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	revenueGroups *RevenueGroups
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ResourceConfigAPIPutRevenueGroupsRequest) Authorization(authorization string) ResourceConfigAPIPutRevenueGroupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ResourceConfigAPIPutRevenueGroupsRequest) XAppKey(xAppKey string) ResourceConfigAPIPutRevenueGroupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ResourceConfigAPIPutRevenueGroupsRequest) XHotelid(xHotelid string) ResourceConfigAPIPutRevenueGroupsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing existing Catering Revenue Groups Configurations.
func (r ResourceConfigAPIPutRevenueGroupsRequest) RevenueGroups(revenueGroups RevenueGroups) ResourceConfigAPIPutRevenueGroupsRequest {
	r.revenueGroups = &revenueGroups
	return r
}

// External system code.
func (r ResourceConfigAPIPutRevenueGroupsRequest) XExternalsystem(xExternalsystem string) ResourceConfigAPIPutRevenueGroupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ResourceConfigAPIPutRevenueGroupsRequest) AcceptLanguage(acceptLanguage string) ResourceConfigAPIPutRevenueGroupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ResourceConfigAPIPutRevenueGroupsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutRevenueGroupsExecute(r)
}

/*
PutRevenueGroups Update Catering Revenue Groups

You can use this API to update a catering revenue group Code. <p><strong>OperationId:</strong>putRevenueGroups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param revenueGroupsCode Unique Revenue Group Code
 @return ResourceConfigAPIPutRevenueGroupsRequest
*/
func (a *ResourceConfigAPIService) PutRevenueGroups(ctx context.Context, revenueGroupsCode string) ResourceConfigAPIPutRevenueGroupsRequest {
	return ResourceConfigAPIPutRevenueGroupsRequest{
		ApiService: a,
		ctx: ctx,
		revenueGroupsCode: revenueGroupsCode,
	}
}

// Execute executes the request
//  @return Status
func (a *ResourceConfigAPIService) PutRevenueGroupsExecute(r ResourceConfigAPIPutRevenueGroupsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResourceConfigAPIService.PutRevenueGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/revenueGroups/{revenueGroupsCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"revenueGroupsCode"+"}", url.PathEscape(parameterValueToString(r.revenueGroupsCode, "revenueGroupsCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.revenueGroupsCode) < 1 {
		return localVarReturnValue, nil, reportError("revenueGroupsCode must have at least 1 elements")
	}
	if strlen(r.revenueGroupsCode) > 2000 {
		return localVarReturnValue, nil, reportError("revenueGroupsCode must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.revenueGroups
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ResourceConfigAPIPutRevenueTypesRequest struct {
	ctx context.Context
	ApiService *ResourceConfigAPIService
	revenueTypesId string
	authorization *string
	xAppKey *string
	xHotelid *string
	revenueTypes *RevenueTypes
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ResourceConfigAPIPutRevenueTypesRequest) Authorization(authorization string) ResourceConfigAPIPutRevenueTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ResourceConfigAPIPutRevenueTypesRequest) XAppKey(xAppKey string) ResourceConfigAPIPutRevenueTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ResourceConfigAPIPutRevenueTypesRequest) XHotelid(xHotelid string) ResourceConfigAPIPutRevenueTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing existing Revenue Types Setup Configurations.
func (r ResourceConfigAPIPutRevenueTypesRequest) RevenueTypes(revenueTypes RevenueTypes) ResourceConfigAPIPutRevenueTypesRequest {
	r.revenueTypes = &revenueTypes
	return r
}

// External system code.
func (r ResourceConfigAPIPutRevenueTypesRequest) XExternalsystem(xExternalsystem string) ResourceConfigAPIPutRevenueTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ResourceConfigAPIPutRevenueTypesRequest) AcceptLanguage(acceptLanguage string) ResourceConfigAPIPutRevenueTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ResourceConfigAPIPutRevenueTypesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutRevenueTypesExecute(r)
}

/*
PutRevenueTypes Update Catering Revenue Types

You can use this API to update a Catering Revenue Type code. <p><strong>OperationId:</strong>putRevenueTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param revenueTypesId Unique code for  Revenue Type
 @return ResourceConfigAPIPutRevenueTypesRequest
*/
func (a *ResourceConfigAPIService) PutRevenueTypes(ctx context.Context, revenueTypesId string) ResourceConfigAPIPutRevenueTypesRequest {
	return ResourceConfigAPIPutRevenueTypesRequest{
		ApiService: a,
		ctx: ctx,
		revenueTypesId: revenueTypesId,
	}
}

// Execute executes the request
//  @return Status
func (a *ResourceConfigAPIService) PutRevenueTypesExecute(r ResourceConfigAPIPutRevenueTypesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResourceConfigAPIService.PutRevenueTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/revenueTypes/{revenueTypesId}"
	localVarPath = strings.Replace(localVarPath, "{"+"revenueTypesId"+"}", url.PathEscape(parameterValueToString(r.revenueTypesId, "revenueTypesId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.revenueTypesId) < 1 {
		return localVarReturnValue, nil, reportError("revenueTypesId must have at least 1 elements")
	}
	if strlen(r.revenueTypesId) > 2000 {
		return localVarReturnValue, nil, reportError("revenueTypesId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.revenueTypes
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
