/*
OPERA Cloud Event Configuration API

This API caters for Event Configuration in OPERA Cloud. <br /><There are operations to post, update, fetch and delete codes such as item inventory, function spaces, menu items and many more.<br /><br /> Compatible with OPERA Cloud release 22.3.<br /><br /><p> This document and all content within is available under the Universal Permissive License v 1.0 (https://oss.oracle.com/licenses/upl). Copyright (c) 2020, 2023 Oracle and/or its affiliates.</p>

API version: 22.3
Contact: hospitality_apis_ww_grp@oracle.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package evmcfg

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// ResourceConfigApiService ResourceConfigApi service
type ResourceConfigApiService service

type ResourceConfigApiGetCateringMenuItemsRequest struct {
	ctx context.Context
	ApiService *ResourceConfigApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	name *string
	codes *[]string
	quickInsertCode *string
	listTypeCodes *[]string
	inactive *bool
	eventTypesCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ResourceConfigApiGetCateringMenuItemsRequest) Authorization(authorization string) ResourceConfigApiGetCateringMenuItemsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r ResourceConfigApiGetCateringMenuItemsRequest) XAppKey(xAppKey string) ResourceConfigApiGetCateringMenuItemsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ResourceConfigApiGetCateringMenuItemsRequest) XHotelid(xHotelid string) ResourceConfigApiGetCateringMenuItemsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ResourceConfigApiGetCateringMenuItemsRequest) Limit(limit int32) ResourceConfigApiGetCateringMenuItemsRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ResourceConfigApiGetCateringMenuItemsRequest) Offset(offset int32) ResourceConfigApiGetCateringMenuItemsRequest {
	r.offset = &offset
	return r
}

// Menu item name of string lentgth 30
func (r ResourceConfigApiGetCateringMenuItemsRequest) Name(name string) ResourceConfigApiGetCateringMenuItemsRequest {
	r.name = &name
	return r
}

func (r ResourceConfigApiGetCateringMenuItemsRequest) Codes(codes []string) ResourceConfigApiGetCateringMenuItemsRequest {
	r.codes = &codes
	return r
}

// Article number of Menu Item in Caps
func (r ResourceConfigApiGetCateringMenuItemsRequest) QuickInsertCode(quickInsertCode string) ResourceConfigApiGetCateringMenuItemsRequest {
	r.quickInsertCode = &quickInsertCode
	return r
}

func (r ResourceConfigApiGetCateringMenuItemsRequest) ListTypeCodes(listTypeCodes []string) ResourceConfigApiGetCateringMenuItemsRequest {
	r.listTypeCodes = &listTypeCodes
	return r
}

// If true this boolean will set the criteria to only return Menu Items configured as Inactive.
func (r ResourceConfigApiGetCateringMenuItemsRequest) Inactive(inactive bool) ResourceConfigApiGetCateringMenuItemsRequest {
	r.inactive = &inactive
	return r
}

func (r ResourceConfigApiGetCateringMenuItemsRequest) EventTypesCodes(eventTypesCodes []string) ResourceConfigApiGetCateringMenuItemsRequest {
	r.eventTypesCodes = &eventTypesCodes
	return r
}

// External system code.
func (r ResourceConfigApiGetCateringMenuItemsRequest) XExternalsystem(xExternalsystem string) ResourceConfigApiGetCateringMenuItemsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ResourceConfigApiGetCateringMenuItemsRequest) AcceptLanguage(acceptLanguage string) ResourceConfigApiGetCateringMenuItemsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ResourceConfigApiGetCateringMenuItemsRequest) Execute() (*CateringMenuItemsInfo, *http.Response, error) {
	return r.ApiService.GetCateringMenuItemsExecute(r)
}

/*
GetCateringMenuItems Get Menu items

Get Menu items for a property. <p><strong>OperationId:</strong>getCateringMenuItems</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique OPERA Hotel Id
 @return ResourceConfigApiGetCateringMenuItemsRequest
*/
func (a *ResourceConfigApiService) GetCateringMenuItems(ctx context.Context, hotelId string) ResourceConfigApiGetCateringMenuItemsRequest {
	return ResourceConfigApiGetCateringMenuItemsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CateringMenuItemsInfo
func (a *ResourceConfigApiService) GetCateringMenuItemsExecute(r ResourceConfigApiGetCateringMenuItemsRequest) (*CateringMenuItemsInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CateringMenuItemsInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResourceConfigApiService.GetCateringMenuItems")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/cateringMenuItems"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
	}
	if r.codes != nil {
		t := *r.codes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "codes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "codes", t, "multi")
		}
	}
	if r.quickInsertCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "quickInsertCode", r.quickInsertCode, "")
	}
	if r.listTypeCodes != nil {
		t := *r.listTypeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "listTypeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "listTypeCodes", t, "multi")
		}
	}
	if r.inactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inactive", r.inactive, "")
	}
	if r.eventTypesCodes != nil {
		t := *r.eventTypesCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "eventTypesCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "eventTypesCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ResourceConfigApiGetCateringMenusRequest struct {
	ctx context.Context
	ApiService *ResourceConfigApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	menuId *string
	iDExtension *int32
	idContext *string
	menuIDType *string
	name *string
	classNameListCodes *[]string
	eventTypesCodes *[]string
	menuTypes *[]string
	dietaryListCodes *[]string
	inactive *bool
	multiChoice *bool
	webBookable *bool
	end *string
	start *string
	fetchInstructions *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ResourceConfigApiGetCateringMenusRequest) Authorization(authorization string) ResourceConfigApiGetCateringMenusRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r ResourceConfigApiGetCateringMenusRequest) XAppKey(xAppKey string) ResourceConfigApiGetCateringMenusRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ResourceConfigApiGetCateringMenusRequest) XHotelid(xHotelid string) ResourceConfigApiGetCateringMenusRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ResourceConfigApiGetCateringMenusRequest) Limit(limit int32) ResourceConfigApiGetCateringMenusRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ResourceConfigApiGetCateringMenusRequest) Offset(offset int32) ResourceConfigApiGetCateringMenusRequest {
	r.offset = &offset
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ResourceConfigApiGetCateringMenusRequest) MenuId(menuId string) ResourceConfigApiGetCateringMenusRequest {
	r.menuId = &menuId
	return r
}

// Additional identifying value assigned by the creating system.
func (r ResourceConfigApiGetCateringMenusRequest) IDExtension(iDExtension int32) ResourceConfigApiGetCateringMenusRequest {
	r.iDExtension = &iDExtension
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ResourceConfigApiGetCateringMenusRequest) IdContext(idContext string) ResourceConfigApiGetCateringMenusRequest {
	r.idContext = &idContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ResourceConfigApiGetCateringMenusRequest) MenuIDType(menuIDType string) ResourceConfigApiGetCateringMenusRequest {
	r.menuIDType = &menuIDType
	return r
}

// This type holds name of Menu Class.
func (r ResourceConfigApiGetCateringMenusRequest) Name(name string) ResourceConfigApiGetCateringMenusRequest {
	r.name = &name
	return r
}

func (r ResourceConfigApiGetCateringMenusRequest) ClassNameListCodes(classNameListCodes []string) ResourceConfigApiGetCateringMenusRequest {
	r.classNameListCodes = &classNameListCodes
	return r
}

func (r ResourceConfigApiGetCateringMenusRequest) EventTypesCodes(eventTypesCodes []string) ResourceConfigApiGetCateringMenusRequest {
	r.eventTypesCodes = &eventTypesCodes
	return r
}

// Defines values for Menu Type
func (r ResourceConfigApiGetCateringMenusRequest) MenuTypes(menuTypes []string) ResourceConfigApiGetCateringMenusRequest {
	r.menuTypes = &menuTypes
	return r
}

func (r ResourceConfigApiGetCateringMenusRequest) DietaryListCodes(dietaryListCodes []string) ResourceConfigApiGetCateringMenusRequest {
	r.dietaryListCodes = &dietaryListCodes
	return r
}

// If true, only Composed Menu&#39;s marked as Inactive in Menu Configuration will be returned.
func (r ResourceConfigApiGetCateringMenusRequest) Inactive(inactive bool) ResourceConfigApiGetCateringMenusRequest {
	r.inactive = &inactive
	return r
}

// When selected Only Composed Menu&#39;s noted as Multi Choice in Menu Configuration will be returned.
func (r ResourceConfigApiGetCateringMenusRequest) MultiChoice(multiChoice bool) ResourceConfigApiGetCateringMenusRequest {
	r.multiChoice = &multiChoice
	return r
}

// Check of Menu if it is web bookable
func (r ResourceConfigApiGetCateringMenusRequest) WebBookable(webBookable bool) ResourceConfigApiGetCateringMenusRequest {
	r.webBookable = &webBookable
	return r
}

// The ending value of the date range.
func (r ResourceConfigApiGetCateringMenusRequest) End(end string) ResourceConfigApiGetCateringMenusRequest {
	r.end = &end
	return r
}

// The starting value of the date range.
func (r ResourceConfigApiGetCateringMenusRequest) Start(start string) ResourceConfigApiGetCateringMenusRequest {
	r.start = &start
	return r
}

// Fetch instructions that can be used in Catering Menus maintenance.
func (r ResourceConfigApiGetCateringMenusRequest) FetchInstructions(fetchInstructions []string) ResourceConfigApiGetCateringMenusRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// External system code.
func (r ResourceConfigApiGetCateringMenusRequest) XExternalsystem(xExternalsystem string) ResourceConfigApiGetCateringMenusRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ResourceConfigApiGetCateringMenusRequest) AcceptLanguage(acceptLanguage string) ResourceConfigApiGetCateringMenusRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ResourceConfigApiGetCateringMenusRequest) Execute() (*CateringMenusInfo, *http.Response, error) {
	return r.ApiService.GetCateringMenusExecute(r)
}

/*
GetCateringMenus Get menus

Retrieve a list of menus for a property. <p><strong>OperationId:</strong>getCateringMenus</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique OPERA Hotel ID
 @return ResourceConfigApiGetCateringMenusRequest
*/
func (a *ResourceConfigApiService) GetCateringMenus(ctx context.Context, hotelId string) ResourceConfigApiGetCateringMenusRequest {
	return ResourceConfigApiGetCateringMenusRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CateringMenusInfo
func (a *ResourceConfigApiService) GetCateringMenusExecute(r ResourceConfigApiGetCateringMenusRequest) (*CateringMenusInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CateringMenusInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResourceConfigApiService.GetCateringMenus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/cateringMenus"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.menuId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "menuId", r.menuId, "")
	}
	if r.iDExtension != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "iDExtension", r.iDExtension, "")
	}
	if r.idContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", r.idContext, "")
	}
	if r.menuIDType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "menuIDType", r.menuIDType, "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
	}
	if r.classNameListCodes != nil {
		t := *r.classNameListCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "classNameListCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "classNameListCodes", t, "multi")
		}
	}
	if r.eventTypesCodes != nil {
		t := *r.eventTypesCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "eventTypesCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "eventTypesCodes", t, "multi")
		}
	}
	if r.menuTypes != nil {
		t := *r.menuTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "menuTypes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "menuTypes", t, "multi")
		}
	}
	if r.dietaryListCodes != nil {
		t := *r.dietaryListCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "dietaryListCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "dietaryListCodes", t, "multi")
		}
	}
	if r.inactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inactive", r.inactive, "")
	}
	if r.multiChoice != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "multiChoice", r.multiChoice, "")
	}
	if r.webBookable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "webBookable", r.webBookable, "")
	}
	if r.end != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end", r.end, "")
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "")
	}
	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ResourceConfigApiPostCateringMenuClassesRequest struct {
	ctx context.Context
	ApiService *ResourceConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	cateringMenuClasses *PostCateringMenuClassesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ResourceConfigApiPostCateringMenuClassesRequest) Authorization(authorization string) ResourceConfigApiPostCateringMenuClassesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r ResourceConfigApiPostCateringMenuClassesRequest) XAppKey(xAppKey string) ResourceConfigApiPostCateringMenuClassesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ResourceConfigApiPostCateringMenuClassesRequest) XHotelid(xHotelid string) ResourceConfigApiPostCateringMenuClassesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Requestion object for creating new Menu Classes.
func (r ResourceConfigApiPostCateringMenuClassesRequest) CateringMenuClasses(cateringMenuClasses PostCateringMenuClassesRequest) ResourceConfigApiPostCateringMenuClassesRequest {
	r.cateringMenuClasses = &cateringMenuClasses
	return r
}

// External system code.
func (r ResourceConfigApiPostCateringMenuClassesRequest) XExternalsystem(xExternalsystem string) ResourceConfigApiPostCateringMenuClassesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ResourceConfigApiPostCateringMenuClassesRequest) AcceptLanguage(acceptLanguage string) ResourceConfigApiPostCateringMenuClassesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ResourceConfigApiPostCateringMenuClassesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostCateringMenuClassesExecute(r)
}

/*
PostCateringMenuClasses Create menu classes

You can use this API to create menu classes. <p><strong>OperationId:</strong>postCateringMenuClasses</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ResourceConfigApiPostCateringMenuClassesRequest
*/
func (a *ResourceConfigApiService) PostCateringMenuClasses(ctx context.Context) ResourceConfigApiPostCateringMenuClassesRequest {
	return ResourceConfigApiPostCateringMenuClassesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ResourceConfigApiService) PostCateringMenuClassesExecute(r ResourceConfigApiPostCateringMenuClassesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResourceConfigApiService.PostCateringMenuClasses")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cateringMenuClasses"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.cateringMenuClasses
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ResourceConfigApiPostCateringMenuItemClassesRequest struct {
	ctx context.Context
	ApiService *ResourceConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	cateringMenuItemClasses *PostCateringMenuItemClassesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ResourceConfigApiPostCateringMenuItemClassesRequest) Authorization(authorization string) ResourceConfigApiPostCateringMenuItemClassesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r ResourceConfigApiPostCateringMenuItemClassesRequest) XAppKey(xAppKey string) ResourceConfigApiPostCateringMenuItemClassesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ResourceConfigApiPostCateringMenuItemClassesRequest) XHotelid(xHotelid string) ResourceConfigApiPostCateringMenuItemClassesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for Creating Menu Item Classes.
func (r ResourceConfigApiPostCateringMenuItemClassesRequest) CateringMenuItemClasses(cateringMenuItemClasses PostCateringMenuItemClassesRequest) ResourceConfigApiPostCateringMenuItemClassesRequest {
	r.cateringMenuItemClasses = &cateringMenuItemClasses
	return r
}

// External system code.
func (r ResourceConfigApiPostCateringMenuItemClassesRequest) XExternalsystem(xExternalsystem string) ResourceConfigApiPostCateringMenuItemClassesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ResourceConfigApiPostCateringMenuItemClassesRequest) AcceptLanguage(acceptLanguage string) ResourceConfigApiPostCateringMenuItemClassesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ResourceConfigApiPostCateringMenuItemClassesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostCateringMenuItemClassesExecute(r)
}

/*
PostCateringMenuItemClasses Create menu item classes

You can use this API to create menu item classes. <p><strong>OperationId:</strong>postCateringMenuItemClasses</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ResourceConfigApiPostCateringMenuItemClassesRequest
*/
func (a *ResourceConfigApiService) PostCateringMenuItemClasses(ctx context.Context) ResourceConfigApiPostCateringMenuItemClassesRequest {
	return ResourceConfigApiPostCateringMenuItemClassesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ResourceConfigApiService) PostCateringMenuItemClassesExecute(r ResourceConfigApiPostCateringMenuItemClassesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResourceConfigApiService.PostCateringMenuItemClasses")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cateringMenuItemClasses"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.cateringMenuItemClasses
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
