/*
OPERA Cloud Room Rotation Configuration Service API

APIs to cater for Room Rotation Configuration functionality in OPERA Cloud. Api provides capability to handle Room Rotation in OPERA Cloud. Room Rotation provides room ownership options for automatic inventory rotation and prioritization for owner rooms assignment and occupancy.<br /><br /> Compatible with OPERA Cloud release 22.3.<br /><br /><p> This document and all content within is available under the Universal Permissive License v 1.0 (https://oss.oracle.com/licenses/upl). Copyright (c) 2020, 2023 Oracle and/or its affiliates.</p>

API version: 22.3
Contact: hospitality_apis_ww_grp@oracle.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package rmrcfg

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// RoomRotationConfigApiService RoomRotationConfigApi service
type RoomRotationConfigApiService service

type RoomRotationConfigApiDeleteAdjustmentReasonsRequest struct {
	ctx context.Context
	ApiService *RoomRotationConfigApiService
	adjustmentReasonsId string
	authorization *string
	xAppKey *string
	xHotelid *string
	code *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RoomRotationConfigApiDeleteAdjustmentReasonsRequest) Authorization(authorization string) RoomRotationConfigApiDeleteAdjustmentReasonsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r RoomRotationConfigApiDeleteAdjustmentReasonsRequest) XAppKey(xAppKey string) RoomRotationConfigApiDeleteAdjustmentReasonsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RoomRotationConfigApiDeleteAdjustmentReasonsRequest) XHotelid(xHotelid string) RoomRotationConfigApiDeleteAdjustmentReasonsRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r RoomRotationConfigApiDeleteAdjustmentReasonsRequest) Code(code []string) RoomRotationConfigApiDeleteAdjustmentReasonsRequest {
	r.code = &code
	return r
}

// External system code.
func (r RoomRotationConfigApiDeleteAdjustmentReasonsRequest) XExternalsystem(xExternalsystem string) RoomRotationConfigApiDeleteAdjustmentReasonsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RoomRotationConfigApiDeleteAdjustmentReasonsRequest) AcceptLanguage(acceptLanguage string) RoomRotationConfigApiDeleteAdjustmentReasonsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RoomRotationConfigApiDeleteAdjustmentReasonsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteAdjustmentReasonsExecute(r)
}

/*
DeleteAdjustmentReasons Delete Room Rotation Adjustment Reasons

Use this API to update Room Rotation Adjustment Reasons. <p><strong>OperationId:</strong>deleteAdjustmentReasons</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param adjustmentReasonsId Unique ID of Room Rotation Adjustment Reason
 @return RoomRotationConfigApiDeleteAdjustmentReasonsRequest
*/
func (a *RoomRotationConfigApiService) DeleteAdjustmentReasons(ctx context.Context, adjustmentReasonsId string) RoomRotationConfigApiDeleteAdjustmentReasonsRequest {
	return RoomRotationConfigApiDeleteAdjustmentReasonsRequest{
		ApiService: a,
		ctx: ctx,
		adjustmentReasonsId: adjustmentReasonsId,
	}
}

// Execute executes the request
//  @return Status
func (a *RoomRotationConfigApiService) DeleteAdjustmentReasonsExecute(r RoomRotationConfigApiDeleteAdjustmentReasonsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoomRotationConfigApiService.DeleteAdjustmentReasons")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/adjustmentReasons/{adjustmentReasonsId}"
	localVarPath = strings.Replace(localVarPath, "{"+"adjustmentReasonsId"+"}", url.PathEscape(parameterValueToString(r.adjustmentReasonsId, "adjustmentReasonsId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.adjustmentReasonsId) < 1 {
		return localVarReturnValue, nil, reportError("adjustmentReasonsId must have at least 1 elements")
	}
	if strlen(r.adjustmentReasonsId) > 2000 {
		return localVarReturnValue, nil, reportError("adjustmentReasonsId must have less than 2000 elements")
	}

	if r.code != nil {
		t := *r.code
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "code", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "code", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RoomRotationConfigApiDeleteOverrideReasonsRequest struct {
	ctx context.Context
	ApiService *RoomRotationConfigApiService
	overrideReasonsId string
	authorization *string
	xAppKey *string
	xHotelid *string
	code *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RoomRotationConfigApiDeleteOverrideReasonsRequest) Authorization(authorization string) RoomRotationConfigApiDeleteOverrideReasonsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r RoomRotationConfigApiDeleteOverrideReasonsRequest) XAppKey(xAppKey string) RoomRotationConfigApiDeleteOverrideReasonsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RoomRotationConfigApiDeleteOverrideReasonsRequest) XHotelid(xHotelid string) RoomRotationConfigApiDeleteOverrideReasonsRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r RoomRotationConfigApiDeleteOverrideReasonsRequest) Code(code []string) RoomRotationConfigApiDeleteOverrideReasonsRequest {
	r.code = &code
	return r
}

// External system code.
func (r RoomRotationConfigApiDeleteOverrideReasonsRequest) XExternalsystem(xExternalsystem string) RoomRotationConfigApiDeleteOverrideReasonsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RoomRotationConfigApiDeleteOverrideReasonsRequest) AcceptLanguage(acceptLanguage string) RoomRotationConfigApiDeleteOverrideReasonsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RoomRotationConfigApiDeleteOverrideReasonsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteOverrideReasonsExecute(r)
}

/*
DeleteOverrideReasons Delete an existing Room Rotation Override Reason

Use this API to delete an existing Room Rotation Override Reason. <p><strong>OperationId:</strong>deleteOverrideReasons</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param overrideReasonsId Unique ID of Room Rotation Override Reason
 @return RoomRotationConfigApiDeleteOverrideReasonsRequest
*/
func (a *RoomRotationConfigApiService) DeleteOverrideReasons(ctx context.Context, overrideReasonsId string) RoomRotationConfigApiDeleteOverrideReasonsRequest {
	return RoomRotationConfigApiDeleteOverrideReasonsRequest{
		ApiService: a,
		ctx: ctx,
		overrideReasonsId: overrideReasonsId,
	}
}

// Execute executes the request
//  @return Status
func (a *RoomRotationConfigApiService) DeleteOverrideReasonsExecute(r RoomRotationConfigApiDeleteOverrideReasonsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoomRotationConfigApiService.DeleteOverrideReasons")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/overrideReasons/{overrideReasonsId}"
	localVarPath = strings.Replace(localVarPath, "{"+"overrideReasonsId"+"}", url.PathEscape(parameterValueToString(r.overrideReasonsId, "overrideReasonsId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.overrideReasonsId) < 1 {
		return localVarReturnValue, nil, reportError("overrideReasonsId must have at least 1 elements")
	}
	if strlen(r.overrideReasonsId) > 2000 {
		return localVarReturnValue, nil, reportError("overrideReasonsId must have less than 2000 elements")
	}

	if r.code != nil {
		t := *r.code
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "code", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "code", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RoomRotationConfigApiDeleteRoomOwnerRequest struct {
	ctx context.Context
	ApiService *RoomRotationConfigApiService
	roomOwnerId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RoomRotationConfigApiDeleteRoomOwnerRequest) Authorization(authorization string) RoomRotationConfigApiDeleteRoomOwnerRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r RoomRotationConfigApiDeleteRoomOwnerRequest) XAppKey(xAppKey string) RoomRotationConfigApiDeleteRoomOwnerRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RoomRotationConfigApiDeleteRoomOwnerRequest) XHotelid(xHotelid string) RoomRotationConfigApiDeleteRoomOwnerRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r RoomRotationConfigApiDeleteRoomOwnerRequest) XExternalsystem(xExternalsystem string) RoomRotationConfigApiDeleteRoomOwnerRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RoomRotationConfigApiDeleteRoomOwnerRequest) AcceptLanguage(acceptLanguage string) RoomRotationConfigApiDeleteRoomOwnerRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RoomRotationConfigApiDeleteRoomOwnerRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteRoomOwnerExecute(r)
}

/*
DeleteRoomOwner Delete Room Owner

Use this API to delete Room Owner. <p><strong>OperationId:</strong>deleteRoomOwner</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param roomOwnerId Unique Room Owner Code.
 @param hotelId Unique ID of hotel.
 @return RoomRotationConfigApiDeleteRoomOwnerRequest
*/
func (a *RoomRotationConfigApiService) DeleteRoomOwner(ctx context.Context, roomOwnerId string, hotelId string) RoomRotationConfigApiDeleteRoomOwnerRequest {
	return RoomRotationConfigApiDeleteRoomOwnerRequest{
		ApiService: a,
		ctx: ctx,
		roomOwnerId: roomOwnerId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *RoomRotationConfigApiService) DeleteRoomOwnerExecute(r RoomRotationConfigApiDeleteRoomOwnerRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoomRotationConfigApiService.DeleteRoomOwner")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/RoomOwner/{RoomOwnerId}"
	localVarPath = strings.Replace(localVarPath, "{"+"RoomOwnerId"+"}", url.PathEscape(parameterValueToString(r.roomOwnerId, "roomOwnerId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.roomOwnerId) < 1 {
		return localVarReturnValue, nil, reportError("roomOwnerId must have at least 1 elements")
	}
	if strlen(r.roomOwnerId) > 2000 {
		return localVarReturnValue, nil, reportError("roomOwnerId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RoomRotationConfigApiDeleteRoomRotationConfigServiceCacheRequest struct {
	ctx context.Context
	ApiService *RoomRotationConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	operaClearInput *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RoomRotationConfigApiDeleteRoomRotationConfigServiceCacheRequest) Authorization(authorization string) RoomRotationConfigApiDeleteRoomRotationConfigServiceCacheRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r RoomRotationConfigApiDeleteRoomRotationConfigServiceCacheRequest) XAppKey(xAppKey string) RoomRotationConfigApiDeleteRoomRotationConfigServiceCacheRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RoomRotationConfigApiDeleteRoomRotationConfigServiceCacheRequest) XHotelid(xHotelid string) RoomRotationConfigApiDeleteRoomRotationConfigServiceCacheRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for cleaning WS cache input type
func (r RoomRotationConfigApiDeleteRoomRotationConfigServiceCacheRequest) OperaClearInput(operaClearInput string) RoomRotationConfigApiDeleteRoomRotationConfigServiceCacheRequest {
	r.operaClearInput = &operaClearInput
	return r
}

// External system code.
func (r RoomRotationConfigApiDeleteRoomRotationConfigServiceCacheRequest) XExternalsystem(xExternalsystem string) RoomRotationConfigApiDeleteRoomRotationConfigServiceCacheRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RoomRotationConfigApiDeleteRoomRotationConfigServiceCacheRequest) AcceptLanguage(acceptLanguage string) RoomRotationConfigApiDeleteRoomRotationConfigServiceCacheRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RoomRotationConfigApiDeleteRoomRotationConfigServiceCacheRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteRoomRotationConfigServiceCacheExecute(r)
}

/*
DeleteRoomRotationConfigServiceCache Clear Cache

This API facilitates clearing of cache in room rotation service <p><strong>OperationId:</strong>deleteRoomRotationConfigServiceCache</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return RoomRotationConfigApiDeleteRoomRotationConfigServiceCacheRequest
*/
func (a *RoomRotationConfigApiService) DeleteRoomRotationConfigServiceCache(ctx context.Context) RoomRotationConfigApiDeleteRoomRotationConfigServiceCacheRequest {
	return RoomRotationConfigApiDeleteRoomRotationConfigServiceCacheRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *RoomRotationConfigApiService) DeleteRoomRotationConfigServiceCacheExecute(r RoomRotationConfigApiDeleteRoomRotationConfigServiceCacheRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoomRotationConfigApiService.DeleteRoomRotationConfigServiceCache")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/services/roomrotation/cache"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.operaClearInput != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "operaClearInput", r.operaClearInput, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RoomRotationConfigApiDeleteRotationGroupsRequest struct {
	ctx context.Context
	ApiService *RoomRotationConfigApiService
	rotationGroupsId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RoomRotationConfigApiDeleteRotationGroupsRequest) Authorization(authorization string) RoomRotationConfigApiDeleteRotationGroupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r RoomRotationConfigApiDeleteRotationGroupsRequest) XAppKey(xAppKey string) RoomRotationConfigApiDeleteRotationGroupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RoomRotationConfigApiDeleteRotationGroupsRequest) XHotelid(xHotelid string) RoomRotationConfigApiDeleteRotationGroupsRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r RoomRotationConfigApiDeleteRotationGroupsRequest) XExternalsystem(xExternalsystem string) RoomRotationConfigApiDeleteRotationGroupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RoomRotationConfigApiDeleteRotationGroupsRequest) AcceptLanguage(acceptLanguage string) RoomRotationConfigApiDeleteRotationGroupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RoomRotationConfigApiDeleteRotationGroupsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteRotationGroupsExecute(r)
}

/*
DeleteRotationGroups Delete Room Rotation Groups

Use this API to delete Room Rotation Group. <p><strong>OperationId:</strong>deleteRotationGroups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param rotationGroupsId Unique Rotation Group Code.
 @param hotelId Unique ID of hotel.
 @return RoomRotationConfigApiDeleteRotationGroupsRequest
*/
func (a *RoomRotationConfigApiService) DeleteRotationGroups(ctx context.Context, rotationGroupsId string, hotelId string) RoomRotationConfigApiDeleteRotationGroupsRequest {
	return RoomRotationConfigApiDeleteRotationGroupsRequest{
		ApiService: a,
		ctx: ctx,
		rotationGroupsId: rotationGroupsId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *RoomRotationConfigApiService) DeleteRotationGroupsExecute(r RoomRotationConfigApiDeleteRotationGroupsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoomRotationConfigApiService.DeleteRotationGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/rotationGroups/{rotationGroupsId}"
	localVarPath = strings.Replace(localVarPath, "{"+"rotationGroupsId"+"}", url.PathEscape(parameterValueToString(r.rotationGroupsId, "rotationGroupsId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.rotationGroupsId) < 1 {
		return localVarReturnValue, nil, reportError("rotationGroupsId must have at least 1 elements")
	}
	if strlen(r.rotationGroupsId) > 2000 {
		return localVarReturnValue, nil, reportError("rotationGroupsId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RoomRotationConfigApiDeleteRotationRulesRequest struct {
	ctx context.Context
	ApiService *RoomRotationConfigApiService
	ruleId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RoomRotationConfigApiDeleteRotationRulesRequest) Authorization(authorization string) RoomRotationConfigApiDeleteRotationRulesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r RoomRotationConfigApiDeleteRotationRulesRequest) XAppKey(xAppKey string) RoomRotationConfigApiDeleteRotationRulesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RoomRotationConfigApiDeleteRotationRulesRequest) XHotelid(xHotelid string) RoomRotationConfigApiDeleteRotationRulesRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r RoomRotationConfigApiDeleteRotationRulesRequest) XExternalsystem(xExternalsystem string) RoomRotationConfigApiDeleteRotationRulesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RoomRotationConfigApiDeleteRotationRulesRequest) AcceptLanguage(acceptLanguage string) RoomRotationConfigApiDeleteRotationRulesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RoomRotationConfigApiDeleteRotationRulesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteRotationRulesExecute(r)
}

/*
DeleteRotationRules Delete an existing Room Rotation Rule

Use this API to delete an existing Room Rotation Rule. <p><strong>OperationId:</strong>deleteRotationRules</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param ruleId Unique ID of Rotation Rule.
 @param hotelId Unique ID of hotel.
 @return RoomRotationConfigApiDeleteRotationRulesRequest
*/
func (a *RoomRotationConfigApiService) DeleteRotationRules(ctx context.Context, ruleId string, hotelId string) RoomRotationConfigApiDeleteRotationRulesRequest {
	return RoomRotationConfigApiDeleteRotationRulesRequest{
		ApiService: a,
		ctx: ctx,
		ruleId: ruleId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *RoomRotationConfigApiService) DeleteRotationRulesExecute(r RoomRotationConfigApiDeleteRotationRulesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoomRotationConfigApiService.DeleteRotationRules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/rules/{ruleId}"
	localVarPath = strings.Replace(localVarPath, "{"+"ruleId"+"}", url.PathEscape(parameterValueToString(r.ruleId, "ruleId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.ruleId) < 1 {
		return localVarReturnValue, nil, reportError("ruleId must have at least 1 elements")
	}
	if strlen(r.ruleId) > 2000 {
		return localVarReturnValue, nil, reportError("ruleId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RoomRotationConfigApiDeleteUnitGradesRequest struct {
	ctx context.Context
	ApiService *RoomRotationConfigApiService
	unitGradeCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	code *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RoomRotationConfigApiDeleteUnitGradesRequest) Authorization(authorization string) RoomRotationConfigApiDeleteUnitGradesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r RoomRotationConfigApiDeleteUnitGradesRequest) XAppKey(xAppKey string) RoomRotationConfigApiDeleteUnitGradesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RoomRotationConfigApiDeleteUnitGradesRequest) XHotelid(xHotelid string) RoomRotationConfigApiDeleteUnitGradesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Configuration code.
func (r RoomRotationConfigApiDeleteUnitGradesRequest) Code(code []string) RoomRotationConfigApiDeleteUnitGradesRequest {
	r.code = &code
	return r
}

// External system code.
func (r RoomRotationConfigApiDeleteUnitGradesRequest) XExternalsystem(xExternalsystem string) RoomRotationConfigApiDeleteUnitGradesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RoomRotationConfigApiDeleteUnitGradesRequest) AcceptLanguage(acceptLanguage string) RoomRotationConfigApiDeleteUnitGradesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RoomRotationConfigApiDeleteUnitGradesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteUnitGradesExecute(r)
}

/*
DeleteUnitGrades Delete an existing Room Rotation Unit Grade

Use this API to delete an existing Room Rotation Unit Grade. <p><strong>OperationId:</strong>deleteUnitGrades</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param unitGradeCode Unique Code of Unit Grade.
 @param hotelId Unique ID of hotel.
 @return RoomRotationConfigApiDeleteUnitGradesRequest
*/
func (a *RoomRotationConfigApiService) DeleteUnitGrades(ctx context.Context, unitGradeCode string, hotelId string) RoomRotationConfigApiDeleteUnitGradesRequest {
	return RoomRotationConfigApiDeleteUnitGradesRequest{
		ApiService: a,
		ctx: ctx,
		unitGradeCode: unitGradeCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *RoomRotationConfigApiService) DeleteUnitGradesExecute(r RoomRotationConfigApiDeleteUnitGradesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoomRotationConfigApiService.DeleteUnitGrades")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/unitGrades/{unitGradeCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"unitGradeCode"+"}", url.PathEscape(parameterValueToString(r.unitGradeCode, "unitGradeCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.unitGradeCode) < 1 {
		return localVarReturnValue, nil, reportError("unitGradeCode must have at least 1 elements")
	}
	if strlen(r.unitGradeCode) > 2000 {
		return localVarReturnValue, nil, reportError("unitGradeCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.code != nil {
		t := *r.code
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "code", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "code", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RoomRotationConfigApiGetAdjustmentReasonsRequest struct {
	ctx context.Context
	ApiService *RoomRotationConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	fetchInactive *bool
	code *[]string
	wildCard *string
	description *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RoomRotationConfigApiGetAdjustmentReasonsRequest) Authorization(authorization string) RoomRotationConfigApiGetAdjustmentReasonsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r RoomRotationConfigApiGetAdjustmentReasonsRequest) XAppKey(xAppKey string) RoomRotationConfigApiGetAdjustmentReasonsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RoomRotationConfigApiGetAdjustmentReasonsRequest) XHotelid(xHotelid string) RoomRotationConfigApiGetAdjustmentReasonsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Determines wether to fetch inactive records or not.
func (r RoomRotationConfigApiGetAdjustmentReasonsRequest) FetchInactive(fetchInactive bool) RoomRotationConfigApiGetAdjustmentReasonsRequest {
	r.fetchInactive = &fetchInactive
	return r
}

// Codes to be searched.
func (r RoomRotationConfigApiGetAdjustmentReasonsRequest) Code(code []string) RoomRotationConfigApiGetAdjustmentReasonsRequest {
	r.code = &code
	return r
}

// Wildcard search on the code.
func (r RoomRotationConfigApiGetAdjustmentReasonsRequest) WildCard(wildCard string) RoomRotationConfigApiGetAdjustmentReasonsRequest {
	r.wildCard = &wildCard
	return r
}

// Description of the code.
func (r RoomRotationConfigApiGetAdjustmentReasonsRequest) Description(description string) RoomRotationConfigApiGetAdjustmentReasonsRequest {
	r.description = &description
	return r
}

// External system code.
func (r RoomRotationConfigApiGetAdjustmentReasonsRequest) XExternalsystem(xExternalsystem string) RoomRotationConfigApiGetAdjustmentReasonsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RoomRotationConfigApiGetAdjustmentReasonsRequest) AcceptLanguage(acceptLanguage string) RoomRotationConfigApiGetAdjustmentReasonsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RoomRotationConfigApiGetAdjustmentReasonsRequest) Execute() (*FetchAdjustmentReasonsDetails, *http.Response, error) {
	return r.ApiService.GetAdjustmentReasonsExecute(r)
}

/*
GetAdjustmentReasons Get Room Rotation Adjustment Reasons

Use this API to get Room Rotation Adjustment Reasons. <p><strong>OperationId:</strong>getAdjustmentReasons</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return RoomRotationConfigApiGetAdjustmentReasonsRequest
*/
func (a *RoomRotationConfigApiService) GetAdjustmentReasons(ctx context.Context) RoomRotationConfigApiGetAdjustmentReasonsRequest {
	return RoomRotationConfigApiGetAdjustmentReasonsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FetchAdjustmentReasonsDetails
func (a *RoomRotationConfigApiService) GetAdjustmentReasonsExecute(r RoomRotationConfigApiGetAdjustmentReasonsRequest) (*FetchAdjustmentReasonsDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FetchAdjustmentReasonsDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoomRotationConfigApiService.GetAdjustmentReasons")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/adjustmentReasons"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fetchInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInactive", r.fetchInactive, "")
	}
	if r.code != nil {
		t := *r.code
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "code", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "code", t, "multi")
		}
	}
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
	}
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RoomRotationConfigApiGetOverrideReasonsRequest struct {
	ctx context.Context
	ApiService *RoomRotationConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	fetchInactive *bool
	code *[]string
	wildCard *string
	description *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RoomRotationConfigApiGetOverrideReasonsRequest) Authorization(authorization string) RoomRotationConfigApiGetOverrideReasonsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r RoomRotationConfigApiGetOverrideReasonsRequest) XAppKey(xAppKey string) RoomRotationConfigApiGetOverrideReasonsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RoomRotationConfigApiGetOverrideReasonsRequest) XHotelid(xHotelid string) RoomRotationConfigApiGetOverrideReasonsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Determines wether to fetch inactive records or not.
func (r RoomRotationConfigApiGetOverrideReasonsRequest) FetchInactive(fetchInactive bool) RoomRotationConfigApiGetOverrideReasonsRequest {
	r.fetchInactive = &fetchInactive
	return r
}

// Codes to be searched.
func (r RoomRotationConfigApiGetOverrideReasonsRequest) Code(code []string) RoomRotationConfigApiGetOverrideReasonsRequest {
	r.code = &code
	return r
}

// Wildcard search on the code.
func (r RoomRotationConfigApiGetOverrideReasonsRequest) WildCard(wildCard string) RoomRotationConfigApiGetOverrideReasonsRequest {
	r.wildCard = &wildCard
	return r
}

// Description of the code.
func (r RoomRotationConfigApiGetOverrideReasonsRequest) Description(description string) RoomRotationConfigApiGetOverrideReasonsRequest {
	r.description = &description
	return r
}

// External system code.
func (r RoomRotationConfigApiGetOverrideReasonsRequest) XExternalsystem(xExternalsystem string) RoomRotationConfigApiGetOverrideReasonsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RoomRotationConfigApiGetOverrideReasonsRequest) AcceptLanguage(acceptLanguage string) RoomRotationConfigApiGetOverrideReasonsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RoomRotationConfigApiGetOverrideReasonsRequest) Execute() (*OverrideReasonsDetails, *http.Response, error) {
	return r.ApiService.GetOverrideReasonsExecute(r)
}

/*
GetOverrideReasons Get Room Rotation Override Reasons

Use this API to get Room Rotation Override Reasons. <p><strong>OperationId:</strong>getOverrideReasons</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return RoomRotationConfigApiGetOverrideReasonsRequest
*/
func (a *RoomRotationConfigApiService) GetOverrideReasons(ctx context.Context) RoomRotationConfigApiGetOverrideReasonsRequest {
	return RoomRotationConfigApiGetOverrideReasonsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return OverrideReasonsDetails
func (a *RoomRotationConfigApiService) GetOverrideReasonsExecute(r RoomRotationConfigApiGetOverrideReasonsRequest) (*OverrideReasonsDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OverrideReasonsDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoomRotationConfigApiService.GetOverrideReasons")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/overrideReasons"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fetchInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInactive", r.fetchInactive, "")
	}
	if r.code != nil {
		t := *r.code
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "code", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "code", t, "multi")
		}
	}
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
	}
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RoomRotationConfigApiGetRevenueTransactionCodesRequest struct {
	ctx context.Context
	ApiService *RoomRotationConfigApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	rotationRevenue *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RoomRotationConfigApiGetRevenueTransactionCodesRequest) Authorization(authorization string) RoomRotationConfigApiGetRevenueTransactionCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r RoomRotationConfigApiGetRevenueTransactionCodesRequest) XAppKey(xAppKey string) RoomRotationConfigApiGetRevenueTransactionCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RoomRotationConfigApiGetRevenueTransactionCodesRequest) XHotelid(xHotelid string) RoomRotationConfigApiGetRevenueTransactionCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicate to retrieve transaction codes that are marked as Rotation Revenue transaction codes. If this value is omitted, all transaction codes will be returned for the given property.
func (r RoomRotationConfigApiGetRevenueTransactionCodesRequest) RotationRevenue(rotationRevenue bool) RoomRotationConfigApiGetRevenueTransactionCodesRequest {
	r.rotationRevenue = &rotationRevenue
	return r
}

// External system code.
func (r RoomRotationConfigApiGetRevenueTransactionCodesRequest) XExternalsystem(xExternalsystem string) RoomRotationConfigApiGetRevenueTransactionCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RoomRotationConfigApiGetRevenueTransactionCodesRequest) AcceptLanguage(acceptLanguage string) RoomRotationConfigApiGetRevenueTransactionCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RoomRotationConfigApiGetRevenueTransactionCodesRequest) Execute() (*FetchRevenueTransactionCodesDetails, *http.Response, error) {
	return r.ApiService.GetRevenueTransactionCodesExecute(r)
}

/*
GetRevenueTransactionCodes Retrieve all Room Rotation Revenue Transaction Codes

Use this API to retrieve all existing Room Rotation Revenue Transaction Codes. <p><strong>OperationId:</strong>getRevenueTransactionCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of hotel.
 @return RoomRotationConfigApiGetRevenueTransactionCodesRequest
*/
func (a *RoomRotationConfigApiService) GetRevenueTransactionCodes(ctx context.Context, hotelId string) RoomRotationConfigApiGetRevenueTransactionCodesRequest {
	return RoomRotationConfigApiGetRevenueTransactionCodesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return FetchRevenueTransactionCodesDetails
func (a *RoomRotationConfigApiService) GetRevenueTransactionCodesExecute(r RoomRotationConfigApiGetRevenueTransactionCodesRequest) (*FetchRevenueTransactionCodesDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FetchRevenueTransactionCodesDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoomRotationConfigApiService.GetRevenueTransactionCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/revenueTransactionCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.rotationRevenue != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rotationRevenue", r.rotationRevenue, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RoomRotationConfigApiGetRotationGroupsRequest struct {
	ctx context.Context
	ApiService *RoomRotationConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelId *[]string
	code *[]string
	description *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RoomRotationConfigApiGetRotationGroupsRequest) Authorization(authorization string) RoomRotationConfigApiGetRotationGroupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r RoomRotationConfigApiGetRotationGroupsRequest) XAppKey(xAppKey string) RoomRotationConfigApiGetRotationGroupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RoomRotationConfigApiGetRotationGroupsRequest) XHotelid(xHotelid string) RoomRotationConfigApiGetRotationGroupsRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r RoomRotationConfigApiGetRotationGroupsRequest) HotelId(hotelId []string) RoomRotationConfigApiGetRotationGroupsRequest {
	r.hotelId = &hotelId
	return r
}

func (r RoomRotationConfigApiGetRotationGroupsRequest) Code(code []string) RoomRotationConfigApiGetRotationGroupsRequest {
	r.code = &code
	return r
}

// Specifies description criteria.
func (r RoomRotationConfigApiGetRotationGroupsRequest) Description(description string) RoomRotationConfigApiGetRotationGroupsRequest {
	r.description = &description
	return r
}

// External system code.
func (r RoomRotationConfigApiGetRotationGroupsRequest) XExternalsystem(xExternalsystem string) RoomRotationConfigApiGetRotationGroupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RoomRotationConfigApiGetRotationGroupsRequest) AcceptLanguage(acceptLanguage string) RoomRotationConfigApiGetRotationGroupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RoomRotationConfigApiGetRotationGroupsRequest) Execute() (*RotationGroupsResult, *http.Response, error) {
	return r.ApiService.GetRotationGroupsExecute(r)
}

/*
GetRotationGroups Get Room Rotation Groups

Use this API to get Room Rotation Groups. <p><strong>OperationId:</strong>getRotationGroups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return RoomRotationConfigApiGetRotationGroupsRequest
*/
func (a *RoomRotationConfigApiService) GetRotationGroups(ctx context.Context) RoomRotationConfigApiGetRotationGroupsRequest {
	return RoomRotationConfigApiGetRotationGroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RotationGroupsResult
func (a *RoomRotationConfigApiService) GetRotationGroupsExecute(r RoomRotationConfigApiGetRotationGroupsRequest) (*RotationGroupsResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RotationGroupsResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoomRotationConfigApiService.GetRotationGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rotationGroups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.hotelId != nil {
		t := *r.hotelId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", t, "multi")
		}
	}
	if r.code != nil {
		t := *r.code
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "code", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "code", t, "multi")
		}
	}
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RoomRotationConfigApiGetRotationPeriodRequest struct {
	ctx context.Context
	ApiService *RoomRotationConfigApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RoomRotationConfigApiGetRotationPeriodRequest) Authorization(authorization string) RoomRotationConfigApiGetRotationPeriodRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r RoomRotationConfigApiGetRotationPeriodRequest) XAppKey(xAppKey string) RoomRotationConfigApiGetRotationPeriodRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RoomRotationConfigApiGetRotationPeriodRequest) XHotelid(xHotelid string) RoomRotationConfigApiGetRotationPeriodRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r RoomRotationConfigApiGetRotationPeriodRequest) XExternalsystem(xExternalsystem string) RoomRotationConfigApiGetRotationPeriodRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RoomRotationConfigApiGetRotationPeriodRequest) AcceptLanguage(acceptLanguage string) RoomRotationConfigApiGetRotationPeriodRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RoomRotationConfigApiGetRotationPeriodRequest) Execute() (*FetchRotationPeriodResponse, *http.Response, error) {
	return r.ApiService.GetRotationPeriodExecute(r)
}

/*
GetRotationPeriod Fetch Room Rotation Period

Use this API to fetch Room Rotation Period based on criteria. <p><strong>OperationId:</strong>getRotationPeriod</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of hotel.
 @return RoomRotationConfigApiGetRotationPeriodRequest
*/
func (a *RoomRotationConfigApiService) GetRotationPeriod(ctx context.Context, hotelId string) RoomRotationConfigApiGetRotationPeriodRequest {
	return RoomRotationConfigApiGetRotationPeriodRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return FetchRotationPeriodResponse
func (a *RoomRotationConfigApiService) GetRotationPeriodExecute(r RoomRotationConfigApiGetRotationPeriodRequest) (*FetchRotationPeriodResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FetchRotationPeriodResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoomRotationConfigApiService.GetRotationPeriod")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/rotationPeriod"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RoomRotationConfigApiGetRotationRulesRequest struct {
	ctx context.Context
	ApiService *RoomRotationConfigApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	setupType *string
	inactiveRules *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RoomRotationConfigApiGetRotationRulesRequest) Authorization(authorization string) RoomRotationConfigApiGetRotationRulesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r RoomRotationConfigApiGetRotationRulesRequest) XAppKey(xAppKey string) RoomRotationConfigApiGetRotationRulesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RoomRotationConfigApiGetRotationRulesRequest) XHotelid(xHotelid string) RoomRotationConfigApiGetRotationRulesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r RoomRotationConfigApiGetRotationRulesRequest) Limit(limit int32) RoomRotationConfigApiGetRotationRulesRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r RoomRotationConfigApiGetRotationRulesRequest) Offset(offset int32) RoomRotationConfigApiGetRotationRulesRequest {
	r.offset = &offset
	return r
}

// Simple type for Rotation Rule Setup.
func (r RoomRotationConfigApiGetRotationRulesRequest) SetupType(setupType string) RoomRotationConfigApiGetRotationRulesRequest {
	r.setupType = &setupType
	return r
}

// If set to True, only Inactive Rotation Rules will be retrieved. Otherwise, only Active Rotation Rules will be retrieved.
func (r RoomRotationConfigApiGetRotationRulesRequest) InactiveRules(inactiveRules bool) RoomRotationConfigApiGetRotationRulesRequest {
	r.inactiveRules = &inactiveRules
	return r
}

// External system code.
func (r RoomRotationConfigApiGetRotationRulesRequest) XExternalsystem(xExternalsystem string) RoomRotationConfigApiGetRotationRulesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RoomRotationConfigApiGetRotationRulesRequest) AcceptLanguage(acceptLanguage string) RoomRotationConfigApiGetRotationRulesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RoomRotationConfigApiGetRotationRulesRequest) Execute() (*FetchRotationRulesResponse, *http.Response, error) {
	return r.ApiService.GetRotationRulesExecute(r)
}

/*
GetRotationRules Retrieve all Room Rotation Rules

Use this API to retrieve all existing Room Rotation Rules based on criteria. <p><strong>OperationId:</strong>getRotationRules</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of hotel.
 @return RoomRotationConfigApiGetRotationRulesRequest
*/
func (a *RoomRotationConfigApiService) GetRotationRules(ctx context.Context, hotelId string) RoomRotationConfigApiGetRotationRulesRequest {
	return RoomRotationConfigApiGetRotationRulesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return FetchRotationRulesResponse
func (a *RoomRotationConfigApiService) GetRotationRulesExecute(r RoomRotationConfigApiGetRotationRulesRequest) (*FetchRotationRulesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FetchRotationRulesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoomRotationConfigApiService.GetRotationRules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/rules"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.setupType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "setupType", r.setupType, "")
	}
	if r.inactiveRules != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inactiveRules", r.inactiveRules, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RoomRotationConfigApiGetUnitGradesRequest struct {
	ctx context.Context
	ApiService *RoomRotationConfigApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	fetchInactive *bool
	code *[]string
	wildCard *string
	description *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RoomRotationConfigApiGetUnitGradesRequest) Authorization(authorization string) RoomRotationConfigApiGetUnitGradesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r RoomRotationConfigApiGetUnitGradesRequest) XAppKey(xAppKey string) RoomRotationConfigApiGetUnitGradesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RoomRotationConfigApiGetUnitGradesRequest) XHotelid(xHotelid string) RoomRotationConfigApiGetUnitGradesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Determines wether to fetch inactive records or not.
func (r RoomRotationConfigApiGetUnitGradesRequest) FetchInactive(fetchInactive bool) RoomRotationConfigApiGetUnitGradesRequest {
	r.fetchInactive = &fetchInactive
	return r
}

// Codes to be searched.
func (r RoomRotationConfigApiGetUnitGradesRequest) Code(code []string) RoomRotationConfigApiGetUnitGradesRequest {
	r.code = &code
	return r
}

// Wildcard search on the code.
func (r RoomRotationConfigApiGetUnitGradesRequest) WildCard(wildCard string) RoomRotationConfigApiGetUnitGradesRequest {
	r.wildCard = &wildCard
	return r
}

// Description of the code.
func (r RoomRotationConfigApiGetUnitGradesRequest) Description(description string) RoomRotationConfigApiGetUnitGradesRequest {
	r.description = &description
	return r
}

// External system code.
func (r RoomRotationConfigApiGetUnitGradesRequest) XExternalsystem(xExternalsystem string) RoomRotationConfigApiGetUnitGradesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RoomRotationConfigApiGetUnitGradesRequest) AcceptLanguage(acceptLanguage string) RoomRotationConfigApiGetUnitGradesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RoomRotationConfigApiGetUnitGradesRequest) Execute() (*FetchUnitGradesDetails, *http.Response, error) {
	return r.ApiService.GetUnitGradesExecute(r)
}

/*
GetUnitGrades Get Room Rotation Unit Grades

Use this API to get Room Rotation Unit Grades. <p><strong>OperationId:</strong>getUnitGrades</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of hotel.
 @return RoomRotationConfigApiGetUnitGradesRequest
*/
func (a *RoomRotationConfigApiService) GetUnitGrades(ctx context.Context, hotelId string) RoomRotationConfigApiGetUnitGradesRequest {
	return RoomRotationConfigApiGetUnitGradesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return FetchUnitGradesDetails
func (a *RoomRotationConfigApiService) GetUnitGradesExecute(r RoomRotationConfigApiGetUnitGradesRequest) (*FetchUnitGradesDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FetchUnitGradesDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoomRotationConfigApiService.GetUnitGrades")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/unitGrades"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.fetchInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInactive", r.fetchInactive, "")
	}
	if r.code != nil {
		t := *r.code
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "code", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "code", t, "multi")
		}
	}
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
	}
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RoomRotationConfigApiPingRoomRotationConfigServiceRequest struct {
	ctx context.Context
	ApiService *RoomRotationConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	operaPingInput *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RoomRotationConfigApiPingRoomRotationConfigServiceRequest) Authorization(authorization string) RoomRotationConfigApiPingRoomRotationConfigServiceRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r RoomRotationConfigApiPingRoomRotationConfigServiceRequest) XAppKey(xAppKey string) RoomRotationConfigApiPingRoomRotationConfigServiceRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RoomRotationConfigApiPingRoomRotationConfigServiceRequest) XHotelid(xHotelid string) RoomRotationConfigApiPingRoomRotationConfigServiceRequest {
	r.xHotelid = &xHotelid
	return r
}

// Opera Ping request input type
func (r RoomRotationConfigApiPingRoomRotationConfigServiceRequest) OperaPingInput(operaPingInput string) RoomRotationConfigApiPingRoomRotationConfigServiceRequest {
	r.operaPingInput = &operaPingInput
	return r
}

// External system code.
func (r RoomRotationConfigApiPingRoomRotationConfigServiceRequest) XExternalsystem(xExternalsystem string) RoomRotationConfigApiPingRoomRotationConfigServiceRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RoomRotationConfigApiPingRoomRotationConfigServiceRequest) AcceptLanguage(acceptLanguage string) RoomRotationConfigApiPingRoomRotationConfigServiceRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RoomRotationConfigApiPingRoomRotationConfigServiceRequest) Execute() (*PingDetail, *http.Response, error) {
	return r.ApiService.PingRoomRotationConfigServiceExecute(r)
}

/*
PingRoomRotationConfigService Ping

This API facilitates status check of room rotation service <p><strong>OperationId:</strong>pingRoomRotationConfigService</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return RoomRotationConfigApiPingRoomRotationConfigServiceRequest
*/
func (a *RoomRotationConfigApiService) PingRoomRotationConfigService(ctx context.Context) RoomRotationConfigApiPingRoomRotationConfigServiceRequest {
	return RoomRotationConfigApiPingRoomRotationConfigServiceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PingDetail
func (a *RoomRotationConfigApiService) PingRoomRotationConfigServiceExecute(r RoomRotationConfigApiPingRoomRotationConfigServiceRequest) (*PingDetail, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PingDetail
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoomRotationConfigApiService.PingRoomRotationConfigService")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/services/roomrotation/status"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.operaPingInput != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "operaPingInput", r.operaPingInput, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RoomRotationConfigApiPostAdjustmentReasonsRequest struct {
	ctx context.Context
	ApiService *RoomRotationConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	createAdjustmentReasonsDetails *PostAdjustmentReasonsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RoomRotationConfigApiPostAdjustmentReasonsRequest) Authorization(authorization string) RoomRotationConfigApiPostAdjustmentReasonsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r RoomRotationConfigApiPostAdjustmentReasonsRequest) XAppKey(xAppKey string) RoomRotationConfigApiPostAdjustmentReasonsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RoomRotationConfigApiPostAdjustmentReasonsRequest) XHotelid(xHotelid string) RoomRotationConfigApiPostAdjustmentReasonsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating a new Room Rotation Adjustment Reason.
func (r RoomRotationConfigApiPostAdjustmentReasonsRequest) CreateAdjustmentReasonsDetails(createAdjustmentReasonsDetails PostAdjustmentReasonsRequest) RoomRotationConfigApiPostAdjustmentReasonsRequest {
	r.createAdjustmentReasonsDetails = &createAdjustmentReasonsDetails
	return r
}

// External system code.
func (r RoomRotationConfigApiPostAdjustmentReasonsRequest) XExternalsystem(xExternalsystem string) RoomRotationConfigApiPostAdjustmentReasonsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RoomRotationConfigApiPostAdjustmentReasonsRequest) AcceptLanguage(acceptLanguage string) RoomRotationConfigApiPostAdjustmentReasonsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RoomRotationConfigApiPostAdjustmentReasonsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostAdjustmentReasonsExecute(r)
}

/*
PostAdjustmentReasons Post Room Rotation Adjustment Reasons

Use this API to post Room Rotation Adjustment Reasons. <p><strong>OperationId:</strong>postAdjustmentReasons</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return RoomRotationConfigApiPostAdjustmentReasonsRequest
*/
func (a *RoomRotationConfigApiService) PostAdjustmentReasons(ctx context.Context) RoomRotationConfigApiPostAdjustmentReasonsRequest {
	return RoomRotationConfigApiPostAdjustmentReasonsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *RoomRotationConfigApiService) PostAdjustmentReasonsExecute(r RoomRotationConfigApiPostAdjustmentReasonsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoomRotationConfigApiService.PostAdjustmentReasons")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/adjustmentReasons"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.createAdjustmentReasonsDetails
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RoomRotationConfigApiPostOverrideReasonsRequest struct {
	ctx context.Context
	ApiService *RoomRotationConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	overrideReasonsCriteria *PostOverrideReasonsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RoomRotationConfigApiPostOverrideReasonsRequest) Authorization(authorization string) RoomRotationConfigApiPostOverrideReasonsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r RoomRotationConfigApiPostOverrideReasonsRequest) XAppKey(xAppKey string) RoomRotationConfigApiPostOverrideReasonsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RoomRotationConfigApiPostOverrideReasonsRequest) XHotelid(xHotelid string) RoomRotationConfigApiPostOverrideReasonsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating a new Room Rotation Override Reason.
func (r RoomRotationConfigApiPostOverrideReasonsRequest) OverrideReasonsCriteria(overrideReasonsCriteria PostOverrideReasonsRequest) RoomRotationConfigApiPostOverrideReasonsRequest {
	r.overrideReasonsCriteria = &overrideReasonsCriteria
	return r
}

// External system code.
func (r RoomRotationConfigApiPostOverrideReasonsRequest) XExternalsystem(xExternalsystem string) RoomRotationConfigApiPostOverrideReasonsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RoomRotationConfigApiPostOverrideReasonsRequest) AcceptLanguage(acceptLanguage string) RoomRotationConfigApiPostOverrideReasonsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RoomRotationConfigApiPostOverrideReasonsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostOverrideReasonsExecute(r)
}

/*
PostOverrideReasons Create a new Room Rotation Override Reason

Use this API to create a new Room Rotation Override Reason. <p><strong>OperationId:</strong>postOverrideReasons</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return RoomRotationConfigApiPostOverrideReasonsRequest
*/
func (a *RoomRotationConfigApiService) PostOverrideReasons(ctx context.Context) RoomRotationConfigApiPostOverrideReasonsRequest {
	return RoomRotationConfigApiPostOverrideReasonsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *RoomRotationConfigApiService) PostOverrideReasonsExecute(r RoomRotationConfigApiPostOverrideReasonsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoomRotationConfigApiService.PostOverrideReasons")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/overrideReasons"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.overrideReasonsCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RoomRotationConfigApiPostRoomOwnerRequest struct {
	ctx context.Context
	ApiService *RoomRotationConfigApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	createRoomOwnerDetails *PostRoomOwnerRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RoomRotationConfigApiPostRoomOwnerRequest) Authorization(authorization string) RoomRotationConfigApiPostRoomOwnerRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r RoomRotationConfigApiPostRoomOwnerRequest) XAppKey(xAppKey string) RoomRotationConfigApiPostRoomOwnerRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RoomRotationConfigApiPostRoomOwnerRequest) XHotelid(xHotelid string) RoomRotationConfigApiPostRoomOwnerRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating room owner.
func (r RoomRotationConfigApiPostRoomOwnerRequest) CreateRoomOwnerDetails(createRoomOwnerDetails PostRoomOwnerRequest) RoomRotationConfigApiPostRoomOwnerRequest {
	r.createRoomOwnerDetails = &createRoomOwnerDetails
	return r
}

// External system code.
func (r RoomRotationConfigApiPostRoomOwnerRequest) XExternalsystem(xExternalsystem string) RoomRotationConfigApiPostRoomOwnerRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RoomRotationConfigApiPostRoomOwnerRequest) AcceptLanguage(acceptLanguage string) RoomRotationConfigApiPostRoomOwnerRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RoomRotationConfigApiPostRoomOwnerRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostRoomOwnerExecute(r)
}

/*
PostRoomOwner Create Room Owner

Use this API to create Room Owner. <p><strong>OperationId:</strong>postRoomOwner</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of hotel.
 @return RoomRotationConfigApiPostRoomOwnerRequest
*/
func (a *RoomRotationConfigApiService) PostRoomOwner(ctx context.Context, hotelId string) RoomRotationConfigApiPostRoomOwnerRequest {
	return RoomRotationConfigApiPostRoomOwnerRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *RoomRotationConfigApiService) PostRoomOwnerExecute(r RoomRotationConfigApiPostRoomOwnerRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoomRotationConfigApiService.PostRoomOwner")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/roomOwner"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.createRoomOwnerDetails
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RoomRotationConfigApiPostRotationGroupsRequest struct {
	ctx context.Context
	ApiService *RoomRotationConfigApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	rotationGroups *PostRotationGroupsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RoomRotationConfigApiPostRotationGroupsRequest) Authorization(authorization string) RoomRotationConfigApiPostRotationGroupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r RoomRotationConfigApiPostRotationGroupsRequest) XAppKey(xAppKey string) RoomRotationConfigApiPostRotationGroupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RoomRotationConfigApiPostRotationGroupsRequest) XHotelid(xHotelid string) RoomRotationConfigApiPostRotationGroupsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating room rotation groups.
func (r RoomRotationConfigApiPostRotationGroupsRequest) RotationGroups(rotationGroups PostRotationGroupsRequest) RoomRotationConfigApiPostRotationGroupsRequest {
	r.rotationGroups = &rotationGroups
	return r
}

// External system code.
func (r RoomRotationConfigApiPostRotationGroupsRequest) XExternalsystem(xExternalsystem string) RoomRotationConfigApiPostRotationGroupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RoomRotationConfigApiPostRotationGroupsRequest) AcceptLanguage(acceptLanguage string) RoomRotationConfigApiPostRotationGroupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RoomRotationConfigApiPostRotationGroupsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostRotationGroupsExecute(r)
}

/*
PostRotationGroups Create Room Rotation Groups

Use this API to create Room Rotation Groups. <p><strong>OperationId:</strong>postRotationGroups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of hotel.
 @return RoomRotationConfigApiPostRotationGroupsRequest
*/
func (a *RoomRotationConfigApiService) PostRotationGroups(ctx context.Context, hotelId string) RoomRotationConfigApiPostRotationGroupsRequest {
	return RoomRotationConfigApiPostRotationGroupsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *RoomRotationConfigApiService) PostRotationGroupsExecute(r RoomRotationConfigApiPostRotationGroupsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoomRotationConfigApiService.PostRotationGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/rotationGroups"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.rotationGroups
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RoomRotationConfigApiPostRotationRulesRequest struct {
	ctx context.Context
	ApiService *RoomRotationConfigApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	rotationRules *PostRotationRulesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RoomRotationConfigApiPostRotationRulesRequest) Authorization(authorization string) RoomRotationConfigApiPostRotationRulesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r RoomRotationConfigApiPostRotationRulesRequest) XAppKey(xAppKey string) RoomRotationConfigApiPostRotationRulesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RoomRotationConfigApiPostRotationRulesRequest) XHotelid(xHotelid string) RoomRotationConfigApiPostRotationRulesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating Rotation Rules for a given property
func (r RoomRotationConfigApiPostRotationRulesRequest) RotationRules(rotationRules PostRotationRulesRequest) RoomRotationConfigApiPostRotationRulesRequest {
	r.rotationRules = &rotationRules
	return r
}

// External system code.
func (r RoomRotationConfigApiPostRotationRulesRequest) XExternalsystem(xExternalsystem string) RoomRotationConfigApiPostRotationRulesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RoomRotationConfigApiPostRotationRulesRequest) AcceptLanguage(acceptLanguage string) RoomRotationConfigApiPostRotationRulesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RoomRotationConfigApiPostRotationRulesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostRotationRulesExecute(r)
}

/*
PostRotationRules Create Room Rotation Rules

Use this API to create Room Rotation Rules. <p><strong>OperationId:</strong>postRotationRules</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of hotel.
 @return RoomRotationConfigApiPostRotationRulesRequest
*/
func (a *RoomRotationConfigApiService) PostRotationRules(ctx context.Context, hotelId string) RoomRotationConfigApiPostRotationRulesRequest {
	return RoomRotationConfigApiPostRotationRulesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *RoomRotationConfigApiService) PostRotationRulesExecute(r RoomRotationConfigApiPostRotationRulesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoomRotationConfigApiService.PostRotationRules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/rules"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.rotationRules
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RoomRotationConfigApiPostUnitGradesRequest struct {
	ctx context.Context
	ApiService *RoomRotationConfigApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	createUnitGradesDetails *PostUnitGradesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RoomRotationConfigApiPostUnitGradesRequest) Authorization(authorization string) RoomRotationConfigApiPostUnitGradesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r RoomRotationConfigApiPostUnitGradesRequest) XAppKey(xAppKey string) RoomRotationConfigApiPostUnitGradesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RoomRotationConfigApiPostUnitGradesRequest) XHotelid(xHotelid string) RoomRotationConfigApiPostUnitGradesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating a new Room Rotation Unit Grade.
func (r RoomRotationConfigApiPostUnitGradesRequest) CreateUnitGradesDetails(createUnitGradesDetails PostUnitGradesRequest) RoomRotationConfigApiPostUnitGradesRequest {
	r.createUnitGradesDetails = &createUnitGradesDetails
	return r
}

// External system code.
func (r RoomRotationConfigApiPostUnitGradesRequest) XExternalsystem(xExternalsystem string) RoomRotationConfigApiPostUnitGradesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RoomRotationConfigApiPostUnitGradesRequest) AcceptLanguage(acceptLanguage string) RoomRotationConfigApiPostUnitGradesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RoomRotationConfigApiPostUnitGradesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostUnitGradesExecute(r)
}

/*
PostUnitGrades Create a new Room Rotation Unit Grade

Use this API to create a new Room Rotation Unit Grade. <p><strong>OperationId:</strong>postUnitGrades</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of hotel.
 @return RoomRotationConfigApiPostUnitGradesRequest
*/
func (a *RoomRotationConfigApiService) PostUnitGrades(ctx context.Context, hotelId string) RoomRotationConfigApiPostUnitGradesRequest {
	return RoomRotationConfigApiPostUnitGradesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *RoomRotationConfigApiService) PostUnitGradesExecute(r RoomRotationConfigApiPostUnitGradesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoomRotationConfigApiService.PostUnitGrades")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/unitGrades"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.createUnitGradesDetails
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RoomRotationConfigApiPutAdjustmentReasonsRequest struct {
	ctx context.Context
	ApiService *RoomRotationConfigApiService
	adjustmentReasonsId string
	authorization *string
	xAppKey *string
	xHotelid *string
	changeAdjustmentReasonsDetails *PutAdjustmentReasonsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RoomRotationConfigApiPutAdjustmentReasonsRequest) Authorization(authorization string) RoomRotationConfigApiPutAdjustmentReasonsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r RoomRotationConfigApiPutAdjustmentReasonsRequest) XAppKey(xAppKey string) RoomRotationConfigApiPutAdjustmentReasonsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RoomRotationConfigApiPutAdjustmentReasonsRequest) XHotelid(xHotelid string) RoomRotationConfigApiPutAdjustmentReasonsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing an existing Room Rotation Adjustment Reasons.
func (r RoomRotationConfigApiPutAdjustmentReasonsRequest) ChangeAdjustmentReasonsDetails(changeAdjustmentReasonsDetails PutAdjustmentReasonsRequest) RoomRotationConfigApiPutAdjustmentReasonsRequest {
	r.changeAdjustmentReasonsDetails = &changeAdjustmentReasonsDetails
	return r
}

// External system code.
func (r RoomRotationConfigApiPutAdjustmentReasonsRequest) XExternalsystem(xExternalsystem string) RoomRotationConfigApiPutAdjustmentReasonsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RoomRotationConfigApiPutAdjustmentReasonsRequest) AcceptLanguage(acceptLanguage string) RoomRotationConfigApiPutAdjustmentReasonsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RoomRotationConfigApiPutAdjustmentReasonsRequest) Execute() (*AdjustmentReasonsDetailsUpdated, *http.Response, error) {
	return r.ApiService.PutAdjustmentReasonsExecute(r)
}

/*
PutAdjustmentReasons Update Room Rotation Adjustment Reasons

Use this API to update Room Rotation Adjustment Reasons. <p><strong>OperationId:</strong>putAdjustmentReasons</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param adjustmentReasonsId Unique ID of Room Rotation Adjustment Reason
 @return RoomRotationConfigApiPutAdjustmentReasonsRequest
*/
func (a *RoomRotationConfigApiService) PutAdjustmentReasons(ctx context.Context, adjustmentReasonsId string) RoomRotationConfigApiPutAdjustmentReasonsRequest {
	return RoomRotationConfigApiPutAdjustmentReasonsRequest{
		ApiService: a,
		ctx: ctx,
		adjustmentReasonsId: adjustmentReasonsId,
	}
}

// Execute executes the request
//  @return AdjustmentReasonsDetailsUpdated
func (a *RoomRotationConfigApiService) PutAdjustmentReasonsExecute(r RoomRotationConfigApiPutAdjustmentReasonsRequest) (*AdjustmentReasonsDetailsUpdated, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AdjustmentReasonsDetailsUpdated
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoomRotationConfigApiService.PutAdjustmentReasons")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/adjustmentReasons/{adjustmentReasonsId}"
	localVarPath = strings.Replace(localVarPath, "{"+"adjustmentReasonsId"+"}", url.PathEscape(parameterValueToString(r.adjustmentReasonsId, "adjustmentReasonsId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.adjustmentReasonsId) < 1 {
		return localVarReturnValue, nil, reportError("adjustmentReasonsId must have at least 1 elements")
	}
	if strlen(r.adjustmentReasonsId) > 2000 {
		return localVarReturnValue, nil, reportError("adjustmentReasonsId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.changeAdjustmentReasonsDetails
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RoomRotationConfigApiPutOverrideReasonsRequest struct {
	ctx context.Context
	ApiService *RoomRotationConfigApiService
	overrideReasonsId string
	authorization *string
	xAppKey *string
	xHotelid *string
	overrideReasonsToBeChanged *PutOverrideReasonsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RoomRotationConfigApiPutOverrideReasonsRequest) Authorization(authorization string) RoomRotationConfigApiPutOverrideReasonsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r RoomRotationConfigApiPutOverrideReasonsRequest) XAppKey(xAppKey string) RoomRotationConfigApiPutOverrideReasonsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RoomRotationConfigApiPutOverrideReasonsRequest) XHotelid(xHotelid string) RoomRotationConfigApiPutOverrideReasonsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing an existing Room Rotation Override Reason.
func (r RoomRotationConfigApiPutOverrideReasonsRequest) OverrideReasonsToBeChanged(overrideReasonsToBeChanged PutOverrideReasonsRequest) RoomRotationConfigApiPutOverrideReasonsRequest {
	r.overrideReasonsToBeChanged = &overrideReasonsToBeChanged
	return r
}

// External system code.
func (r RoomRotationConfigApiPutOverrideReasonsRequest) XExternalsystem(xExternalsystem string) RoomRotationConfigApiPutOverrideReasonsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RoomRotationConfigApiPutOverrideReasonsRequest) AcceptLanguage(acceptLanguage string) RoomRotationConfigApiPutOverrideReasonsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RoomRotationConfigApiPutOverrideReasonsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutOverrideReasonsExecute(r)
}

/*
PutOverrideReasons Change an existing Room Rotation Override Reason

Use this API to update an existing Room Rotation Override Reason. <p><strong>OperationId:</strong>putOverrideReasons</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param overrideReasonsId Unique ID of Room Rotation Override Reason
 @return RoomRotationConfigApiPutOverrideReasonsRequest
*/
func (a *RoomRotationConfigApiService) PutOverrideReasons(ctx context.Context, overrideReasonsId string) RoomRotationConfigApiPutOverrideReasonsRequest {
	return RoomRotationConfigApiPutOverrideReasonsRequest{
		ApiService: a,
		ctx: ctx,
		overrideReasonsId: overrideReasonsId,
	}
}

// Execute executes the request
//  @return Status
func (a *RoomRotationConfigApiService) PutOverrideReasonsExecute(r RoomRotationConfigApiPutOverrideReasonsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoomRotationConfigApiService.PutOverrideReasons")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/overrideReasons/{overrideReasonsId}"
	localVarPath = strings.Replace(localVarPath, "{"+"overrideReasonsId"+"}", url.PathEscape(parameterValueToString(r.overrideReasonsId, "overrideReasonsId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.overrideReasonsId) < 1 {
		return localVarReturnValue, nil, reportError("overrideReasonsId must have at least 1 elements")
	}
	if strlen(r.overrideReasonsId) > 2000 {
		return localVarReturnValue, nil, reportError("overrideReasonsId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.overrideReasonsToBeChanged
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RoomRotationConfigApiPutRevenueTransactionCodesRequest struct {
	ctx context.Context
	ApiService *RoomRotationConfigApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	changeRevenueTransactionCodesCriteria *PutRevenueTransactionCodesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RoomRotationConfigApiPutRevenueTransactionCodesRequest) Authorization(authorization string) RoomRotationConfigApiPutRevenueTransactionCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r RoomRotationConfigApiPutRevenueTransactionCodesRequest) XAppKey(xAppKey string) RoomRotationConfigApiPutRevenueTransactionCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RoomRotationConfigApiPutRevenueTransactionCodesRequest) XHotelid(xHotelid string) RoomRotationConfigApiPutRevenueTransactionCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for updating the rotation revenue status of a transaction code for a given property.
func (r RoomRotationConfigApiPutRevenueTransactionCodesRequest) ChangeRevenueTransactionCodesCriteria(changeRevenueTransactionCodesCriteria PutRevenueTransactionCodesRequest) RoomRotationConfigApiPutRevenueTransactionCodesRequest {
	r.changeRevenueTransactionCodesCriteria = &changeRevenueTransactionCodesCriteria
	return r
}

// External system code.
func (r RoomRotationConfigApiPutRevenueTransactionCodesRequest) XExternalsystem(xExternalsystem string) RoomRotationConfigApiPutRevenueTransactionCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RoomRotationConfigApiPutRevenueTransactionCodesRequest) AcceptLanguage(acceptLanguage string) RoomRotationConfigApiPutRevenueTransactionCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RoomRotationConfigApiPutRevenueTransactionCodesRequest) Execute() (*ChangeRevenueTransactionCodesDetails, *http.Response, error) {
	return r.ApiService.PutRevenueTransactionCodesExecute(r)
}

/*
PutRevenueTransactionCodes Update the room rotation revenue status of a set of transaction codes

Use this API to update the room rotation revenue status of a set of transaction codes. <p><strong>OperationId:</strong>putRevenueTransactionCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of hotel.
 @return RoomRotationConfigApiPutRevenueTransactionCodesRequest
*/
func (a *RoomRotationConfigApiService) PutRevenueTransactionCodes(ctx context.Context, hotelId string) RoomRotationConfigApiPutRevenueTransactionCodesRequest {
	return RoomRotationConfigApiPutRevenueTransactionCodesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ChangeRevenueTransactionCodesDetails
func (a *RoomRotationConfigApiService) PutRevenueTransactionCodesExecute(r RoomRotationConfigApiPutRevenueTransactionCodesRequest) (*ChangeRevenueTransactionCodesDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChangeRevenueTransactionCodesDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoomRotationConfigApiService.PutRevenueTransactionCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/revenueTransactionCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.changeRevenueTransactionCodesCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RoomRotationConfigApiPutRoomOwnerRequest struct {
	ctx context.Context
	ApiService *RoomRotationConfigApiService
	roomOwnerId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	changeRoomOwnerDetails *PutRoomOwnerRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RoomRotationConfigApiPutRoomOwnerRequest) Authorization(authorization string) RoomRotationConfigApiPutRoomOwnerRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r RoomRotationConfigApiPutRoomOwnerRequest) XAppKey(xAppKey string) RoomRotationConfigApiPutRoomOwnerRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RoomRotationConfigApiPutRoomOwnerRequest) XHotelid(xHotelid string) RoomRotationConfigApiPutRoomOwnerRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing room owner.
func (r RoomRotationConfigApiPutRoomOwnerRequest) ChangeRoomOwnerDetails(changeRoomOwnerDetails PutRoomOwnerRequest) RoomRotationConfigApiPutRoomOwnerRequest {
	r.changeRoomOwnerDetails = &changeRoomOwnerDetails
	return r
}

// External system code.
func (r RoomRotationConfigApiPutRoomOwnerRequest) XExternalsystem(xExternalsystem string) RoomRotationConfigApiPutRoomOwnerRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RoomRotationConfigApiPutRoomOwnerRequest) AcceptLanguage(acceptLanguage string) RoomRotationConfigApiPutRoomOwnerRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RoomRotationConfigApiPutRoomOwnerRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutRoomOwnerExecute(r)
}

/*
PutRoomOwner Change Room Owner

Use this API to update Room Owner. <p><strong>OperationId:</strong>putRoomOwner</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param roomOwnerId Contract ID of the room owner record.
 @param hotelId Unique ID of hotel.
 @return RoomRotationConfigApiPutRoomOwnerRequest
*/
func (a *RoomRotationConfigApiService) PutRoomOwner(ctx context.Context, roomOwnerId string, hotelId string) RoomRotationConfigApiPutRoomOwnerRequest {
	return RoomRotationConfigApiPutRoomOwnerRequest{
		ApiService: a,
		ctx: ctx,
		roomOwnerId: roomOwnerId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *RoomRotationConfigApiService) PutRoomOwnerExecute(r RoomRotationConfigApiPutRoomOwnerRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoomRotationConfigApiService.PutRoomOwner")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/RoomOwner/{RoomOwnerId}"
	localVarPath = strings.Replace(localVarPath, "{"+"RoomOwnerId"+"}", url.PathEscape(parameterValueToString(r.roomOwnerId, "roomOwnerId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.roomOwnerId) < 1 {
		return localVarReturnValue, nil, reportError("roomOwnerId must have at least 1 elements")
	}
	if strlen(r.roomOwnerId) > 2000 {
		return localVarReturnValue, nil, reportError("roomOwnerId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.changeRoomOwnerDetails
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RoomRotationConfigApiPutRotationGroupsRequest struct {
	ctx context.Context
	ApiService *RoomRotationConfigApiService
	rotationGroupsId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	rotationGroups *PostRotationGroupsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RoomRotationConfigApiPutRotationGroupsRequest) Authorization(authorization string) RoomRotationConfigApiPutRotationGroupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r RoomRotationConfigApiPutRotationGroupsRequest) XAppKey(xAppKey string) RoomRotationConfigApiPutRotationGroupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RoomRotationConfigApiPutRotationGroupsRequest) XHotelid(xHotelid string) RoomRotationConfigApiPutRotationGroupsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing room rotation groups.
func (r RoomRotationConfigApiPutRotationGroupsRequest) RotationGroups(rotationGroups PostRotationGroupsRequest) RoomRotationConfigApiPutRotationGroupsRequest {
	r.rotationGroups = &rotationGroups
	return r
}

// External system code.
func (r RoomRotationConfigApiPutRotationGroupsRequest) XExternalsystem(xExternalsystem string) RoomRotationConfigApiPutRotationGroupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RoomRotationConfigApiPutRotationGroupsRequest) AcceptLanguage(acceptLanguage string) RoomRotationConfigApiPutRotationGroupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RoomRotationConfigApiPutRotationGroupsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutRotationGroupsExecute(r)
}

/*
PutRotationGroups Change Room Rotation Groups

Use this API to update Room Rotation Group. <p><strong>OperationId:</strong>putRotationGroups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param rotationGroupsId Unique Rotation Group Code.
 @param hotelId Unique ID of hotel.
 @return RoomRotationConfigApiPutRotationGroupsRequest
*/
func (a *RoomRotationConfigApiService) PutRotationGroups(ctx context.Context, rotationGroupsId string, hotelId string) RoomRotationConfigApiPutRotationGroupsRequest {
	return RoomRotationConfigApiPutRotationGroupsRequest{
		ApiService: a,
		ctx: ctx,
		rotationGroupsId: rotationGroupsId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *RoomRotationConfigApiService) PutRotationGroupsExecute(r RoomRotationConfigApiPutRotationGroupsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoomRotationConfigApiService.PutRotationGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/rotationGroups/{rotationGroupsId}"
	localVarPath = strings.Replace(localVarPath, "{"+"rotationGroupsId"+"}", url.PathEscape(parameterValueToString(r.rotationGroupsId, "rotationGroupsId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.rotationGroupsId) < 1 {
		return localVarReturnValue, nil, reportError("rotationGroupsId must have at least 1 elements")
	}
	if strlen(r.rotationGroupsId) > 2000 {
		return localVarReturnValue, nil, reportError("rotationGroupsId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.rotationGroups
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RoomRotationConfigApiPutRotationPeriodRequest struct {
	ctx context.Context
	ApiService *RoomRotationConfigApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	rotationPeriod *PutRotationPeriodRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RoomRotationConfigApiPutRotationPeriodRequest) Authorization(authorization string) RoomRotationConfigApiPutRotationPeriodRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r RoomRotationConfigApiPutRotationPeriodRequest) XAppKey(xAppKey string) RoomRotationConfigApiPutRotationPeriodRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RoomRotationConfigApiPutRotationPeriodRequest) XHotelid(xHotelid string) RoomRotationConfigApiPutRotationPeriodRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request Object for changing Rotation Period
func (r RoomRotationConfigApiPutRotationPeriodRequest) RotationPeriod(rotationPeriod PutRotationPeriodRequest) RoomRotationConfigApiPutRotationPeriodRequest {
	r.rotationPeriod = &rotationPeriod
	return r
}

// External system code.
func (r RoomRotationConfigApiPutRotationPeriodRequest) XExternalsystem(xExternalsystem string) RoomRotationConfigApiPutRotationPeriodRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RoomRotationConfigApiPutRotationPeriodRequest) AcceptLanguage(acceptLanguage string) RoomRotationConfigApiPutRotationPeriodRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RoomRotationConfigApiPutRotationPeriodRequest) Execute() (*ChangeRotationPeriodDetails, *http.Response, error) {
	return r.ApiService.PutRotationPeriodExecute(r)
}

/*
PutRotationPeriod Change Room Rotation Period

Use this API to change Room Rotation Period. <p><strong>OperationId:</strong>putRotationPeriod</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of hotel.
 @return RoomRotationConfigApiPutRotationPeriodRequest
*/
func (a *RoomRotationConfigApiService) PutRotationPeriod(ctx context.Context, hotelId string) RoomRotationConfigApiPutRotationPeriodRequest {
	return RoomRotationConfigApiPutRotationPeriodRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ChangeRotationPeriodDetails
func (a *RoomRotationConfigApiService) PutRotationPeriodExecute(r RoomRotationConfigApiPutRotationPeriodRequest) (*ChangeRotationPeriodDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChangeRotationPeriodDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoomRotationConfigApiService.PutRotationPeriod")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/rotationPeriod"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.rotationPeriod
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RoomRotationConfigApiPutRotationRulesRequest struct {
	ctx context.Context
	ApiService *RoomRotationConfigApiService
	ruleId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	rotationRules *PostRotationRulesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RoomRotationConfigApiPutRotationRulesRequest) Authorization(authorization string) RoomRotationConfigApiPutRotationRulesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r RoomRotationConfigApiPutRotationRulesRequest) XAppKey(xAppKey string) RoomRotationConfigApiPutRotationRulesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RoomRotationConfigApiPutRotationRulesRequest) XHotelid(xHotelid string) RoomRotationConfigApiPutRotationRulesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing room rotation rules.
func (r RoomRotationConfigApiPutRotationRulesRequest) RotationRules(rotationRules PostRotationRulesRequest) RoomRotationConfigApiPutRotationRulesRequest {
	r.rotationRules = &rotationRules
	return r
}

// External system code.
func (r RoomRotationConfigApiPutRotationRulesRequest) XExternalsystem(xExternalsystem string) RoomRotationConfigApiPutRotationRulesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RoomRotationConfigApiPutRotationRulesRequest) AcceptLanguage(acceptLanguage string) RoomRotationConfigApiPutRotationRulesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RoomRotationConfigApiPutRotationRulesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutRotationRulesExecute(r)
}

/*
PutRotationRules Change Room Rotation Rules

Use this API to update Room Rotation Rule. <p><strong>OperationId:</strong>putRotationRules</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param ruleId Unique Rotation Group Code.
 @param hotelId Unique ID of hotel.
 @return RoomRotationConfigApiPutRotationRulesRequest
*/
func (a *RoomRotationConfigApiService) PutRotationRules(ctx context.Context, ruleId string, hotelId string) RoomRotationConfigApiPutRotationRulesRequest {
	return RoomRotationConfigApiPutRotationRulesRequest{
		ApiService: a,
		ctx: ctx,
		ruleId: ruleId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *RoomRotationConfigApiService) PutRotationRulesExecute(r RoomRotationConfigApiPutRotationRulesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoomRotationConfigApiService.PutRotationRules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/rules/{ruleId}"
	localVarPath = strings.Replace(localVarPath, "{"+"ruleId"+"}", url.PathEscape(parameterValueToString(r.ruleId, "ruleId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.ruleId) < 1 {
		return localVarReturnValue, nil, reportError("ruleId must have at least 1 elements")
	}
	if strlen(r.ruleId) > 2000 {
		return localVarReturnValue, nil, reportError("ruleId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.rotationRules
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RoomRotationConfigApiPutUnitGradesRequest struct {
	ctx context.Context
	ApiService *RoomRotationConfigApiService
	unitGradeCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	changeUnitGradesDetails *PutUnitGradesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RoomRotationConfigApiPutUnitGradesRequest) Authorization(authorization string) RoomRotationConfigApiPutUnitGradesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r RoomRotationConfigApiPutUnitGradesRequest) XAppKey(xAppKey string) RoomRotationConfigApiPutUnitGradesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RoomRotationConfigApiPutUnitGradesRequest) XHotelid(xHotelid string) RoomRotationConfigApiPutUnitGradesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing an existing Room Rotation Unit Grades.
func (r RoomRotationConfigApiPutUnitGradesRequest) ChangeUnitGradesDetails(changeUnitGradesDetails PutUnitGradesRequest) RoomRotationConfigApiPutUnitGradesRequest {
	r.changeUnitGradesDetails = &changeUnitGradesDetails
	return r
}

// External system code.
func (r RoomRotationConfigApiPutUnitGradesRequest) XExternalsystem(xExternalsystem string) RoomRotationConfigApiPutUnitGradesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RoomRotationConfigApiPutUnitGradesRequest) AcceptLanguage(acceptLanguage string) RoomRotationConfigApiPutUnitGradesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RoomRotationConfigApiPutUnitGradesRequest) Execute() (*UnitGradesDetailsUpdated, *http.Response, error) {
	return r.ApiService.PutUnitGradesExecute(r)
}

/*
PutUnitGrades Change an existing Room Rotation Unit Grade

Use this API to update Room Rotation Unit Grades. <p><strong>OperationId:</strong>putUnitGrades</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param unitGradeCode Unique Code of Unit Grade.
 @param hotelId Unique ID of hotel.
 @return RoomRotationConfigApiPutUnitGradesRequest
*/
func (a *RoomRotationConfigApiService) PutUnitGrades(ctx context.Context, unitGradeCode string, hotelId string) RoomRotationConfigApiPutUnitGradesRequest {
	return RoomRotationConfigApiPutUnitGradesRequest{
		ApiService: a,
		ctx: ctx,
		unitGradeCode: unitGradeCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return UnitGradesDetailsUpdated
func (a *RoomRotationConfigApiService) PutUnitGradesExecute(r RoomRotationConfigApiPutUnitGradesRequest) (*UnitGradesDetailsUpdated, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UnitGradesDetailsUpdated
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoomRotationConfigApiService.PutUnitGrades")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/unitGrades/{unitGradeCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"unitGradeCode"+"}", url.PathEscape(parameterValueToString(r.unitGradeCode, "unitGradeCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.unitGradeCode) < 1 {
		return localVarReturnValue, nil, reportError("unitGradeCode must have at least 1 elements")
	}
	if strlen(r.unitGradeCode) > 2000 {
		return localVarReturnValue, nil, reportError("unitGradeCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.changeUnitGradesDetails
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
