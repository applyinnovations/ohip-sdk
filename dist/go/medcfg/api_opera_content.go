/*
OPERA Cloud Content Service

Opera Content Service offers capability to manage large content such as images and files.<br /><br /> Compatible with OPERA Cloud release 23.2.<br /><br /><p> This document and all content within is available under the Universal Permissive License v 1.0 (https://oss.oracle.com/licenses/upl). Copyright (c) 2020, 2023 Oracle and/or its affiliates.</p>

API version: 23.2
Contact: hospitality_apis_ww_grp@oracle.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package medcfg

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"os"
	"reflect"
)


// OperaContentApiService OperaContentApi service
type OperaContentApiService service

type OperaContentApiEmailFolioReportRequest struct {
	ctx context.Context
	ApiService *OperaContentApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	folioReportToEmail *EmailFolioReportRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r OperaContentApiEmailFolioReportRequest) Authorization(authorization string) OperaContentApiEmailFolioReportRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r OperaContentApiEmailFolioReportRequest) XAppKey(xAppKey string) OperaContentApiEmailFolioReportRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r OperaContentApiEmailFolioReportRequest) XHotelid(xHotelid string) OperaContentApiEmailFolioReportRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to generate and email a folio report.
func (r OperaContentApiEmailFolioReportRequest) FolioReportToEmail(folioReportToEmail EmailFolioReportRequest) OperaContentApiEmailFolioReportRequest {
	r.folioReportToEmail = &folioReportToEmail
	return r
}

// External system code.
func (r OperaContentApiEmailFolioReportRequest) XExternalsystem(xExternalsystem string) OperaContentApiEmailFolioReportRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r OperaContentApiEmailFolioReportRequest) AcceptLanguage(acceptLanguage string) OperaContentApiEmailFolioReportRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r OperaContentApiEmailFolioReportRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.EmailFolioReportExecute(r)
}

/*
EmailFolioReport Email folio report

Use this APU to email folio report. <p><strong>OperationId:</strong>emailFolioReport</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return OperaContentApiEmailFolioReportRequest
*/
func (a *OperaContentApiService) EmailFolioReport(ctx context.Context) OperaContentApiEmailFolioReportRequest {
	return OperaContentApiEmailFolioReportRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *OperaContentApiService) EmailFolioReportExecute(r OperaContentApiEmailFolioReportRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperaContentApiService.EmailFolioReport")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/folioReports/email"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.folioReportToEmail
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type OperaContentApiGetCustomizedLetterRequest struct {
	ctx context.Context
	ApiService *OperaContentApiService
	letterId string
	authorization *string
	xAppKey *string
	xHotelid *string
	letterIdContext *string
	letterIdtype *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r OperaContentApiGetCustomizedLetterRequest) Authorization(authorization string) OperaContentApiGetCustomizedLetterRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r OperaContentApiGetCustomizedLetterRequest) XAppKey(xAppKey string) OperaContentApiGetCustomizedLetterRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r OperaContentApiGetCustomizedLetterRequest) XHotelid(xHotelid string) OperaContentApiGetCustomizedLetterRequest {
	r.xHotelid = &xHotelid
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r OperaContentApiGetCustomizedLetterRequest) LetterIdContext(letterIdContext string) OperaContentApiGetCustomizedLetterRequest {
	r.letterIdContext = &letterIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r OperaContentApiGetCustomizedLetterRequest) LetterIdtype(letterIdtype string) OperaContentApiGetCustomizedLetterRequest {
	r.letterIdtype = &letterIdtype
	return r
}

// External system code.
func (r OperaContentApiGetCustomizedLetterRequest) XExternalsystem(xExternalsystem string) OperaContentApiGetCustomizedLetterRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r OperaContentApiGetCustomizedLetterRequest) AcceptLanguage(acceptLanguage string) OperaContentApiGetCustomizedLetterRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r OperaContentApiGetCustomizedLetterRequest) Execute() (*CustomizedLetter, *http.Response, error) {
	return r.ApiService.GetCustomizedLetterExecute(r)
}

/*
GetCustomizedLetter Get customized letter

Use this API to return a customized letter based on search criteria such as letterId, letterIdContext, letterIdtype. <p><strong>OperationId:</strong>getCustomizedLetter</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param letterId
 @return OperaContentApiGetCustomizedLetterRequest
*/
func (a *OperaContentApiService) GetCustomizedLetter(ctx context.Context, letterId string) OperaContentApiGetCustomizedLetterRequest {
	return OperaContentApiGetCustomizedLetterRequest{
		ApiService: a,
		ctx: ctx,
		letterId: letterId,
	}
}

// Execute executes the request
//  @return CustomizedLetter
func (a *OperaContentApiService) GetCustomizedLetterExecute(r OperaContentApiGetCustomizedLetterRequest) (*CustomizedLetter, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CustomizedLetter
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperaContentApiService.GetCustomizedLetter")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customizedLetter/{letterId}"
	localVarPath = strings.Replace(localVarPath, "{"+"letterId"+"}", url.PathEscape(parameterValueToString(r.letterId, "letterId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.letterId) < 1 {
		return localVarReturnValue, nil, reportError("letterId must have at least 1 elements")
	}
	if strlen(r.letterId) > 2000 {
		return localVarReturnValue, nil, reportError("letterId must have less than 2000 elements")
	}

	if r.letterIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "letterIdContext", r.letterIdContext, "")
	}
	if r.letterIdtype != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "letterIdtype", r.letterIdtype, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type OperaContentApiGetEmailFileRequest struct {
	ctx context.Context
	ApiService *OperaContentApiService
	emailId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r OperaContentApiGetEmailFileRequest) Authorization(authorization string) OperaContentApiGetEmailFileRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r OperaContentApiGetEmailFileRequest) XAppKey(xAppKey string) OperaContentApiGetEmailFileRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r OperaContentApiGetEmailFileRequest) XHotelid(xHotelid string) OperaContentApiGetEmailFileRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r OperaContentApiGetEmailFileRequest) XExternalsystem(xExternalsystem string) OperaContentApiGetEmailFileRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r OperaContentApiGetEmailFileRequest) AcceptLanguage(acceptLanguage string) OperaContentApiGetEmailFileRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r OperaContentApiGetEmailFileRequest) Execute() (*EmailFile, *http.Response, error) {
	return r.ApiService.GetEmailFileExecute(r)
}

/*
GetEmailFile Get Email Blob File

Use this API to retrieve email Blob File Stored in File Storage Schema.Its used in  Profiles to fetch Email and Open in an end user's mail client. <p><strong>OperationId:</strong>getEmailFile</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param emailId Unique OPERA Email ID which is used to find an Email BLOB File from OPERA. This ID is a primary identification of an email file in OPERA.
 @return OperaContentApiGetEmailFileRequest
*/
func (a *OperaContentApiService) GetEmailFile(ctx context.Context, emailId string) OperaContentApiGetEmailFileRequest {
	return OperaContentApiGetEmailFileRequest{
		ApiService: a,
		ctx: ctx,
		emailId: emailId,
	}
}

// Execute executes the request
//  @return EmailFile
func (a *OperaContentApiService) GetEmailFileExecute(r OperaContentApiGetEmailFileRequest) (*EmailFile, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EmailFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperaContentApiService.GetEmailFile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/emailFile/{emailId}"
	localVarPath = strings.Replace(localVarPath, "{"+"emailId"+"}", url.PathEscape(parameterValueToString(r.emailId, "emailId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.emailId) < 1 {
		return localVarReturnValue, nil, reportError("emailId must have at least 1 elements")
	}
	if strlen(r.emailId) > 2000 {
		return localVarReturnValue, nil, reportError("emailId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type OperaContentApiGetFileAttachmentRequest struct {
	ctx context.Context
	ApiService *OperaContentApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	id *string
	idContext *string
	idType *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r OperaContentApiGetFileAttachmentRequest) Authorization(authorization string) OperaContentApiGetFileAttachmentRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r OperaContentApiGetFileAttachmentRequest) XAppKey(xAppKey string) OperaContentApiGetFileAttachmentRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r OperaContentApiGetFileAttachmentRequest) XHotelid(xHotelid string) OperaContentApiGetFileAttachmentRequest {
	r.xHotelid = &xHotelid
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r OperaContentApiGetFileAttachmentRequest) Id(id string) OperaContentApiGetFileAttachmentRequest {
	r.id = &id
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r OperaContentApiGetFileAttachmentRequest) IdContext(idContext string) OperaContentApiGetFileAttachmentRequest {
	r.idContext = &idContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r OperaContentApiGetFileAttachmentRequest) IdType(idType string) OperaContentApiGetFileAttachmentRequest {
	r.idType = &idType
	return r
}

// External system code.
func (r OperaContentApiGetFileAttachmentRequest) XExternalsystem(xExternalsystem string) OperaContentApiGetFileAttachmentRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r OperaContentApiGetFileAttachmentRequest) AcceptLanguage(acceptLanguage string) OperaContentApiGetFileAttachmentRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r OperaContentApiGetFileAttachmentRequest) Execute() (**os.File, *http.Response, error) {
	return r.ApiService.GetFileAttachmentExecute(r)
}

/*
GetFileAttachment Get file attachment

Use this API to return file attachments based on search criteria such as id, idContext, idType. <p><strong>OperationId:</strong>getFileAttachment</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return OperaContentApiGetFileAttachmentRequest
*/
func (a *OperaContentApiService) GetFileAttachment(ctx context.Context) OperaContentApiGetFileAttachmentRequest {
	return OperaContentApiGetFileAttachmentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return *os.File
func (a *OperaContentApiService) GetFileAttachmentExecute(r OperaContentApiGetFileAttachmentRequest) (**os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  **os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperaContentApiService.GetFileAttachment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fileAttachments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.idContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", r.idContext, "")
	}
	if r.idType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idType", r.idType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type OperaContentApiGetFolioReportRequest struct {
	ctx context.Context
	ApiService *OperaContentApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	reservationIdContext *string
	reservationIdType *string
	folioWindowNo *int32
	billNumber *int32
	folioType *string
	folioDate *string
	referenceCurrency *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r OperaContentApiGetFolioReportRequest) Authorization(authorization string) OperaContentApiGetFolioReportRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r OperaContentApiGetFolioReportRequest) XAppKey(xAppKey string) OperaContentApiGetFolioReportRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r OperaContentApiGetFolioReportRequest) XHotelid(xHotelid string) OperaContentApiGetFolioReportRequest {
	r.xHotelid = &xHotelid
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r OperaContentApiGetFolioReportRequest) ReservationIdContext(reservationIdContext string) OperaContentApiGetFolioReportRequest {
	r.reservationIdContext = &reservationIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r OperaContentApiGetFolioReportRequest) ReservationIdType(reservationIdType string) OperaContentApiGetFolioReportRequest {
	r.reservationIdType = &reservationIdType
	return r
}

// Folio window number to generate (defaults to view 1).
func (r OperaContentApiGetFolioReportRequest) FolioWindowNo(folioWindowNo int32) OperaContentApiGetFolioReportRequest {
	r.folioWindowNo = &folioWindowNo
	return r
}

// Optional bill number to generate.
func (r OperaContentApiGetFolioReportRequest) BillNumber(billNumber int32) OperaContentApiGetFolioReportRequest {
	r.billNumber = &billNumber
	return r
}

// Optional folio type.
func (r OperaContentApiGetFolioReportRequest) FolioType(folioType string) OperaContentApiGetFolioReportRequest {
	r.folioType = &folioType
	return r
}

// Optional folio generation date - defaults to hotel business date.
func (r OperaContentApiGetFolioReportRequest) FolioDate(folioDate string) OperaContentApiGetFolioReportRequest {
	r.folioDate = &folioDate
	return r
}

// Folio currency code.
func (r OperaContentApiGetFolioReportRequest) ReferenceCurrency(referenceCurrency string) OperaContentApiGetFolioReportRequest {
	r.referenceCurrency = &referenceCurrency
	return r
}

// External system code.
func (r OperaContentApiGetFolioReportRequest) XExternalsystem(xExternalsystem string) OperaContentApiGetFolioReportRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r OperaContentApiGetFolioReportRequest) AcceptLanguage(acceptLanguage string) OperaContentApiGetFolioReportRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r OperaContentApiGetFolioReportRequest) Execute() (*FolioReport, *http.Response, error) {
	return r.ApiService.GetFolioReportExecute(r)
}

/*
GetFolioReport Get folio report

This API will get a folio report for a reservation. <p><strong>OperationId:</strong>getFolioReport</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId
 @param hotelId
 @return OperaContentApiGetFolioReportRequest
*/
func (a *OperaContentApiService) GetFolioReport(ctx context.Context, reservationId string, hotelId string) OperaContentApiGetFolioReportRequest {
	return OperaContentApiGetFolioReportRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return FolioReport
func (a *OperaContentApiService) GetFolioReportExecute(r OperaContentApiGetFolioReportRequest) (*FolioReport, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FolioReport
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperaContentApiService.GetFolioReport")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/folioReports"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.reservationIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIdContext", r.reservationIdContext, "")
	}
	if r.reservationIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIdType", r.reservationIdType, "")
	}
	if r.folioWindowNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioWindowNo", r.folioWindowNo, "")
	}
	if r.billNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "billNumber", r.billNumber, "")
	}
	if r.folioType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioType", r.folioType, "")
	}
	if r.folioDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioDate", r.folioDate, "")
	}
	if r.referenceCurrency != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "referenceCurrency", r.referenceCurrency, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type OperaContentApiGetImageRequest struct {
	ctx context.Context
	ApiService *OperaContentApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	linkId *string
	linkIdContext *string
	linkIdType *string
	imageCode *string
	imageParameterCode *[]string
	imageParameterValue *[]string
	languageCode *string
	imageStyle *string
	imageId *string
	imageIdContext *string
	imageIdType *string
	base64 *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r OperaContentApiGetImageRequest) Authorization(authorization string) OperaContentApiGetImageRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r OperaContentApiGetImageRequest) XAppKey(xAppKey string) OperaContentApiGetImageRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r OperaContentApiGetImageRequest) XHotelid(xHotelid string) OperaContentApiGetImageRequest {
	r.xHotelid = &xHotelid
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r OperaContentApiGetImageRequest) LinkId(linkId string) OperaContentApiGetImageRequest {
	r.linkId = &linkId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r OperaContentApiGetImageRequest) LinkIdContext(linkIdContext string) OperaContentApiGetImageRequest {
	r.linkIdContext = &linkIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r OperaContentApiGetImageRequest) LinkIdType(linkIdType string) OperaContentApiGetImageRequest {
	r.linkIdType = &linkIdType
	return r
}

func (r OperaContentApiGetImageRequest) ImageCode(imageCode string) OperaContentApiGetImageRequest {
	r.imageCode = &imageCode
	return r
}

func (r OperaContentApiGetImageRequest) ImageParameterCode(imageParameterCode []string) OperaContentApiGetImageRequest {
	r.imageParameterCode = &imageParameterCode
	return r
}

// Image parameter value.
func (r OperaContentApiGetImageRequest) ImageParameterValue(imageParameterValue []string) OperaContentApiGetImageRequest {
	r.imageParameterValue = &imageParameterValue
	return r
}

func (r OperaContentApiGetImageRequest) LanguageCode(languageCode string) OperaContentApiGetImageRequest {
	r.languageCode = &languageCode
	return r
}

// An enumeration of image styles.
func (r OperaContentApiGetImageRequest) ImageStyle(imageStyle string) OperaContentApiGetImageRequest {
	r.imageStyle = &imageStyle
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r OperaContentApiGetImageRequest) ImageId(imageId string) OperaContentApiGetImageRequest {
	r.imageId = &imageId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r OperaContentApiGetImageRequest) ImageIdContext(imageIdContext string) OperaContentApiGetImageRequest {
	r.imageIdContext = &imageIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r OperaContentApiGetImageRequest) ImageIdType(imageIdType string) OperaContentApiGetImageRequest {
	r.imageIdType = &imageIdType
	return r
}

// True if the image to be returned as a base64String else if the image to be returned as the binary in MTOM attachment then false .
func (r OperaContentApiGetImageRequest) Base64(base64 bool) OperaContentApiGetImageRequest {
	r.base64 = &base64
	return r
}

// External system code.
func (r OperaContentApiGetImageRequest) XExternalsystem(xExternalsystem string) OperaContentApiGetImageRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r OperaContentApiGetImageRequest) AcceptLanguage(acceptLanguage string) OperaContentApiGetImageRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r OperaContentApiGetImageRequest) Execute() (*Image, *http.Response, error) {
	return r.ApiService.GetImageExecute(r)
}

/*
GetImage Get image

Use this API to return an image based on search criteria such as linkId, linkIdContext, linkIdType, imageCode, imageParameterCode, imageParameterValue, languageCode, imageStyle, imageId, imageIdContext, imageIdType, base64.  <p><strong>OperationId:</strong>getImage</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return OperaContentApiGetImageRequest
*/
func (a *OperaContentApiService) GetImage(ctx context.Context) OperaContentApiGetImageRequest {
	return OperaContentApiGetImageRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Image
func (a *OperaContentApiService) GetImageExecute(r OperaContentApiGetImageRequest) (*Image, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Image
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperaContentApiService.GetImage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/images"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.linkId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "linkId", r.linkId, "")
	}
	if r.linkIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "linkIdContext", r.linkIdContext, "")
	}
	if r.linkIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "linkIdType", r.linkIdType, "")
	}
	if r.imageCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "imageCode", r.imageCode, "")
	}
	if r.imageParameterCode != nil {
		t := *r.imageParameterCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "imageParameterCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "imageParameterCode", t, "multi")
		}
	}
	if r.imageParameterValue != nil {
		t := *r.imageParameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "imageParameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "imageParameterValue", t, "multi")
		}
	}
	if r.languageCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "languageCode", r.languageCode, "")
	}
	if r.imageStyle != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "imageStyle", r.imageStyle, "")
	}
	if r.imageId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "imageId", r.imageId, "")
	}
	if r.imageIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "imageIdContext", r.imageIdContext, "")
	}
	if r.imageIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "imageIdType", r.imageIdType, "")
	}
	if r.base64 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "base64", r.base64, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type OperaContentApiGetRegistrationCardRequest struct {
	ctx context.Context
	ApiService *OperaContentApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	reservationIdContext *string
	reservationIdType *string
	regenerate *bool
	signedOnly *bool
	language *string
	template *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r OperaContentApiGetRegistrationCardRequest) Authorization(authorization string) OperaContentApiGetRegistrationCardRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r OperaContentApiGetRegistrationCardRequest) XAppKey(xAppKey string) OperaContentApiGetRegistrationCardRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r OperaContentApiGetRegistrationCardRequest) XHotelid(xHotelid string) OperaContentApiGetRegistrationCardRequest {
	r.xHotelid = &xHotelid
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r OperaContentApiGetRegistrationCardRequest) ReservationIdContext(reservationIdContext string) OperaContentApiGetRegistrationCardRequest {
	r.reservationIdContext = &reservationIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r OperaContentApiGetRegistrationCardRequest) ReservationIdType(reservationIdType string) OperaContentApiGetRegistrationCardRequest {
	r.reservationIdType = &reservationIdType
	return r
}

// Flag indicating whether a new registration card should be generated even if a signed card already exists.
func (r OperaContentApiGetRegistrationCardRequest) Regenerate(regenerate bool) OperaContentApiGetRegistrationCardRequest {
	r.regenerate = &regenerate
	return r
}

// Flag indicating whether return only the signed registrationCard if present.
func (r OperaContentApiGetRegistrationCardRequest) SignedOnly(signedOnly bool) OperaContentApiGetRegistrationCardRequest {
	r.signedOnly = &signedOnly
	return r
}

// Optional language code to use for registration card generation. Default guest language will be applied if not specified.
func (r OperaContentApiGetRegistrationCardRequest) Language(language string) OperaContentApiGetRegistrationCardRequest {
	r.language = &language
	return r
}

// Optional registration card template code to use for registration card generation. Default template will be applied if not specified.
func (r OperaContentApiGetRegistrationCardRequest) Template(template string) OperaContentApiGetRegistrationCardRequest {
	r.template = &template
	return r
}

// External system code.
func (r OperaContentApiGetRegistrationCardRequest) XExternalsystem(xExternalsystem string) OperaContentApiGetRegistrationCardRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r OperaContentApiGetRegistrationCardRequest) AcceptLanguage(acceptLanguage string) OperaContentApiGetRegistrationCardRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r OperaContentApiGetRegistrationCardRequest) Execute() (*RegistrationCard, *http.Response, error) {
	return r.ApiService.GetRegistrationCardExecute(r)
}

/*
GetRegistrationCard Get registration card

Use this API to return a registration card for a reservation based on search criteria such as reservationId, hotelId, reservationIdContext, reservationIdType, regenerate, signedOnly, language, template.  <p><strong>OperationId:</strong>getRegistrationCard</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId
 @param hotelId
 @return OperaContentApiGetRegistrationCardRequest
*/
func (a *OperaContentApiService) GetRegistrationCard(ctx context.Context, reservationId string, hotelId string) OperaContentApiGetRegistrationCardRequest {
	return OperaContentApiGetRegistrationCardRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return RegistrationCard
func (a *OperaContentApiService) GetRegistrationCardExecute(r OperaContentApiGetRegistrationCardRequest) (*RegistrationCard, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RegistrationCard
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperaContentApiService.GetRegistrationCard")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/registrationCard"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.reservationIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIdContext", r.reservationIdContext, "")
	}
	if r.reservationIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIdType", r.reservationIdType, "")
	}
	if r.regenerate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "regenerate", r.regenerate, "")
	}
	if r.signedOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "signedOnly", r.signedOnly, "")
	}
	if r.language != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "language", r.language, "")
	}
	if r.template != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "template", r.template, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type OperaContentApiRemoveImageRequest struct {
	ctx context.Context
	ApiService *OperaContentApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	imageCode *string
	imageSet *string
	imageId *string
	imageIdContext *string
	imageIdType *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r OperaContentApiRemoveImageRequest) Authorization(authorization string) OperaContentApiRemoveImageRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r OperaContentApiRemoveImageRequest) XAppKey(xAppKey string) OperaContentApiRemoveImageRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r OperaContentApiRemoveImageRequest) XHotelid(xHotelid string) OperaContentApiRemoveImageRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r OperaContentApiRemoveImageRequest) ImageCode(imageCode string) OperaContentApiRemoveImageRequest {
	r.imageCode = &imageCode
	return r
}

// Used for Character Strings, length 0 to 800.
func (r OperaContentApiRemoveImageRequest) ImageSet(imageSet string) OperaContentApiRemoveImageRequest {
	r.imageSet = &imageSet
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r OperaContentApiRemoveImageRequest) ImageId(imageId string) OperaContentApiRemoveImageRequest {
	r.imageId = &imageId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r OperaContentApiRemoveImageRequest) ImageIdContext(imageIdContext string) OperaContentApiRemoveImageRequest {
	r.imageIdContext = &imageIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r OperaContentApiRemoveImageRequest) ImageIdType(imageIdType string) OperaContentApiRemoveImageRequest {
	r.imageIdType = &imageIdType
	return r
}

// External system code.
func (r OperaContentApiRemoveImageRequest) XExternalsystem(xExternalsystem string) OperaContentApiRemoveImageRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r OperaContentApiRemoveImageRequest) AcceptLanguage(acceptLanguage string) OperaContentApiRemoveImageRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r OperaContentApiRemoveImageRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.RemoveImageExecute(r)
}

/*
RemoveImage Use this API to Delete image

Use this API to delete an image. <p><strong>OperationId:</strong>removeImage</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return OperaContentApiRemoveImageRequest
*/
func (a *OperaContentApiService) RemoveImage(ctx context.Context) OperaContentApiRemoveImageRequest {
	return OperaContentApiRemoveImageRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *OperaContentApiService) RemoveImageExecute(r OperaContentApiRemoveImageRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperaContentApiService.RemoveImage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/images"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.imageCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "imageCode", r.imageCode, "")
	}
	if r.imageSet != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "imageSet", r.imageSet, "")
	}
	if r.imageId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "imageId", r.imageId, "")
	}
	if r.imageIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "imageIdContext", r.imageIdContext, "")
	}
	if r.imageIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "imageIdType", r.imageIdType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type OperaContentApiSetCustomizedLetterRequest struct {
	ctx context.Context
	ApiService *OperaContentApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	customizedLetter *SetCustomizedLetterRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r OperaContentApiSetCustomizedLetterRequest) Authorization(authorization string) OperaContentApiSetCustomizedLetterRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r OperaContentApiSetCustomizedLetterRequest) XAppKey(xAppKey string) OperaContentApiSetCustomizedLetterRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r OperaContentApiSetCustomizedLetterRequest) XHotelid(xHotelid string) OperaContentApiSetCustomizedLetterRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to save customized letter.
func (r OperaContentApiSetCustomizedLetterRequest) CustomizedLetter(customizedLetter SetCustomizedLetterRequest) OperaContentApiSetCustomizedLetterRequest {
	r.customizedLetter = &customizedLetter
	return r
}

// External system code.
func (r OperaContentApiSetCustomizedLetterRequest) XExternalsystem(xExternalsystem string) OperaContentApiSetCustomizedLetterRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r OperaContentApiSetCustomizedLetterRequest) AcceptLanguage(acceptLanguage string) OperaContentApiSetCustomizedLetterRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r OperaContentApiSetCustomizedLetterRequest) Execute() (*CustomizedLetterStatus, *http.Response, error) {
	return r.ApiService.SetCustomizedLetterExecute(r)
}

/*
SetCustomizedLetter Set customized letter

Use this API to set a customized letter for a specific reservation based on the hotelId, reservationId, customizedLetter. <p><strong>OperationId:</strong>setCustomizedLetter</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId
 @param hotelId
 @return OperaContentApiSetCustomizedLetterRequest
*/
func (a *OperaContentApiService) SetCustomizedLetter(ctx context.Context, reservationId string, hotelId string) OperaContentApiSetCustomizedLetterRequest {
	return OperaContentApiSetCustomizedLetterRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CustomizedLetterStatus
func (a *OperaContentApiService) SetCustomizedLetterExecute(r OperaContentApiSetCustomizedLetterRequest) (*CustomizedLetterStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CustomizedLetterStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperaContentApiService.SetCustomizedLetter")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/customizedLetter"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.customizedLetter
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type OperaContentApiUploadFileAttachmentRequest struct {
	ctx context.Context
	ApiService *OperaContentApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	fileToUpload *UploadFileAttachmentRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r OperaContentApiUploadFileAttachmentRequest) Authorization(authorization string) OperaContentApiUploadFileAttachmentRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r OperaContentApiUploadFileAttachmentRequest) XAppKey(xAppKey string) OperaContentApiUploadFileAttachmentRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r OperaContentApiUploadFileAttachmentRequest) XHotelid(xHotelid string) OperaContentApiUploadFileAttachmentRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to upload a file attachment.
func (r OperaContentApiUploadFileAttachmentRequest) FileToUpload(fileToUpload UploadFileAttachmentRequest) OperaContentApiUploadFileAttachmentRequest {
	r.fileToUpload = &fileToUpload
	return r
}

// External system code.
func (r OperaContentApiUploadFileAttachmentRequest) XExternalsystem(xExternalsystem string) OperaContentApiUploadFileAttachmentRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r OperaContentApiUploadFileAttachmentRequest) AcceptLanguage(acceptLanguage string) OperaContentApiUploadFileAttachmentRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r OperaContentApiUploadFileAttachmentRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.UploadFileAttachmentExecute(r)
}

/*
UploadFileAttachment Upload a file attachment

Use this API to create a file attachment. <p><strong>OperationId:</strong>uploadFileAttachment</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return OperaContentApiUploadFileAttachmentRequest
*/
func (a *OperaContentApiService) UploadFileAttachment(ctx context.Context) OperaContentApiUploadFileAttachmentRequest {
	return OperaContentApiUploadFileAttachmentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *OperaContentApiService) UploadFileAttachmentExecute(r OperaContentApiUploadFileAttachmentRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperaContentApiService.UploadFileAttachment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fileAttachments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.fileToUpload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type OperaContentApiUploadImageRequest struct {
	ctx context.Context
	ApiService *OperaContentApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	imageToUpload *UploadImageRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r OperaContentApiUploadImageRequest) Authorization(authorization string) OperaContentApiUploadImageRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r OperaContentApiUploadImageRequest) XAppKey(xAppKey string) OperaContentApiUploadImageRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r OperaContentApiUploadImageRequest) XHotelid(xHotelid string) OperaContentApiUploadImageRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to upload an image.
func (r OperaContentApiUploadImageRequest) ImageToUpload(imageToUpload UploadImageRequest) OperaContentApiUploadImageRequest {
	r.imageToUpload = &imageToUpload
	return r
}

// External system code.
func (r OperaContentApiUploadImageRequest) XExternalsystem(xExternalsystem string) OperaContentApiUploadImageRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r OperaContentApiUploadImageRequest) AcceptLanguage(acceptLanguage string) OperaContentApiUploadImageRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r OperaContentApiUploadImageRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.UploadImageExecute(r)
}

/*
UploadImage Use this API to Upload an image

Use this API to upload an image. <p><strong>OperationId:</strong>uploadImage</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return OperaContentApiUploadImageRequest
*/
func (a *OperaContentApiService) UploadImage(ctx context.Context) OperaContentApiUploadImageRequest {
	return OperaContentApiUploadImageRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *OperaContentApiService) UploadImageExecute(r OperaContentApiUploadImageRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperaContentApiService.UploadImage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/images"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.imageToUpload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
