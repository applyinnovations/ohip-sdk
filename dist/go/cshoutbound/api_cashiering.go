/*
OPERA Cloud Cashiering Outbound API

APIs to cater for Cashiering related external (outbound) functionality with OPERA. These APIs facilitate various operations related to getting data from an external system, and inserting it into OPERA.<br /><br /> Compatible with OPERA Cloud release 22.3.<br /><br /><p> This document and all content within is available under the Universal Permissive License v 1.0 (https://oss.oracle.com/licenses/upl). Copyright (c) 2020, 2023 Oracle and/or its affiliates.</p>

API version: 22.3
Contact: hospitality_apis_ww_grp@oracle.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package cshoutbound

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// CashieringApiService CashieringApi service
type CashieringApiService service

type CashieringApiApproveCompPostingsRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	hotelId string
	authorization *string
	xAppKey *string
	postings *ApproveCompPostingsRequest
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringApiApproveCompPostingsRequest) Authorization(authorization string) CashieringApiApproveCompPostingsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner??????s Application Key
func (r CashieringApiApproveCompPostingsRequest) XAppKey(xAppKey string) CashieringApiApproveCompPostingsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Request object to submit comp transactions request to gaming system
func (r CashieringApiApproveCompPostingsRequest) Postings(postings ApproveCompPostingsRequest) CashieringApiApproveCompPostingsRequest {
	r.postings = &postings
	return r
}

// Language code
func (r CashieringApiApproveCompPostingsRequest) AcceptLanguage(acceptLanguage string) CashieringApiApproveCompPostingsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringApiApproveCompPostingsRequest) Execute() (*SendCompTransactionsStatus, *http.Response, error) {
	return r.ApiService.ApproveCompPostingsExecute(r)
}

/*
ApproveCompPostings Operation to request for comp postings approval.

You can use this API to submit Comp Transactions. <p><strong>OperationId:</strong>approveCompPostings</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return CashieringApiApproveCompPostingsRequest
*/
func (a *CashieringApiService) ApproveCompPostings(ctx context.Context, hotelId string) CashieringApiApproveCompPostingsRequest {
	return CashieringApiApproveCompPostingsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return SendCompTransactionsStatus
func (a *CashieringApiService) ApproveCompPostingsExecute(r CashieringApiApproveCompPostingsRequest) (*SendCompTransactionsStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SendCompTransactionsStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.ApproveCompPostings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/compPostingsApproval"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 20 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 20 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.postings
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringApiAuthorizeCompRedemptionsRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	membershipId string
	hotelId string
	authorization *string
	xAppKey *string
	authorizeCompRedemptions *AuthorizeCompRedemptionsRequest
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringApiAuthorizeCompRedemptionsRequest) Authorization(authorization string) CashieringApiAuthorizeCompRedemptionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner??????s Application Key
func (r CashieringApiAuthorizeCompRedemptionsRequest) XAppKey(xAppKey string) CashieringApiAuthorizeCompRedemptionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Request type for Complimentary Redemptions authorization.
func (r CashieringApiAuthorizeCompRedemptionsRequest) AuthorizeCompRedemptions(authorizeCompRedemptions AuthorizeCompRedemptionsRequest) CashieringApiAuthorizeCompRedemptionsRequest {
	r.authorizeCompRedemptions = &authorizeCompRedemptions
	return r
}

// Language code
func (r CashieringApiAuthorizeCompRedemptionsRequest) AcceptLanguage(acceptLanguage string) CashieringApiAuthorizeCompRedemptionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringApiAuthorizeCompRedemptionsRequest) Execute() (*AuthorizeCompRedemptionsRS, *http.Response, error) {
	return r.ApiService.AuthorizeCompRedemptionsExecute(r)
}

/*
AuthorizeCompRedemptions Operation to authorize complimentary redemptions for a guest having PTS Membership Type

You can use this API to authorize complimentary redemptions for a guest having PTS Membership Type <p><strong>OperationId:</strong>authorizeCompRedemptions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param membershipId Membership number of the guest in the reservation
 @param hotelId Unique ID of the hotel
 @return CashieringApiAuthorizeCompRedemptionsRequest
*/
func (a *CashieringApiService) AuthorizeCompRedemptions(ctx context.Context, membershipId string, hotelId string) CashieringApiAuthorizeCompRedemptionsRequest {
	return CashieringApiAuthorizeCompRedemptionsRequest{
		ApiService: a,
		ctx: ctx,
		membershipId: membershipId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return AuthorizeCompRedemptionsRS
func (a *CashieringApiService) AuthorizeCompRedemptionsExecute(r CashieringApiAuthorizeCompRedemptionsRequest) (*AuthorizeCompRedemptionsRS, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuthorizeCompRedemptionsRS
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.AuthorizeCompRedemptions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/memberships/{membershipId}/compRedemptionAuthorizations"
	localVarPath = strings.Replace(localVarPath, "{"+"membershipId"+"}", url.PathEscape(parameterValueToString(r.membershipId, "membershipId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.membershipId) < 1 {
		return localVarReturnValue, nil, reportError("membershipId must have at least 1 elements")
	}
	if strlen(r.membershipId) > 2000 {
		return localVarReturnValue, nil, reportError("membershipId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 20 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 20 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.authorizeCompRedemptions
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringApiGetCompRedemptionsRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	membershipId string
	hotelId string
	authorization *string
	xAppKey *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringApiGetCompRedemptionsRequest) Authorization(authorization string) CashieringApiGetCompRedemptionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner??????s Application Key
func (r CashieringApiGetCompRedemptionsRequest) XAppKey(xAppKey string) CashieringApiGetCompRedemptionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Language code
func (r CashieringApiGetCompRedemptionsRequest) AcceptLanguage(acceptLanguage string) CashieringApiGetCompRedemptionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringApiGetCompRedemptionsRequest) Execute() (*FetchCompRedemptionsRS, *http.Response, error) {
	return r.ApiService.GetCompRedemptionsExecute(r)
}

/*
GetCompRedemptions Operation to get complimentary redemptions for a guest having PTS Membership Type

You can use this API to get complimentary redemptions for a guest having PTS Membership Type <p><strong>OperationId:</strong>getCompRedemptions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param membershipId Membership number of the guest in the reservation
 @param hotelId Unique ID of the hotel
 @return CashieringApiGetCompRedemptionsRequest
*/
func (a *CashieringApiService) GetCompRedemptions(ctx context.Context, membershipId string, hotelId string) CashieringApiGetCompRedemptionsRequest {
	return CashieringApiGetCompRedemptionsRequest{
		ApiService: a,
		ctx: ctx,
		membershipId: membershipId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return FetchCompRedemptionsRS
func (a *CashieringApiService) GetCompRedemptionsExecute(r CashieringApiGetCompRedemptionsRequest) (*FetchCompRedemptionsRS, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FetchCompRedemptionsRS
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.GetCompRedemptions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/memberships/{membershipId}/compRedemptions"
	localVarPath = strings.Replace(localVarPath, "{"+"membershipId"+"}", url.PathEscape(parameterValueToString(r.membershipId, "membershipId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.membershipId) < 1 {
		return localVarReturnValue, nil, reportError("membershipId must have at least 1 elements")
	}
	if strlen(r.membershipId) > 2000 {
		return localVarReturnValue, nil, reportError("membershipId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 20 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 20 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringApiPostCompRedemptionsRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	membershipId string
	hotelId string
	authorization *string
	xAppKey *string
	postCompRedemptions *PostCompRedemptionsRequest
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringApiPostCompRedemptionsRequest) Authorization(authorization string) CashieringApiPostCompRedemptionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner??????s Application Key
func (r CashieringApiPostCompRedemptionsRequest) XAppKey(xAppKey string) CashieringApiPostCompRedemptionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Request type of Complimentary Redemptions posting.
func (r CashieringApiPostCompRedemptionsRequest) PostCompRedemptions(postCompRedemptions PostCompRedemptionsRequest) CashieringApiPostCompRedemptionsRequest {
	r.postCompRedemptions = &postCompRedemptions
	return r
}

// Language code
func (r CashieringApiPostCompRedemptionsRequest) AcceptLanguage(acceptLanguage string) CashieringApiPostCompRedemptionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringApiPostCompRedemptionsRequest) Execute() (*PostCompRedemptionsRS, *http.Response, error) {
	return r.ApiService.PostCompRedemptionsExecute(r)
}

/*
PostCompRedemptions Operation to post complimentary redemptions for a guest having PTS Membership Type

You can use this API to post complimentary redemptions for a guest having PTS Membership Type <p><strong>OperationId:</strong>postCompRedemptions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param membershipId Membership number of the guest in the reservation
 @param hotelId Unique ID of the hotel
 @return CashieringApiPostCompRedemptionsRequest
*/
func (a *CashieringApiService) PostCompRedemptions(ctx context.Context, membershipId string, hotelId string) CashieringApiPostCompRedemptionsRequest {
	return CashieringApiPostCompRedemptionsRequest{
		ApiService: a,
		ctx: ctx,
		membershipId: membershipId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return PostCompRedemptionsRS
func (a *CashieringApiService) PostCompRedemptionsExecute(r CashieringApiPostCompRedemptionsRequest) (*PostCompRedemptionsRS, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PostCompRedemptionsRS
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.PostCompRedemptions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/memberships/{membershipId}/compRedemptionPostings"
	localVarPath = strings.Replace(localVarPath, "{"+"membershipId"+"}", url.PathEscape(parameterValueToString(r.membershipId, "membershipId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.membershipId) < 1 {
		return localVarReturnValue, nil, reportError("membershipId must have at least 1 elements")
	}
	if strlen(r.membershipId) > 2000 {
		return localVarReturnValue, nil, reportError("membershipId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 20 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 20 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.postCompRedemptions
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringApiReverseCompPostingsRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	hotelId string
	authorization *string
	xAppKey *string
	postings *ApproveCompPostingsRequest
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringApiReverseCompPostingsRequest) Authorization(authorization string) CashieringApiReverseCompPostingsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner??????s Application Key
func (r CashieringApiReverseCompPostingsRequest) XAppKey(xAppKey string) CashieringApiReverseCompPostingsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Request object for comp postings reversal to be sent to the gaming system.
func (r CashieringApiReverseCompPostingsRequest) Postings(postings ApproveCompPostingsRequest) CashieringApiReverseCompPostingsRequest {
	r.postings = &postings
	return r
}

// Language code
func (r CashieringApiReverseCompPostingsRequest) AcceptLanguage(acceptLanguage string) CashieringApiReverseCompPostingsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringApiReverseCompPostingsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.ReverseCompPostingsExecute(r)
}

/*
ReverseCompPostings Operation to request for comp postings reversal.

You can use this API to reverse Comp Transactions. <p><strong>OperationId:</strong>reverseCompPostings</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return CashieringApiReverseCompPostingsRequest
*/
func (a *CashieringApiService) ReverseCompPostings(ctx context.Context, hotelId string) CashieringApiReverseCompPostingsRequest {
	return CashieringApiReverseCompPostingsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringApiService) ReverseCompPostingsExecute(r CashieringApiReverseCompPostingsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.ReverseCompPostings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/compPostingsReversal"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.postings
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringApiReverseCompRedemptionsRequest struct {
	ctx context.Context
	ApiService *CashieringApiService
	membershipId string
	hotelId string
	authorization *string
	xAppKey *string
	reverseCompRedemptions *ReverseCompRedemptionsRequest
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringApiReverseCompRedemptionsRequest) Authorization(authorization string) CashieringApiReverseCompRedemptionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner??????s Application Key
func (r CashieringApiReverseCompRedemptionsRequest) XAppKey(xAppKey string) CashieringApiReverseCompRedemptionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Request type of Complimentary Redemptions reversal.
func (r CashieringApiReverseCompRedemptionsRequest) ReverseCompRedemptions(reverseCompRedemptions ReverseCompRedemptionsRequest) CashieringApiReverseCompRedemptionsRequest {
	r.reverseCompRedemptions = &reverseCompRedemptions
	return r
}

// Language code
func (r CashieringApiReverseCompRedemptionsRequest) AcceptLanguage(acceptLanguage string) CashieringApiReverseCompRedemptionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringApiReverseCompRedemptionsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.ReverseCompRedemptionsExecute(r)
}

/*
ReverseCompRedemptions Operation to reverse complimentary redemptions for a guest having PTS Membership Type

You can use this API to reverse complimentary redemptions for a guest having PTS Membership Type <p><strong>OperationId:</strong>reverseCompRedemptions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param membershipId Membership number of the guest in the reservation
 @param hotelId Unique ID of the hotel
 @return CashieringApiReverseCompRedemptionsRequest
*/
func (a *CashieringApiService) ReverseCompRedemptions(ctx context.Context, membershipId string, hotelId string) CashieringApiReverseCompRedemptionsRequest {
	return CashieringApiReverseCompRedemptionsRequest{
		ApiService: a,
		ctx: ctx,
		membershipId: membershipId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringApiService) ReverseCompRedemptionsExecute(r CashieringApiReverseCompRedemptionsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringApiService.ReverseCompRedemptions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/memberships/{membershipId}/compRedemptionReversals"
	localVarPath = strings.Replace(localVarPath, "{"+"membershipId"+"}", url.PathEscape(parameterValueToString(r.membershipId, "membershipId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.membershipId) < 1 {
		return localVarReturnValue, nil, reportError("membershipId must have at least 1 elements")
	}
	if strlen(r.membershipId) > 2000 {
		return localVarReturnValue, nil, reportError("membershipId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 20 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 20 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.reverseCompRedemptions
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
