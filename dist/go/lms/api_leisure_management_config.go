/*
OPERA Cloud Leisure Management API

APIs to cater for external Leisure Management functionality integrated with OPERA Cloud.<br /><br /> Compatible with OPERA Cloud release 23.2.<br /><br /><p> This document and all content within is available under the Universal Permissive License v 1.0 (https://oss.oracle.com/licenses/upl). Copyright (c) 2020, 2023 Oracle and/or its affiliates.</p>

API version: 23.2
Contact: hospitality-integrations_ww@oracle.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package lms

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// LeisureManagementConfigAPIService LeisureManagementConfigAPI service
type LeisureManagementConfigAPIService service

type LeisureManagementConfigAPICopyActivityLocationsRequest struct {
	ctx context.Context
	ApiService *LeisureManagementConfigAPIService
	activityLocationsId string
	authorization *string
	xAppKey *string
	xHotelid *string
	copyActivityLocations *CopyActivityLocations
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LeisureManagementConfigAPICopyActivityLocationsRequest) Authorization(authorization string) LeisureManagementConfigAPICopyActivityLocationsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r LeisureManagementConfigAPICopyActivityLocationsRequest) XAppKey(xAppKey string) LeisureManagementConfigAPICopyActivityLocationsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LeisureManagementConfigAPICopyActivityLocationsRequest) XHotelid(xHotelid string) LeisureManagementConfigAPICopyActivityLocationsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for copying Activity Locations to hotel(s).
func (r LeisureManagementConfigAPICopyActivityLocationsRequest) CopyActivityLocations(copyActivityLocations CopyActivityLocations) LeisureManagementConfigAPICopyActivityLocationsRequest {
	r.copyActivityLocations = &copyActivityLocations
	return r
}

// External system code.
func (r LeisureManagementConfigAPICopyActivityLocationsRequest) XExternalsystem(xExternalsystem string) LeisureManagementConfigAPICopyActivityLocationsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LeisureManagementConfigAPICopyActivityLocationsRequest) AcceptLanguage(acceptLanguage string) LeisureManagementConfigAPICopyActivityLocationsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LeisureManagementConfigAPICopyActivityLocationsRequest) Execute() (*CopyActivityLocationsRS, *http.Response, error) {
	return r.ApiService.CopyActivityLocationsExecute(r)
}

/*
CopyActivityLocations Copy Activity Locations

Use this API to copy an Activity location for a property. <p><strong>OperationId:</strong>copyActivityLocations</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param activityLocationsId OPERA Source Activity locations id
 @return LeisureManagementConfigAPICopyActivityLocationsRequest
*/
func (a *LeisureManagementConfigAPIService) CopyActivityLocations(ctx context.Context, activityLocationsId string) LeisureManagementConfigAPICopyActivityLocationsRequest {
	return LeisureManagementConfigAPICopyActivityLocationsRequest{
		ApiService: a,
		ctx: ctx,
		activityLocationsId: activityLocationsId,
	}
}

// Execute executes the request
//  @return CopyActivityLocationsRS
func (a *LeisureManagementConfigAPIService) CopyActivityLocationsExecute(r LeisureManagementConfigAPICopyActivityLocationsRequest) (*CopyActivityLocationsRS, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CopyActivityLocationsRS
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LeisureManagementConfigAPIService.CopyActivityLocations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/activityLocations/{activityLocationsId}/copy"
	localVarPath = strings.Replace(localVarPath, "{"+"activityLocationsId"+"}", url.PathEscape(parameterValueToString(r.activityLocationsId, "activityLocationsId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.activityLocationsId) < 1 {
		return localVarReturnValue, nil, reportError("activityLocationsId must have at least 1 elements")
	}
	if strlen(r.activityLocationsId) > 2000 {
		return localVarReturnValue, nil, reportError("activityLocationsId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.copyActivityLocations
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LeisureManagementConfigAPICopyActivityTypesRequest struct {
	ctx context.Context
	ApiService *LeisureManagementConfigAPIService
	activityTypesId string
	authorization *string
	xAppKey *string
	xHotelid *string
	copyActivityTypes *CopyActivityTypes
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LeisureManagementConfigAPICopyActivityTypesRequest) Authorization(authorization string) LeisureManagementConfigAPICopyActivityTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r LeisureManagementConfigAPICopyActivityTypesRequest) XAppKey(xAppKey string) LeisureManagementConfigAPICopyActivityTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LeisureManagementConfigAPICopyActivityTypesRequest) XHotelid(xHotelid string) LeisureManagementConfigAPICopyActivityTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for copying Activity Types to hotel(s).
func (r LeisureManagementConfigAPICopyActivityTypesRequest) CopyActivityTypes(copyActivityTypes CopyActivityTypes) LeisureManagementConfigAPICopyActivityTypesRequest {
	r.copyActivityTypes = &copyActivityTypes
	return r
}

// External system code.
func (r LeisureManagementConfigAPICopyActivityTypesRequest) XExternalsystem(xExternalsystem string) LeisureManagementConfigAPICopyActivityTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LeisureManagementConfigAPICopyActivityTypesRequest) AcceptLanguage(acceptLanguage string) LeisureManagementConfigAPICopyActivityTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LeisureManagementConfigAPICopyActivityTypesRequest) Execute() (*CopyActivityTypesRS, *http.Response, error) {
	return r.ApiService.CopyActivityTypesExecute(r)
}

/*
CopyActivityTypes Copy Activity Types

Copy existing Activity Types from source property to target properties. <p><strong>OperationId:</strong>copyActivityTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param activityTypesId OPERA Activity types id
 @return LeisureManagementConfigAPICopyActivityTypesRequest
*/
func (a *LeisureManagementConfigAPIService) CopyActivityTypes(ctx context.Context, activityTypesId string) LeisureManagementConfigAPICopyActivityTypesRequest {
	return LeisureManagementConfigAPICopyActivityTypesRequest{
		ApiService: a,
		ctx: ctx,
		activityTypesId: activityTypesId,
	}
}

// Execute executes the request
//  @return CopyActivityTypesRS
func (a *LeisureManagementConfigAPIService) CopyActivityTypesExecute(r LeisureManagementConfigAPICopyActivityTypesRequest) (*CopyActivityTypesRS, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CopyActivityTypesRS
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LeisureManagementConfigAPIService.CopyActivityTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/activityTypes/{activityTypesId}/copy"
	localVarPath = strings.Replace(localVarPath, "{"+"activityTypesId"+"}", url.PathEscape(parameterValueToString(r.activityTypesId, "activityTypesId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.activityTypesId) < 1 {
		return localVarReturnValue, nil, reportError("activityTypesId must have at least 1 elements")
	}
	if strlen(r.activityTypesId) > 2000 {
		return localVarReturnValue, nil, reportError("activityTypesId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.copyActivityTypes
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LeisureManagementConfigAPIDeleteActivityLocationsRequest struct {
	ctx context.Context
	ApiService *LeisureManagementConfigAPIService
	activityLocationsId string
	hotelIds *string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Hotel where the code is configured.
func (r LeisureManagementConfigAPIDeleteActivityLocationsRequest) HotelIds(hotelIds string) LeisureManagementConfigAPIDeleteActivityLocationsRequest {
	r.hotelIds = &hotelIds
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LeisureManagementConfigAPIDeleteActivityLocationsRequest) Authorization(authorization string) LeisureManagementConfigAPIDeleteActivityLocationsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r LeisureManagementConfigAPIDeleteActivityLocationsRequest) XAppKey(xAppKey string) LeisureManagementConfigAPIDeleteActivityLocationsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LeisureManagementConfigAPIDeleteActivityLocationsRequest) XHotelid(xHotelid string) LeisureManagementConfigAPIDeleteActivityLocationsRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r LeisureManagementConfigAPIDeleteActivityLocationsRequest) XExternalsystem(xExternalsystem string) LeisureManagementConfigAPIDeleteActivityLocationsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LeisureManagementConfigAPIDeleteActivityLocationsRequest) AcceptLanguage(acceptLanguage string) LeisureManagementConfigAPIDeleteActivityLocationsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LeisureManagementConfigAPIDeleteActivityLocationsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteActivityLocationsExecute(r)
}

/*
DeleteActivityLocations Remove Activity Locations

Use this API to delete an Activity location for a property. <p><strong>OperationId:</strong>deleteActivityLocations</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param activityLocationsId OPERA Activity locations id
 @return LeisureManagementConfigAPIDeleteActivityLocationsRequest
*/
func (a *LeisureManagementConfigAPIService) DeleteActivityLocations(ctx context.Context, activityLocationsId string) LeisureManagementConfigAPIDeleteActivityLocationsRequest {
	return LeisureManagementConfigAPIDeleteActivityLocationsRequest{
		ApiService: a,
		ctx: ctx,
		activityLocationsId: activityLocationsId,
	}
}

// Execute executes the request
//  @return Status
func (a *LeisureManagementConfigAPIService) DeleteActivityLocationsExecute(r LeisureManagementConfigAPIDeleteActivityLocationsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LeisureManagementConfigAPIService.DeleteActivityLocations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/activityLocations/{activityLocationsId}"
	localVarPath = strings.Replace(localVarPath, "{"+"activityLocationsId"+"}", url.PathEscape(parameterValueToString(r.activityLocationsId, "activityLocationsId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.activityLocationsId) < 1 {
		return localVarReturnValue, nil, reportError("activityLocationsId must have at least 1 elements")
	}
	if strlen(r.activityLocationsId) > 2000 {
		return localVarReturnValue, nil, reportError("activityLocationsId must have less than 2000 elements")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", r.hotelIds, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LeisureManagementConfigAPIDeleteActivityStatusCodesRequest struct {
	ctx context.Context
	ApiService *LeisureManagementConfigAPIService
	activityStatusCodesId string
	hotelIds *string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Hotel where the code is configured.
func (r LeisureManagementConfigAPIDeleteActivityStatusCodesRequest) HotelIds(hotelIds string) LeisureManagementConfigAPIDeleteActivityStatusCodesRequest {
	r.hotelIds = &hotelIds
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LeisureManagementConfigAPIDeleteActivityStatusCodesRequest) Authorization(authorization string) LeisureManagementConfigAPIDeleteActivityStatusCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r LeisureManagementConfigAPIDeleteActivityStatusCodesRequest) XAppKey(xAppKey string) LeisureManagementConfigAPIDeleteActivityStatusCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LeisureManagementConfigAPIDeleteActivityStatusCodesRequest) XHotelid(xHotelid string) LeisureManagementConfigAPIDeleteActivityStatusCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r LeisureManagementConfigAPIDeleteActivityStatusCodesRequest) XExternalsystem(xExternalsystem string) LeisureManagementConfigAPIDeleteActivityStatusCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LeisureManagementConfigAPIDeleteActivityStatusCodesRequest) AcceptLanguage(acceptLanguage string) LeisureManagementConfigAPIDeleteActivityStatusCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LeisureManagementConfigAPIDeleteActivityStatusCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteActivityStatusCodesExecute(r)
}

/*
DeleteActivityStatusCodes Remove Activity Status Code

Remove an Activity Status Code that is configured for a property.  <p><strong>OperationId:</strong>deleteActivityStatusCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param activityStatusCodesId OPERA Activity status codes
 @return LeisureManagementConfigAPIDeleteActivityStatusCodesRequest
*/
func (a *LeisureManagementConfigAPIService) DeleteActivityStatusCodes(ctx context.Context, activityStatusCodesId string) LeisureManagementConfigAPIDeleteActivityStatusCodesRequest {
	return LeisureManagementConfigAPIDeleteActivityStatusCodesRequest{
		ApiService: a,
		ctx: ctx,
		activityStatusCodesId: activityStatusCodesId,
	}
}

// Execute executes the request
//  @return Status
func (a *LeisureManagementConfigAPIService) DeleteActivityStatusCodesExecute(r LeisureManagementConfigAPIDeleteActivityStatusCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LeisureManagementConfigAPIService.DeleteActivityStatusCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/activityStatusCodes/{activityStatusCodesId}"
	localVarPath = strings.Replace(localVarPath, "{"+"activityStatusCodesId"+"}", url.PathEscape(parameterValueToString(r.activityStatusCodesId, "activityStatusCodesId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.activityStatusCodesId) < 1 {
		return localVarReturnValue, nil, reportError("activityStatusCodesId must have at least 1 elements")
	}
	if strlen(r.activityStatusCodesId) > 2000 {
		return localVarReturnValue, nil, reportError("activityStatusCodesId must have less than 2000 elements")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", r.hotelIds, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LeisureManagementConfigAPIDeleteActivityTypesRequest struct {
	ctx context.Context
	ApiService *LeisureManagementConfigAPIService
	activityTypesId string
	hotelIds *string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Hotel where the code is configured.
func (r LeisureManagementConfigAPIDeleteActivityTypesRequest) HotelIds(hotelIds string) LeisureManagementConfigAPIDeleteActivityTypesRequest {
	r.hotelIds = &hotelIds
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LeisureManagementConfigAPIDeleteActivityTypesRequest) Authorization(authorization string) LeisureManagementConfigAPIDeleteActivityTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r LeisureManagementConfigAPIDeleteActivityTypesRequest) XAppKey(xAppKey string) LeisureManagementConfigAPIDeleteActivityTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LeisureManagementConfigAPIDeleteActivityTypesRequest) XHotelid(xHotelid string) LeisureManagementConfigAPIDeleteActivityTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r LeisureManagementConfigAPIDeleteActivityTypesRequest) XExternalsystem(xExternalsystem string) LeisureManagementConfigAPIDeleteActivityTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LeisureManagementConfigAPIDeleteActivityTypesRequest) AcceptLanguage(acceptLanguage string) LeisureManagementConfigAPIDeleteActivityTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LeisureManagementConfigAPIDeleteActivityTypesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteActivityTypesExecute(r)
}

/*
DeleteActivityTypes Remove Activity Types

Delete an Activity Type Code that is configured for a property. <p><strong>OperationId:</strong>deleteActivityTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param activityTypesId OPERA Activity types id
 @return LeisureManagementConfigAPIDeleteActivityTypesRequest
*/
func (a *LeisureManagementConfigAPIService) DeleteActivityTypes(ctx context.Context, activityTypesId string) LeisureManagementConfigAPIDeleteActivityTypesRequest {
	return LeisureManagementConfigAPIDeleteActivityTypesRequest{
		ApiService: a,
		ctx: ctx,
		activityTypesId: activityTypesId,
	}
}

// Execute executes the request
//  @return Status
func (a *LeisureManagementConfigAPIService) DeleteActivityTypesExecute(r LeisureManagementConfigAPIDeleteActivityTypesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LeisureManagementConfigAPIService.DeleteActivityTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/activityTypes/{activityTypesId}"
	localVarPath = strings.Replace(localVarPath, "{"+"activityTypesId"+"}", url.PathEscape(parameterValueToString(r.activityTypesId, "activityTypesId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.activityTypesId) < 1 {
		return localVarReturnValue, nil, reportError("activityTypesId must have at least 1 elements")
	}
	if strlen(r.activityTypesId) > 2000 {
		return localVarReturnValue, nil, reportError("activityTypesId must have less than 2000 elements")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", r.hotelIds, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LeisureManagementConfigAPIGetActivityLocationsRequest struct {
	ctx context.Context
	ApiService *LeisureManagementConfigAPIService
	hotelIds *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	criteriaCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

func (r LeisureManagementConfigAPIGetActivityLocationsRequest) HotelIds(hotelIds []string) LeisureManagementConfigAPIGetActivityLocationsRequest {
	r.hotelIds = &hotelIds
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LeisureManagementConfigAPIGetActivityLocationsRequest) Authorization(authorization string) LeisureManagementConfigAPIGetActivityLocationsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r LeisureManagementConfigAPIGetActivityLocationsRequest) XAppKey(xAppKey string) LeisureManagementConfigAPIGetActivityLocationsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LeisureManagementConfigAPIGetActivityLocationsRequest) XHotelid(xHotelid string) LeisureManagementConfigAPIGetActivityLocationsRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r LeisureManagementConfigAPIGetActivityLocationsRequest) CriteriaCodes(criteriaCodes []string) LeisureManagementConfigAPIGetActivityLocationsRequest {
	r.criteriaCodes = &criteriaCodes
	return r
}

// External system code.
func (r LeisureManagementConfigAPIGetActivityLocationsRequest) XExternalsystem(xExternalsystem string) LeisureManagementConfigAPIGetActivityLocationsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LeisureManagementConfigAPIGetActivityLocationsRequest) AcceptLanguage(acceptLanguage string) LeisureManagementConfigAPIGetActivityLocationsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LeisureManagementConfigAPIGetActivityLocationsRequest) Execute() (*FetchActivityLocations, *http.Response, error) {
	return r.ApiService.GetActivityLocationsExecute(r)
}

/*
GetActivityLocations Look up of Activity Locations

Use this API to fetch Activity location codes for a property. <p><strong>OperationId:</strong>getActivityLocations</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LeisureManagementConfigAPIGetActivityLocationsRequest
*/
func (a *LeisureManagementConfigAPIService) GetActivityLocations(ctx context.Context) LeisureManagementConfigAPIGetActivityLocationsRequest {
	return LeisureManagementConfigAPIGetActivityLocationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FetchActivityLocations
func (a *LeisureManagementConfigAPIService) GetActivityLocationsExecute(r LeisureManagementConfigAPIGetActivityLocationsRequest) (*FetchActivityLocations, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FetchActivityLocations
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LeisureManagementConfigAPIService.GetActivityLocations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/activityLocations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	{
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.criteriaCodes != nil {
		t := *r.criteriaCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "criteriaCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "criteriaCodes", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LeisureManagementConfigAPIGetActivityStatusCodesRequest struct {
	ctx context.Context
	ApiService *LeisureManagementConfigAPIService
	hotelIds *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	criteriaCodes *[]string
	applicationCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

func (r LeisureManagementConfigAPIGetActivityStatusCodesRequest) HotelIds(hotelIds []string) LeisureManagementConfigAPIGetActivityStatusCodesRequest {
	r.hotelIds = &hotelIds
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LeisureManagementConfigAPIGetActivityStatusCodesRequest) Authorization(authorization string) LeisureManagementConfigAPIGetActivityStatusCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r LeisureManagementConfigAPIGetActivityStatusCodesRequest) XAppKey(xAppKey string) LeisureManagementConfigAPIGetActivityStatusCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LeisureManagementConfigAPIGetActivityStatusCodesRequest) XHotelid(xHotelid string) LeisureManagementConfigAPIGetActivityStatusCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r LeisureManagementConfigAPIGetActivityStatusCodesRequest) CriteriaCodes(criteriaCodes []string) LeisureManagementConfigAPIGetActivityStatusCodesRequest {
	r.criteriaCodes = &criteriaCodes
	return r
}

func (r LeisureManagementConfigAPIGetActivityStatusCodesRequest) ApplicationCodes(applicationCodes []string) LeisureManagementConfigAPIGetActivityStatusCodesRequest {
	r.applicationCodes = &applicationCodes
	return r
}

// External system code.
func (r LeisureManagementConfigAPIGetActivityStatusCodesRequest) XExternalsystem(xExternalsystem string) LeisureManagementConfigAPIGetActivityStatusCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LeisureManagementConfigAPIGetActivityStatusCodesRequest) AcceptLanguage(acceptLanguage string) LeisureManagementConfigAPIGetActivityStatusCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LeisureManagementConfigAPIGetActivityStatusCodesRequest) Execute() (*FetchActivityStatusCodes, *http.Response, error) {
	return r.ApiService.GetActivityStatusCodesExecute(r)
}

/*
GetActivityStatusCodes Get Activity Status Codes

Fetch Activity Status Codes that are configured for a property.  <p><strong>OperationId:</strong>getActivityStatusCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LeisureManagementConfigAPIGetActivityStatusCodesRequest
*/
func (a *LeisureManagementConfigAPIService) GetActivityStatusCodes(ctx context.Context) LeisureManagementConfigAPIGetActivityStatusCodesRequest {
	return LeisureManagementConfigAPIGetActivityStatusCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FetchActivityStatusCodes
func (a *LeisureManagementConfigAPIService) GetActivityStatusCodesExecute(r LeisureManagementConfigAPIGetActivityStatusCodesRequest) (*FetchActivityStatusCodes, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FetchActivityStatusCodes
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LeisureManagementConfigAPIService.GetActivityStatusCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/activityStatusCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	{
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.criteriaCodes != nil {
		t := *r.criteriaCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "criteriaCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "criteriaCodes", t, "multi")
		}
  }
	if r.applicationCodes != nil {
		t := *r.applicationCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "applicationCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "applicationCodes", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LeisureManagementConfigAPIGetActivityTypesRequest struct {
	ctx context.Context
	ApiService *LeisureManagementConfigAPIService
	hotelIds *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	typeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

func (r LeisureManagementConfigAPIGetActivityTypesRequest) HotelIds(hotelIds []string) LeisureManagementConfigAPIGetActivityTypesRequest {
	r.hotelIds = &hotelIds
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LeisureManagementConfigAPIGetActivityTypesRequest) Authorization(authorization string) LeisureManagementConfigAPIGetActivityTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r LeisureManagementConfigAPIGetActivityTypesRequest) XAppKey(xAppKey string) LeisureManagementConfigAPIGetActivityTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LeisureManagementConfigAPIGetActivityTypesRequest) XHotelid(xHotelid string) LeisureManagementConfigAPIGetActivityTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r LeisureManagementConfigAPIGetActivityTypesRequest) TypeCodes(typeCodes []string) LeisureManagementConfigAPIGetActivityTypesRequest {
	r.typeCodes = &typeCodes
	return r
}

// External system code.
func (r LeisureManagementConfigAPIGetActivityTypesRequest) XExternalsystem(xExternalsystem string) LeisureManagementConfigAPIGetActivityTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LeisureManagementConfigAPIGetActivityTypesRequest) AcceptLanguage(acceptLanguage string) LeisureManagementConfigAPIGetActivityTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LeisureManagementConfigAPIGetActivityTypesRequest) Execute() (*FetchActivityTypes, *http.Response, error) {
	return r.ApiService.GetActivityTypesExecute(r)
}

/*
GetActivityTypes Fetch Activity Types

Retrieve Activity Types that are configured for a property.  Activity Types are typically used when an EAS (External Activities Scheduler system) interface is connected to OPERA.   <p><strong>OperationId:</strong>getActivityTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LeisureManagementConfigAPIGetActivityTypesRequest
*/
func (a *LeisureManagementConfigAPIService) GetActivityTypes(ctx context.Context) LeisureManagementConfigAPIGetActivityTypesRequest {
	return LeisureManagementConfigAPIGetActivityTypesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FetchActivityTypes
func (a *LeisureManagementConfigAPIService) GetActivityTypesExecute(r LeisureManagementConfigAPIGetActivityTypesRequest) (*FetchActivityTypes, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FetchActivityTypes
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LeisureManagementConfigAPIService.GetActivityTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/activityTypes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	{
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.typeCodes != nil {
		t := *r.typeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "typeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "typeCodes", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LeisureManagementConfigAPIPostActivityLocationsRequest struct {
	ctx context.Context
	ApiService *LeisureManagementConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	createActivityLocations *CreateActivityLocations
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LeisureManagementConfigAPIPostActivityLocationsRequest) Authorization(authorization string) LeisureManagementConfigAPIPostActivityLocationsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r LeisureManagementConfigAPIPostActivityLocationsRequest) XAppKey(xAppKey string) LeisureManagementConfigAPIPostActivityLocationsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LeisureManagementConfigAPIPostActivityLocationsRequest) XHotelid(xHotelid string) LeisureManagementConfigAPIPostActivityLocationsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating Activity Locations.
func (r LeisureManagementConfigAPIPostActivityLocationsRequest) CreateActivityLocations(createActivityLocations CreateActivityLocations) LeisureManagementConfigAPIPostActivityLocationsRequest {
	r.createActivityLocations = &createActivityLocations
	return r
}

// External system code.
func (r LeisureManagementConfigAPIPostActivityLocationsRequest) XExternalsystem(xExternalsystem string) LeisureManagementConfigAPIPostActivityLocationsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LeisureManagementConfigAPIPostActivityLocationsRequest) AcceptLanguage(acceptLanguage string) LeisureManagementConfigAPIPostActivityLocationsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LeisureManagementConfigAPIPostActivityLocationsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostActivityLocationsExecute(r)
}

/*
PostActivityLocations Create an Activity Locations

Use this API to create a new Activity location for a property. <p><strong>OperationId:</strong>postActivityLocations</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LeisureManagementConfigAPIPostActivityLocationsRequest
*/
func (a *LeisureManagementConfigAPIService) PostActivityLocations(ctx context.Context) LeisureManagementConfigAPIPostActivityLocationsRequest {
	return LeisureManagementConfigAPIPostActivityLocationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *LeisureManagementConfigAPIService) PostActivityLocationsExecute(r LeisureManagementConfigAPIPostActivityLocationsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LeisureManagementConfigAPIService.PostActivityLocations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/activityLocations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.createActivityLocations
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LeisureManagementConfigAPIPostActivityStatusCodesRequest struct {
	ctx context.Context
	ApiService *LeisureManagementConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	createActivityStatusCodes *CreateActivityStatusCodes
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LeisureManagementConfigAPIPostActivityStatusCodesRequest) Authorization(authorization string) LeisureManagementConfigAPIPostActivityStatusCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r LeisureManagementConfigAPIPostActivityStatusCodesRequest) XAppKey(xAppKey string) LeisureManagementConfigAPIPostActivityStatusCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LeisureManagementConfigAPIPostActivityStatusCodesRequest) XHotelid(xHotelid string) LeisureManagementConfigAPIPostActivityStatusCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating Activity Status Codes.
func (r LeisureManagementConfigAPIPostActivityStatusCodesRequest) CreateActivityStatusCodes(createActivityStatusCodes CreateActivityStatusCodes) LeisureManagementConfigAPIPostActivityStatusCodesRequest {
	r.createActivityStatusCodes = &createActivityStatusCodes
	return r
}

// External system code.
func (r LeisureManagementConfigAPIPostActivityStatusCodesRequest) XExternalsystem(xExternalsystem string) LeisureManagementConfigAPIPostActivityStatusCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LeisureManagementConfigAPIPostActivityStatusCodesRequest) AcceptLanguage(acceptLanguage string) LeisureManagementConfigAPIPostActivityStatusCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LeisureManagementConfigAPIPostActivityStatusCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostActivityStatusCodesExecute(r)
}

/*
PostActivityStatusCodes Create Activity Status Code

Retrieve Activity Status Code that are configured for a property.  Activity Status Codes are typically used when an EAS (External Activities Scheduler system) interface is connected to OPERA.   <p><strong>OperationId:</strong>postActivityStatusCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LeisureManagementConfigAPIPostActivityStatusCodesRequest
*/
func (a *LeisureManagementConfigAPIService) PostActivityStatusCodes(ctx context.Context) LeisureManagementConfigAPIPostActivityStatusCodesRequest {
	return LeisureManagementConfigAPIPostActivityStatusCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *LeisureManagementConfigAPIService) PostActivityStatusCodesExecute(r LeisureManagementConfigAPIPostActivityStatusCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LeisureManagementConfigAPIService.PostActivityStatusCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/activityStatusCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.createActivityStatusCodes
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LeisureManagementConfigAPIPostActivityTypesRequest struct {
	ctx context.Context
	ApiService *LeisureManagementConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	createActivityTypes *CreateActivityTypes
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LeisureManagementConfigAPIPostActivityTypesRequest) Authorization(authorization string) LeisureManagementConfigAPIPostActivityTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r LeisureManagementConfigAPIPostActivityTypesRequest) XAppKey(xAppKey string) LeisureManagementConfigAPIPostActivityTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LeisureManagementConfigAPIPostActivityTypesRequest) XHotelid(xHotelid string) LeisureManagementConfigAPIPostActivityTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating Activity Types.
func (r LeisureManagementConfigAPIPostActivityTypesRequest) CreateActivityTypes(createActivityTypes CreateActivityTypes) LeisureManagementConfigAPIPostActivityTypesRequest {
	r.createActivityTypes = &createActivityTypes
	return r
}

// External system code.
func (r LeisureManagementConfigAPIPostActivityTypesRequest) XExternalsystem(xExternalsystem string) LeisureManagementConfigAPIPostActivityTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LeisureManagementConfigAPIPostActivityTypesRequest) AcceptLanguage(acceptLanguage string) LeisureManagementConfigAPIPostActivityTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LeisureManagementConfigAPIPostActivityTypesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostActivityTypesExecute(r)
}

/*
PostActivityTypes Create Activity Types

Create a new Activity Type Code for a specific property. <p><strong>OperationId:</strong>postActivityTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LeisureManagementConfigAPIPostActivityTypesRequest
*/
func (a *LeisureManagementConfigAPIService) PostActivityTypes(ctx context.Context) LeisureManagementConfigAPIPostActivityTypesRequest {
	return LeisureManagementConfigAPIPostActivityTypesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *LeisureManagementConfigAPIService) PostActivityTypesExecute(r LeisureManagementConfigAPIPostActivityTypesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LeisureManagementConfigAPIService.PostActivityTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/activityTypes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.createActivityTypes
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LeisureManagementConfigAPIPutActivityLocationsRequest struct {
	ctx context.Context
	ApiService *LeisureManagementConfigAPIService
	activityLocationsId string
	authorization *string
	xAppKey *string
	xHotelid *string
	changeActivityLocations *ChangeActivityLocations
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LeisureManagementConfigAPIPutActivityLocationsRequest) Authorization(authorization string) LeisureManagementConfigAPIPutActivityLocationsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r LeisureManagementConfigAPIPutActivityLocationsRequest) XAppKey(xAppKey string) LeisureManagementConfigAPIPutActivityLocationsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LeisureManagementConfigAPIPutActivityLocationsRequest) XHotelid(xHotelid string) LeisureManagementConfigAPIPutActivityLocationsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing Activity Locations.
func (r LeisureManagementConfigAPIPutActivityLocationsRequest) ChangeActivityLocations(changeActivityLocations ChangeActivityLocations) LeisureManagementConfigAPIPutActivityLocationsRequest {
	r.changeActivityLocations = &changeActivityLocations
	return r
}

// External system code.
func (r LeisureManagementConfigAPIPutActivityLocationsRequest) XExternalsystem(xExternalsystem string) LeisureManagementConfigAPIPutActivityLocationsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LeisureManagementConfigAPIPutActivityLocationsRequest) AcceptLanguage(acceptLanguage string) LeisureManagementConfigAPIPutActivityLocationsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LeisureManagementConfigAPIPutActivityLocationsRequest) Execute() (*ChangeActivityLocationsRS, *http.Response, error) {
	return r.ApiService.PutActivityLocationsExecute(r)
}

/*
PutActivityLocations Change in Activity Locations

Use this API to update an existing Activity location Code for a property. <p><strong>OperationId:</strong>putActivityLocations</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param activityLocationsId OPERA Activity locations id
 @return LeisureManagementConfigAPIPutActivityLocationsRequest
*/
func (a *LeisureManagementConfigAPIService) PutActivityLocations(ctx context.Context, activityLocationsId string) LeisureManagementConfigAPIPutActivityLocationsRequest {
	return LeisureManagementConfigAPIPutActivityLocationsRequest{
		ApiService: a,
		ctx: ctx,
		activityLocationsId: activityLocationsId,
	}
}

// Execute executes the request
//  @return ChangeActivityLocationsRS
func (a *LeisureManagementConfigAPIService) PutActivityLocationsExecute(r LeisureManagementConfigAPIPutActivityLocationsRequest) (*ChangeActivityLocationsRS, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChangeActivityLocationsRS
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LeisureManagementConfigAPIService.PutActivityLocations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/activityLocations/{activityLocationsId}"
	localVarPath = strings.Replace(localVarPath, "{"+"activityLocationsId"+"}", url.PathEscape(parameterValueToString(r.activityLocationsId, "activityLocationsId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.activityLocationsId) < 1 {
		return localVarReturnValue, nil, reportError("activityLocationsId must have at least 1 elements")
	}
	if strlen(r.activityLocationsId) > 2000 {
		return localVarReturnValue, nil, reportError("activityLocationsId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.changeActivityLocations
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LeisureManagementConfigAPIPutActivityStatusCodesRequest struct {
	ctx context.Context
	ApiService *LeisureManagementConfigAPIService
	activityStatusCodesId string
	authorization *string
	xAppKey *string
	xHotelid *string
	changeActivityStatusCodes *ChangeActivityStatusCodes
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LeisureManagementConfigAPIPutActivityStatusCodesRequest) Authorization(authorization string) LeisureManagementConfigAPIPutActivityStatusCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r LeisureManagementConfigAPIPutActivityStatusCodesRequest) XAppKey(xAppKey string) LeisureManagementConfigAPIPutActivityStatusCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LeisureManagementConfigAPIPutActivityStatusCodesRequest) XHotelid(xHotelid string) LeisureManagementConfigAPIPutActivityStatusCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing Activity Status Codes.
func (r LeisureManagementConfigAPIPutActivityStatusCodesRequest) ChangeActivityStatusCodes(changeActivityStatusCodes ChangeActivityStatusCodes) LeisureManagementConfigAPIPutActivityStatusCodesRequest {
	r.changeActivityStatusCodes = &changeActivityStatusCodes
	return r
}

// External system code.
func (r LeisureManagementConfigAPIPutActivityStatusCodesRequest) XExternalsystem(xExternalsystem string) LeisureManagementConfigAPIPutActivityStatusCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LeisureManagementConfigAPIPutActivityStatusCodesRequest) AcceptLanguage(acceptLanguage string) LeisureManagementConfigAPIPutActivityStatusCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LeisureManagementConfigAPIPutActivityStatusCodesRequest) Execute() (*ChangeActivityStatusCodesRS, *http.Response, error) {
	return r.ApiService.PutActivityStatusCodesExecute(r)
}

/*
PutActivityStatusCodes Change Activity Status Code

Modify an Activity Status Code that is configured for a property.  <p><strong>OperationId:</strong>putActivityStatusCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param activityStatusCodesId OPERA Activity status codes
 @return LeisureManagementConfigAPIPutActivityStatusCodesRequest
*/
func (a *LeisureManagementConfigAPIService) PutActivityStatusCodes(ctx context.Context, activityStatusCodesId string) LeisureManagementConfigAPIPutActivityStatusCodesRequest {
	return LeisureManagementConfigAPIPutActivityStatusCodesRequest{
		ApiService: a,
		ctx: ctx,
		activityStatusCodesId: activityStatusCodesId,
	}
}

// Execute executes the request
//  @return ChangeActivityStatusCodesRS
func (a *LeisureManagementConfigAPIService) PutActivityStatusCodesExecute(r LeisureManagementConfigAPIPutActivityStatusCodesRequest) (*ChangeActivityStatusCodesRS, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChangeActivityStatusCodesRS
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LeisureManagementConfigAPIService.PutActivityStatusCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/activityStatusCodes/{activityStatusCodesId}"
	localVarPath = strings.Replace(localVarPath, "{"+"activityStatusCodesId"+"}", url.PathEscape(parameterValueToString(r.activityStatusCodesId, "activityStatusCodesId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.activityStatusCodesId) < 1 {
		return localVarReturnValue, nil, reportError("activityStatusCodesId must have at least 1 elements")
	}
	if strlen(r.activityStatusCodesId) > 2000 {
		return localVarReturnValue, nil, reportError("activityStatusCodesId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.changeActivityStatusCodes
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LeisureManagementConfigAPIPutActivityTypesRequest struct {
	ctx context.Context
	ApiService *LeisureManagementConfigAPIService
	activityTypesId string
	authorization *string
	xAppKey *string
	xHotelid *string
	changeActivityTypes *ChangeActivityTypes
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LeisureManagementConfigAPIPutActivityTypesRequest) Authorization(authorization string) LeisureManagementConfigAPIPutActivityTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r LeisureManagementConfigAPIPutActivityTypesRequest) XAppKey(xAppKey string) LeisureManagementConfigAPIPutActivityTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LeisureManagementConfigAPIPutActivityTypesRequest) XHotelid(xHotelid string) LeisureManagementConfigAPIPutActivityTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing Activity Types.
func (r LeisureManagementConfigAPIPutActivityTypesRequest) ChangeActivityTypes(changeActivityTypes ChangeActivityTypes) LeisureManagementConfigAPIPutActivityTypesRequest {
	r.changeActivityTypes = &changeActivityTypes
	return r
}

// External system code.
func (r LeisureManagementConfigAPIPutActivityTypesRequest) XExternalsystem(xExternalsystem string) LeisureManagementConfigAPIPutActivityTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LeisureManagementConfigAPIPutActivityTypesRequest) AcceptLanguage(acceptLanguage string) LeisureManagementConfigAPIPutActivityTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LeisureManagementConfigAPIPutActivityTypesRequest) Execute() (*ChangeActivityTypesRS, *http.Response, error) {
	return r.ApiService.PutActivityTypesExecute(r)
}

/*
PutActivityTypes Change Activity Types

Modify an Activity Type Code that is configured for a property. <p><strong>OperationId:</strong>putActivityTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param activityTypesId OPERA Activity types id
 @return LeisureManagementConfigAPIPutActivityTypesRequest
*/
func (a *LeisureManagementConfigAPIService) PutActivityTypes(ctx context.Context, activityTypesId string) LeisureManagementConfigAPIPutActivityTypesRequest {
	return LeisureManagementConfigAPIPutActivityTypesRequest{
		ApiService: a,
		ctx: ctx,
		activityTypesId: activityTypesId,
	}
}

// Execute executes the request
//  @return ChangeActivityTypesRS
func (a *LeisureManagementConfigAPIService) PutActivityTypesExecute(r LeisureManagementConfigAPIPutActivityTypesRequest) (*ChangeActivityTypesRS, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChangeActivityTypesRS
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LeisureManagementConfigAPIService.PutActivityTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/activityTypes/{activityTypesId}"
	localVarPath = strings.Replace(localVarPath, "{"+"activityTypesId"+"}", url.PathEscape(parameterValueToString(r.activityTypesId, "activityTypesId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.activityTypesId) < 1 {
		return localVarReturnValue, nil, reportError("activityTypesId must have at least 1 elements")
	}
	if strlen(r.activityTypesId) > 2000 {
		return localVarReturnValue, nil, reportError("activityTypesId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.changeActivityTypes
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
