/*
OPERA Cloud Leisure Management API

APIs to cater for external Leisure Management functionality integrated with OPERA Cloud.<br /><br /> Compatible with OPERA Cloud release 23.2.<br /><br /><p> This document and all content within is available under the Universal Permissive License v 1.0 (https://oss.oracle.com/licenses/upl). Copyright (c) 2020, 2023 Oracle and/or its affiliates.</p>

API version: 23.2
Contact: hospitality_apis_ww_grp@oracle.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package lms

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// LeisureManagementConfigApiService LeisureManagementConfigApi service
type LeisureManagementConfigApiService service

type LeisureManagementConfigApiCopyActivityLocationsRequest struct {
	ctx context.Context
	ApiService *LeisureManagementConfigApiService
	activityLocationsId string
	authorization *string
	xAppKey *string
	xHotelid *string
	copyActivityLocations *CopyActivityLocationsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LeisureManagementConfigApiCopyActivityLocationsRequest) Authorization(authorization string) LeisureManagementConfigApiCopyActivityLocationsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r LeisureManagementConfigApiCopyActivityLocationsRequest) XAppKey(xAppKey string) LeisureManagementConfigApiCopyActivityLocationsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LeisureManagementConfigApiCopyActivityLocationsRequest) XHotelid(xHotelid string) LeisureManagementConfigApiCopyActivityLocationsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for copying Activity Locations to hotel(s).
func (r LeisureManagementConfigApiCopyActivityLocationsRequest) CopyActivityLocations(copyActivityLocations CopyActivityLocationsRequest) LeisureManagementConfigApiCopyActivityLocationsRequest {
	r.copyActivityLocations = &copyActivityLocations
	return r
}

// External system code.
func (r LeisureManagementConfigApiCopyActivityLocationsRequest) XExternalsystem(xExternalsystem string) LeisureManagementConfigApiCopyActivityLocationsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LeisureManagementConfigApiCopyActivityLocationsRequest) AcceptLanguage(acceptLanguage string) LeisureManagementConfigApiCopyActivityLocationsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LeisureManagementConfigApiCopyActivityLocationsRequest) Execute() (*CopyActivityLocationsRS, *http.Response, error) {
	return r.ApiService.CopyActivityLocationsExecute(r)
}

/*
CopyActivityLocations Copy Activity Locations

Use this API to copy an Activity location for a property. <p><strong>OperationId:</strong>copyActivityLocations</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param activityLocationsId OPERA Source Activity locations id
 @return LeisureManagementConfigApiCopyActivityLocationsRequest
*/
func (a *LeisureManagementConfigApiService) CopyActivityLocations(ctx context.Context, activityLocationsId string) LeisureManagementConfigApiCopyActivityLocationsRequest {
	return LeisureManagementConfigApiCopyActivityLocationsRequest{
		ApiService: a,
		ctx: ctx,
		activityLocationsId: activityLocationsId,
	}
}

// Execute executes the request
//  @return CopyActivityLocationsRS
func (a *LeisureManagementConfigApiService) CopyActivityLocationsExecute(r LeisureManagementConfigApiCopyActivityLocationsRequest) (*CopyActivityLocationsRS, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CopyActivityLocationsRS
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LeisureManagementConfigApiService.CopyActivityLocations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/activityLocations/{activityLocationsId}/copy"
	localVarPath = strings.Replace(localVarPath, "{"+"activityLocationsId"+"}", url.PathEscape(parameterValueToString(r.activityLocationsId, "activityLocationsId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.activityLocationsId) < 1 {
		return localVarReturnValue, nil, reportError("activityLocationsId must have at least 1 elements")
	}
	if strlen(r.activityLocationsId) > 2000 {
		return localVarReturnValue, nil, reportError("activityLocationsId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.copyActivityLocations
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LeisureManagementConfigApiCopyActivityTypesRequest struct {
	ctx context.Context
	ApiService *LeisureManagementConfigApiService
	activityTypesId string
	authorization *string
	xAppKey *string
	xHotelid *string
	copyActivityTypes *CopyActivityTypesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LeisureManagementConfigApiCopyActivityTypesRequest) Authorization(authorization string) LeisureManagementConfigApiCopyActivityTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r LeisureManagementConfigApiCopyActivityTypesRequest) XAppKey(xAppKey string) LeisureManagementConfigApiCopyActivityTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LeisureManagementConfigApiCopyActivityTypesRequest) XHotelid(xHotelid string) LeisureManagementConfigApiCopyActivityTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for copying Activity Types to hotel(s).
func (r LeisureManagementConfigApiCopyActivityTypesRequest) CopyActivityTypes(copyActivityTypes CopyActivityTypesRequest) LeisureManagementConfigApiCopyActivityTypesRequest {
	r.copyActivityTypes = &copyActivityTypes
	return r
}

// External system code.
func (r LeisureManagementConfigApiCopyActivityTypesRequest) XExternalsystem(xExternalsystem string) LeisureManagementConfigApiCopyActivityTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LeisureManagementConfigApiCopyActivityTypesRequest) AcceptLanguage(acceptLanguage string) LeisureManagementConfigApiCopyActivityTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LeisureManagementConfigApiCopyActivityTypesRequest) Execute() (*CopyActivityTypesRS, *http.Response, error) {
	return r.ApiService.CopyActivityTypesExecute(r)
}

/*
CopyActivityTypes Copy Activity Types

Copy existing Activity Types from source property to target properties. <p><strong>OperationId:</strong>copyActivityTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param activityTypesId OPERA Activity types id
 @return LeisureManagementConfigApiCopyActivityTypesRequest
*/
func (a *LeisureManagementConfigApiService) CopyActivityTypes(ctx context.Context, activityTypesId string) LeisureManagementConfigApiCopyActivityTypesRequest {
	return LeisureManagementConfigApiCopyActivityTypesRequest{
		ApiService: a,
		ctx: ctx,
		activityTypesId: activityTypesId,
	}
}

// Execute executes the request
//  @return CopyActivityTypesRS
func (a *LeisureManagementConfigApiService) CopyActivityTypesExecute(r LeisureManagementConfigApiCopyActivityTypesRequest) (*CopyActivityTypesRS, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CopyActivityTypesRS
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LeisureManagementConfigApiService.CopyActivityTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/activityTypes/{activityTypesId}/copy"
	localVarPath = strings.Replace(localVarPath, "{"+"activityTypesId"+"}", url.PathEscape(parameterValueToString(r.activityTypesId, "activityTypesId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.activityTypesId) < 1 {
		return localVarReturnValue, nil, reportError("activityTypesId must have at least 1 elements")
	}
	if strlen(r.activityTypesId) > 2000 {
		return localVarReturnValue, nil, reportError("activityTypesId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.copyActivityTypes
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LeisureManagementConfigApiDeleteActivityLocationsRequest struct {
	ctx context.Context
	ApiService *LeisureManagementConfigApiService
	activityLocationsId string
	hotelIds *string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Hotel where the code is configured.
func (r LeisureManagementConfigApiDeleteActivityLocationsRequest) HotelIds(hotelIds string) LeisureManagementConfigApiDeleteActivityLocationsRequest {
	r.hotelIds = &hotelIds
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LeisureManagementConfigApiDeleteActivityLocationsRequest) Authorization(authorization string) LeisureManagementConfigApiDeleteActivityLocationsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r LeisureManagementConfigApiDeleteActivityLocationsRequest) XAppKey(xAppKey string) LeisureManagementConfigApiDeleteActivityLocationsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LeisureManagementConfigApiDeleteActivityLocationsRequest) XHotelid(xHotelid string) LeisureManagementConfigApiDeleteActivityLocationsRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r LeisureManagementConfigApiDeleteActivityLocationsRequest) XExternalsystem(xExternalsystem string) LeisureManagementConfigApiDeleteActivityLocationsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LeisureManagementConfigApiDeleteActivityLocationsRequest) AcceptLanguage(acceptLanguage string) LeisureManagementConfigApiDeleteActivityLocationsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LeisureManagementConfigApiDeleteActivityLocationsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteActivityLocationsExecute(r)
}

/*
DeleteActivityLocations Remove Activity Locations

Use this API to delete an Activity location for a property. <p><strong>OperationId:</strong>deleteActivityLocations</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param activityLocationsId OPERA Activity locations id
 @return LeisureManagementConfigApiDeleteActivityLocationsRequest
*/
func (a *LeisureManagementConfigApiService) DeleteActivityLocations(ctx context.Context, activityLocationsId string) LeisureManagementConfigApiDeleteActivityLocationsRequest {
	return LeisureManagementConfigApiDeleteActivityLocationsRequest{
		ApiService: a,
		ctx: ctx,
		activityLocationsId: activityLocationsId,
	}
}

// Execute executes the request
//  @return Status
func (a *LeisureManagementConfigApiService) DeleteActivityLocationsExecute(r LeisureManagementConfigApiDeleteActivityLocationsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LeisureManagementConfigApiService.DeleteActivityLocations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/activityLocations/{activityLocationsId}"
	localVarPath = strings.Replace(localVarPath, "{"+"activityLocationsId"+"}", url.PathEscape(parameterValueToString(r.activityLocationsId, "activityLocationsId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.activityLocationsId) < 1 {
		return localVarReturnValue, nil, reportError("activityLocationsId must have at least 1 elements")
	}
	if strlen(r.activityLocationsId) > 2000 {
		return localVarReturnValue, nil, reportError("activityLocationsId must have less than 2000 elements")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", r.hotelIds, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LeisureManagementConfigApiDeleteActivityStatusCodesRequest struct {
	ctx context.Context
	ApiService *LeisureManagementConfigApiService
	activityStatusCodesId string
	hotelIds *string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Hotel where the code is configured.
func (r LeisureManagementConfigApiDeleteActivityStatusCodesRequest) HotelIds(hotelIds string) LeisureManagementConfigApiDeleteActivityStatusCodesRequest {
	r.hotelIds = &hotelIds
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LeisureManagementConfigApiDeleteActivityStatusCodesRequest) Authorization(authorization string) LeisureManagementConfigApiDeleteActivityStatusCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r LeisureManagementConfigApiDeleteActivityStatusCodesRequest) XAppKey(xAppKey string) LeisureManagementConfigApiDeleteActivityStatusCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LeisureManagementConfigApiDeleteActivityStatusCodesRequest) XHotelid(xHotelid string) LeisureManagementConfigApiDeleteActivityStatusCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r LeisureManagementConfigApiDeleteActivityStatusCodesRequest) XExternalsystem(xExternalsystem string) LeisureManagementConfigApiDeleteActivityStatusCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LeisureManagementConfigApiDeleteActivityStatusCodesRequest) AcceptLanguage(acceptLanguage string) LeisureManagementConfigApiDeleteActivityStatusCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LeisureManagementConfigApiDeleteActivityStatusCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteActivityStatusCodesExecute(r)
}

/*
DeleteActivityStatusCodes Remove Activity Status Code

Remove an Activity Status Code that is configured for a property.  <p><strong>OperationId:</strong>deleteActivityStatusCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param activityStatusCodesId OPERA Activity status codes
 @return LeisureManagementConfigApiDeleteActivityStatusCodesRequest
*/
func (a *LeisureManagementConfigApiService) DeleteActivityStatusCodes(ctx context.Context, activityStatusCodesId string) LeisureManagementConfigApiDeleteActivityStatusCodesRequest {
	return LeisureManagementConfigApiDeleteActivityStatusCodesRequest{
		ApiService: a,
		ctx: ctx,
		activityStatusCodesId: activityStatusCodesId,
	}
}

// Execute executes the request
//  @return Status
func (a *LeisureManagementConfigApiService) DeleteActivityStatusCodesExecute(r LeisureManagementConfigApiDeleteActivityStatusCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LeisureManagementConfigApiService.DeleteActivityStatusCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/activityStatusCodes/{activityStatusCodesId}"
	localVarPath = strings.Replace(localVarPath, "{"+"activityStatusCodesId"+"}", url.PathEscape(parameterValueToString(r.activityStatusCodesId, "activityStatusCodesId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.activityStatusCodesId) < 1 {
		return localVarReturnValue, nil, reportError("activityStatusCodesId must have at least 1 elements")
	}
	if strlen(r.activityStatusCodesId) > 2000 {
		return localVarReturnValue, nil, reportError("activityStatusCodesId must have less than 2000 elements")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", r.hotelIds, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LeisureManagementConfigApiDeleteActivityTypesRequest struct {
	ctx context.Context
	ApiService *LeisureManagementConfigApiService
	activityTypesId string
	hotelIds *string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Hotel where the code is configured.
func (r LeisureManagementConfigApiDeleteActivityTypesRequest) HotelIds(hotelIds string) LeisureManagementConfigApiDeleteActivityTypesRequest {
	r.hotelIds = &hotelIds
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LeisureManagementConfigApiDeleteActivityTypesRequest) Authorization(authorization string) LeisureManagementConfigApiDeleteActivityTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r LeisureManagementConfigApiDeleteActivityTypesRequest) XAppKey(xAppKey string) LeisureManagementConfigApiDeleteActivityTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LeisureManagementConfigApiDeleteActivityTypesRequest) XHotelid(xHotelid string) LeisureManagementConfigApiDeleteActivityTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r LeisureManagementConfigApiDeleteActivityTypesRequest) XExternalsystem(xExternalsystem string) LeisureManagementConfigApiDeleteActivityTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LeisureManagementConfigApiDeleteActivityTypesRequest) AcceptLanguage(acceptLanguage string) LeisureManagementConfigApiDeleteActivityTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LeisureManagementConfigApiDeleteActivityTypesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteActivityTypesExecute(r)
}

/*
DeleteActivityTypes Remove Activity Types

Delete an Activity Type Code that is configured for a property. <p><strong>OperationId:</strong>deleteActivityTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param activityTypesId OPERA Activity types id
 @return LeisureManagementConfigApiDeleteActivityTypesRequest
*/
func (a *LeisureManagementConfigApiService) DeleteActivityTypes(ctx context.Context, activityTypesId string) LeisureManagementConfigApiDeleteActivityTypesRequest {
	return LeisureManagementConfigApiDeleteActivityTypesRequest{
		ApiService: a,
		ctx: ctx,
		activityTypesId: activityTypesId,
	}
}

// Execute executes the request
//  @return Status
func (a *LeisureManagementConfigApiService) DeleteActivityTypesExecute(r LeisureManagementConfigApiDeleteActivityTypesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LeisureManagementConfigApiService.DeleteActivityTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/activityTypes/{activityTypesId}"
	localVarPath = strings.Replace(localVarPath, "{"+"activityTypesId"+"}", url.PathEscape(parameterValueToString(r.activityTypesId, "activityTypesId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.activityTypesId) < 1 {
		return localVarReturnValue, nil, reportError("activityTypesId must have at least 1 elements")
	}
	if strlen(r.activityTypesId) > 2000 {
		return localVarReturnValue, nil, reportError("activityTypesId must have less than 2000 elements")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", r.hotelIds, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LeisureManagementConfigApiGetActivityLocationsRequest struct {
	ctx context.Context
	ApiService *LeisureManagementConfigApiService
	hotelIds *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	criteriaCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

func (r LeisureManagementConfigApiGetActivityLocationsRequest) HotelIds(hotelIds []string) LeisureManagementConfigApiGetActivityLocationsRequest {
	r.hotelIds = &hotelIds
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LeisureManagementConfigApiGetActivityLocationsRequest) Authorization(authorization string) LeisureManagementConfigApiGetActivityLocationsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r LeisureManagementConfigApiGetActivityLocationsRequest) XAppKey(xAppKey string) LeisureManagementConfigApiGetActivityLocationsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LeisureManagementConfigApiGetActivityLocationsRequest) XHotelid(xHotelid string) LeisureManagementConfigApiGetActivityLocationsRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r LeisureManagementConfigApiGetActivityLocationsRequest) CriteriaCodes(criteriaCodes []string) LeisureManagementConfigApiGetActivityLocationsRequest {
	r.criteriaCodes = &criteriaCodes
	return r
}

// External system code.
func (r LeisureManagementConfigApiGetActivityLocationsRequest) XExternalsystem(xExternalsystem string) LeisureManagementConfigApiGetActivityLocationsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LeisureManagementConfigApiGetActivityLocationsRequest) AcceptLanguage(acceptLanguage string) LeisureManagementConfigApiGetActivityLocationsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LeisureManagementConfigApiGetActivityLocationsRequest) Execute() (*FetchActivityLocations, *http.Response, error) {
	return r.ApiService.GetActivityLocationsExecute(r)
}

/*
GetActivityLocations Look up of Activity Locations

Use this API to fetch Activity location codes for a property. <p><strong>OperationId:</strong>getActivityLocations</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LeisureManagementConfigApiGetActivityLocationsRequest
*/
func (a *LeisureManagementConfigApiService) GetActivityLocations(ctx context.Context) LeisureManagementConfigApiGetActivityLocationsRequest {
	return LeisureManagementConfigApiGetActivityLocationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FetchActivityLocations
func (a *LeisureManagementConfigApiService) GetActivityLocationsExecute(r LeisureManagementConfigApiGetActivityLocationsRequest) (*FetchActivityLocations, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FetchActivityLocations
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LeisureManagementConfigApiService.GetActivityLocations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/activityLocations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	{
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.criteriaCodes != nil {
		t := *r.criteriaCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "criteriaCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "criteriaCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LeisureManagementConfigApiGetActivityStatusCodesRequest struct {
	ctx context.Context
	ApiService *LeisureManagementConfigApiService
	hotelIds *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	criteriaCodes *[]string
	applicationCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

func (r LeisureManagementConfigApiGetActivityStatusCodesRequest) HotelIds(hotelIds []string) LeisureManagementConfigApiGetActivityStatusCodesRequest {
	r.hotelIds = &hotelIds
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LeisureManagementConfigApiGetActivityStatusCodesRequest) Authorization(authorization string) LeisureManagementConfigApiGetActivityStatusCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r LeisureManagementConfigApiGetActivityStatusCodesRequest) XAppKey(xAppKey string) LeisureManagementConfigApiGetActivityStatusCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LeisureManagementConfigApiGetActivityStatusCodesRequest) XHotelid(xHotelid string) LeisureManagementConfigApiGetActivityStatusCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r LeisureManagementConfigApiGetActivityStatusCodesRequest) CriteriaCodes(criteriaCodes []string) LeisureManagementConfigApiGetActivityStatusCodesRequest {
	r.criteriaCodes = &criteriaCodes
	return r
}

func (r LeisureManagementConfigApiGetActivityStatusCodesRequest) ApplicationCodes(applicationCodes []string) LeisureManagementConfigApiGetActivityStatusCodesRequest {
	r.applicationCodes = &applicationCodes
	return r
}

// External system code.
func (r LeisureManagementConfigApiGetActivityStatusCodesRequest) XExternalsystem(xExternalsystem string) LeisureManagementConfigApiGetActivityStatusCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LeisureManagementConfigApiGetActivityStatusCodesRequest) AcceptLanguage(acceptLanguage string) LeisureManagementConfigApiGetActivityStatusCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LeisureManagementConfigApiGetActivityStatusCodesRequest) Execute() (*FetchActivityStatusCodes, *http.Response, error) {
	return r.ApiService.GetActivityStatusCodesExecute(r)
}

/*
GetActivityStatusCodes Get Activity Status Codes

Fetch Activity Status Codes that are configured for a property.  <p><strong>OperationId:</strong>getActivityStatusCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LeisureManagementConfigApiGetActivityStatusCodesRequest
*/
func (a *LeisureManagementConfigApiService) GetActivityStatusCodes(ctx context.Context) LeisureManagementConfigApiGetActivityStatusCodesRequest {
	return LeisureManagementConfigApiGetActivityStatusCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FetchActivityStatusCodes
func (a *LeisureManagementConfigApiService) GetActivityStatusCodesExecute(r LeisureManagementConfigApiGetActivityStatusCodesRequest) (*FetchActivityStatusCodes, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FetchActivityStatusCodes
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LeisureManagementConfigApiService.GetActivityStatusCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/activityStatusCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	{
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.criteriaCodes != nil {
		t := *r.criteriaCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "criteriaCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "criteriaCodes", t, "multi")
		}
	}
	if r.applicationCodes != nil {
		t := *r.applicationCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "applicationCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "applicationCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LeisureManagementConfigApiGetActivityTypesRequest struct {
	ctx context.Context
	ApiService *LeisureManagementConfigApiService
	hotelIds *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	typeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

func (r LeisureManagementConfigApiGetActivityTypesRequest) HotelIds(hotelIds []string) LeisureManagementConfigApiGetActivityTypesRequest {
	r.hotelIds = &hotelIds
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LeisureManagementConfigApiGetActivityTypesRequest) Authorization(authorization string) LeisureManagementConfigApiGetActivityTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r LeisureManagementConfigApiGetActivityTypesRequest) XAppKey(xAppKey string) LeisureManagementConfigApiGetActivityTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LeisureManagementConfigApiGetActivityTypesRequest) XHotelid(xHotelid string) LeisureManagementConfigApiGetActivityTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r LeisureManagementConfigApiGetActivityTypesRequest) TypeCodes(typeCodes []string) LeisureManagementConfigApiGetActivityTypesRequest {
	r.typeCodes = &typeCodes
	return r
}

// External system code.
func (r LeisureManagementConfigApiGetActivityTypesRequest) XExternalsystem(xExternalsystem string) LeisureManagementConfigApiGetActivityTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LeisureManagementConfigApiGetActivityTypesRequest) AcceptLanguage(acceptLanguage string) LeisureManagementConfigApiGetActivityTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LeisureManagementConfigApiGetActivityTypesRequest) Execute() (*FetchActivityTypes, *http.Response, error) {
	return r.ApiService.GetActivityTypesExecute(r)
}

/*
GetActivityTypes Fetch Activity Types

Retrieve Activity Types that are configured for a property.  Activity Types are typically used when an EAS (External Activities Scheduler system) interface is connected to OPERA.   <p><strong>OperationId:</strong>getActivityTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LeisureManagementConfigApiGetActivityTypesRequest
*/
func (a *LeisureManagementConfigApiService) GetActivityTypes(ctx context.Context) LeisureManagementConfigApiGetActivityTypesRequest {
	return LeisureManagementConfigApiGetActivityTypesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FetchActivityTypes
func (a *LeisureManagementConfigApiService) GetActivityTypesExecute(r LeisureManagementConfigApiGetActivityTypesRequest) (*FetchActivityTypes, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FetchActivityTypes
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LeisureManagementConfigApiService.GetActivityTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/activityTypes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	{
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.typeCodes != nil {
		t := *r.typeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "typeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "typeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LeisureManagementConfigApiPostActivityLocationsRequest struct {
	ctx context.Context
	ApiService *LeisureManagementConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	createActivityLocations *PostActivityLocationsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LeisureManagementConfigApiPostActivityLocationsRequest) Authorization(authorization string) LeisureManagementConfigApiPostActivityLocationsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r LeisureManagementConfigApiPostActivityLocationsRequest) XAppKey(xAppKey string) LeisureManagementConfigApiPostActivityLocationsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LeisureManagementConfigApiPostActivityLocationsRequest) XHotelid(xHotelid string) LeisureManagementConfigApiPostActivityLocationsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating Activity Locations.
func (r LeisureManagementConfigApiPostActivityLocationsRequest) CreateActivityLocations(createActivityLocations PostActivityLocationsRequest) LeisureManagementConfigApiPostActivityLocationsRequest {
	r.createActivityLocations = &createActivityLocations
	return r
}

// External system code.
func (r LeisureManagementConfigApiPostActivityLocationsRequest) XExternalsystem(xExternalsystem string) LeisureManagementConfigApiPostActivityLocationsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LeisureManagementConfigApiPostActivityLocationsRequest) AcceptLanguage(acceptLanguage string) LeisureManagementConfigApiPostActivityLocationsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LeisureManagementConfigApiPostActivityLocationsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostActivityLocationsExecute(r)
}

/*
PostActivityLocations Create an Activity Locations

Use this API to create a new Activity location for a property. <p><strong>OperationId:</strong>postActivityLocations</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LeisureManagementConfigApiPostActivityLocationsRequest
*/
func (a *LeisureManagementConfigApiService) PostActivityLocations(ctx context.Context) LeisureManagementConfigApiPostActivityLocationsRequest {
	return LeisureManagementConfigApiPostActivityLocationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *LeisureManagementConfigApiService) PostActivityLocationsExecute(r LeisureManagementConfigApiPostActivityLocationsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LeisureManagementConfigApiService.PostActivityLocations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/activityLocations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.createActivityLocations
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LeisureManagementConfigApiPostActivityStatusCodesRequest struct {
	ctx context.Context
	ApiService *LeisureManagementConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	createActivityStatusCodes *PostActivityStatusCodesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LeisureManagementConfigApiPostActivityStatusCodesRequest) Authorization(authorization string) LeisureManagementConfigApiPostActivityStatusCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r LeisureManagementConfigApiPostActivityStatusCodesRequest) XAppKey(xAppKey string) LeisureManagementConfigApiPostActivityStatusCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LeisureManagementConfigApiPostActivityStatusCodesRequest) XHotelid(xHotelid string) LeisureManagementConfigApiPostActivityStatusCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating Activity Status Codes.
func (r LeisureManagementConfigApiPostActivityStatusCodesRequest) CreateActivityStatusCodes(createActivityStatusCodes PostActivityStatusCodesRequest) LeisureManagementConfigApiPostActivityStatusCodesRequest {
	r.createActivityStatusCodes = &createActivityStatusCodes
	return r
}

// External system code.
func (r LeisureManagementConfigApiPostActivityStatusCodesRequest) XExternalsystem(xExternalsystem string) LeisureManagementConfigApiPostActivityStatusCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LeisureManagementConfigApiPostActivityStatusCodesRequest) AcceptLanguage(acceptLanguage string) LeisureManagementConfigApiPostActivityStatusCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LeisureManagementConfigApiPostActivityStatusCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostActivityStatusCodesExecute(r)
}

/*
PostActivityStatusCodes Create Activity Status Code

Retrieve Activity Status Code that are configured for a property.  Activity Status Codes are typically used when an EAS (External Activities Scheduler system) interface is connected to OPERA.   <p><strong>OperationId:</strong>postActivityStatusCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LeisureManagementConfigApiPostActivityStatusCodesRequest
*/
func (a *LeisureManagementConfigApiService) PostActivityStatusCodes(ctx context.Context) LeisureManagementConfigApiPostActivityStatusCodesRequest {
	return LeisureManagementConfigApiPostActivityStatusCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *LeisureManagementConfigApiService) PostActivityStatusCodesExecute(r LeisureManagementConfigApiPostActivityStatusCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LeisureManagementConfigApiService.PostActivityStatusCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/activityStatusCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.createActivityStatusCodes
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LeisureManagementConfigApiPostActivityTypesRequest struct {
	ctx context.Context
	ApiService *LeisureManagementConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	createActivityTypes *PostActivityTypesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LeisureManagementConfigApiPostActivityTypesRequest) Authorization(authorization string) LeisureManagementConfigApiPostActivityTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r LeisureManagementConfigApiPostActivityTypesRequest) XAppKey(xAppKey string) LeisureManagementConfigApiPostActivityTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LeisureManagementConfigApiPostActivityTypesRequest) XHotelid(xHotelid string) LeisureManagementConfigApiPostActivityTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating Activity Types.
func (r LeisureManagementConfigApiPostActivityTypesRequest) CreateActivityTypes(createActivityTypes PostActivityTypesRequest) LeisureManagementConfigApiPostActivityTypesRequest {
	r.createActivityTypes = &createActivityTypes
	return r
}

// External system code.
func (r LeisureManagementConfigApiPostActivityTypesRequest) XExternalsystem(xExternalsystem string) LeisureManagementConfigApiPostActivityTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LeisureManagementConfigApiPostActivityTypesRequest) AcceptLanguage(acceptLanguage string) LeisureManagementConfigApiPostActivityTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LeisureManagementConfigApiPostActivityTypesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostActivityTypesExecute(r)
}

/*
PostActivityTypes Create Activity Types

Create a new Activity Type Code for a specific property. <p><strong>OperationId:</strong>postActivityTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LeisureManagementConfigApiPostActivityTypesRequest
*/
func (a *LeisureManagementConfigApiService) PostActivityTypes(ctx context.Context) LeisureManagementConfigApiPostActivityTypesRequest {
	return LeisureManagementConfigApiPostActivityTypesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *LeisureManagementConfigApiService) PostActivityTypesExecute(r LeisureManagementConfigApiPostActivityTypesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LeisureManagementConfigApiService.PostActivityTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/activityTypes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.createActivityTypes
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LeisureManagementConfigApiPutActivityLocationsRequest struct {
	ctx context.Context
	ApiService *LeisureManagementConfigApiService
	activityLocationsId string
	authorization *string
	xAppKey *string
	xHotelid *string
	changeActivityLocations *PutActivityLocationsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LeisureManagementConfigApiPutActivityLocationsRequest) Authorization(authorization string) LeisureManagementConfigApiPutActivityLocationsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r LeisureManagementConfigApiPutActivityLocationsRequest) XAppKey(xAppKey string) LeisureManagementConfigApiPutActivityLocationsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LeisureManagementConfigApiPutActivityLocationsRequest) XHotelid(xHotelid string) LeisureManagementConfigApiPutActivityLocationsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing Activity Locations.
func (r LeisureManagementConfigApiPutActivityLocationsRequest) ChangeActivityLocations(changeActivityLocations PutActivityLocationsRequest) LeisureManagementConfigApiPutActivityLocationsRequest {
	r.changeActivityLocations = &changeActivityLocations
	return r
}

// External system code.
func (r LeisureManagementConfigApiPutActivityLocationsRequest) XExternalsystem(xExternalsystem string) LeisureManagementConfigApiPutActivityLocationsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LeisureManagementConfigApiPutActivityLocationsRequest) AcceptLanguage(acceptLanguage string) LeisureManagementConfigApiPutActivityLocationsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LeisureManagementConfigApiPutActivityLocationsRequest) Execute() (*ChangeActivityLocationsRS, *http.Response, error) {
	return r.ApiService.PutActivityLocationsExecute(r)
}

/*
PutActivityLocations Change in Activity Locations

Use this API to update an existing Activity location Code for a property. <p><strong>OperationId:</strong>putActivityLocations</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param activityLocationsId OPERA Activity locations id
 @return LeisureManagementConfigApiPutActivityLocationsRequest
*/
func (a *LeisureManagementConfigApiService) PutActivityLocations(ctx context.Context, activityLocationsId string) LeisureManagementConfigApiPutActivityLocationsRequest {
	return LeisureManagementConfigApiPutActivityLocationsRequest{
		ApiService: a,
		ctx: ctx,
		activityLocationsId: activityLocationsId,
	}
}

// Execute executes the request
//  @return ChangeActivityLocationsRS
func (a *LeisureManagementConfigApiService) PutActivityLocationsExecute(r LeisureManagementConfigApiPutActivityLocationsRequest) (*ChangeActivityLocationsRS, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChangeActivityLocationsRS
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LeisureManagementConfigApiService.PutActivityLocations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/activityLocations/{activityLocationsId}"
	localVarPath = strings.Replace(localVarPath, "{"+"activityLocationsId"+"}", url.PathEscape(parameterValueToString(r.activityLocationsId, "activityLocationsId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.activityLocationsId) < 1 {
		return localVarReturnValue, nil, reportError("activityLocationsId must have at least 1 elements")
	}
	if strlen(r.activityLocationsId) > 2000 {
		return localVarReturnValue, nil, reportError("activityLocationsId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.changeActivityLocations
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LeisureManagementConfigApiPutActivityStatusCodesRequest struct {
	ctx context.Context
	ApiService *LeisureManagementConfigApiService
	activityStatusCodesId string
	authorization *string
	xAppKey *string
	xHotelid *string
	changeActivityStatusCodes *PutActivityStatusCodesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LeisureManagementConfigApiPutActivityStatusCodesRequest) Authorization(authorization string) LeisureManagementConfigApiPutActivityStatusCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r LeisureManagementConfigApiPutActivityStatusCodesRequest) XAppKey(xAppKey string) LeisureManagementConfigApiPutActivityStatusCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LeisureManagementConfigApiPutActivityStatusCodesRequest) XHotelid(xHotelid string) LeisureManagementConfigApiPutActivityStatusCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing Activity Status Codes.
func (r LeisureManagementConfigApiPutActivityStatusCodesRequest) ChangeActivityStatusCodes(changeActivityStatusCodes PutActivityStatusCodesRequest) LeisureManagementConfigApiPutActivityStatusCodesRequest {
	r.changeActivityStatusCodes = &changeActivityStatusCodes
	return r
}

// External system code.
func (r LeisureManagementConfigApiPutActivityStatusCodesRequest) XExternalsystem(xExternalsystem string) LeisureManagementConfigApiPutActivityStatusCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LeisureManagementConfigApiPutActivityStatusCodesRequest) AcceptLanguage(acceptLanguage string) LeisureManagementConfigApiPutActivityStatusCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LeisureManagementConfigApiPutActivityStatusCodesRequest) Execute() (*ChangeActivityStatusCodesRS, *http.Response, error) {
	return r.ApiService.PutActivityStatusCodesExecute(r)
}

/*
PutActivityStatusCodes Change Activity Status Code

Modify an Activity Status Code that is configured for a property.  <p><strong>OperationId:</strong>putActivityStatusCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param activityStatusCodesId OPERA Activity status codes
 @return LeisureManagementConfigApiPutActivityStatusCodesRequest
*/
func (a *LeisureManagementConfigApiService) PutActivityStatusCodes(ctx context.Context, activityStatusCodesId string) LeisureManagementConfigApiPutActivityStatusCodesRequest {
	return LeisureManagementConfigApiPutActivityStatusCodesRequest{
		ApiService: a,
		ctx: ctx,
		activityStatusCodesId: activityStatusCodesId,
	}
}

// Execute executes the request
//  @return ChangeActivityStatusCodesRS
func (a *LeisureManagementConfigApiService) PutActivityStatusCodesExecute(r LeisureManagementConfigApiPutActivityStatusCodesRequest) (*ChangeActivityStatusCodesRS, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChangeActivityStatusCodesRS
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LeisureManagementConfigApiService.PutActivityStatusCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/activityStatusCodes/{activityStatusCodesId}"
	localVarPath = strings.Replace(localVarPath, "{"+"activityStatusCodesId"+"}", url.PathEscape(parameterValueToString(r.activityStatusCodesId, "activityStatusCodesId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.activityStatusCodesId) < 1 {
		return localVarReturnValue, nil, reportError("activityStatusCodesId must have at least 1 elements")
	}
	if strlen(r.activityStatusCodesId) > 2000 {
		return localVarReturnValue, nil, reportError("activityStatusCodesId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.changeActivityStatusCodes
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LeisureManagementConfigApiPutActivityTypesRequest struct {
	ctx context.Context
	ApiService *LeisureManagementConfigApiService
	activityTypesId string
	authorization *string
	xAppKey *string
	xHotelid *string
	changeActivityTypes *PutActivityTypesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LeisureManagementConfigApiPutActivityTypesRequest) Authorization(authorization string) LeisureManagementConfigApiPutActivityTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r LeisureManagementConfigApiPutActivityTypesRequest) XAppKey(xAppKey string) LeisureManagementConfigApiPutActivityTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LeisureManagementConfigApiPutActivityTypesRequest) XHotelid(xHotelid string) LeisureManagementConfigApiPutActivityTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing Activity Types.
func (r LeisureManagementConfigApiPutActivityTypesRequest) ChangeActivityTypes(changeActivityTypes PutActivityTypesRequest) LeisureManagementConfigApiPutActivityTypesRequest {
	r.changeActivityTypes = &changeActivityTypes
	return r
}

// External system code.
func (r LeisureManagementConfigApiPutActivityTypesRequest) XExternalsystem(xExternalsystem string) LeisureManagementConfigApiPutActivityTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LeisureManagementConfigApiPutActivityTypesRequest) AcceptLanguage(acceptLanguage string) LeisureManagementConfigApiPutActivityTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LeisureManagementConfigApiPutActivityTypesRequest) Execute() (*ChangeActivityTypesRS, *http.Response, error) {
	return r.ApiService.PutActivityTypesExecute(r)
}

/*
PutActivityTypes Change Activity Types

Modify an Activity Type Code that is configured for a property. <p><strong>OperationId:</strong>putActivityTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param activityTypesId OPERA Activity types id
 @return LeisureManagementConfigApiPutActivityTypesRequest
*/
func (a *LeisureManagementConfigApiService) PutActivityTypes(ctx context.Context, activityTypesId string) LeisureManagementConfigApiPutActivityTypesRequest {
	return LeisureManagementConfigApiPutActivityTypesRequest{
		ApiService: a,
		ctx: ctx,
		activityTypesId: activityTypesId,
	}
}

// Execute executes the request
//  @return ChangeActivityTypesRS
func (a *LeisureManagementConfigApiService) PutActivityTypesExecute(r LeisureManagementConfigApiPutActivityTypesRequest) (*ChangeActivityTypesRS, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChangeActivityTypesRS
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LeisureManagementConfigApiService.PutActivityTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/activityTypes/{activityTypesId}"
	localVarPath = strings.Replace(localVarPath, "{"+"activityTypesId"+"}", url.PathEscape(parameterValueToString(r.activityTypesId, "activityTypesId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.activityTypesId) < 1 {
		return localVarReturnValue, nil, reportError("activityTypesId must have at least 1 elements")
	}
	if strlen(r.activityTypesId) > 2000 {
		return localVarReturnValue, nil, reportError("activityTypesId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.changeActivityTypes
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
