/*
Opera Cloud Rate Plan Asynchronous Service API

APIs catering to the Rate Plan asynchronous related functionality in a hotel.  This includes adding/updating daily rates&apos; pricing schedules and best available rates by day or length of stay. <p>This API follows an async pattern where</p><ul><li>You make an initial request, which returns a Location header</li><li>You poll HEAD on the Location header returned to obtain the status of the process</li><li>Once the process completes HEAD will return in the Location header the URL that must be called to obtain the results of the process</li><li>You call the URL to obtain the results of the process</li></ul><br /><br /> Compatible with OPERA Cloud release 22.3.<br /><br /><p> This document and all content within is available under the Universal Permissive License v 1.0 (https://oss.oracle.com/licenses/upl). Copyright (c) 2020, 2023 Oracle and/or its affiliates.</p>

API version: 22.3
Contact: hospitality_apis_ww_grp@oracle.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package rtpasync

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// RatePlanAsyncApiService RatePlanAsyncApi service
type RatePlanAsyncApiService service

type RatePlanAsyncApiGetBestAvailableRatePlansRequest struct {
	ctx context.Context
	ApiService *RatePlanAsyncApiService
	requestId string
	hotelId string
	extSystemCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanAsyncApiGetBestAvailableRatePlansRequest) Authorization(authorization string) RatePlanAsyncApiGetBestAvailableRatePlansRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r RatePlanAsyncApiGetBestAvailableRatePlansRequest) XAppKey(xAppKey string) RatePlanAsyncApiGetBestAvailableRatePlansRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanAsyncApiGetBestAvailableRatePlansRequest) XHotelid(xHotelid string) RatePlanAsyncApiGetBestAvailableRatePlansRequest {
	r.xHotelid = &xHotelid
	return r
}

// Language code
func (r RatePlanAsyncApiGetBestAvailableRatePlansRequest) AcceptLanguage(acceptLanguage string) RatePlanAsyncApiGetBestAvailableRatePlansRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanAsyncApiGetBestAvailableRatePlansRequest) Execute() (*BestAvailableRatePlansStatus, *http.Response, error) {
	return r.ApiService.GetBestAvailableRatePlansExecute(r)
}

/*
GetBestAvailableRatePlans Get results of a daily rate plan schedule process

Use this API to get the result of the process to set best available rate plans, which will include details of any data that has been failed to process. You can get the value of the summaryId from the Location header returned by the getBestAvailableRatePlansProcessStatus operation after the process is completed. <p><strong>OperationId:</strong>getBestAvailableRatePlans</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param requestId
 @param hotelId
 @param extSystemCode
 @return RatePlanAsyncApiGetBestAvailableRatePlansRequest
*/
func (a *RatePlanAsyncApiService) GetBestAvailableRatePlans(ctx context.Context, requestId string, hotelId string, extSystemCode string) RatePlanAsyncApiGetBestAvailableRatePlansRequest {
	return RatePlanAsyncApiGetBestAvailableRatePlansRequest{
		ApiService: a,
		ctx: ctx,
		requestId: requestId,
		hotelId: hotelId,
		extSystemCode: extSystemCode,
	}
}

// Execute executes the request
//  @return BestAvailableRatePlansStatus
func (a *RatePlanAsyncApiService) GetBestAvailableRatePlansExecute(r RatePlanAsyncApiGetBestAvailableRatePlansRequest) (*BestAvailableRatePlansStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BestAvailableRatePlansStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanAsyncApiService.GetBestAvailableRatePlans")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/externalSystems/{extSystemCode}/hotels/{hotelId}/ratePlans/bestAvailableLOS/{requestId}"
	localVarPath = strings.Replace(localVarPath, "{"+"requestId"+"}", url.PathEscape(parameterValueToString(r.requestId, "requestId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extSystemCode"+"}", url.PathEscape(parameterValueToString(r.extSystemCode, "extSystemCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.requestId) < 1 {
		return localVarReturnValue, nil, reportError("requestId must have at least 1 elements")
	}
	if strlen(r.requestId) > 2000 {
		return localVarReturnValue, nil, reportError("requestId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if strlen(r.extSystemCode) < 1 {
		return localVarReturnValue, nil, reportError("extSystemCode must have at least 1 elements")
	}
	if strlen(r.extSystemCode) > 2000 {
		return localVarReturnValue, nil, reportError("extSystemCode must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanAsyncApiGetBestAvailableRatePlansProcessStatusRequest struct {
	ctx context.Context
	ApiService *RatePlanAsyncApiService
	requestId string
	extSystemCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanAsyncApiGetBestAvailableRatePlansProcessStatusRequest) Authorization(authorization string) RatePlanAsyncApiGetBestAvailableRatePlansProcessStatusRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r RatePlanAsyncApiGetBestAvailableRatePlansProcessStatusRequest) XAppKey(xAppKey string) RatePlanAsyncApiGetBestAvailableRatePlansProcessStatusRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanAsyncApiGetBestAvailableRatePlansProcessStatusRequest) XHotelid(xHotelid string) RatePlanAsyncApiGetBestAvailableRatePlansProcessStatusRequest {
	r.xHotelid = &xHotelid
	return r
}

// Language code
func (r RatePlanAsyncApiGetBestAvailableRatePlansProcessStatusRequest) AcceptLanguage(acceptLanguage string) RatePlanAsyncApiGetBestAvailableRatePlansProcessStatusRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanAsyncApiGetBestAvailableRatePlansProcessStatusRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetBestAvailableRatePlansProcessStatusExecute(r)
}

/*
GetBestAvailableRatePlansProcessStatus Check status of setting best available rate plans process

Use this API to check whether the setting of best available rate plans process is completed. You can get value of summaryId from the Location header returned by the startSetBestAvailableRatePlansProcess operation.<p><strong>OperationId:</strong>getBestAvailableRatePlansProcessStatus</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param requestId
 @param extSystemCode
 @param hotelId
 @return RatePlanAsyncApiGetBestAvailableRatePlansProcessStatusRequest
*/
func (a *RatePlanAsyncApiService) GetBestAvailableRatePlansProcessStatus(ctx context.Context, requestId string, extSystemCode string, hotelId string) RatePlanAsyncApiGetBestAvailableRatePlansProcessStatusRequest {
	return RatePlanAsyncApiGetBestAvailableRatePlansProcessStatusRequest{
		ApiService: a,
		ctx: ctx,
		requestId: requestId,
		extSystemCode: extSystemCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
func (a *RatePlanAsyncApiService) GetBestAvailableRatePlansProcessStatusExecute(r RatePlanAsyncApiGetBestAvailableRatePlansProcessStatusRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanAsyncApiService.GetBestAvailableRatePlansProcessStatus")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/externalSystems/{extSystemCode}/hotels/{hotelId}/ratePlans/bestAvailableLOS/{requestId}"
	localVarPath = strings.Replace(localVarPath, "{"+"requestId"+"}", url.PathEscape(parameterValueToString(r.requestId, "requestId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extSystemCode"+"}", url.PathEscape(parameterValueToString(r.extSystemCode, "extSystemCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.requestId) < 1 {
		return nil, reportError("requestId must have at least 1 elements")
	}
	if strlen(r.requestId) > 2000 {
		return nil, reportError("requestId must have less than 2000 elements")
	}
	if strlen(r.extSystemCode) < 1 {
		return nil, reportError("extSystemCode must have at least 1 elements")
	}
	if strlen(r.extSystemCode) > 2000 {
		return nil, reportError("extSystemCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type RatePlanAsyncApiGetDailyRatePlanSchedulesRequest struct {
	ctx context.Context
	ApiService *RatePlanAsyncApiService
	requestId string
	hotelId string
	extSystemCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanAsyncApiGetDailyRatePlanSchedulesRequest) Authorization(authorization string) RatePlanAsyncApiGetDailyRatePlanSchedulesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r RatePlanAsyncApiGetDailyRatePlanSchedulesRequest) XAppKey(xAppKey string) RatePlanAsyncApiGetDailyRatePlanSchedulesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanAsyncApiGetDailyRatePlanSchedulesRequest) XHotelid(xHotelid string) RatePlanAsyncApiGetDailyRatePlanSchedulesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Language code
func (r RatePlanAsyncApiGetDailyRatePlanSchedulesRequest) AcceptLanguage(acceptLanguage string) RatePlanAsyncApiGetDailyRatePlanSchedulesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanAsyncApiGetDailyRatePlanSchedulesRequest) Execute() (*DailyRatePlanSchedulesStatus, *http.Response, error) {
	return r.ApiService.GetDailyRatePlanSchedulesExecute(r)
}

/*
GetDailyRatePlanSchedules Get results of a daily rate plan schedule process

Use this API to get the result of the daily rate plans schedule process, which will include details of any data that has failed to process. You can get the value of the summaryId from the Location header returned by the getDailyRatePlanSchedulesProcessStatus operation after the process is completed. <p><strong>OperationId:</strong>getDailyRatePlanSchedules</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param requestId
 @param hotelId
 @param extSystemCode
 @return RatePlanAsyncApiGetDailyRatePlanSchedulesRequest
*/
func (a *RatePlanAsyncApiService) GetDailyRatePlanSchedules(ctx context.Context, requestId string, hotelId string, extSystemCode string) RatePlanAsyncApiGetDailyRatePlanSchedulesRequest {
	return RatePlanAsyncApiGetDailyRatePlanSchedulesRequest{
		ApiService: a,
		ctx: ctx,
		requestId: requestId,
		hotelId: hotelId,
		extSystemCode: extSystemCode,
	}
}

// Execute executes the request
//  @return DailyRatePlanSchedulesStatus
func (a *RatePlanAsyncApiService) GetDailyRatePlanSchedulesExecute(r RatePlanAsyncApiGetDailyRatePlanSchedulesRequest) (*DailyRatePlanSchedulesStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DailyRatePlanSchedulesStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanAsyncApiService.GetDailyRatePlanSchedules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/externalSystems/{extSystemCode}/hotels/{hotelId}/ratePlans/dailySchedules/{requestId}"
	localVarPath = strings.Replace(localVarPath, "{"+"requestId"+"}", url.PathEscape(parameterValueToString(r.requestId, "requestId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extSystemCode"+"}", url.PathEscape(parameterValueToString(r.extSystemCode, "extSystemCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.requestId) < 1 {
		return localVarReturnValue, nil, reportError("requestId must have at least 1 elements")
	}
	if strlen(r.requestId) > 2000 {
		return localVarReturnValue, nil, reportError("requestId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if strlen(r.extSystemCode) < 1 {
		return localVarReturnValue, nil, reportError("extSystemCode must have at least 1 elements")
	}
	if strlen(r.extSystemCode) > 2000 {
		return localVarReturnValue, nil, reportError("extSystemCode must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanAsyncApiGetDailyRatePlanSchedulesProcessStatusRequest struct {
	ctx context.Context
	ApiService *RatePlanAsyncApiService
	requestId string
	extSystemCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanAsyncApiGetDailyRatePlanSchedulesProcessStatusRequest) Authorization(authorization string) RatePlanAsyncApiGetDailyRatePlanSchedulesProcessStatusRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r RatePlanAsyncApiGetDailyRatePlanSchedulesProcessStatusRequest) XAppKey(xAppKey string) RatePlanAsyncApiGetDailyRatePlanSchedulesProcessStatusRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanAsyncApiGetDailyRatePlanSchedulesProcessStatusRequest) XHotelid(xHotelid string) RatePlanAsyncApiGetDailyRatePlanSchedulesProcessStatusRequest {
	r.xHotelid = &xHotelid
	return r
}

// Language code
func (r RatePlanAsyncApiGetDailyRatePlanSchedulesProcessStatusRequest) AcceptLanguage(acceptLanguage string) RatePlanAsyncApiGetDailyRatePlanSchedulesProcessStatusRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanAsyncApiGetDailyRatePlanSchedulesProcessStatusRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetDailyRatePlanSchedulesProcessStatusExecute(r)
}

/*
GetDailyRatePlanSchedulesProcessStatus Check status of setting daily rate plan schedule process

Use this API to check whether the rate plan pricing schedule process is completed. You can get value of summaryId from the Location header returned by the startSetDailyRatePlanSchedulesProcess operation.<p><strong>OperationId:</strong>getDailyRatePlanSchedulesProcessStatus</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param requestId
 @param extSystemCode
 @param hotelId
 @return RatePlanAsyncApiGetDailyRatePlanSchedulesProcessStatusRequest
*/
func (a *RatePlanAsyncApiService) GetDailyRatePlanSchedulesProcessStatus(ctx context.Context, requestId string, extSystemCode string, hotelId string) RatePlanAsyncApiGetDailyRatePlanSchedulesProcessStatusRequest {
	return RatePlanAsyncApiGetDailyRatePlanSchedulesProcessStatusRequest{
		ApiService: a,
		ctx: ctx,
		requestId: requestId,
		extSystemCode: extSystemCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
func (a *RatePlanAsyncApiService) GetDailyRatePlanSchedulesProcessStatusExecute(r RatePlanAsyncApiGetDailyRatePlanSchedulesProcessStatusRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanAsyncApiService.GetDailyRatePlanSchedulesProcessStatus")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/externalSystems/{extSystemCode}/hotels/{hotelId}/ratePlans/dailySchedules/{requestId}"
	localVarPath = strings.Replace(localVarPath, "{"+"requestId"+"}", url.PathEscape(parameterValueToString(r.requestId, "requestId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extSystemCode"+"}", url.PathEscape(parameterValueToString(r.extSystemCode, "extSystemCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.requestId) < 1 {
		return nil, reportError("requestId must have at least 1 elements")
	}
	if strlen(r.requestId) > 2000 {
		return nil, reportError("requestId must have less than 2000 elements")
	}
	if strlen(r.extSystemCode) < 1 {
		return nil, reportError("extSystemCode must have at least 1 elements")
	}
	if strlen(r.extSystemCode) > 2000 {
		return nil, reportError("extSystemCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type RatePlanAsyncApiGetHurdleRatesRequest struct {
	ctx context.Context
	ApiService *RatePlanAsyncApiService
	hotelId string
	extSystemCode string
	requestId string
	authorization *string
	xAppKey *string
	xHotelid *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanAsyncApiGetHurdleRatesRequest) Authorization(authorization string) RatePlanAsyncApiGetHurdleRatesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r RatePlanAsyncApiGetHurdleRatesRequest) XAppKey(xAppKey string) RatePlanAsyncApiGetHurdleRatesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanAsyncApiGetHurdleRatesRequest) XHotelid(xHotelid string) RatePlanAsyncApiGetHurdleRatesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Language code
func (r RatePlanAsyncApiGetHurdleRatesRequest) AcceptLanguage(acceptLanguage string) RatePlanAsyncApiGetHurdleRatesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanAsyncApiGetHurdleRatesRequest) Execute() (*HurdleRatesStatus, *http.Response, error) {
	return r.ApiService.GetHurdleRatesExecute(r)
}

/*
GetHurdleRates This API facilitates fetching of status for configured hurdle rates.

 <p><strong>OperationId:</strong>getHurdleRates</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of Hotel in OPERA.
 @param extSystemCode Unique code of the external system.
 @param requestId Unique ID to fetch status of configured hurdle rates.
 @return RatePlanAsyncApiGetHurdleRatesRequest
*/
func (a *RatePlanAsyncApiService) GetHurdleRates(ctx context.Context, hotelId string, extSystemCode string, requestId string) RatePlanAsyncApiGetHurdleRatesRequest {
	return RatePlanAsyncApiGetHurdleRatesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
		extSystemCode: extSystemCode,
		requestId: requestId,
	}
}

// Execute executes the request
//  @return HurdleRatesStatus
func (a *RatePlanAsyncApiService) GetHurdleRatesExecute(r RatePlanAsyncApiGetHurdleRatesRequest) (*HurdleRatesStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HurdleRatesStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanAsyncApiService.GetHurdleRates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/externalSystems/{extSystemCode}/hotels/{hotelId}/rates/hurdles/{requestId}"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extSystemCode"+"}", url.PathEscape(parameterValueToString(r.extSystemCode, "extSystemCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"requestId"+"}", url.PathEscape(parameterValueToString(r.requestId, "requestId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if strlen(r.extSystemCode) < 1 {
		return localVarReturnValue, nil, reportError("extSystemCode must have at least 1 elements")
	}
	if strlen(r.extSystemCode) > 2000 {
		return localVarReturnValue, nil, reportError("extSystemCode must have less than 2000 elements")
	}
	if strlen(r.requestId) < 1 {
		return localVarReturnValue, nil, reportError("requestId must have at least 1 elements")
	}
	if strlen(r.requestId) > 2000 {
		return localVarReturnValue, nil, reportError("requestId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanAsyncApiGetHurdleRatesProcessStatusRequest struct {
	ctx context.Context
	ApiService *RatePlanAsyncApiService
	requestId string
	extSystemCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanAsyncApiGetHurdleRatesProcessStatusRequest) Authorization(authorization string) RatePlanAsyncApiGetHurdleRatesProcessStatusRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r RatePlanAsyncApiGetHurdleRatesProcessStatusRequest) XAppKey(xAppKey string) RatePlanAsyncApiGetHurdleRatesProcessStatusRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanAsyncApiGetHurdleRatesProcessStatusRequest) XHotelid(xHotelid string) RatePlanAsyncApiGetHurdleRatesProcessStatusRequest {
	r.xHotelid = &xHotelid
	return r
}

// Language code
func (r RatePlanAsyncApiGetHurdleRatesProcessStatusRequest) AcceptLanguage(acceptLanguage string) RatePlanAsyncApiGetHurdleRatesProcessStatusRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanAsyncApiGetHurdleRatesProcessStatusRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetHurdleRatesProcessStatusExecute(r)
}

/*
GetHurdleRatesProcessStatus This API returns the status of asynchronous process scheduled for given id.

 <p><strong>OperationId:</strong>getHurdleRatesProcessStatus</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param requestId Unique ID to fetch status of configured hurdle rates.
 @param extSystemCode Unique code of the external system.
 @param hotelId Unique ID of Hotel in OPERA.
 @return RatePlanAsyncApiGetHurdleRatesProcessStatusRequest
*/
func (a *RatePlanAsyncApiService) GetHurdleRatesProcessStatus(ctx context.Context, requestId string, extSystemCode string, hotelId string) RatePlanAsyncApiGetHurdleRatesProcessStatusRequest {
	return RatePlanAsyncApiGetHurdleRatesProcessStatusRequest{
		ApiService: a,
		ctx: ctx,
		requestId: requestId,
		extSystemCode: extSystemCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
func (a *RatePlanAsyncApiService) GetHurdleRatesProcessStatusExecute(r RatePlanAsyncApiGetHurdleRatesProcessStatusRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanAsyncApiService.GetHurdleRatesProcessStatus")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/externalSystems/{extSystemCode}/hotels/{hotelId}/rates/hurdles/{requestId}"
	localVarPath = strings.Replace(localVarPath, "{"+"requestId"+"}", url.PathEscape(parameterValueToString(r.requestId, "requestId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extSystemCode"+"}", url.PathEscape(parameterValueToString(r.extSystemCode, "extSystemCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.requestId) < 1 {
		return nil, reportError("requestId must have at least 1 elements")
	}
	if strlen(r.requestId) > 2000 {
		return nil, reportError("requestId must have less than 2000 elements")
	}
	if strlen(r.extSystemCode) < 1 {
		return nil, reportError("extSystemCode must have at least 1 elements")
	}
	if strlen(r.extSystemCode) > 2000 {
		return nil, reportError("extSystemCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type RatePlanAsyncApiStartHurdleRatesProcessRequest struct {
	ctx context.Context
	ApiService *RatePlanAsyncApiService
	hotelId string
	extSystemCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	hurdleRates *[]HurdleRateType
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanAsyncApiStartHurdleRatesProcessRequest) Authorization(authorization string) RatePlanAsyncApiStartHurdleRatesProcessRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r RatePlanAsyncApiStartHurdleRatesProcessRequest) XAppKey(xAppKey string) RatePlanAsyncApiStartHurdleRatesProcessRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanAsyncApiStartHurdleRatesProcessRequest) XHotelid(xHotelid string) RatePlanAsyncApiStartHurdleRatesProcessRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request for configuring hurdle rates.
func (r RatePlanAsyncApiStartHurdleRatesProcessRequest) HurdleRates(hurdleRates []HurdleRateType) RatePlanAsyncApiStartHurdleRatesProcessRequest {
	r.hurdleRates = &hurdleRates
	return r
}

// Language code
func (r RatePlanAsyncApiStartHurdleRatesProcessRequest) AcceptLanguage(acceptLanguage string) RatePlanAsyncApiStartHurdleRatesProcessRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanAsyncApiStartHurdleRatesProcessRequest) Execute() (*http.Response, error) {
	return r.ApiService.StartHurdleRatesProcessExecute(r)
}

/*
StartHurdleRatesProcess Operation to configure hurdle rates.

 <p><strong>OperationId:</strong>startHurdleRatesProcess</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel in OPERA
 @param extSystemCode Unique code of the external system
 @return RatePlanAsyncApiStartHurdleRatesProcessRequest
*/
func (a *RatePlanAsyncApiService) StartHurdleRatesProcess(ctx context.Context, hotelId string, extSystemCode string) RatePlanAsyncApiStartHurdleRatesProcessRequest {
	return RatePlanAsyncApiStartHurdleRatesProcessRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
		extSystemCode: extSystemCode,
	}
}

// Execute executes the request
func (a *RatePlanAsyncApiService) StartHurdleRatesProcessExecute(r RatePlanAsyncApiStartHurdleRatesProcessRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanAsyncApiService.StartHurdleRatesProcess")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/externalSystems/{extSystemCode}/hotels/{hotelId}/rates/hurdles"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extSystemCode"+"}", url.PathEscape(parameterValueToString(r.extSystemCode, "extSystemCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return nil, reportError("hotelId must have less than 2000 elements")
	}
	if strlen(r.extSystemCode) < 1 {
		return nil, reportError("extSystemCode must have at least 1 elements")
	}
	if strlen(r.extSystemCode) > 2000 {
		return nil, reportError("extSystemCode must have less than 2000 elements")
	}
	if len(*r.hurdleRates) > 4000 {
		return nil, reportError("hurdleRates must have less than 4000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.hurdleRates
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type RatePlanAsyncApiStartSetBestAvailableRatePlansProcessRequest struct {
	ctx context.Context
	ApiService *RatePlanAsyncApiService
	hotelId string
	extSystemCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	bestAvailableRatePlans *BestAvailableRatePlans
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanAsyncApiStartSetBestAvailableRatePlansProcessRequest) Authorization(authorization string) RatePlanAsyncApiStartSetBestAvailableRatePlansProcessRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r RatePlanAsyncApiStartSetBestAvailableRatePlansProcessRequest) XAppKey(xAppKey string) RatePlanAsyncApiStartSetBestAvailableRatePlansProcessRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanAsyncApiStartSetBestAvailableRatePlansProcessRequest) XHotelid(xHotelid string) RatePlanAsyncApiStartSetBestAvailableRatePlansProcessRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request for configuring best available rate plans.
func (r RatePlanAsyncApiStartSetBestAvailableRatePlansProcessRequest) BestAvailableRatePlans(bestAvailableRatePlans BestAvailableRatePlans) RatePlanAsyncApiStartSetBestAvailableRatePlansProcessRequest {
	r.bestAvailableRatePlans = &bestAvailableRatePlans
	return r
}

// Language code
func (r RatePlanAsyncApiStartSetBestAvailableRatePlansProcessRequest) AcceptLanguage(acceptLanguage string) RatePlanAsyncApiStartSetBestAvailableRatePlansProcessRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanAsyncApiStartSetBestAvailableRatePlansProcessRequest) Execute() (*http.Response, error) {
	return r.ApiService.StartSetBestAvailableRatePlansProcessExecute(r)
}

/*
StartSetBestAvailableRatePlansProcess API to initiate setting best available rate plans process.

Use this API to start the process of adding and updating best available rate plans by day or by length of stay. Returns a header parameter Location that can be used in the getBestAvailableRatePlansProcessStatus operation. <p><strong>OperationId:</strong>startSetBestAvailableRatePlansProcess</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel in OPERA
 @param extSystemCode
 @return RatePlanAsyncApiStartSetBestAvailableRatePlansProcessRequest
*/
func (a *RatePlanAsyncApiService) StartSetBestAvailableRatePlansProcess(ctx context.Context, hotelId string, extSystemCode string) RatePlanAsyncApiStartSetBestAvailableRatePlansProcessRequest {
	return RatePlanAsyncApiStartSetBestAvailableRatePlansProcessRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
		extSystemCode: extSystemCode,
	}
}

// Execute executes the request
func (a *RatePlanAsyncApiService) StartSetBestAvailableRatePlansProcessExecute(r RatePlanAsyncApiStartSetBestAvailableRatePlansProcessRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanAsyncApiService.StartSetBestAvailableRatePlansProcess")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/externalSystems/{extSystemCode}/hotels/{hotelId}/ratePlans/bestAvailableLOS"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extSystemCode"+"}", url.PathEscape(parameterValueToString(r.extSystemCode, "extSystemCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return nil, reportError("hotelId must have less than 2000 elements")
	}
	if strlen(r.extSystemCode) < 1 {
		return nil, reportError("extSystemCode must have at least 1 elements")
	}
	if strlen(r.extSystemCode) > 2000 {
		return nil, reportError("extSystemCode must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.bestAvailableRatePlans
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type RatePlanAsyncApiStartSetDailyRatePlanSchedulesProcessRequest struct {
	ctx context.Context
	ApiService *RatePlanAsyncApiService
	hotelId string
	extSystemCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	dailyRatePlanSchedules *DailyRatePlanSchedules
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanAsyncApiStartSetDailyRatePlanSchedulesProcessRequest) Authorization(authorization string) RatePlanAsyncApiStartSetDailyRatePlanSchedulesProcessRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r RatePlanAsyncApiStartSetDailyRatePlanSchedulesProcessRequest) XAppKey(xAppKey string) RatePlanAsyncApiStartSetDailyRatePlanSchedulesProcessRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanAsyncApiStartSetDailyRatePlanSchedulesProcessRequest) XHotelid(xHotelid string) RatePlanAsyncApiStartSetDailyRatePlanSchedulesProcessRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request for configuring daily rate plan schedules.
func (r RatePlanAsyncApiStartSetDailyRatePlanSchedulesProcessRequest) DailyRatePlanSchedules(dailyRatePlanSchedules DailyRatePlanSchedules) RatePlanAsyncApiStartSetDailyRatePlanSchedulesProcessRequest {
	r.dailyRatePlanSchedules = &dailyRatePlanSchedules
	return r
}

// Language code
func (r RatePlanAsyncApiStartSetDailyRatePlanSchedulesProcessRequest) AcceptLanguage(acceptLanguage string) RatePlanAsyncApiStartSetDailyRatePlanSchedulesProcessRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanAsyncApiStartSetDailyRatePlanSchedulesProcessRequest) Execute() (*http.Response, error) {
	return r.ApiService.StartSetDailyRatePlanSchedulesProcessExecute(r)
}

/*
StartSetDailyRatePlanSchedulesProcess API to initiate rate plans&apos; price update process

Use this API to start the process to add and update daily rate plans&apos; pricing schedule. Returns a header parameter Location that can be used in the getDailyRatePlanSchedulesProcessStatus operation. <p><strong>OperationId:</strong>startSetDailyRatePlanSchedulesProcess</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId
 @param extSystemCode
 @return RatePlanAsyncApiStartSetDailyRatePlanSchedulesProcessRequest
*/
func (a *RatePlanAsyncApiService) StartSetDailyRatePlanSchedulesProcess(ctx context.Context, hotelId string, extSystemCode string) RatePlanAsyncApiStartSetDailyRatePlanSchedulesProcessRequest {
	return RatePlanAsyncApiStartSetDailyRatePlanSchedulesProcessRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
		extSystemCode: extSystemCode,
	}
}

// Execute executes the request
func (a *RatePlanAsyncApiService) StartSetDailyRatePlanSchedulesProcessExecute(r RatePlanAsyncApiStartSetDailyRatePlanSchedulesProcessRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanAsyncApiService.StartSetDailyRatePlanSchedulesProcess")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/externalSystems/{extSystemCode}/hotels/{hotelId}/ratePlans/dailySchedules"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extSystemCode"+"}", url.PathEscape(parameterValueToString(r.extSystemCode, "extSystemCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return nil, reportError("hotelId must have less than 2000 elements")
	}
	if strlen(r.extSystemCode) < 1 {
		return nil, reportError("extSystemCode must have at least 1 elements")
	}
	if strlen(r.extSystemCode) > 2000 {
		return nil, reportError("extSystemCode must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.dailyRatePlanSchedules
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
