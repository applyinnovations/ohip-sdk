/*
OPERA Cloud API for Customer Management Service

This API deals with the different aspect of the CustomerManagement.<br /><br /> Compatible with OPERA Cloud release 23.2.<br /><br /><p> This document and all content within is available under the Universal Permissive License v 1.0 (https://oss.oracle.com/licenses/upl). Copyright (c) 2020, 2023 Oracle and/or its affiliates.</p>

API version: 23.2
Contact: hospitality-integrations_ww@oracle.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package cms

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// CustomerManagementAPIService CustomerManagementAPI service
type CustomerManagementAPIService service

type CustomerManagementAPIDeleteCalendarTaskRequest struct {
	ctx context.Context
	ApiService *CustomerManagementAPIService
	activityId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CustomerManagementAPIDeleteCalendarTaskRequest) Authorization(authorization string) CustomerManagementAPIDeleteCalendarTaskRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CustomerManagementAPIDeleteCalendarTaskRequest) XAppKey(xAppKey string) CustomerManagementAPIDeleteCalendarTaskRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CustomerManagementAPIDeleteCalendarTaskRequest) XHotelid(xHotelid string) CustomerManagementAPIDeleteCalendarTaskRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r CustomerManagementAPIDeleteCalendarTaskRequest) XExternalsystem(xExternalsystem string) CustomerManagementAPIDeleteCalendarTaskRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CustomerManagementAPIDeleteCalendarTaskRequest) AcceptLanguage(acceptLanguage string) CustomerManagementAPIDeleteCalendarTaskRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CustomerManagementAPIDeleteCalendarTaskRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteCalendarTaskExecute(r)
}

/*
DeleteCalendarTask Delete a Calendar Task

This API will allow you to delete a Calendar Task. <p><strong>OperationId:</strong>deleteCalendarTask</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param activityId
 @param hotelId
 @return CustomerManagementAPIDeleteCalendarTaskRequest
*/
func (a *CustomerManagementAPIService) DeleteCalendarTask(ctx context.Context, activityId string, hotelId string) CustomerManagementAPIDeleteCalendarTaskRequest {
	return CustomerManagementAPIDeleteCalendarTaskRequest{
		ApiService: a,
		ctx: ctx,
		activityId: activityId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CustomerManagementAPIService) DeleteCalendarTaskExecute(r CustomerManagementAPIDeleteCalendarTaskRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomerManagementAPIService.DeleteCalendarTask")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/activities/{activityId}/task"
	localVarPath = strings.Replace(localVarPath, "{"+"activityId"+"}", url.PathEscape(parameterValueToString(r.activityId, "activityId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.activityId) < 1 {
		return localVarReturnValue, nil, reportError("activityId must have at least 1 elements")
	}
	if strlen(r.activityId) > 2000 {
		return localVarReturnValue, nil, reportError("activityId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CustomerManagementAPIDeleteCalendarTaskAttachmentRequest struct {
	ctx context.Context
	ApiService *CustomerManagementAPIService
	linkedToId *string
	attachId *string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r CustomerManagementAPIDeleteCalendarTaskAttachmentRequest) LinkedToId(linkedToId string) CustomerManagementAPIDeleteCalendarTaskAttachmentRequest {
	r.linkedToId = &linkedToId
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r CustomerManagementAPIDeleteCalendarTaskAttachmentRequest) AttachId(attachId string) CustomerManagementAPIDeleteCalendarTaskAttachmentRequest {
	r.attachId = &attachId
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CustomerManagementAPIDeleteCalendarTaskAttachmentRequest) Authorization(authorization string) CustomerManagementAPIDeleteCalendarTaskAttachmentRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CustomerManagementAPIDeleteCalendarTaskAttachmentRequest) XAppKey(xAppKey string) CustomerManagementAPIDeleteCalendarTaskAttachmentRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CustomerManagementAPIDeleteCalendarTaskAttachmentRequest) XHotelid(xHotelid string) CustomerManagementAPIDeleteCalendarTaskAttachmentRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r CustomerManagementAPIDeleteCalendarTaskAttachmentRequest) XExternalsystem(xExternalsystem string) CustomerManagementAPIDeleteCalendarTaskAttachmentRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CustomerManagementAPIDeleteCalendarTaskAttachmentRequest) AcceptLanguage(acceptLanguage string) CustomerManagementAPIDeleteCalendarTaskAttachmentRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CustomerManagementAPIDeleteCalendarTaskAttachmentRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteCalendarTaskAttachmentExecute(r)
}

/*
DeleteCalendarTaskAttachment Delete a Calendar Task attachment 

Delete an attachment associated with the calendar task <p><strong>OperationId:</strong>deleteCalendarTaskAttachment</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CustomerManagementAPIDeleteCalendarTaskAttachmentRequest
*/
func (a *CustomerManagementAPIService) DeleteCalendarTaskAttachment(ctx context.Context) CustomerManagementAPIDeleteCalendarTaskAttachmentRequest {
	return CustomerManagementAPIDeleteCalendarTaskAttachmentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CustomerManagementAPIService) DeleteCalendarTaskAttachmentExecute(r CustomerManagementAPIDeleteCalendarTaskAttachmentRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomerManagementAPIService.DeleteCalendarTaskAttachment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/activities/tasks/attachment"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	parameterAddToHeaderOrQuery(localVarQueryParams, "linkedToId", r.linkedToId, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "attachId", r.attachId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CustomerManagementAPIDeleteTrackItItemsRequest struct {
	ctx context.Context
	ApiService *CustomerManagementAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	trackItId *[]string
	trackItIdContext *[]string
	trackItIdType *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CustomerManagementAPIDeleteTrackItItemsRequest) Authorization(authorization string) CustomerManagementAPIDeleteTrackItItemsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CustomerManagementAPIDeleteTrackItItemsRequest) XAppKey(xAppKey string) CustomerManagementAPIDeleteTrackItItemsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CustomerManagementAPIDeleteTrackItItemsRequest) XHotelid(xHotelid string) CustomerManagementAPIDeleteTrackItItemsRequest {
	r.xHotelid = &xHotelid
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r CustomerManagementAPIDeleteTrackItItemsRequest) TrackItId(trackItId []string) CustomerManagementAPIDeleteTrackItItemsRequest {
	r.trackItId = &trackItId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r CustomerManagementAPIDeleteTrackItItemsRequest) TrackItIdContext(trackItIdContext []string) CustomerManagementAPIDeleteTrackItItemsRequest {
	r.trackItIdContext = &trackItIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r CustomerManagementAPIDeleteTrackItItemsRequest) TrackItIdType(trackItIdType []string) CustomerManagementAPIDeleteTrackItItemsRequest {
	r.trackItIdType = &trackItIdType
	return r
}

// External system code.
func (r CustomerManagementAPIDeleteTrackItItemsRequest) XExternalsystem(xExternalsystem string) CustomerManagementAPIDeleteTrackItItemsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CustomerManagementAPIDeleteTrackItItemsRequest) AcceptLanguage(acceptLanguage string) CustomerManagementAPIDeleteTrackItItemsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CustomerManagementAPIDeleteTrackItItemsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteTrackItItemsExecute(r)
}

/*
DeleteTrackItItems Deletes track it items

Delete a Track It Item for a property. <p><strong>OperationId:</strong>deleteTrackItItems</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId
 @return CustomerManagementAPIDeleteTrackItItemsRequest
*/
func (a *CustomerManagementAPIService) DeleteTrackItItems(ctx context.Context, hotelId string) CustomerManagementAPIDeleteTrackItItemsRequest {
	return CustomerManagementAPIDeleteTrackItItemsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CustomerManagementAPIService) DeleteTrackItItemsExecute(r CustomerManagementAPIDeleteTrackItItemsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomerManagementAPIService.DeleteTrackItItems")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/trackItems"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.trackItId != nil {
		t := *r.trackItId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "trackItId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "trackItId", t, "multi")
		}
  }
	if r.trackItIdContext != nil {
		t := *r.trackItIdContext
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "trackItIdContext", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "trackItIdContext", t, "multi")
		}
  }
	if r.trackItIdType != nil {
		t := *r.trackItIdType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "trackItIdType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "trackItIdType", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CustomerManagementAPIGetCalendarTaskRequest struct {
	ctx context.Context
	ApiService *CustomerManagementAPIService
	activityId string
	authorization *string
	xAppKey *string
	xHotelid *string
	idContext *string
	idType *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CustomerManagementAPIGetCalendarTaskRequest) Authorization(authorization string) CustomerManagementAPIGetCalendarTaskRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CustomerManagementAPIGetCalendarTaskRequest) XAppKey(xAppKey string) CustomerManagementAPIGetCalendarTaskRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CustomerManagementAPIGetCalendarTaskRequest) XHotelid(xHotelid string) CustomerManagementAPIGetCalendarTaskRequest {
	r.xHotelid = &xHotelid
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r CustomerManagementAPIGetCalendarTaskRequest) IdContext(idContext string) CustomerManagementAPIGetCalendarTaskRequest {
	r.idContext = &idContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r CustomerManagementAPIGetCalendarTaskRequest) IdType(idType string) CustomerManagementAPIGetCalendarTaskRequest {
	r.idType = &idType
	return r
}

// External system code.
func (r CustomerManagementAPIGetCalendarTaskRequest) XExternalsystem(xExternalsystem string) CustomerManagementAPIGetCalendarTaskRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CustomerManagementAPIGetCalendarTaskRequest) AcceptLanguage(acceptLanguage string) CustomerManagementAPIGetCalendarTaskRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CustomerManagementAPIGetCalendarTaskRequest) Execute() (*CalendarTask, *http.Response, error) {
	return r.ApiService.GetCalendarTaskExecute(r)
}

/*
GetCalendarTask Get a Calendar Task

With this API you can get a Calendar Task. <p><strong>OperationId:</strong>getCalendarTask</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param activityId
 @return CustomerManagementAPIGetCalendarTaskRequest
*/
func (a *CustomerManagementAPIService) GetCalendarTask(ctx context.Context, activityId string) CustomerManagementAPIGetCalendarTaskRequest {
	return CustomerManagementAPIGetCalendarTaskRequest{
		ApiService: a,
		ctx: ctx,
		activityId: activityId,
	}
}

// Execute executes the request
//  @return CalendarTask
func (a *CustomerManagementAPIService) GetCalendarTaskExecute(r CustomerManagementAPIGetCalendarTaskRequest) (*CalendarTask, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CalendarTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomerManagementAPIService.GetCalendarTask")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/activities/{activityId}/task"
	localVarPath = strings.Replace(localVarPath, "{"+"activityId"+"}", url.PathEscape(parameterValueToString(r.activityId, "activityId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.activityId) < 1 {
		return localVarReturnValue, nil, reportError("activityId must have at least 1 elements")
	}
	if strlen(r.activityId) > 2000 {
		return localVarReturnValue, nil, reportError("activityId must have less than 2000 elements")
	}

	if r.idContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", r.idContext, "")
  }
	if r.idType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idType", r.idType, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CustomerManagementAPIGetCalendarTaskAttachmentsRequest struct {
	ctx context.Context
	ApiService *CustomerManagementAPIService
	taskId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	idContext *string
	idType *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CustomerManagementAPIGetCalendarTaskAttachmentsRequest) Authorization(authorization string) CustomerManagementAPIGetCalendarTaskAttachmentsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CustomerManagementAPIGetCalendarTaskAttachmentsRequest) XAppKey(xAppKey string) CustomerManagementAPIGetCalendarTaskAttachmentsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CustomerManagementAPIGetCalendarTaskAttachmentsRequest) XHotelid(xHotelid string) CustomerManagementAPIGetCalendarTaskAttachmentsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r CustomerManagementAPIGetCalendarTaskAttachmentsRequest) IdContext(idContext string) CustomerManagementAPIGetCalendarTaskAttachmentsRequest {
	r.idContext = &idContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r CustomerManagementAPIGetCalendarTaskAttachmentsRequest) IdType(idType string) CustomerManagementAPIGetCalendarTaskAttachmentsRequest {
	r.idType = &idType
	return r
}

// External system code.
func (r CustomerManagementAPIGetCalendarTaskAttachmentsRequest) XExternalsystem(xExternalsystem string) CustomerManagementAPIGetCalendarTaskAttachmentsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CustomerManagementAPIGetCalendarTaskAttachmentsRequest) AcceptLanguage(acceptLanguage string) CustomerManagementAPIGetCalendarTaskAttachmentsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CustomerManagementAPIGetCalendarTaskAttachmentsRequest) Execute() (*CalendarTaskAttachments, *http.Response, error) {
	return r.ApiService.GetCalendarTaskAttachmentsExecute(r)
}

/*
GetCalendarTaskAttachments Get calendar task attachments

Retrieve the attachments on a Calendar task. <p><strong>OperationId:</strong>getCalendarTaskAttachments</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taskId
 @param hotelId
 @return CustomerManagementAPIGetCalendarTaskAttachmentsRequest
*/
func (a *CustomerManagementAPIService) GetCalendarTaskAttachments(ctx context.Context, taskId string, hotelId string) CustomerManagementAPIGetCalendarTaskAttachmentsRequest {
	return CustomerManagementAPIGetCalendarTaskAttachmentsRequest{
		ApiService: a,
		ctx: ctx,
		taskId: taskId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CalendarTaskAttachments
func (a *CustomerManagementAPIService) GetCalendarTaskAttachmentsExecute(r CustomerManagementAPIGetCalendarTaskAttachmentsRequest) (*CalendarTaskAttachments, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CalendarTaskAttachments
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomerManagementAPIService.GetCalendarTaskAttachments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/activities/tasks/{taskId}/attachments"
	localVarPath = strings.Replace(localVarPath, "{"+"taskId"+"}", url.PathEscape(parameterValueToString(r.taskId, "taskId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.taskId) < 1 {
		return localVarReturnValue, nil, reportError("taskId must have at least 1 elements")
	}
	if strlen(r.taskId) > 2000 {
		return localVarReturnValue, nil, reportError("taskId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.idContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", r.idContext, "")
  }
	if r.idType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idType", r.idType, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CustomerManagementAPIGetCalendarTasksRequest struct {
	ctx context.Context
	ApiService *CustomerManagementAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	countSummary *bool
	taskSummary *bool
	hotelIds *[]string
	startDate *string
	endDate *string
	duration *string
	completionStatus *string
	priorityCodes *[]string
	classCodes *[]string
	typeCodes *[]string
	purpose *string
	taskOwner *string
	author *string
	accountId *string
	accountIdContext *string
	accountIdType *string
	contactId *string
	contactIdContext *string
	contactIdType *string
	blockId *string
	blockIdContext *string
	blockIdType *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CustomerManagementAPIGetCalendarTasksRequest) Authorization(authorization string) CustomerManagementAPIGetCalendarTasksRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CustomerManagementAPIGetCalendarTasksRequest) XAppKey(xAppKey string) CustomerManagementAPIGetCalendarTasksRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CustomerManagementAPIGetCalendarTasksRequest) XHotelid(xHotelid string) CustomerManagementAPIGetCalendarTasksRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicator whether summary count will be retrieved or not.
func (r CustomerManagementAPIGetCalendarTasksRequest) CountSummary(countSummary bool) CustomerManagementAPIGetCalendarTasksRequest {
	r.countSummary = &countSummary
	return r
}

// Indicator whether task summary will be retrieved or not.
func (r CustomerManagementAPIGetCalendarTasksRequest) TaskSummary(taskSummary bool) CustomerManagementAPIGetCalendarTasksRequest {
	r.taskSummary = &taskSummary
	return r
}

// List of Hotel codes of calendar task.
func (r CustomerManagementAPIGetCalendarTasksRequest) HotelIds(hotelIds []string) CustomerManagementAPIGetCalendarTasksRequest {
	r.hotelIds = &hotelIds
	return r
}

func (r CustomerManagementAPIGetCalendarTasksRequest) StartDate(startDate string) CustomerManagementAPIGetCalendarTasksRequest {
	r.startDate = &startDate
	return r
}

func (r CustomerManagementAPIGetCalendarTasksRequest) EndDate(endDate string) CustomerManagementAPIGetCalendarTasksRequest {
	r.endDate = &endDate
	return r
}

func (r CustomerManagementAPIGetCalendarTasksRequest) Duration(duration string) CustomerManagementAPIGetCalendarTasksRequest {
	r.duration = &duration
	return r
}

// Defines completion status codes of calendar task.
func (r CustomerManagementAPIGetCalendarTasksRequest) CompletionStatus(completionStatus string) CustomerManagementAPIGetCalendarTasksRequest {
	r.completionStatus = &completionStatus
	return r
}

// List of priority levels of calendar task.
func (r CustomerManagementAPIGetCalendarTasksRequest) PriorityCodes(priorityCodes []string) CustomerManagementAPIGetCalendarTasksRequest {
	r.priorityCodes = &priorityCodes
	return r
}

// Defines classification codes of calendar task.
func (r CustomerManagementAPIGetCalendarTasksRequest) ClassCodes(classCodes []string) CustomerManagementAPIGetCalendarTasksRequest {
	r.classCodes = &classCodes
	return r
}

// List of types of calendar task based on its classification.
func (r CustomerManagementAPIGetCalendarTasksRequest) TypeCodes(typeCodes []string) CustomerManagementAPIGetCalendarTasksRequest {
	r.typeCodes = &typeCodes
	return r
}

// Brief description and purpose of calendar task.
func (r CustomerManagementAPIGetCalendarTasksRequest) Purpose(purpose string) CustomerManagementAPIGetCalendarTasksRequest {
	r.purpose = &purpose
	return r
}

// Owner code of the person to whom the calendar task is assigned.
func (r CustomerManagementAPIGetCalendarTasksRequest) TaskOwner(taskOwner string) CustomerManagementAPIGetCalendarTasksRequest {
	r.taskOwner = &taskOwner
	return r
}

// Author of the calendar task.
func (r CustomerManagementAPIGetCalendarTasksRequest) Author(author string) CustomerManagementAPIGetCalendarTasksRequest {
	r.author = &author
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r CustomerManagementAPIGetCalendarTasksRequest) AccountId(accountId string) CustomerManagementAPIGetCalendarTasksRequest {
	r.accountId = &accountId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r CustomerManagementAPIGetCalendarTasksRequest) AccountIdContext(accountIdContext string) CustomerManagementAPIGetCalendarTasksRequest {
	r.accountIdContext = &accountIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r CustomerManagementAPIGetCalendarTasksRequest) AccountIdType(accountIdType string) CustomerManagementAPIGetCalendarTasksRequest {
	r.accountIdType = &accountIdType
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r CustomerManagementAPIGetCalendarTasksRequest) ContactId(contactId string) CustomerManagementAPIGetCalendarTasksRequest {
	r.contactId = &contactId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r CustomerManagementAPIGetCalendarTasksRequest) ContactIdContext(contactIdContext string) CustomerManagementAPIGetCalendarTasksRequest {
	r.contactIdContext = &contactIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r CustomerManagementAPIGetCalendarTasksRequest) ContactIdType(contactIdType string) CustomerManagementAPIGetCalendarTasksRequest {
	r.contactIdType = &contactIdType
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r CustomerManagementAPIGetCalendarTasksRequest) BlockId(blockId string) CustomerManagementAPIGetCalendarTasksRequest {
	r.blockId = &blockId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r CustomerManagementAPIGetCalendarTasksRequest) BlockIdContext(blockIdContext string) CustomerManagementAPIGetCalendarTasksRequest {
	r.blockIdContext = &blockIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r CustomerManagementAPIGetCalendarTasksRequest) BlockIdType(blockIdType string) CustomerManagementAPIGetCalendarTasksRequest {
	r.blockIdType = &blockIdType
	return r
}

// External system code.
func (r CustomerManagementAPIGetCalendarTasksRequest) XExternalsystem(xExternalsystem string) CustomerManagementAPIGetCalendarTasksRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CustomerManagementAPIGetCalendarTasksRequest) AcceptLanguage(acceptLanguage string) CustomerManagementAPIGetCalendarTasksRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CustomerManagementAPIGetCalendarTasksRequest) Execute() (*CalendarTasks, *http.Response, error) {
	return r.ApiService.GetCalendarTasksExecute(r)
}

/*
GetCalendarTasks Get Calendar Tasks

You can fetch a list of Calendar Tasks for with this API, for one or more properties. <p><strong>OperationId:</strong>getCalendarTasks</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CustomerManagementAPIGetCalendarTasksRequest
*/
func (a *CustomerManagementAPIService) GetCalendarTasks(ctx context.Context) CustomerManagementAPIGetCalendarTasksRequest {
	return CustomerManagementAPIGetCalendarTasksRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CalendarTasks
func (a *CustomerManagementAPIService) GetCalendarTasksExecute(r CustomerManagementAPIGetCalendarTasksRequest) (*CalendarTasks, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CalendarTasks
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomerManagementAPIService.GetCalendarTasks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/activities/tasks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.countSummary != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "countSummary", r.countSummary, "")
  }
	if r.taskSummary != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "taskSummary", r.taskSummary, "")
  }
	if r.hotelIds != nil {
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
  }
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
  }
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
  }
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration", r.duration, "")
  }
	if r.completionStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "completionStatus", r.completionStatus, "")
  }
	if r.priorityCodes != nil {
		t := *r.priorityCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "priorityCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "priorityCodes", t, "multi")
		}
  }
	if r.classCodes != nil {
		t := *r.classCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "classCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "classCodes", t, "multi")
		}
  }
	if r.typeCodes != nil {
		t := *r.typeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "typeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "typeCodes", t, "multi")
		}
  }
	if r.purpose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "purpose", r.purpose, "")
  }
	if r.taskOwner != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "taskOwner", r.taskOwner, "")
  }
	if r.author != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "author", r.author, "")
  }
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "")
  }
	if r.accountIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountIdContext", r.accountIdContext, "")
  }
	if r.accountIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountIdType", r.accountIdType, "")
  }
	if r.contactId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "contactId", r.contactId, "")
  }
	if r.contactIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "contactIdContext", r.contactIdContext, "")
  }
	if r.contactIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "contactIdType", r.contactIdType, "")
  }
	if r.blockId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blockId", r.blockId, "")
  }
	if r.blockIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blockIdContext", r.blockIdContext, "")
  }
	if r.blockIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blockIdType", r.blockIdType, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CustomerManagementAPIGetTrackItItemsRequest struct {
	ctx context.Context
	ApiService *CustomerManagementAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	ticketId *string
	reservationId *string
	reservationIdContext *string
	reservationIdType *string
	givenName *string
	surname *string
	trackItGroups *[]string
	types *[]string
	locations *[]string
	actions *[]string
	actionStatuses *[]string
	appUserId *string
	appUserIdContext *string
	appUserIdType *string
	assignedStatuses *[]string
	room *string
	followUpDate *string
	createdOn *string
	createdByUserId *string
	createdByUserIdContext *string
	createdByUserIdType *string
	description *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CustomerManagementAPIGetTrackItItemsRequest) Authorization(authorization string) CustomerManagementAPIGetTrackItItemsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CustomerManagementAPIGetTrackItItemsRequest) XAppKey(xAppKey string) CustomerManagementAPIGetTrackItItemsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CustomerManagementAPIGetTrackItItemsRequest) XHotelid(xHotelid string) CustomerManagementAPIGetTrackItItemsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Complete ticket number of the Track It item.
func (r CustomerManagementAPIGetTrackItItemsRequest) TicketId(ticketId string) CustomerManagementAPIGetTrackItItemsRequest {
	r.ticketId = &ticketId
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r CustomerManagementAPIGetTrackItItemsRequest) ReservationId(reservationId string) CustomerManagementAPIGetTrackItItemsRequest {
	r.reservationId = &reservationId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r CustomerManagementAPIGetTrackItItemsRequest) ReservationIdContext(reservationIdContext string) CustomerManagementAPIGetTrackItItemsRequest {
	r.reservationIdContext = &reservationIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r CustomerManagementAPIGetTrackItItemsRequest) ReservationIdType(reservationIdType string) CustomerManagementAPIGetTrackItItemsRequest {
	r.reservationIdType = &reservationIdType
	return r
}

// Given name, first name or names.
func (r CustomerManagementAPIGetTrackItItemsRequest) GivenName(givenName string) CustomerManagementAPIGetTrackItItemsRequest {
	r.givenName = &givenName
	return r
}

// Family name, last name. May also be used for full name if the sending system does not have the ability to separate a full name into its parts, e.g. the surname element may be used to pass the full name.
func (r CustomerManagementAPIGetTrackItItemsRequest) Surname(surname string) CustomerManagementAPIGetTrackItItemsRequest {
	r.surname = &surname
	return r
}

// Group to which the Track It items belong.
func (r CustomerManagementAPIGetTrackItItemsRequest) TrackItGroups(trackItGroups []string) CustomerManagementAPIGetTrackItItemsRequest {
	r.trackItGroups = &trackItGroups
	return r
}

// Track It types based on the Track It group.
func (r CustomerManagementAPIGetTrackItItemsRequest) Types(types []string) CustomerManagementAPIGetTrackItItemsRequest {
	r.types = &types
	return r
}

// Locations for Track It location.
func (r CustomerManagementAPIGetTrackItItemsRequest) Locations(locations []string) CustomerManagementAPIGetTrackItItemsRequest {
	r.locations = &locations
	return r
}

// Track It actions based on Track It groups.
func (r CustomerManagementAPIGetTrackItItemsRequest) Actions(actions []string) CustomerManagementAPIGetTrackItItemsRequest {
	r.actions = &actions
	return r
}

// Action status of the Track It item(Open, Closed).
func (r CustomerManagementAPIGetTrackItItemsRequest) ActionStatuses(actionStatuses []string) CustomerManagementAPIGetTrackItItemsRequest {
	r.actionStatuses = &actionStatuses
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r CustomerManagementAPIGetTrackItItemsRequest) AppUserId(appUserId string) CustomerManagementAPIGetTrackItItemsRequest {
	r.appUserId = &appUserId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r CustomerManagementAPIGetTrackItItemsRequest) AppUserIdContext(appUserIdContext string) CustomerManagementAPIGetTrackItItemsRequest {
	r.appUserIdContext = &appUserIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r CustomerManagementAPIGetTrackItItemsRequest) AppUserIdType(appUserIdType string) CustomerManagementAPIGetTrackItItemsRequest {
	r.appUserIdType = &appUserIdType
	return r
}

// Assignment status of the Track It item(Assigned, Unassigned).
func (r CustomerManagementAPIGetTrackItItemsRequest) AssignedStatuses(assignedStatuses []string) CustomerManagementAPIGetTrackItItemsRequest {
	r.assignedStatuses = &assignedStatuses
	return r
}

// Guest&#39;s room number if ticket associated with a reservation.
func (r CustomerManagementAPIGetTrackItItemsRequest) Room(room string) CustomerManagementAPIGetTrackItItemsRequest {
	r.room = &room
	return r
}

// Follow up date for the ticket.
func (r CustomerManagementAPIGetTrackItItemsRequest) FollowUpDate(followUpDate string) CustomerManagementAPIGetTrackItItemsRequest {
	r.followUpDate = &followUpDate
	return r
}

// Date when the ticket was created.
func (r CustomerManagementAPIGetTrackItItemsRequest) CreatedOn(createdOn string) CustomerManagementAPIGetTrackItItemsRequest {
	r.createdOn = &createdOn
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r CustomerManagementAPIGetTrackItItemsRequest) CreatedByUserId(createdByUserId string) CustomerManagementAPIGetTrackItItemsRequest {
	r.createdByUserId = &createdByUserId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r CustomerManagementAPIGetTrackItItemsRequest) CreatedByUserIdContext(createdByUserIdContext string) CustomerManagementAPIGetTrackItItemsRequest {
	r.createdByUserIdContext = &createdByUserIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r CustomerManagementAPIGetTrackItItemsRequest) CreatedByUserIdType(createdByUserIdType string) CustomerManagementAPIGetTrackItItemsRequest {
	r.createdByUserIdType = &createdByUserIdType
	return r
}

// Description associated with the Track It item.
func (r CustomerManagementAPIGetTrackItItemsRequest) Description(description string) CustomerManagementAPIGetTrackItItemsRequest {
	r.description = &description
	return r
}

// External system code.
func (r CustomerManagementAPIGetTrackItItemsRequest) XExternalsystem(xExternalsystem string) CustomerManagementAPIGetTrackItItemsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CustomerManagementAPIGetTrackItItemsRequest) AcceptLanguage(acceptLanguage string) CustomerManagementAPIGetTrackItItemsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CustomerManagementAPIGetTrackItItemsRequest) Execute() (*TrackItItems, *http.Response, error) {
	return r.ApiService.GetTrackItItemsExecute(r)
}

/*
GetTrackItItems Fetches track it items

Retrieve a list of all Track It Items for a property. <p><strong>OperationId:</strong>getTrackItItems</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId
 @return CustomerManagementAPIGetTrackItItemsRequest
*/
func (a *CustomerManagementAPIService) GetTrackItItems(ctx context.Context, hotelId string) CustomerManagementAPIGetTrackItItemsRequest {
	return CustomerManagementAPIGetTrackItItemsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return TrackItItems
func (a *CustomerManagementAPIService) GetTrackItItemsExecute(r CustomerManagementAPIGetTrackItItemsRequest) (*TrackItItems, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TrackItItems
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomerManagementAPIService.GetTrackItItems")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/trackItems"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.ticketId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ticketId", r.ticketId, "")
  }
	if r.reservationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationId", r.reservationId, "")
  }
	if r.reservationIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIdContext", r.reservationIdContext, "")
  }
	if r.reservationIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIdType", r.reservationIdType, "")
  }
	if r.givenName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "givenName", r.givenName, "")
  }
	if r.surname != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "surname", r.surname, "")
  }
	if r.trackItGroups != nil {
		t := *r.trackItGroups
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "trackItGroups", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "trackItGroups", t, "multi")
		}
  }
	if r.types != nil {
		t := *r.types
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "types", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "types", t, "multi")
		}
  }
	if r.locations != nil {
		t := *r.locations
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "locations", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "locations", t, "multi")
		}
  }
	if r.actions != nil {
		t := *r.actions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "actions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "actions", t, "multi")
		}
  }
	if r.actionStatuses != nil {
		t := *r.actionStatuses
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "actionStatuses", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "actionStatuses", t, "multi")
		}
  }
	if r.appUserId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appUserId", r.appUserId, "")
  }
	if r.appUserIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appUserIdContext", r.appUserIdContext, "")
  }
	if r.appUserIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appUserIdType", r.appUserIdType, "")
  }
	if r.assignedStatuses != nil {
		t := *r.assignedStatuses
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "assignedStatuses", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "assignedStatuses", t, "multi")
		}
  }
	if r.room != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "room", r.room, "")
  }
	if r.followUpDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "followUpDate", r.followUpDate, "")
  }
	if r.createdOn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createdOn", r.createdOn, "")
  }
	if r.createdByUserId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createdByUserId", r.createdByUserId, "")
  }
	if r.createdByUserIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createdByUserIdContext", r.createdByUserIdContext, "")
  }
	if r.createdByUserIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createdByUserIdType", r.createdByUserIdType, "")
  }
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CustomerManagementAPIPostCalendarTaskRequest struct {
	ctx context.Context
	ApiService *CustomerManagementAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	calendarTask *CalendarTask
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CustomerManagementAPIPostCalendarTaskRequest) Authorization(authorization string) CustomerManagementAPIPostCalendarTaskRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CustomerManagementAPIPostCalendarTaskRequest) XAppKey(xAppKey string) CustomerManagementAPIPostCalendarTaskRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CustomerManagementAPIPostCalendarTaskRequest) XHotelid(xHotelid string) CustomerManagementAPIPostCalendarTaskRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to create calendar task.
func (r CustomerManagementAPIPostCalendarTaskRequest) CalendarTask(calendarTask CalendarTask) CustomerManagementAPIPostCalendarTaskRequest {
	r.calendarTask = &calendarTask
	return r
}

// External system code.
func (r CustomerManagementAPIPostCalendarTaskRequest) XExternalsystem(xExternalsystem string) CustomerManagementAPIPostCalendarTaskRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CustomerManagementAPIPostCalendarTaskRequest) AcceptLanguage(acceptLanguage string) CustomerManagementAPIPostCalendarTaskRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CustomerManagementAPIPostCalendarTaskRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostCalendarTaskExecute(r)
}

/*
PostCalendarTask Create Calendar Task

This API will allow you to create a new Calendar Task. <p><strong>OperationId:</strong>postCalendarTask</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId
 @return CustomerManagementAPIPostCalendarTaskRequest
*/
func (a *CustomerManagementAPIService) PostCalendarTask(ctx context.Context, hotelId string) CustomerManagementAPIPostCalendarTaskRequest {
	return CustomerManagementAPIPostCalendarTaskRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CustomerManagementAPIService) PostCalendarTaskExecute(r CustomerManagementAPIPostCalendarTaskRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomerManagementAPIService.PostCalendarTask")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/activities/task"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.calendarTask
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CustomerManagementAPIPostTrackItItemsRequest struct {
	ctx context.Context
	ApiService *CustomerManagementAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	trackItItems *TrackItItems
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CustomerManagementAPIPostTrackItItemsRequest) Authorization(authorization string) CustomerManagementAPIPostTrackItItemsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CustomerManagementAPIPostTrackItItemsRequest) XAppKey(xAppKey string) CustomerManagementAPIPostTrackItItemsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CustomerManagementAPIPostTrackItItemsRequest) XHotelid(xHotelid string) CustomerManagementAPIPostTrackItItemsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to create Track It items.
func (r CustomerManagementAPIPostTrackItItemsRequest) TrackItItems(trackItItems TrackItItems) CustomerManagementAPIPostTrackItItemsRequest {
	r.trackItItems = &trackItItems
	return r
}

// External system code.
func (r CustomerManagementAPIPostTrackItItemsRequest) XExternalsystem(xExternalsystem string) CustomerManagementAPIPostTrackItItemsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CustomerManagementAPIPostTrackItItemsRequest) AcceptLanguage(acceptLanguage string) CustomerManagementAPIPostTrackItItemsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CustomerManagementAPIPostTrackItItemsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostTrackItItemsExecute(r)
}

/*
PostTrackItItems Creates track it items

Create a new Track It Item. Track It manages storage and delivery of guest luggage, parcels, vehicles (valet), and lost items.  They can optionally be linked to a reservation if related or an arrival, in-house or departure reservation. <p><strong>OperationId:</strong>postTrackItItems</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId
 @return CustomerManagementAPIPostTrackItItemsRequest
*/
func (a *CustomerManagementAPIService) PostTrackItItems(ctx context.Context, hotelId string) CustomerManagementAPIPostTrackItItemsRequest {
	return CustomerManagementAPIPostTrackItItemsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CustomerManagementAPIService) PostTrackItItemsExecute(r CustomerManagementAPIPostTrackItItemsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomerManagementAPIService.PostTrackItItems")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/trackItems"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.trackItItems
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CustomerManagementAPIPutCalendarTaskRequest struct {
	ctx context.Context
	ApiService *CustomerManagementAPIService
	activityId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	calendarTask *CalendarTask
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CustomerManagementAPIPutCalendarTaskRequest) Authorization(authorization string) CustomerManagementAPIPutCalendarTaskRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CustomerManagementAPIPutCalendarTaskRequest) XAppKey(xAppKey string) CustomerManagementAPIPutCalendarTaskRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CustomerManagementAPIPutCalendarTaskRequest) XHotelid(xHotelid string) CustomerManagementAPIPutCalendarTaskRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to update calendar task.
func (r CustomerManagementAPIPutCalendarTaskRequest) CalendarTask(calendarTask CalendarTask) CustomerManagementAPIPutCalendarTaskRequest {
	r.calendarTask = &calendarTask
	return r
}

// External system code.
func (r CustomerManagementAPIPutCalendarTaskRequest) XExternalsystem(xExternalsystem string) CustomerManagementAPIPutCalendarTaskRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CustomerManagementAPIPutCalendarTaskRequest) AcceptLanguage(acceptLanguage string) CustomerManagementAPIPutCalendarTaskRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CustomerManagementAPIPutCalendarTaskRequest) Execute() (*CalendarTask, *http.Response, error) {
	return r.ApiService.PutCalendarTaskExecute(r)
}

/*
PutCalendarTask Update Calendar Task

This API will allow you to update an existing Calendar Task. <p><strong>OperationId:</strong>putCalendarTask</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param activityId
 @param hotelId
 @return CustomerManagementAPIPutCalendarTaskRequest
*/
func (a *CustomerManagementAPIService) PutCalendarTask(ctx context.Context, activityId string, hotelId string) CustomerManagementAPIPutCalendarTaskRequest {
	return CustomerManagementAPIPutCalendarTaskRequest{
		ApiService: a,
		ctx: ctx,
		activityId: activityId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CalendarTask
func (a *CustomerManagementAPIService) PutCalendarTaskExecute(r CustomerManagementAPIPutCalendarTaskRequest) (*CalendarTask, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CalendarTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomerManagementAPIService.PutCalendarTask")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/activities/{activityId}/task"
	localVarPath = strings.Replace(localVarPath, "{"+"activityId"+"}", url.PathEscape(parameterValueToString(r.activityId, "activityId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.activityId) < 1 {
		return localVarReturnValue, nil, reportError("activityId must have at least 1 elements")
	}
	if strlen(r.activityId) > 2000 {
		return localVarReturnValue, nil, reportError("activityId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.calendarTask
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CustomerManagementAPIPutTrackItItemsRequest struct {
	ctx context.Context
	ApiService *CustomerManagementAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	trackItItems *TrackItItems
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CustomerManagementAPIPutTrackItItemsRequest) Authorization(authorization string) CustomerManagementAPIPutTrackItItemsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CustomerManagementAPIPutTrackItItemsRequest) XAppKey(xAppKey string) CustomerManagementAPIPutTrackItItemsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CustomerManagementAPIPutTrackItItemsRequest) XHotelid(xHotelid string) CustomerManagementAPIPutTrackItItemsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to update Track It items.
func (r CustomerManagementAPIPutTrackItItemsRequest) TrackItItems(trackItItems TrackItItems) CustomerManagementAPIPutTrackItItemsRequest {
	r.trackItItems = &trackItItems
	return r
}

// External system code.
func (r CustomerManagementAPIPutTrackItItemsRequest) XExternalsystem(xExternalsystem string) CustomerManagementAPIPutTrackItItemsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CustomerManagementAPIPutTrackItItemsRequest) AcceptLanguage(acceptLanguage string) CustomerManagementAPIPutTrackItItemsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CustomerManagementAPIPutTrackItItemsRequest) Execute() (*TrackItItems, *http.Response, error) {
	return r.ApiService.PutTrackItItemsExecute(r)
}

/*
PutTrackItItems Updates track it items

Update the details of a Track It Item for a property. <p><strong>OperationId:</strong>putTrackItItems</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId
 @return CustomerManagementAPIPutTrackItItemsRequest
*/
func (a *CustomerManagementAPIService) PutTrackItItems(ctx context.Context, hotelId string) CustomerManagementAPIPutTrackItItemsRequest {
	return CustomerManagementAPIPutTrackItItemsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return TrackItItems
func (a *CustomerManagementAPIService) PutTrackItItemsExecute(r CustomerManagementAPIPutTrackItItemsRequest) (*TrackItItems, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TrackItItems
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomerManagementAPIService.PutTrackItItems")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/trackItems"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.trackItItems
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
