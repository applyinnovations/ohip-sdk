/*
OPERA Cloud List of Values Management API

APIs to cater for List of Value functionality in OPERA Cloud. A List of Values in the OPERA Application can be configured by a property.  Then by using these APIs you can retrieve all configured codes.  As an example, Titles is a configurable ListOfValues.  A hotel can specify what titles they wish to use, and thus fetching the LOV for title, you can view the codes that are configured for a property.<br /><br /> Compatible with OPERA Cloud release 22.3.<br /><br /><p> This document and all content within is available under the Universal Permissive License v 1.0 (https://oss.oracle.com/licenses/upl). Copyright (c) 2020, 2023 Oracle and/or its affiliates.</p>

API version: 22.3
Contact: hospitality_apis_ww_grp@oracle.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package lov

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// LOVApiService LOVApi service
type LOVApiService service

type LOVApiGetADSEchoTokenLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	errorType string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetADSEchoTokenLOVRequest) Authorization(authorization string) LOVApiGetADSEchoTokenLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetADSEchoTokenLOVRequest) XAppKey(xAppKey string) LOVApiGetADSEchoTokenLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetADSEchoTokenLOVRequest) XHotelid(xHotelid string) LOVApiGetADSEchoTokenLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetADSEchoTokenLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetADSEchoTokenLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetADSEchoTokenLOVRequest) ParameterName(parameterName []string) LOVApiGetADSEchoTokenLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetADSEchoTokenLOVRequest) ParameterValue(parameterValue []string) LOVApiGetADSEchoTokenLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetADSEchoTokenLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetADSEchoTokenLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetADSEchoTokenLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetADSEchoTokenLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetADSEchoTokenLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetADSEchoTokenLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetADSEchoTokenLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetADSEchoTokenLOVExecute(r)
}

/*
GetADSEchoTokenLOV Fetch List Of Values for ADSEcho Token

 <p><strong>OperationId:</strong>getADSEchoTokenLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param errorType Value of the parameter 'errorType' which is required to fetch ADSEchoToken LOV
 @return LOVApiGetADSEchoTokenLOVRequest
*/
func (a *LOVApiService) GetADSEchoTokenLOV(ctx context.Context, errorType string) LOVApiGetADSEchoTokenLOVRequest {
	return LOVApiGetADSEchoTokenLOVRequest{
		ApiService: a,
		ctx: ctx,
		errorType: errorType,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetADSEchoTokenLOVExecute(r LOVApiGetADSEchoTokenLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetADSEchoTokenLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/errorType/{errorType}/adsEchoToken"
	localVarPath = strings.Replace(localVarPath, "{"+"errorType"+"}", url.PathEscape(parameterValueToString(r.errorType, "errorType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.errorType) < 1 {
		return localVarReturnValue, nil, reportError("errorType must have at least 1 elements")
	}
	if strlen(r.errorType) > 2000 {
		return localVarReturnValue, nil, reportError("errorType must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetADSStatusLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	errorType string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetADSStatusLOVRequest) Authorization(authorization string) LOVApiGetADSStatusLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetADSStatusLOVRequest) XAppKey(xAppKey string) LOVApiGetADSStatusLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetADSStatusLOVRequest) XHotelid(xHotelid string) LOVApiGetADSStatusLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetADSStatusLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetADSStatusLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetADSStatusLOVRequest) ParameterName(parameterName []string) LOVApiGetADSStatusLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetADSStatusLOVRequest) ParameterValue(parameterValue []string) LOVApiGetADSStatusLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetADSStatusLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetADSStatusLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetADSStatusLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetADSStatusLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetADSStatusLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetADSStatusLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetADSStatusLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetADSStatusLOVExecute(r)
}

/*
GetADSStatusLOV Fetch List Of Values for ADSStatus

 <p><strong>OperationId:</strong>getADSStatusLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param errorType Value of the parameter 'errorType' which is required to fetch ADSStatus LOV
 @return LOVApiGetADSStatusLOVRequest
*/
func (a *LOVApiService) GetADSStatusLOV(ctx context.Context, errorType string) LOVApiGetADSStatusLOVRequest {
	return LOVApiGetADSStatusLOVRequest{
		ApiService: a,
		ctx: ctx,
		errorType: errorType,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetADSStatusLOVExecute(r LOVApiGetADSStatusLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetADSStatusLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/errorType/{errorType}/adsStatus"
	localVarPath = strings.Replace(localVarPath, "{"+"errorType"+"}", url.PathEscape(parameterValueToString(r.errorType, "errorType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.errorType) < 1 {
		return localVarReturnValue, nil, reportError("errorType must have at least 1 elements")
	}
	if strlen(r.errorType) > 2000 {
		return localVarReturnValue, nil, reportError("errorType must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetARAccountTypesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetARAccountTypesLOVRequest) Authorization(authorization string) LOVApiGetARAccountTypesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetARAccountTypesLOVRequest) XAppKey(xAppKey string) LOVApiGetARAccountTypesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetARAccountTypesLOVRequest) XHotelid(xHotelid string) LOVApiGetARAccountTypesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetARAccountTypesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetARAccountTypesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetARAccountTypesLOVRequest) ParameterName(parameterName []string) LOVApiGetARAccountTypesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetARAccountTypesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetARAccountTypesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetARAccountTypesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetARAccountTypesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetARAccountTypesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetARAccountTypesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetARAccountTypesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetARAccountTypesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetARAccountTypesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetARAccountTypesLOVExecute(r)
}

/*
GetARAccountTypesLOV Fetch List Of Values for ARAccount Types

 <p><strong>OperationId:</strong>getARAccountTypesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ARAccountTypes LOV
 @return LOVApiGetARAccountTypesLOVRequest
*/
func (a *LOVApiService) GetARAccountTypesLOV(ctx context.Context, hotelId string) LOVApiGetARAccountTypesLOVRequest {
	return LOVApiGetARAccountTypesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetARAccountTypesLOVExecute(r LOVApiGetARAccountTypesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetARAccountTypesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/arAccountTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetARCreditCardsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetARCreditCardsLOVRequest) Authorization(authorization string) LOVApiGetARCreditCardsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetARCreditCardsLOVRequest) XAppKey(xAppKey string) LOVApiGetARCreditCardsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetARCreditCardsLOVRequest) XHotelid(xHotelid string) LOVApiGetARCreditCardsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetARCreditCardsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetARCreditCardsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetARCreditCardsLOVRequest) ParameterName(parameterName []string) LOVApiGetARCreditCardsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetARCreditCardsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetARCreditCardsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetARCreditCardsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetARCreditCardsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetARCreditCardsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetARCreditCardsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetARCreditCardsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetARCreditCardsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetARCreditCardsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetARCreditCardsLOVExecute(r)
}

/*
GetARCreditCardsLOV Fetch List Of Values for ARCredit Cards

 <p><strong>OperationId:</strong>getARCreditCardsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ARCreditCards LOV
 @return LOVApiGetARCreditCardsLOVRequest
*/
func (a *LOVApiService) GetARCreditCardsLOV(ctx context.Context, hotelId string) LOVApiGetARCreditCardsLOVRequest {
	return LOVApiGetARCreditCardsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetARCreditCardsLOVExecute(r LOVApiGetARCreditCardsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetARCreditCardsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/arCreditCards"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetActionTypesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	module string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetActionTypesLOVRequest) Authorization(authorization string) LOVApiGetActionTypesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetActionTypesLOVRequest) XAppKey(xAppKey string) LOVApiGetActionTypesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetActionTypesLOVRequest) XHotelid(xHotelid string) LOVApiGetActionTypesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetActionTypesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetActionTypesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetActionTypesLOVRequest) ParameterName(parameterName []string) LOVApiGetActionTypesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetActionTypesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetActionTypesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetActionTypesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetActionTypesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetActionTypesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetActionTypesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetActionTypesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetActionTypesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetActionTypesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetActionTypesLOVExecute(r)
}

/*
GetActionTypesLOV Fetch List Of Values for Action Types

 <p><strong>OperationId:</strong>getActionTypesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param module Value of the parameter 'module' which is required to fetch ActionTypes LOV
 @return LOVApiGetActionTypesLOVRequest
*/
func (a *LOVApiService) GetActionTypesLOV(ctx context.Context, module string) LOVApiGetActionTypesLOVRequest {
	return LOVApiGetActionTypesLOVRequest{
		ApiService: a,
		ctx: ctx,
		module: module,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetActionTypesLOVExecute(r LOVApiGetActionTypesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetActionTypesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/module/{module}/actionTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"module"+"}", url.PathEscape(parameterValueToString(r.module, "module")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.module) < 1 {
		return localVarReturnValue, nil, reportError("module must have at least 1 elements")
	}
	if strlen(r.module) > 2000 {
		return localVarReturnValue, nil, reportError("module must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetActivitiesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetActivitiesLOVRequest) Authorization(authorization string) LOVApiGetActivitiesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetActivitiesLOVRequest) XAppKey(xAppKey string) LOVApiGetActivitiesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetActivitiesLOVRequest) XHotelid(xHotelid string) LOVApiGetActivitiesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetActivitiesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetActivitiesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetActivitiesLOVRequest) ParameterName(parameterName []string) LOVApiGetActivitiesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetActivitiesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetActivitiesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetActivitiesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetActivitiesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetActivitiesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetActivitiesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetActivitiesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetActivitiesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetActivitiesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetActivitiesLOVExecute(r)
}

/*
GetActivitiesLOV Fetch List Of Values for Activities

 <p><strong>OperationId:</strong>getActivitiesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch Activities LOV
 @return LOVApiGetActivitiesLOVRequest
*/
func (a *LOVApiService) GetActivitiesLOV(ctx context.Context, hotelId string) LOVApiGetActivitiesLOVRequest {
	return LOVApiGetActivitiesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetActivitiesLOVExecute(r LOVApiGetActivitiesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetActivitiesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/activities"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetActivityConfigTypesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetActivityConfigTypesLOVRequest) Authorization(authorization string) LOVApiGetActivityConfigTypesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetActivityConfigTypesLOVRequest) XAppKey(xAppKey string) LOVApiGetActivityConfigTypesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetActivityConfigTypesLOVRequest) XHotelid(xHotelid string) LOVApiGetActivityConfigTypesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetActivityConfigTypesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetActivityConfigTypesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetActivityConfigTypesLOVRequest) ParameterName(parameterName []string) LOVApiGetActivityConfigTypesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetActivityConfigTypesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetActivityConfigTypesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetActivityConfigTypesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetActivityConfigTypesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetActivityConfigTypesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetActivityConfigTypesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetActivityConfigTypesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetActivityConfigTypesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetActivityConfigTypesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetActivityConfigTypesLOVExecute(r)
}

/*
GetActivityConfigTypesLOV Fetch List Of Values for Activity Config Types

 <p><strong>OperationId:</strong>getActivityConfigTypesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ActivityConfigTypes LOV
 @return LOVApiGetActivityConfigTypesLOVRequest
*/
func (a *LOVApiService) GetActivityConfigTypesLOV(ctx context.Context, hotelId string) LOVApiGetActivityConfigTypesLOVRequest {
	return LOVApiGetActivityConfigTypesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetActivityConfigTypesLOVExecute(r LOVApiGetActivityConfigTypesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetActivityConfigTypesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/activityConfigTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetActivityLocationsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetActivityLocationsLOVRequest) Authorization(authorization string) LOVApiGetActivityLocationsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetActivityLocationsLOVRequest) XAppKey(xAppKey string) LOVApiGetActivityLocationsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetActivityLocationsLOVRequest) XHotelid(xHotelid string) LOVApiGetActivityLocationsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetActivityLocationsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetActivityLocationsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetActivityLocationsLOVRequest) ParameterName(parameterName []string) LOVApiGetActivityLocationsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetActivityLocationsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetActivityLocationsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetActivityLocationsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetActivityLocationsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetActivityLocationsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetActivityLocationsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetActivityLocationsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetActivityLocationsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetActivityLocationsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetActivityLocationsLOVExecute(r)
}

/*
GetActivityLocationsLOV Fetch List Of Values for Activity Locations

 <p><strong>OperationId:</strong>getActivityLocationsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ActivityLocations LOV
 @return LOVApiGetActivityLocationsLOVRequest
*/
func (a *LOVApiService) GetActivityLocationsLOV(ctx context.Context, hotelId string) LOVApiGetActivityLocationsLOVRequest {
	return LOVApiGetActivityLocationsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetActivityLocationsLOVExecute(r LOVApiGetActivityLocationsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetActivityLocationsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/activityLocations"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetActivityStatusLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetActivityStatusLOVRequest) Authorization(authorization string) LOVApiGetActivityStatusLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetActivityStatusLOVRequest) XAppKey(xAppKey string) LOVApiGetActivityStatusLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetActivityStatusLOVRequest) XHotelid(xHotelid string) LOVApiGetActivityStatusLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetActivityStatusLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetActivityStatusLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetActivityStatusLOVRequest) ParameterName(parameterName []string) LOVApiGetActivityStatusLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetActivityStatusLOVRequest) ParameterValue(parameterValue []string) LOVApiGetActivityStatusLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetActivityStatusLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetActivityStatusLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetActivityStatusLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetActivityStatusLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetActivityStatusLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetActivityStatusLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetActivityStatusLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetActivityStatusLOVExecute(r)
}

/*
GetActivityStatusLOV Fetch List Of Values for Activity Status

 <p><strong>OperationId:</strong>getActivityStatusLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ActivityStatus LOV
 @return LOVApiGetActivityStatusLOVRequest
*/
func (a *LOVApiService) GetActivityStatusLOV(ctx context.Context, hotelId string) LOVApiGetActivityStatusLOVRequest {
	return LOVApiGetActivityStatusLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetActivityStatusLOVExecute(r LOVApiGetActivityStatusLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetActivityStatusLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/activityStatus"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetActivityTypesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetActivityTypesLOVRequest) Authorization(authorization string) LOVApiGetActivityTypesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetActivityTypesLOVRequest) XAppKey(xAppKey string) LOVApiGetActivityTypesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetActivityTypesLOVRequest) XHotelid(xHotelid string) LOVApiGetActivityTypesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetActivityTypesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetActivityTypesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetActivityTypesLOVRequest) ParameterName(parameterName []string) LOVApiGetActivityTypesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetActivityTypesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetActivityTypesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetActivityTypesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetActivityTypesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetActivityTypesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetActivityTypesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetActivityTypesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetActivityTypesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetActivityTypesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetActivityTypesLOVExecute(r)
}

/*
GetActivityTypesLOV Fetch List Of Values for Activity Types

 <p><strong>OperationId:</strong>getActivityTypesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ActivityTypes LOV
 @return LOVApiGetActivityTypesLOVRequest
*/
func (a *LOVApiService) GetActivityTypesLOV(ctx context.Context, hotelId string) LOVApiGetActivityTypesLOVRequest {
	return LOVApiGetActivityTypesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetActivityTypesLOVExecute(r LOVApiGetActivityTypesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetActivityTypesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/activityTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetAddressFormatElementsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	salesFormat string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetAddressFormatElementsLOVRequest) Authorization(authorization string) LOVApiGetAddressFormatElementsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetAddressFormatElementsLOVRequest) XAppKey(xAppKey string) LOVApiGetAddressFormatElementsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetAddressFormatElementsLOVRequest) XHotelid(xHotelid string) LOVApiGetAddressFormatElementsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetAddressFormatElementsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetAddressFormatElementsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetAddressFormatElementsLOVRequest) ParameterName(parameterName []string) LOVApiGetAddressFormatElementsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetAddressFormatElementsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetAddressFormatElementsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetAddressFormatElementsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetAddressFormatElementsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetAddressFormatElementsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetAddressFormatElementsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetAddressFormatElementsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetAddressFormatElementsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetAddressFormatElementsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetAddressFormatElementsLOVExecute(r)
}

/*
GetAddressFormatElementsLOV Fetch List Of Values for Address Format Elements

 <p><strong>OperationId:</strong>getAddressFormatElementsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param salesFormat Value of the parameter 'salesFormat' which is required to fetch AddressFormatElements LOV
 @return LOVApiGetAddressFormatElementsLOVRequest
*/
func (a *LOVApiService) GetAddressFormatElementsLOV(ctx context.Context, salesFormat string) LOVApiGetAddressFormatElementsLOVRequest {
	return LOVApiGetAddressFormatElementsLOVRequest{
		ApiService: a,
		ctx: ctx,
		salesFormat: salesFormat,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetAddressFormatElementsLOVExecute(r LOVApiGetAddressFormatElementsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetAddressFormatElementsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/salesFormat/{salesFormat}/addressFormatElements"
	localVarPath = strings.Replace(localVarPath, "{"+"salesFormat"+"}", url.PathEscape(parameterValueToString(r.salesFormat, "salesFormat")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.salesFormat) < 1 {
		return localVarReturnValue, nil, reportError("salesFormat must have at least 1 elements")
	}
	if strlen(r.salesFormat) > 2000 {
		return localVarReturnValue, nil, reportError("salesFormat must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetAgentAccountsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetAgentAccountsLOVRequest) Authorization(authorization string) LOVApiGetAgentAccountsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetAgentAccountsLOVRequest) XAppKey(xAppKey string) LOVApiGetAgentAccountsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetAgentAccountsLOVRequest) XHotelid(xHotelid string) LOVApiGetAgentAccountsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetAgentAccountsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetAgentAccountsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetAgentAccountsLOVRequest) ParameterName(parameterName []string) LOVApiGetAgentAccountsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetAgentAccountsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetAgentAccountsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetAgentAccountsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetAgentAccountsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetAgentAccountsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetAgentAccountsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetAgentAccountsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetAgentAccountsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetAgentAccountsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetAgentAccountsLOVExecute(r)
}

/*
GetAgentAccountsLOV Fetch List Of Values for Agent Accounts

 <p><strong>OperationId:</strong>getAgentAccountsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch AgentAccounts LOV
 @return LOVApiGetAgentAccountsLOVRequest
*/
func (a *LOVApiService) GetAgentAccountsLOV(ctx context.Context, hotelId string) LOVApiGetAgentAccountsLOVRequest {
	return LOVApiGetAgentAccountsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetAgentAccountsLOVExecute(r LOVApiGetAgentAccountsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetAgentAccountsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/agentAccounts"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetAgentSourceCitiesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetAgentSourceCitiesLOVRequest) Authorization(authorization string) LOVApiGetAgentSourceCitiesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetAgentSourceCitiesLOVRequest) XAppKey(xAppKey string) LOVApiGetAgentSourceCitiesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetAgentSourceCitiesLOVRequest) XHotelid(xHotelid string) LOVApiGetAgentSourceCitiesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetAgentSourceCitiesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetAgentSourceCitiesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetAgentSourceCitiesLOVRequest) ParameterName(parameterName []string) LOVApiGetAgentSourceCitiesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetAgentSourceCitiesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetAgentSourceCitiesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetAgentSourceCitiesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetAgentSourceCitiesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetAgentSourceCitiesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetAgentSourceCitiesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetAgentSourceCitiesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetAgentSourceCitiesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetAgentSourceCitiesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetAgentSourceCitiesLOVExecute(r)
}

/*
GetAgentSourceCitiesLOV Fetch List Of Values for Agent Source Cities

 <p><strong>OperationId:</strong>getAgentSourceCitiesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch AgentSourceCities LOV
 @return LOVApiGetAgentSourceCitiesLOVRequest
*/
func (a *LOVApiService) GetAgentSourceCitiesLOV(ctx context.Context, hotelId string) LOVApiGetAgentSourceCitiesLOVRequest {
	return LOVApiGetAgentSourceCitiesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetAgentSourceCitiesLOVExecute(r LOVApiGetAgentSourceCitiesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetAgentSourceCitiesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/agentSourceCities"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetAgentSourceResvCitiesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetAgentSourceResvCitiesLOVRequest) Authorization(authorization string) LOVApiGetAgentSourceResvCitiesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetAgentSourceResvCitiesLOVRequest) XAppKey(xAppKey string) LOVApiGetAgentSourceResvCitiesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetAgentSourceResvCitiesLOVRequest) XHotelid(xHotelid string) LOVApiGetAgentSourceResvCitiesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetAgentSourceResvCitiesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetAgentSourceResvCitiesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetAgentSourceResvCitiesLOVRequest) ParameterName(parameterName []string) LOVApiGetAgentSourceResvCitiesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetAgentSourceResvCitiesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetAgentSourceResvCitiesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetAgentSourceResvCitiesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetAgentSourceResvCitiesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetAgentSourceResvCitiesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetAgentSourceResvCitiesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetAgentSourceResvCitiesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetAgentSourceResvCitiesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetAgentSourceResvCitiesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetAgentSourceResvCitiesLOVExecute(r)
}

/*
GetAgentSourceResvCitiesLOV Fetch List Of Values for Agent Source Resv Cities

 <p><strong>OperationId:</strong>getAgentSourceResvCitiesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch AgentSourceResvCities LOV
 @return LOVApiGetAgentSourceResvCitiesLOVRequest
*/
func (a *LOVApiService) GetAgentSourceResvCitiesLOV(ctx context.Context, hotelId string) LOVApiGetAgentSourceResvCitiesLOVRequest {
	return LOVApiGetAgentSourceResvCitiesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetAgentSourceResvCitiesLOVExecute(r LOVApiGetAgentSourceResvCitiesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetAgentSourceResvCitiesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/agentSourceResvCities"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetAlertCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetAlertCodesLOVRequest) Authorization(authorization string) LOVApiGetAlertCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetAlertCodesLOVRequest) XAppKey(xAppKey string) LOVApiGetAlertCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetAlertCodesLOVRequest) XHotelid(xHotelid string) LOVApiGetAlertCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetAlertCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetAlertCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetAlertCodesLOVRequest) ParameterName(parameterName []string) LOVApiGetAlertCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetAlertCodesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetAlertCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetAlertCodesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetAlertCodesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetAlertCodesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetAlertCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetAlertCodesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetAlertCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetAlertCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetAlertCodesLOVExecute(r)
}

/*
GetAlertCodesLOV Fetch List Of Values for Alert Codes

 <p><strong>OperationId:</strong>getAlertCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch AlertCodes LOV
 @return LOVApiGetAlertCodesLOVRequest
*/
func (a *LOVApiService) GetAlertCodesLOV(ctx context.Context, hotelId string) LOVApiGetAlertCodesLOVRequest {
	return LOVApiGetAlertCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetAlertCodesLOVExecute(r LOVApiGetAlertCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetAlertCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/alertCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetAllRevenueTypesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	interfaceId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetAllRevenueTypesLOVRequest) Authorization(authorization string) LOVApiGetAllRevenueTypesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetAllRevenueTypesLOVRequest) XAppKey(xAppKey string) LOVApiGetAllRevenueTypesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetAllRevenueTypesLOVRequest) XHotelid(xHotelid string) LOVApiGetAllRevenueTypesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetAllRevenueTypesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetAllRevenueTypesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetAllRevenueTypesLOVRequest) ParameterName(parameterName []string) LOVApiGetAllRevenueTypesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetAllRevenueTypesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetAllRevenueTypesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetAllRevenueTypesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetAllRevenueTypesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetAllRevenueTypesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetAllRevenueTypesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetAllRevenueTypesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetAllRevenueTypesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetAllRevenueTypesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetAllRevenueTypesLOVExecute(r)
}

/*
GetAllRevenueTypesLOV Fetch List Of Values for All Revenue Types

 <p><strong>OperationId:</strong>getAllRevenueTypesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param interfaceId Value of the parameter 'interfaceId' which is required to fetch AllRevenueTypes LOV
 @return LOVApiGetAllRevenueTypesLOVRequest
*/
func (a *LOVApiService) GetAllRevenueTypesLOV(ctx context.Context, interfaceId string) LOVApiGetAllRevenueTypesLOVRequest {
	return LOVApiGetAllRevenueTypesLOVRequest{
		ApiService: a,
		ctx: ctx,
		interfaceId: interfaceId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetAllRevenueTypesLOVExecute(r LOVApiGetAllRevenueTypesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetAllRevenueTypesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/interfaceId/{interfaceId}/allRevenueTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"interfaceId"+"}", url.PathEscape(parameterValueToString(r.interfaceId, "interfaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.interfaceId) < 1 {
		return localVarReturnValue, nil, reportError("interfaceId must have at least 1 elements")
	}
	if strlen(r.interfaceId) > 2000 {
		return localVarReturnValue, nil, reportError("interfaceId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetAllowedHotelInterfaceRightsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	interfaceRowId string
	interfaceType string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetAllowedHotelInterfaceRightsLOVRequest) Authorization(authorization string) LOVApiGetAllowedHotelInterfaceRightsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetAllowedHotelInterfaceRightsLOVRequest) XAppKey(xAppKey string) LOVApiGetAllowedHotelInterfaceRightsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetAllowedHotelInterfaceRightsLOVRequest) XHotelid(xHotelid string) LOVApiGetAllowedHotelInterfaceRightsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetAllowedHotelInterfaceRightsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetAllowedHotelInterfaceRightsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetAllowedHotelInterfaceRightsLOVRequest) ParameterName(parameterName []string) LOVApiGetAllowedHotelInterfaceRightsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetAllowedHotelInterfaceRightsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetAllowedHotelInterfaceRightsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetAllowedHotelInterfaceRightsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetAllowedHotelInterfaceRightsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetAllowedHotelInterfaceRightsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetAllowedHotelInterfaceRightsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetAllowedHotelInterfaceRightsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetAllowedHotelInterfaceRightsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetAllowedHotelInterfaceRightsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetAllowedHotelInterfaceRightsLOVExecute(r)
}

/*
GetAllowedHotelInterfaceRightsLOV Fetch List Of Values for Allowed Hotel Interface Rights

 <p><strong>OperationId:</strong>getAllowedHotelInterfaceRightsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param interfaceRowId Value of the parameter 'interfaceRowId' which is required to fetch AllowedHotelInterfaceRights LOV
 @param interfaceType Value of the parameter 'interfaceType' which is required to fetch AllowedHotelInterfaceRights LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch AllowedHotelInterfaceRights LOV
 @return LOVApiGetAllowedHotelInterfaceRightsLOVRequest
*/
func (a *LOVApiService) GetAllowedHotelInterfaceRightsLOV(ctx context.Context, interfaceRowId string, interfaceType string, hotelId string) LOVApiGetAllowedHotelInterfaceRightsLOVRequest {
	return LOVApiGetAllowedHotelInterfaceRightsLOVRequest{
		ApiService: a,
		ctx: ctx,
		interfaceRowId: interfaceRowId,
		interfaceType: interfaceType,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetAllowedHotelInterfaceRightsLOVExecute(r LOVApiGetAllowedHotelInterfaceRightsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetAllowedHotelInterfaceRightsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/interfaceType/{interfaceType}/interfaceRowId/{interfaceRowId}/allowedHotelInterfaceRights"
	localVarPath = strings.Replace(localVarPath, "{"+"interfaceRowId"+"}", url.PathEscape(parameterValueToString(r.interfaceRowId, "interfaceRowId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"interfaceType"+"}", url.PathEscape(parameterValueToString(r.interfaceType, "interfaceType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.interfaceRowId) < 1 {
		return localVarReturnValue, nil, reportError("interfaceRowId must have at least 1 elements")
	}
	if strlen(r.interfaceRowId) > 2000 {
		return localVarReturnValue, nil, reportError("interfaceRowId must have less than 2000 elements")
	}
	if strlen(r.interfaceType) < 1 {
		return localVarReturnValue, nil, reportError("interfaceType must have at least 1 elements")
	}
	if strlen(r.interfaceType) > 2000 {
		return localVarReturnValue, nil, reportError("interfaceType must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetAlternateHotelCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetAlternateHotelCodesLOVRequest) Authorization(authorization string) LOVApiGetAlternateHotelCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetAlternateHotelCodesLOVRequest) XAppKey(xAppKey string) LOVApiGetAlternateHotelCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetAlternateHotelCodesLOVRequest) XHotelid(xHotelid string) LOVApiGetAlternateHotelCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetAlternateHotelCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetAlternateHotelCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetAlternateHotelCodesLOVRequest) ParameterName(parameterName []string) LOVApiGetAlternateHotelCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetAlternateHotelCodesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetAlternateHotelCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetAlternateHotelCodesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetAlternateHotelCodesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetAlternateHotelCodesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetAlternateHotelCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetAlternateHotelCodesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetAlternateHotelCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetAlternateHotelCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetAlternateHotelCodesLOVExecute(r)
}

/*
GetAlternateHotelCodesLOV Fetch List Of Values for Alternate Hotel Codes

 <p><strong>OperationId:</strong>getAlternateHotelCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch AlternateHotelCodes LOV
 @return LOVApiGetAlternateHotelCodesLOVRequest
*/
func (a *LOVApiService) GetAlternateHotelCodesLOV(ctx context.Context, hotelId string) LOVApiGetAlternateHotelCodesLOVRequest {
	return LOVApiGetAlternateHotelCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetAlternateHotelCodesLOVExecute(r LOVApiGetAlternateHotelCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetAlternateHotelCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/alternateHotelCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetAmenitiesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetAmenitiesLOVRequest) Authorization(authorization string) LOVApiGetAmenitiesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetAmenitiesLOVRequest) XAppKey(xAppKey string) LOVApiGetAmenitiesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetAmenitiesLOVRequest) XHotelid(xHotelid string) LOVApiGetAmenitiesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetAmenitiesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetAmenitiesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetAmenitiesLOVRequest) ParameterName(parameterName []string) LOVApiGetAmenitiesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetAmenitiesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetAmenitiesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetAmenitiesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetAmenitiesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetAmenitiesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetAmenitiesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetAmenitiesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetAmenitiesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetAmenitiesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetAmenitiesLOVExecute(r)
}

/*
GetAmenitiesLOV Fetch List Of Values for Amenities

 <p><strong>OperationId:</strong>getAmenitiesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch Amenities LOV
 @return LOVApiGetAmenitiesLOVRequest
*/
func (a *LOVApiService) GetAmenitiesLOV(ctx context.Context, hotelId string) LOVApiGetAmenitiesLOVRequest {
	return LOVApiGetAmenitiesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetAmenitiesLOVExecute(r LOVApiGetAmenitiesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetAmenitiesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/amenities"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetApplicationModulesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	relModuleName string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetApplicationModulesLOVRequest) Authorization(authorization string) LOVApiGetApplicationModulesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetApplicationModulesLOVRequest) XAppKey(xAppKey string) LOVApiGetApplicationModulesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetApplicationModulesLOVRequest) XHotelid(xHotelid string) LOVApiGetApplicationModulesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetApplicationModulesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetApplicationModulesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetApplicationModulesLOVRequest) ParameterName(parameterName []string) LOVApiGetApplicationModulesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetApplicationModulesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetApplicationModulesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetApplicationModulesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetApplicationModulesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetApplicationModulesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetApplicationModulesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetApplicationModulesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetApplicationModulesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetApplicationModulesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetApplicationModulesLOVExecute(r)
}

/*
GetApplicationModulesLOV Fetch List Of Values for Application Modules

 <p><strong>OperationId:</strong>getApplicationModulesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param relModuleName Value of the parameter 'relModuleName' which is required to fetch ApplicationModules LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ApplicationModules LOV
 @return LOVApiGetApplicationModulesLOVRequest
*/
func (a *LOVApiService) GetApplicationModulesLOV(ctx context.Context, relModuleName string, hotelId string) LOVApiGetApplicationModulesLOVRequest {
	return LOVApiGetApplicationModulesLOVRequest{
		ApiService: a,
		ctx: ctx,
		relModuleName: relModuleName,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetApplicationModulesLOVExecute(r LOVApiGetApplicationModulesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetApplicationModulesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/relModuleName/{relModuleName}/applicationModules"
	localVarPath = strings.Replace(localVarPath, "{"+"relModuleName"+"}", url.PathEscape(parameterValueToString(r.relModuleName, "relModuleName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.relModuleName) < 1 {
		return localVarReturnValue, nil, reportError("relModuleName must have at least 1 elements")
	}
	if strlen(r.relModuleName) > 2000 {
		return localVarReturnValue, nil, reportError("relModuleName must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetApplicationSettingsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	settingName string
	levelCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetApplicationSettingsLOVRequest) Authorization(authorization string) LOVApiGetApplicationSettingsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetApplicationSettingsLOVRequest) XAppKey(xAppKey string) LOVApiGetApplicationSettingsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetApplicationSettingsLOVRequest) XHotelid(xHotelid string) LOVApiGetApplicationSettingsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetApplicationSettingsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetApplicationSettingsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetApplicationSettingsLOVRequest) ParameterName(parameterName []string) LOVApiGetApplicationSettingsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetApplicationSettingsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetApplicationSettingsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetApplicationSettingsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetApplicationSettingsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetApplicationSettingsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetApplicationSettingsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetApplicationSettingsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetApplicationSettingsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetApplicationSettingsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetApplicationSettingsLOVExecute(r)
}

/*
GetApplicationSettingsLOV Fetch List Of Values for Application Settings

 <p><strong>OperationId:</strong>getApplicationSettingsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param settingName Value of the parameter 'settingName' which is required to fetch ApplicationSettings LOV
 @param levelCode Value of the parameter 'levelCode' which is required to fetch ApplicationSettings LOV
 @return LOVApiGetApplicationSettingsLOVRequest
*/
func (a *LOVApiService) GetApplicationSettingsLOV(ctx context.Context, settingName string, levelCode string) LOVApiGetApplicationSettingsLOVRequest {
	return LOVApiGetApplicationSettingsLOVRequest{
		ApiService: a,
		ctx: ctx,
		settingName: settingName,
		levelCode: levelCode,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetApplicationSettingsLOVExecute(r LOVApiGetApplicationSettingsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetApplicationSettingsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/levelCode/{levelCode}/settingName/{settingName}/applicationSettings"
	localVarPath = strings.Replace(localVarPath, "{"+"settingName"+"}", url.PathEscape(parameterValueToString(r.settingName, "settingName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"levelCode"+"}", url.PathEscape(parameterValueToString(r.levelCode, "levelCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.settingName) < 1 {
		return localVarReturnValue, nil, reportError("settingName must have at least 1 elements")
	}
	if strlen(r.settingName) > 2000 {
		return localVarReturnValue, nil, reportError("settingName must have less than 2000 elements")
	}
	if strlen(r.levelCode) < 1 {
		return localVarReturnValue, nil, reportError("levelCode must have at least 1 elements")
	}
	if strlen(r.levelCode) > 2000 {
		return localVarReturnValue, nil, reportError("levelCode must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetArrangementCodeLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetArrangementCodeLOVRequest) Authorization(authorization string) LOVApiGetArrangementCodeLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetArrangementCodeLOVRequest) XAppKey(xAppKey string) LOVApiGetArrangementCodeLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetArrangementCodeLOVRequest) XHotelid(xHotelid string) LOVApiGetArrangementCodeLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetArrangementCodeLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetArrangementCodeLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetArrangementCodeLOVRequest) ParameterName(parameterName []string) LOVApiGetArrangementCodeLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetArrangementCodeLOVRequest) ParameterValue(parameterValue []string) LOVApiGetArrangementCodeLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetArrangementCodeLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetArrangementCodeLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetArrangementCodeLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetArrangementCodeLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetArrangementCodeLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetArrangementCodeLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetArrangementCodeLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetArrangementCodeLOVExecute(r)
}

/*
GetArrangementCodeLOV Fetch List Of Values for Arrangement Code

 <p><strong>OperationId:</strong>getArrangementCodeLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ArrangementCode LOV
 @return LOVApiGetArrangementCodeLOVRequest
*/
func (a *LOVApiService) GetArrangementCodeLOV(ctx context.Context, hotelId string) LOVApiGetArrangementCodeLOVRequest {
	return LOVApiGetArrangementCodeLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetArrangementCodeLOVExecute(r LOVApiGetArrangementCodeLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetArrangementCodeLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/arrangementCode"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetArrangementCodesNumberLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	type_ string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetArrangementCodesNumberLOVRequest) Authorization(authorization string) LOVApiGetArrangementCodesNumberLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetArrangementCodesNumberLOVRequest) XAppKey(xAppKey string) LOVApiGetArrangementCodesNumberLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetArrangementCodesNumberLOVRequest) XHotelid(xHotelid string) LOVApiGetArrangementCodesNumberLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetArrangementCodesNumberLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetArrangementCodesNumberLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetArrangementCodesNumberLOVRequest) ParameterName(parameterName []string) LOVApiGetArrangementCodesNumberLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetArrangementCodesNumberLOVRequest) ParameterValue(parameterValue []string) LOVApiGetArrangementCodesNumberLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetArrangementCodesNumberLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetArrangementCodesNumberLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetArrangementCodesNumberLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetArrangementCodesNumberLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetArrangementCodesNumberLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetArrangementCodesNumberLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetArrangementCodesNumberLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetArrangementCodesNumberLOVExecute(r)
}

/*
GetArrangementCodesNumberLOV Fetch List Of Values for Arrangement Codes Number

 <p><strong>OperationId:</strong>getArrangementCodesNumberLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param type_ Value of the parameter 'type' which is required to fetch ArrangementCodesNumber LOV
 @return LOVApiGetArrangementCodesNumberLOVRequest
*/
func (a *LOVApiService) GetArrangementCodesNumberLOV(ctx context.Context, type_ string) LOVApiGetArrangementCodesNumberLOVRequest {
	return LOVApiGetArrangementCodesNumberLOVRequest{
		ApiService: a,
		ctx: ctx,
		type_: type_,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetArrangementCodesNumberLOVExecute(r LOVApiGetArrangementCodesNumberLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetArrangementCodesNumberLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/type/{type}/arrangementCodesNumber"
	localVarPath = strings.Replace(localVarPath, "{"+"type"+"}", url.PathEscape(parameterValueToString(r.type_, "type_")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.type_) < 1 {
		return localVarReturnValue, nil, reportError("type_ must have at least 1 elements")
	}
	if strlen(r.type_) > 2000 {
		return localVarReturnValue, nil, reportError("type_ must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetArticleCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetArticleCodesLOVRequest) Authorization(authorization string) LOVApiGetArticleCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetArticleCodesLOVRequest) XAppKey(xAppKey string) LOVApiGetArticleCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetArticleCodesLOVRequest) XHotelid(xHotelid string) LOVApiGetArticleCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetArticleCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetArticleCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetArticleCodesLOVRequest) ParameterName(parameterName []string) LOVApiGetArticleCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetArticleCodesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetArticleCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetArticleCodesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetArticleCodesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetArticleCodesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetArticleCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetArticleCodesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetArticleCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetArticleCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetArticleCodesLOVExecute(r)
}

/*
GetArticleCodesLOV Fetch List Of Values for Article Codes

 <p><strong>OperationId:</strong>getArticleCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ArticleCodes LOV
 @return LOVApiGetArticleCodesLOVRequest
*/
func (a *LOVApiService) GetArticleCodesLOV(ctx context.Context, hotelId string) LOVApiGetArticleCodesLOVRequest {
	return LOVApiGetArticleCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetArticleCodesLOVExecute(r LOVApiGetArticleCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetArticleCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/articleCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetAssignRoomsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	room string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetAssignRoomsLOVRequest) Authorization(authorization string) LOVApiGetAssignRoomsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetAssignRoomsLOVRequest) XAppKey(xAppKey string) LOVApiGetAssignRoomsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetAssignRoomsLOVRequest) XHotelid(xHotelid string) LOVApiGetAssignRoomsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetAssignRoomsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetAssignRoomsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetAssignRoomsLOVRequest) ParameterName(parameterName []string) LOVApiGetAssignRoomsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetAssignRoomsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetAssignRoomsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetAssignRoomsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetAssignRoomsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetAssignRoomsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetAssignRoomsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetAssignRoomsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetAssignRoomsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetAssignRoomsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetAssignRoomsLOVExecute(r)
}

/*
GetAssignRoomsLOV Fetch List Of Values for Assign Rooms

 <p><strong>OperationId:</strong>getAssignRoomsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param room Value of the parameter 'room' which is required to fetch AssignRooms LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch AssignRooms LOV
 @return LOVApiGetAssignRoomsLOVRequest
*/
func (a *LOVApiService) GetAssignRoomsLOV(ctx context.Context, room string, hotelId string) LOVApiGetAssignRoomsLOVRequest {
	return LOVApiGetAssignRoomsLOVRequest{
		ApiService: a,
		ctx: ctx,
		room: room,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetAssignRoomsLOVExecute(r LOVApiGetAssignRoomsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetAssignRoomsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/room/{room}/assignRooms"
	localVarPath = strings.Replace(localVarPath, "{"+"room"+"}", url.PathEscape(parameterValueToString(r.room, "room")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.room) < 1 {
		return localVarReturnValue, nil, reportError("room must have at least 1 elements")
	}
	if strlen(r.room) > 2000 {
		return localVarReturnValue, nil, reportError("room must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetAttractionsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetAttractionsLOVRequest) Authorization(authorization string) LOVApiGetAttractionsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetAttractionsLOVRequest) XAppKey(xAppKey string) LOVApiGetAttractionsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetAttractionsLOVRequest) XHotelid(xHotelid string) LOVApiGetAttractionsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetAttractionsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetAttractionsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetAttractionsLOVRequest) ParameterName(parameterName []string) LOVApiGetAttractionsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetAttractionsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetAttractionsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetAttractionsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetAttractionsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetAttractionsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetAttractionsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetAttractionsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetAttractionsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetAttractionsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetAttractionsLOVExecute(r)
}

/*
GetAttractionsLOV Fetch List Of Values for Attractions

 <p><strong>OperationId:</strong>getAttractionsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch Attractions LOV
 @return LOVApiGetAttractionsLOVRequest
*/
func (a *LOVApiService) GetAttractionsLOV(ctx context.Context, hotelId string) LOVApiGetAttractionsLOVRequest {
	return LOVApiGetAttractionsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetAttractionsLOVExecute(r LOVApiGetAttractionsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetAttractionsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/attractions"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetAuthorizerLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetAuthorizerLOVRequest) Authorization(authorization string) LOVApiGetAuthorizerLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetAuthorizerLOVRequest) XAppKey(xAppKey string) LOVApiGetAuthorizerLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetAuthorizerLOVRequest) XHotelid(xHotelid string) LOVApiGetAuthorizerLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetAuthorizerLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetAuthorizerLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetAuthorizerLOVRequest) ParameterName(parameterName []string) LOVApiGetAuthorizerLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetAuthorizerLOVRequest) ParameterValue(parameterValue []string) LOVApiGetAuthorizerLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetAuthorizerLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetAuthorizerLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetAuthorizerLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetAuthorizerLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetAuthorizerLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetAuthorizerLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetAuthorizerLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetAuthorizerLOVExecute(r)
}

/*
GetAuthorizerLOV Fetch List Of Values for Authorizer

 <p><strong>OperationId:</strong>getAuthorizerLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch Authorizer LOV
 @return LOVApiGetAuthorizerLOVRequest
*/
func (a *LOVApiService) GetAuthorizerLOV(ctx context.Context, hotelId string) LOVApiGetAuthorizerLOVRequest {
	return LOVApiGetAuthorizerLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetAuthorizerLOVExecute(r LOVApiGetAuthorizerLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetAuthorizerLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/authorizer"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetAutoNumberGeneratorLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	number string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetAutoNumberGeneratorLOVRequest) Authorization(authorization string) LOVApiGetAutoNumberGeneratorLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetAutoNumberGeneratorLOVRequest) XAppKey(xAppKey string) LOVApiGetAutoNumberGeneratorLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetAutoNumberGeneratorLOVRequest) XHotelid(xHotelid string) LOVApiGetAutoNumberGeneratorLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetAutoNumberGeneratorLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetAutoNumberGeneratorLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetAutoNumberGeneratorLOVRequest) ParameterName(parameterName []string) LOVApiGetAutoNumberGeneratorLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetAutoNumberGeneratorLOVRequest) ParameterValue(parameterValue []string) LOVApiGetAutoNumberGeneratorLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetAutoNumberGeneratorLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetAutoNumberGeneratorLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetAutoNumberGeneratorLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetAutoNumberGeneratorLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetAutoNumberGeneratorLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetAutoNumberGeneratorLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetAutoNumberGeneratorLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetAutoNumberGeneratorLOVExecute(r)
}

/*
GetAutoNumberGeneratorLOV Fetch List Of Values for Auto Number Generator

 <p><strong>OperationId:</strong>getAutoNumberGeneratorLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param number Value of the parameter 'number' which is required to fetch AutoNumberGenerator LOV
 @return LOVApiGetAutoNumberGeneratorLOVRequest
*/
func (a *LOVApiService) GetAutoNumberGeneratorLOV(ctx context.Context, number string) LOVApiGetAutoNumberGeneratorLOVRequest {
	return LOVApiGetAutoNumberGeneratorLOVRequest{
		ApiService: a,
		ctx: ctx,
		number: number,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetAutoNumberGeneratorLOVExecute(r LOVApiGetAutoNumberGeneratorLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetAutoNumberGeneratorLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/number/{number}/autoNumberGenerator"
	localVarPath = strings.Replace(localVarPath, "{"+"number"+"}", url.PathEscape(parameterValueToString(r.number, "number")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.number) < 1 {
		return localVarReturnValue, nil, reportError("number must have at least 1 elements")
	}
	if strlen(r.number) > 2000 {
		return localVarReturnValue, nil, reportError("number must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetAutoTraceExpressionFieldsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	traceGroup string
	tableName string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetAutoTraceExpressionFieldsLOVRequest) Authorization(authorization string) LOVApiGetAutoTraceExpressionFieldsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetAutoTraceExpressionFieldsLOVRequest) XAppKey(xAppKey string) LOVApiGetAutoTraceExpressionFieldsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetAutoTraceExpressionFieldsLOVRequest) XHotelid(xHotelid string) LOVApiGetAutoTraceExpressionFieldsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetAutoTraceExpressionFieldsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetAutoTraceExpressionFieldsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetAutoTraceExpressionFieldsLOVRequest) ParameterName(parameterName []string) LOVApiGetAutoTraceExpressionFieldsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetAutoTraceExpressionFieldsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetAutoTraceExpressionFieldsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetAutoTraceExpressionFieldsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetAutoTraceExpressionFieldsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetAutoTraceExpressionFieldsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetAutoTraceExpressionFieldsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetAutoTraceExpressionFieldsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetAutoTraceExpressionFieldsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetAutoTraceExpressionFieldsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetAutoTraceExpressionFieldsLOVExecute(r)
}

/*
GetAutoTraceExpressionFieldsLOV Fetch List Of Values for Auto Trace Expression Fields

 <p><strong>OperationId:</strong>getAutoTraceExpressionFieldsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param traceGroup Value of the parameter 'traceGroup' which is required to fetch AutoTraceExpressionFields LOV
 @param tableName Value of the parameter 'tableName' which is required to fetch AutoTraceExpressionFields LOV
 @return LOVApiGetAutoTraceExpressionFieldsLOVRequest
*/
func (a *LOVApiService) GetAutoTraceExpressionFieldsLOV(ctx context.Context, traceGroup string, tableName string) LOVApiGetAutoTraceExpressionFieldsLOVRequest {
	return LOVApiGetAutoTraceExpressionFieldsLOVRequest{
		ApiService: a,
		ctx: ctx,
		traceGroup: traceGroup,
		tableName: tableName,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetAutoTraceExpressionFieldsLOVExecute(r LOVApiGetAutoTraceExpressionFieldsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetAutoTraceExpressionFieldsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/tableName/{tableName}/traceGroup/{traceGroup}/autoTraceExpressionFields"
	localVarPath = strings.Replace(localVarPath, "{"+"traceGroup"+"}", url.PathEscape(parameterValueToString(r.traceGroup, "traceGroup")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tableName"+"}", url.PathEscape(parameterValueToString(r.tableName, "tableName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.traceGroup) < 1 {
		return localVarReturnValue, nil, reportError("traceGroup must have at least 1 elements")
	}
	if strlen(r.traceGroup) > 2000 {
		return localVarReturnValue, nil, reportError("traceGroup must have less than 2000 elements")
	}
	if strlen(r.tableName) < 1 {
		return localVarReturnValue, nil, reportError("tableName must have at least 1 elements")
	}
	if strlen(r.tableName) > 2000 {
		return localVarReturnValue, nil, reportError("tableName must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetAvailableExportTemplatesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	fileGroup string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetAvailableExportTemplatesLOVRequest) Authorization(authorization string) LOVApiGetAvailableExportTemplatesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetAvailableExportTemplatesLOVRequest) XAppKey(xAppKey string) LOVApiGetAvailableExportTemplatesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetAvailableExportTemplatesLOVRequest) XHotelid(xHotelid string) LOVApiGetAvailableExportTemplatesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetAvailableExportTemplatesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetAvailableExportTemplatesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetAvailableExportTemplatesLOVRequest) ParameterName(parameterName []string) LOVApiGetAvailableExportTemplatesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetAvailableExportTemplatesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetAvailableExportTemplatesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetAvailableExportTemplatesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetAvailableExportTemplatesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetAvailableExportTemplatesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetAvailableExportTemplatesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetAvailableExportTemplatesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetAvailableExportTemplatesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetAvailableExportTemplatesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetAvailableExportTemplatesLOVExecute(r)
}

/*
GetAvailableExportTemplatesLOV Fetch List Of Values for Available Export Templates

 <p><strong>OperationId:</strong>getAvailableExportTemplatesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fileGroup Value of the parameter 'fileGroup' which is required to fetch AvailableExportTemplates LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch AvailableExportTemplates LOV
 @return LOVApiGetAvailableExportTemplatesLOVRequest
*/
func (a *LOVApiService) GetAvailableExportTemplatesLOV(ctx context.Context, fileGroup string, hotelId string) LOVApiGetAvailableExportTemplatesLOVRequest {
	return LOVApiGetAvailableExportTemplatesLOVRequest{
		ApiService: a,
		ctx: ctx,
		fileGroup: fileGroup,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetAvailableExportTemplatesLOVExecute(r LOVApiGetAvailableExportTemplatesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetAvailableExportTemplatesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/fileGroup/{fileGroup}/availableExportTemplates"
	localVarPath = strings.Replace(localVarPath, "{"+"fileGroup"+"}", url.PathEscape(parameterValueToString(r.fileGroup, "fileGroup")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.fileGroup) < 1 {
		return localVarReturnValue, nil, reportError("fileGroup must have at least 1 elements")
	}
	if strlen(r.fileGroup) > 2000 {
		return localVarReturnValue, nil, reportError("fileGroup must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetAvailableProfileOwnerRoomsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetAvailableProfileOwnerRoomsLOVRequest) Authorization(authorization string) LOVApiGetAvailableProfileOwnerRoomsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetAvailableProfileOwnerRoomsLOVRequest) XAppKey(xAppKey string) LOVApiGetAvailableProfileOwnerRoomsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetAvailableProfileOwnerRoomsLOVRequest) XHotelid(xHotelid string) LOVApiGetAvailableProfileOwnerRoomsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetAvailableProfileOwnerRoomsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetAvailableProfileOwnerRoomsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetAvailableProfileOwnerRoomsLOVRequest) ParameterName(parameterName []string) LOVApiGetAvailableProfileOwnerRoomsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetAvailableProfileOwnerRoomsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetAvailableProfileOwnerRoomsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetAvailableProfileOwnerRoomsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetAvailableProfileOwnerRoomsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetAvailableProfileOwnerRoomsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetAvailableProfileOwnerRoomsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetAvailableProfileOwnerRoomsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetAvailableProfileOwnerRoomsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetAvailableProfileOwnerRoomsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetAvailableProfileOwnerRoomsLOVExecute(r)
}

/*
GetAvailableProfileOwnerRoomsLOV Fetch List Of Values for Available Profile Owner Rooms

 <p><strong>OperationId:</strong>getAvailableProfileOwnerRoomsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch AvailableProfileOwnerRooms LOV
 @return LOVApiGetAvailableProfileOwnerRoomsLOVRequest
*/
func (a *LOVApiService) GetAvailableProfileOwnerRoomsLOV(ctx context.Context, hotelId string) LOVApiGetAvailableProfileOwnerRoomsLOVRequest {
	return LOVApiGetAvailableProfileOwnerRoomsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetAvailableProfileOwnerRoomsLOVExecute(r LOVApiGetAvailableProfileOwnerRoomsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetAvailableProfileOwnerRoomsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/availableProfileOwnerRooms"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetAvailableRoomComponentsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	roomNumber string
	roomType string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetAvailableRoomComponentsLOVRequest) Authorization(authorization string) LOVApiGetAvailableRoomComponentsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetAvailableRoomComponentsLOVRequest) XAppKey(xAppKey string) LOVApiGetAvailableRoomComponentsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetAvailableRoomComponentsLOVRequest) XHotelid(xHotelid string) LOVApiGetAvailableRoomComponentsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetAvailableRoomComponentsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetAvailableRoomComponentsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetAvailableRoomComponentsLOVRequest) ParameterName(parameterName []string) LOVApiGetAvailableRoomComponentsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetAvailableRoomComponentsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetAvailableRoomComponentsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetAvailableRoomComponentsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetAvailableRoomComponentsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetAvailableRoomComponentsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetAvailableRoomComponentsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetAvailableRoomComponentsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetAvailableRoomComponentsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetAvailableRoomComponentsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetAvailableRoomComponentsLOVExecute(r)
}

/*
GetAvailableRoomComponentsLOV Fetch List Of Values for Available Room Components

 <p><strong>OperationId:</strong>getAvailableRoomComponentsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param roomNumber Value of the parameter 'roomNumber' which is required to fetch AvailableRoomComponents LOV
 @param roomType Value of the parameter 'roomType' which is required to fetch AvailableRoomComponents LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch AvailableRoomComponents LOV
 @return LOVApiGetAvailableRoomComponentsLOVRequest
*/
func (a *LOVApiService) GetAvailableRoomComponentsLOV(ctx context.Context, roomNumber string, roomType string, hotelId string) LOVApiGetAvailableRoomComponentsLOVRequest {
	return LOVApiGetAvailableRoomComponentsLOVRequest{
		ApiService: a,
		ctx: ctx,
		roomNumber: roomNumber,
		roomType: roomType,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetAvailableRoomComponentsLOVExecute(r LOVApiGetAvailableRoomComponentsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetAvailableRoomComponentsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/roomType/{roomType}/roomNumber/{roomNumber}/availableRoomComponents"
	localVarPath = strings.Replace(localVarPath, "{"+"roomNumber"+"}", url.PathEscape(parameterValueToString(r.roomNumber, "roomNumber")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"roomType"+"}", url.PathEscape(parameterValueToString(r.roomType, "roomType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.roomNumber) < 1 {
		return localVarReturnValue, nil, reportError("roomNumber must have at least 1 elements")
	}
	if strlen(r.roomNumber) > 2000 {
		return localVarReturnValue, nil, reportError("roomNumber must have less than 2000 elements")
	}
	if strlen(r.roomType) < 1 {
		return localVarReturnValue, nil, reportError("roomType must have at least 1 elements")
	}
	if strlen(r.roomType) > 2000 {
		return localVarReturnValue, nil, reportError("roomType must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetAvailableRoomTypeComponentsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	roomType string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetAvailableRoomTypeComponentsLOVRequest) Authorization(authorization string) LOVApiGetAvailableRoomTypeComponentsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetAvailableRoomTypeComponentsLOVRequest) XAppKey(xAppKey string) LOVApiGetAvailableRoomTypeComponentsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetAvailableRoomTypeComponentsLOVRequest) XHotelid(xHotelid string) LOVApiGetAvailableRoomTypeComponentsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetAvailableRoomTypeComponentsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetAvailableRoomTypeComponentsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetAvailableRoomTypeComponentsLOVRequest) ParameterName(parameterName []string) LOVApiGetAvailableRoomTypeComponentsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetAvailableRoomTypeComponentsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetAvailableRoomTypeComponentsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetAvailableRoomTypeComponentsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetAvailableRoomTypeComponentsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetAvailableRoomTypeComponentsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetAvailableRoomTypeComponentsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetAvailableRoomTypeComponentsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetAvailableRoomTypeComponentsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetAvailableRoomTypeComponentsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetAvailableRoomTypeComponentsLOVExecute(r)
}

/*
GetAvailableRoomTypeComponentsLOV Fetch List Of Values for Available Room Type Components

 <p><strong>OperationId:</strong>getAvailableRoomTypeComponentsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param roomType Value of the parameter 'roomType' which is required to fetch AvailableRoomTypeComponents LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch AvailableRoomTypeComponents LOV
 @return LOVApiGetAvailableRoomTypeComponentsLOVRequest
*/
func (a *LOVApiService) GetAvailableRoomTypeComponentsLOV(ctx context.Context, roomType string, hotelId string) LOVApiGetAvailableRoomTypeComponentsLOVRequest {
	return LOVApiGetAvailableRoomTypeComponentsLOVRequest{
		ApiService: a,
		ctx: ctx,
		roomType: roomType,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetAvailableRoomTypeComponentsLOVExecute(r LOVApiGetAvailableRoomTypeComponentsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetAvailableRoomTypeComponentsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/roomType/{roomType}/availableRoomTypeComponents"
	localVarPath = strings.Replace(localVarPath, "{"+"roomType"+"}", url.PathEscape(parameterValueToString(r.roomType, "roomType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.roomType) < 1 {
		return localVarReturnValue, nil, reportError("roomType must have at least 1 elements")
	}
	if strlen(r.roomType) > 2000 {
		return localVarReturnValue, nil, reportError("roomType must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetAvailableScriptLanguagesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetAvailableScriptLanguagesLOVRequest) Authorization(authorization string) LOVApiGetAvailableScriptLanguagesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetAvailableScriptLanguagesLOVRequest) XAppKey(xAppKey string) LOVApiGetAvailableScriptLanguagesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetAvailableScriptLanguagesLOVRequest) XHotelid(xHotelid string) LOVApiGetAvailableScriptLanguagesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetAvailableScriptLanguagesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetAvailableScriptLanguagesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetAvailableScriptLanguagesLOVRequest) ParameterName(parameterName []string) LOVApiGetAvailableScriptLanguagesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetAvailableScriptLanguagesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetAvailableScriptLanguagesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetAvailableScriptLanguagesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetAvailableScriptLanguagesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetAvailableScriptLanguagesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetAvailableScriptLanguagesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetAvailableScriptLanguagesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetAvailableScriptLanguagesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetAvailableScriptLanguagesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetAvailableScriptLanguagesLOVExecute(r)
}

/*
GetAvailableScriptLanguagesLOV Fetch List Of Values for Available Script Languages

 <p><strong>OperationId:</strong>getAvailableScriptLanguagesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch AvailableScriptLanguages LOV
 @return LOVApiGetAvailableScriptLanguagesLOVRequest
*/
func (a *LOVApiService) GetAvailableScriptLanguagesLOV(ctx context.Context, hotelId string) LOVApiGetAvailableScriptLanguagesLOVRequest {
	return LOVApiGetAvailableScriptLanguagesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetAvailableScriptLanguagesLOVExecute(r LOVApiGetAvailableScriptLanguagesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetAvailableScriptLanguagesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/availableScriptLanguages"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetAwardCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetAwardCodesLOVRequest) Authorization(authorization string) LOVApiGetAwardCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetAwardCodesLOVRequest) XAppKey(xAppKey string) LOVApiGetAwardCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetAwardCodesLOVRequest) XHotelid(xHotelid string) LOVApiGetAwardCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetAwardCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetAwardCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetAwardCodesLOVRequest) ParameterName(parameterName []string) LOVApiGetAwardCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetAwardCodesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetAwardCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetAwardCodesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetAwardCodesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetAwardCodesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetAwardCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetAwardCodesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetAwardCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetAwardCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetAwardCodesLOVExecute(r)
}

/*
GetAwardCodesLOV Fetch List Of Values for Award Codes

 <p><strong>OperationId:</strong>getAwardCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch AwardCodes LOV
 @return LOVApiGetAwardCodesLOVRequest
*/
func (a *LOVApiService) GetAwardCodesLOV(ctx context.Context, hotelId string) LOVApiGetAwardCodesLOVRequest {
	return LOVApiGetAwardCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetAwardCodesLOVExecute(r LOVApiGetAwardCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetAwardCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/awardCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetAwardCodesMultiHotelLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetAwardCodesMultiHotelLOVRequest) Authorization(authorization string) LOVApiGetAwardCodesMultiHotelLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetAwardCodesMultiHotelLOVRequest) XAppKey(xAppKey string) LOVApiGetAwardCodesMultiHotelLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetAwardCodesMultiHotelLOVRequest) XHotelid(xHotelid string) LOVApiGetAwardCodesMultiHotelLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetAwardCodesMultiHotelLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetAwardCodesMultiHotelLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetAwardCodesMultiHotelLOVRequest) ParameterName(parameterName []string) LOVApiGetAwardCodesMultiHotelLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetAwardCodesMultiHotelLOVRequest) ParameterValue(parameterValue []string) LOVApiGetAwardCodesMultiHotelLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetAwardCodesMultiHotelLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetAwardCodesMultiHotelLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetAwardCodesMultiHotelLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetAwardCodesMultiHotelLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetAwardCodesMultiHotelLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetAwardCodesMultiHotelLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetAwardCodesMultiHotelLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetAwardCodesMultiHotelLOVExecute(r)
}

/*
GetAwardCodesMultiHotelLOV Fetch List Of Values for Award Codes Multi Hotel

 <p><strong>OperationId:</strong>getAwardCodesMultiHotelLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch AwardCodesMultiHotel LOV
 @return LOVApiGetAwardCodesMultiHotelLOVRequest
*/
func (a *LOVApiService) GetAwardCodesMultiHotelLOV(ctx context.Context, hotelId string) LOVApiGetAwardCodesMultiHotelLOVRequest {
	return LOVApiGetAwardCodesMultiHotelLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetAwardCodesMultiHotelLOVExecute(r LOVApiGetAwardCodesMultiHotelLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetAwardCodesMultiHotelLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/awardCodesMultiHotel"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetAwardMktgCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetAwardMktgCodesLOVRequest) Authorization(authorization string) LOVApiGetAwardMktgCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetAwardMktgCodesLOVRequest) XAppKey(xAppKey string) LOVApiGetAwardMktgCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetAwardMktgCodesLOVRequest) XHotelid(xHotelid string) LOVApiGetAwardMktgCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetAwardMktgCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetAwardMktgCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetAwardMktgCodesLOVRequest) ParameterName(parameterName []string) LOVApiGetAwardMktgCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetAwardMktgCodesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetAwardMktgCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetAwardMktgCodesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetAwardMktgCodesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetAwardMktgCodesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetAwardMktgCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetAwardMktgCodesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetAwardMktgCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetAwardMktgCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetAwardMktgCodesLOVExecute(r)
}

/*
GetAwardMktgCodesLOV Fetch List Of Values for Award Mktg Codes

 <p><strong>OperationId:</strong>getAwardMktgCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch AwardMktgCodes LOV
 @return LOVApiGetAwardMktgCodesLOVRequest
*/
func (a *LOVApiService) GetAwardMktgCodesLOV(ctx context.Context, hotelId string) LOVApiGetAwardMktgCodesLOVRequest {
	return LOVApiGetAwardMktgCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetAwardMktgCodesLOVExecute(r LOVApiGetAwardMktgCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetAwardMktgCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/awardMktgCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetBankAccountsForReportsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetBankAccountsForReportsLOVRequest) Authorization(authorization string) LOVApiGetBankAccountsForReportsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetBankAccountsForReportsLOVRequest) XAppKey(xAppKey string) LOVApiGetBankAccountsForReportsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetBankAccountsForReportsLOVRequest) XHotelid(xHotelid string) LOVApiGetBankAccountsForReportsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetBankAccountsForReportsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetBankAccountsForReportsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetBankAccountsForReportsLOVRequest) ParameterName(parameterName []string) LOVApiGetBankAccountsForReportsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetBankAccountsForReportsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetBankAccountsForReportsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetBankAccountsForReportsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetBankAccountsForReportsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetBankAccountsForReportsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetBankAccountsForReportsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetBankAccountsForReportsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetBankAccountsForReportsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetBankAccountsForReportsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetBankAccountsForReportsLOVExecute(r)
}

/*
GetBankAccountsForReportsLOV Fetch List Of Values for Bank Accounts For Reports

 <p><strong>OperationId:</strong>getBankAccountsForReportsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch BankAccountsForReports LOV
 @return LOVApiGetBankAccountsForReportsLOVRequest
*/
func (a *LOVApiService) GetBankAccountsForReportsLOV(ctx context.Context, hotelId string) LOVApiGetBankAccountsForReportsLOVRequest {
	return LOVApiGetBankAccountsForReportsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetBankAccountsForReportsLOVExecute(r LOVApiGetBankAccountsForReportsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetBankAccountsForReportsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/bankAccountsForReports"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetBankAccountsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetBankAccountsLOVRequest) Authorization(authorization string) LOVApiGetBankAccountsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetBankAccountsLOVRequest) XAppKey(xAppKey string) LOVApiGetBankAccountsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetBankAccountsLOVRequest) XHotelid(xHotelid string) LOVApiGetBankAccountsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetBankAccountsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetBankAccountsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetBankAccountsLOVRequest) ParameterName(parameterName []string) LOVApiGetBankAccountsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetBankAccountsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetBankAccountsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetBankAccountsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetBankAccountsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetBankAccountsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetBankAccountsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetBankAccountsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetBankAccountsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetBankAccountsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetBankAccountsLOVExecute(r)
}

/*
GetBankAccountsLOV Fetch List Of Values for Bank Accounts

 <p><strong>OperationId:</strong>getBankAccountsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch BankAccounts LOV
 @return LOVApiGetBankAccountsLOVRequest
*/
func (a *LOVApiService) GetBankAccountsLOV(ctx context.Context, hotelId string) LOVApiGetBankAccountsLOVRequest {
	return LOVApiGetBankAccountsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetBankAccountsLOVExecute(r LOVApiGetBankAccountsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetBankAccountsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/bankAccounts"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetBanquetPrintingMethodLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetBanquetPrintingMethodLOVRequest) Authorization(authorization string) LOVApiGetBanquetPrintingMethodLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetBanquetPrintingMethodLOVRequest) XAppKey(xAppKey string) LOVApiGetBanquetPrintingMethodLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetBanquetPrintingMethodLOVRequest) XHotelid(xHotelid string) LOVApiGetBanquetPrintingMethodLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetBanquetPrintingMethodLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetBanquetPrintingMethodLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetBanquetPrintingMethodLOVRequest) ParameterName(parameterName []string) LOVApiGetBanquetPrintingMethodLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetBanquetPrintingMethodLOVRequest) ParameterValue(parameterValue []string) LOVApiGetBanquetPrintingMethodLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetBanquetPrintingMethodLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetBanquetPrintingMethodLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetBanquetPrintingMethodLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetBanquetPrintingMethodLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetBanquetPrintingMethodLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetBanquetPrintingMethodLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetBanquetPrintingMethodLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetBanquetPrintingMethodLOVExecute(r)
}

/*
GetBanquetPrintingMethodLOV Fetch List Of Values for Banquet Printing Method

 <p><strong>OperationId:</strong>getBanquetPrintingMethodLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch BanquetPrintingMethod LOV
 @return LOVApiGetBanquetPrintingMethodLOVRequest
*/
func (a *LOVApiService) GetBanquetPrintingMethodLOV(ctx context.Context, hotelId string) LOVApiGetBanquetPrintingMethodLOVRequest {
	return LOVApiGetBanquetPrintingMethodLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetBanquetPrintingMethodLOVExecute(r LOVApiGetBanquetPrintingMethodLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetBanquetPrintingMethodLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/banquetPrintingMethod"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetBillingInstructionsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetBillingInstructionsLOVRequest) Authorization(authorization string) LOVApiGetBillingInstructionsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetBillingInstructionsLOVRequest) XAppKey(xAppKey string) LOVApiGetBillingInstructionsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetBillingInstructionsLOVRequest) XHotelid(xHotelid string) LOVApiGetBillingInstructionsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetBillingInstructionsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetBillingInstructionsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetBillingInstructionsLOVRequest) ParameterName(parameterName []string) LOVApiGetBillingInstructionsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetBillingInstructionsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetBillingInstructionsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetBillingInstructionsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetBillingInstructionsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetBillingInstructionsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetBillingInstructionsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetBillingInstructionsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetBillingInstructionsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetBillingInstructionsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetBillingInstructionsLOVExecute(r)
}

/*
GetBillingInstructionsLOV Fetch List Of Values for Billing Instructions

 <p><strong>OperationId:</strong>getBillingInstructionsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch BillingInstructions LOV
 @return LOVApiGetBillingInstructionsLOVRequest
*/
func (a *LOVApiService) GetBillingInstructionsLOV(ctx context.Context, hotelId string) LOVApiGetBillingInstructionsLOVRequest {
	return LOVApiGetBillingInstructionsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetBillingInstructionsLOVExecute(r LOVApiGetBillingInstructionsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetBillingInstructionsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/billingInstructions"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetBlockBookingStatusesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	blockId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetBlockBookingStatusesLOVRequest) Authorization(authorization string) LOVApiGetBlockBookingStatusesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetBlockBookingStatusesLOVRequest) XAppKey(xAppKey string) LOVApiGetBlockBookingStatusesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetBlockBookingStatusesLOVRequest) XHotelid(xHotelid string) LOVApiGetBlockBookingStatusesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetBlockBookingStatusesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetBlockBookingStatusesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetBlockBookingStatusesLOVRequest) ParameterName(parameterName []string) LOVApiGetBlockBookingStatusesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetBlockBookingStatusesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetBlockBookingStatusesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetBlockBookingStatusesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetBlockBookingStatusesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetBlockBookingStatusesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetBlockBookingStatusesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetBlockBookingStatusesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetBlockBookingStatusesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetBlockBookingStatusesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetBlockBookingStatusesLOVExecute(r)
}

/*
GetBlockBookingStatusesLOV Fetch List Of Values for Block Booking Statuses

 <p><strong>OperationId:</strong>getBlockBookingStatusesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockId Value of the parameter 'blockId' which is required to fetch BlockBookingStatuses LOV
 @return LOVApiGetBlockBookingStatusesLOVRequest
*/
func (a *LOVApiService) GetBlockBookingStatusesLOV(ctx context.Context, blockId string) LOVApiGetBlockBookingStatusesLOVRequest {
	return LOVApiGetBlockBookingStatusesLOVRequest{
		ApiService: a,
		ctx: ctx,
		blockId: blockId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetBlockBookingStatusesLOVExecute(r LOVApiGetBlockBookingStatusesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetBlockBookingStatusesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/blockId/{blockId}/blockBookingStatuses"
	localVarPath = strings.Replace(localVarPath, "{"+"blockId"+"}", url.PathEscape(parameterValueToString(r.blockId, "blockId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.blockId) < 1 {
		return localVarReturnValue, nil, reportError("blockId must have at least 1 elements")
	}
	if strlen(r.blockId) > 2000 {
		return localVarReturnValue, nil, reportError("blockId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetBlockCatNextStatusesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	catStatus string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetBlockCatNextStatusesLOVRequest) Authorization(authorization string) LOVApiGetBlockCatNextStatusesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetBlockCatNextStatusesLOVRequest) XAppKey(xAppKey string) LOVApiGetBlockCatNextStatusesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetBlockCatNextStatusesLOVRequest) XHotelid(xHotelid string) LOVApiGetBlockCatNextStatusesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetBlockCatNextStatusesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetBlockCatNextStatusesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetBlockCatNextStatusesLOVRequest) ParameterName(parameterName []string) LOVApiGetBlockCatNextStatusesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetBlockCatNextStatusesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetBlockCatNextStatusesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetBlockCatNextStatusesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetBlockCatNextStatusesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetBlockCatNextStatusesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetBlockCatNextStatusesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetBlockCatNextStatusesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetBlockCatNextStatusesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetBlockCatNextStatusesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetBlockCatNextStatusesLOVExecute(r)
}

/*
GetBlockCatNextStatusesLOV Fetch List Of Values for Block Cat Next Statuses

 <p><strong>OperationId:</strong>getBlockCatNextStatusesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param catStatus Value of the parameter 'catStatus' which is required to fetch BlockCatNextStatuses LOV
 @return LOVApiGetBlockCatNextStatusesLOVRequest
*/
func (a *LOVApiService) GetBlockCatNextStatusesLOV(ctx context.Context, catStatus string) LOVApiGetBlockCatNextStatusesLOVRequest {
	return LOVApiGetBlockCatNextStatusesLOVRequest{
		ApiService: a,
		ctx: ctx,
		catStatus: catStatus,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetBlockCatNextStatusesLOVExecute(r LOVApiGetBlockCatNextStatusesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetBlockCatNextStatusesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/catStatus/{catStatus}/blockCatNextStatuses"
	localVarPath = strings.Replace(localVarPath, "{"+"catStatus"+"}", url.PathEscape(parameterValueToString(r.catStatus, "catStatus")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.catStatus) < 1 {
		return localVarReturnValue, nil, reportError("catStatus must have at least 1 elements")
	}
	if strlen(r.catStatus) > 2000 {
		return localVarReturnValue, nil, reportError("catStatus must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetBlockCodesByArrivalDateLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	arrivalDate string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetBlockCodesByArrivalDateLOVRequest) Authorization(authorization string) LOVApiGetBlockCodesByArrivalDateLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetBlockCodesByArrivalDateLOVRequest) XAppKey(xAppKey string) LOVApiGetBlockCodesByArrivalDateLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetBlockCodesByArrivalDateLOVRequest) XHotelid(xHotelid string) LOVApiGetBlockCodesByArrivalDateLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetBlockCodesByArrivalDateLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetBlockCodesByArrivalDateLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetBlockCodesByArrivalDateLOVRequest) ParameterName(parameterName []string) LOVApiGetBlockCodesByArrivalDateLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetBlockCodesByArrivalDateLOVRequest) ParameterValue(parameterValue []string) LOVApiGetBlockCodesByArrivalDateLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetBlockCodesByArrivalDateLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetBlockCodesByArrivalDateLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetBlockCodesByArrivalDateLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetBlockCodesByArrivalDateLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetBlockCodesByArrivalDateLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetBlockCodesByArrivalDateLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetBlockCodesByArrivalDateLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetBlockCodesByArrivalDateLOVExecute(r)
}

/*
GetBlockCodesByArrivalDateLOV Fetch List Of Values for Block Codes By Arrival Date

 <p><strong>OperationId:</strong>getBlockCodesByArrivalDateLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param arrivalDate Value of the parameter 'arrivalDate' which is required to fetch BlockCodesByArrivalDate LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch BlockCodesByArrivalDate LOV
 @return LOVApiGetBlockCodesByArrivalDateLOVRequest
*/
func (a *LOVApiService) GetBlockCodesByArrivalDateLOV(ctx context.Context, arrivalDate string, hotelId string) LOVApiGetBlockCodesByArrivalDateLOVRequest {
	return LOVApiGetBlockCodesByArrivalDateLOVRequest{
		ApiService: a,
		ctx: ctx,
		arrivalDate: arrivalDate,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetBlockCodesByArrivalDateLOVExecute(r LOVApiGetBlockCodesByArrivalDateLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetBlockCodesByArrivalDateLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/arrivalDate/{arrivalDate}/blockCodesByArrivalDate"
	localVarPath = strings.Replace(localVarPath, "{"+"arrivalDate"+"}", url.PathEscape(parameterValueToString(r.arrivalDate, "arrivalDate")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.arrivalDate) < 1 {
		return localVarReturnValue, nil, reportError("arrivalDate must have at least 1 elements")
	}
	if strlen(r.arrivalDate) > 2000 {
		return localVarReturnValue, nil, reportError("arrivalDate must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetBlockCodesFinOperationsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetBlockCodesFinOperationsLOVRequest) Authorization(authorization string) LOVApiGetBlockCodesFinOperationsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetBlockCodesFinOperationsLOVRequest) XAppKey(xAppKey string) LOVApiGetBlockCodesFinOperationsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetBlockCodesFinOperationsLOVRequest) XHotelid(xHotelid string) LOVApiGetBlockCodesFinOperationsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetBlockCodesFinOperationsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetBlockCodesFinOperationsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetBlockCodesFinOperationsLOVRequest) ParameterName(parameterName []string) LOVApiGetBlockCodesFinOperationsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetBlockCodesFinOperationsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetBlockCodesFinOperationsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetBlockCodesFinOperationsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetBlockCodesFinOperationsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetBlockCodesFinOperationsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetBlockCodesFinOperationsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetBlockCodesFinOperationsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetBlockCodesFinOperationsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetBlockCodesFinOperationsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetBlockCodesFinOperationsLOVExecute(r)
}

/*
GetBlockCodesFinOperationsLOV Fetch List Of Values for Block Codes Fin Operations

 <p><strong>OperationId:</strong>getBlockCodesFinOperationsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch BlockCodesFinOperations LOV
 @return LOVApiGetBlockCodesFinOperationsLOVRequest
*/
func (a *LOVApiService) GetBlockCodesFinOperationsLOV(ctx context.Context, hotelId string) LOVApiGetBlockCodesFinOperationsLOVRequest {
	return LOVApiGetBlockCodesFinOperationsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetBlockCodesFinOperationsLOVExecute(r LOVApiGetBlockCodesFinOperationsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetBlockCodesFinOperationsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/blockCodesFinOperations"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetBlockCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	endDate string
	beginDate string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetBlockCodesLOVRequest) Authorization(authorization string) LOVApiGetBlockCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetBlockCodesLOVRequest) XAppKey(xAppKey string) LOVApiGetBlockCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetBlockCodesLOVRequest) XHotelid(xHotelid string) LOVApiGetBlockCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetBlockCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetBlockCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetBlockCodesLOVRequest) ParameterName(parameterName []string) LOVApiGetBlockCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetBlockCodesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetBlockCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetBlockCodesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetBlockCodesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetBlockCodesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetBlockCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetBlockCodesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetBlockCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetBlockCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetBlockCodesLOVExecute(r)
}

/*
GetBlockCodesLOV Fetch List Of Values for Block Codes

 <p><strong>OperationId:</strong>getBlockCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param endDate Value of the parameter 'endDate' which is required to fetch BlockCodes LOV
 @param beginDate Value of the parameter 'beginDate' which is required to fetch BlockCodes LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch BlockCodes LOV
 @return LOVApiGetBlockCodesLOVRequest
*/
func (a *LOVApiService) GetBlockCodesLOV(ctx context.Context, endDate string, beginDate string, hotelId string) LOVApiGetBlockCodesLOVRequest {
	return LOVApiGetBlockCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		endDate: endDate,
		beginDate: beginDate,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetBlockCodesLOVExecute(r LOVApiGetBlockCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetBlockCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/beginDate/{beginDate}/endDate/{endDate}/blockCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"endDate"+"}", url.PathEscape(parameterValueToString(r.endDate, "endDate")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"beginDate"+"}", url.PathEscape(parameterValueToString(r.beginDate, "beginDate")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.endDate) < 1 {
		return localVarReturnValue, nil, reportError("endDate must have at least 1 elements")
	}
	if strlen(r.endDate) > 2000 {
		return localVarReturnValue, nil, reportError("endDate must have less than 2000 elements")
	}
	if strlen(r.beginDate) < 1 {
		return localVarReturnValue, nil, reportError("beginDate must have at least 1 elements")
	}
	if strlen(r.beginDate) > 2000 {
		return localVarReturnValue, nil, reportError("beginDate must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetBlockCurrentStatusesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	blockId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetBlockCurrentStatusesLOVRequest) Authorization(authorization string) LOVApiGetBlockCurrentStatusesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetBlockCurrentStatusesLOVRequest) XAppKey(xAppKey string) LOVApiGetBlockCurrentStatusesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetBlockCurrentStatusesLOVRequest) XHotelid(xHotelid string) LOVApiGetBlockCurrentStatusesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetBlockCurrentStatusesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetBlockCurrentStatusesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetBlockCurrentStatusesLOVRequest) ParameterName(parameterName []string) LOVApiGetBlockCurrentStatusesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetBlockCurrentStatusesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetBlockCurrentStatusesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetBlockCurrentStatusesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetBlockCurrentStatusesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetBlockCurrentStatusesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetBlockCurrentStatusesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetBlockCurrentStatusesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetBlockCurrentStatusesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetBlockCurrentStatusesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetBlockCurrentStatusesLOVExecute(r)
}

/*
GetBlockCurrentStatusesLOV Fetch List Of Values for Block Current Statuses

 <p><strong>OperationId:</strong>getBlockCurrentStatusesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockId Value of the parameter 'blockId' which is required to fetch BlockCurrentStatuses LOV
 @return LOVApiGetBlockCurrentStatusesLOVRequest
*/
func (a *LOVApiService) GetBlockCurrentStatusesLOV(ctx context.Context, blockId string) LOVApiGetBlockCurrentStatusesLOVRequest {
	return LOVApiGetBlockCurrentStatusesLOVRequest{
		ApiService: a,
		ctx: ctx,
		blockId: blockId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetBlockCurrentStatusesLOVExecute(r LOVApiGetBlockCurrentStatusesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetBlockCurrentStatusesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/blockId/{blockId}/blockCurrentStatuses"
	localVarPath = strings.Replace(localVarPath, "{"+"blockId"+"}", url.PathEscape(parameterValueToString(r.blockId, "blockId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.blockId) < 1 {
		return localVarReturnValue, nil, reportError("blockId must have at least 1 elements")
	}
	if strlen(r.blockId) > 2000 {
		return localVarReturnValue, nil, reportError("blockId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetBlockEventIdsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	blockId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetBlockEventIdsLOVRequest) Authorization(authorization string) LOVApiGetBlockEventIdsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetBlockEventIdsLOVRequest) XAppKey(xAppKey string) LOVApiGetBlockEventIdsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetBlockEventIdsLOVRequest) XHotelid(xHotelid string) LOVApiGetBlockEventIdsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetBlockEventIdsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetBlockEventIdsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetBlockEventIdsLOVRequest) ParameterName(parameterName []string) LOVApiGetBlockEventIdsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetBlockEventIdsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetBlockEventIdsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetBlockEventIdsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetBlockEventIdsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetBlockEventIdsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetBlockEventIdsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetBlockEventIdsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetBlockEventIdsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetBlockEventIdsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetBlockEventIdsLOVExecute(r)
}

/*
GetBlockEventIdsLOV Fetch List Of Values for Block Event Ids

 <p><strong>OperationId:</strong>getBlockEventIdsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockId Value of the parameter 'blockId' which is required to fetch BlockEventIds LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch BlockEventIds LOV
 @return LOVApiGetBlockEventIdsLOVRequest
*/
func (a *LOVApiService) GetBlockEventIdsLOV(ctx context.Context, blockId string, hotelId string) LOVApiGetBlockEventIdsLOVRequest {
	return LOVApiGetBlockEventIdsLOVRequest{
		ApiService: a,
		ctx: ctx,
		blockId: blockId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetBlockEventIdsLOVExecute(r LOVApiGetBlockEventIdsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetBlockEventIdsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/blockId/{blockId}/blockEventIds"
	localVarPath = strings.Replace(localVarPath, "{"+"blockId"+"}", url.PathEscape(parameterValueToString(r.blockId, "blockId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.blockId) < 1 {
		return localVarReturnValue, nil, reportError("blockId must have at least 1 elements")
	}
	if strlen(r.blockId) > 2000 {
		return localVarReturnValue, nil, reportError("blockId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetBlockEventsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetBlockEventsLOVRequest) Authorization(authorization string) LOVApiGetBlockEventsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetBlockEventsLOVRequest) XAppKey(xAppKey string) LOVApiGetBlockEventsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetBlockEventsLOVRequest) XHotelid(xHotelid string) LOVApiGetBlockEventsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetBlockEventsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetBlockEventsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetBlockEventsLOVRequest) ParameterName(parameterName []string) LOVApiGetBlockEventsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetBlockEventsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetBlockEventsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetBlockEventsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetBlockEventsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetBlockEventsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetBlockEventsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetBlockEventsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetBlockEventsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetBlockEventsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetBlockEventsLOVExecute(r)
}

/*
GetBlockEventsLOV Fetch List Of Values for Block Events

 <p><strong>OperationId:</strong>getBlockEventsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch BlockEvents LOV
 @return LOVApiGetBlockEventsLOVRequest
*/
func (a *LOVApiService) GetBlockEventsLOV(ctx context.Context, hotelId string) LOVApiGetBlockEventsLOVRequest {
	return LOVApiGetBlockEventsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetBlockEventsLOVExecute(r LOVApiGetBlockEventsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetBlockEventsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/blockEvents"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetBlockIdsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	endDate string
	beginDate string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetBlockIdsLOVRequest) Authorization(authorization string) LOVApiGetBlockIdsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetBlockIdsLOVRequest) XAppKey(xAppKey string) LOVApiGetBlockIdsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetBlockIdsLOVRequest) XHotelid(xHotelid string) LOVApiGetBlockIdsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetBlockIdsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetBlockIdsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetBlockIdsLOVRequest) ParameterName(parameterName []string) LOVApiGetBlockIdsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetBlockIdsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetBlockIdsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetBlockIdsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetBlockIdsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetBlockIdsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetBlockIdsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetBlockIdsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetBlockIdsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetBlockIdsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetBlockIdsLOVExecute(r)
}

/*
GetBlockIdsLOV Fetch List Of Values for Block Ids

 <p><strong>OperationId:</strong>getBlockIdsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param endDate Value of the parameter 'endDate' which is required to fetch BlockIds LOV
 @param beginDate Value of the parameter 'beginDate' which is required to fetch BlockIds LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch BlockIds LOV
 @return LOVApiGetBlockIdsLOVRequest
*/
func (a *LOVApiService) GetBlockIdsLOV(ctx context.Context, endDate string, beginDate string, hotelId string) LOVApiGetBlockIdsLOVRequest {
	return LOVApiGetBlockIdsLOVRequest{
		ApiService: a,
		ctx: ctx,
		endDate: endDate,
		beginDate: beginDate,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetBlockIdsLOVExecute(r LOVApiGetBlockIdsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetBlockIdsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/beginDate/{beginDate}/endDate/{endDate}/blockIds"
	localVarPath = strings.Replace(localVarPath, "{"+"endDate"+"}", url.PathEscape(parameterValueToString(r.endDate, "endDate")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"beginDate"+"}", url.PathEscape(parameterValueToString(r.beginDate, "beginDate")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.endDate) < 1 {
		return localVarReturnValue, nil, reportError("endDate must have at least 1 elements")
	}
	if strlen(r.endDate) > 2000 {
		return localVarReturnValue, nil, reportError("endDate must have less than 2000 elements")
	}
	if strlen(r.beginDate) < 1 {
		return localVarReturnValue, nil, reportError("beginDate must have at least 1 elements")
	}
	if strlen(r.beginDate) > 2000 {
		return localVarReturnValue, nil, reportError("beginDate must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetBlockModeLovLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetBlockModeLovLOVRequest) Authorization(authorization string) LOVApiGetBlockModeLovLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetBlockModeLovLOVRequest) XAppKey(xAppKey string) LOVApiGetBlockModeLovLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetBlockModeLovLOVRequest) XHotelid(xHotelid string) LOVApiGetBlockModeLovLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetBlockModeLovLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetBlockModeLovLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetBlockModeLovLOVRequest) ParameterName(parameterName []string) LOVApiGetBlockModeLovLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetBlockModeLovLOVRequest) ParameterValue(parameterValue []string) LOVApiGetBlockModeLovLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetBlockModeLovLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetBlockModeLovLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetBlockModeLovLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetBlockModeLovLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetBlockModeLovLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetBlockModeLovLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetBlockModeLovLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetBlockModeLovLOVExecute(r)
}

/*
GetBlockModeLovLOV Fetch List Of Values for Block Mode Lov

 <p><strong>OperationId:</strong>getBlockModeLovLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch BlockModeLov LOV
 @return LOVApiGetBlockModeLovLOVRequest
*/
func (a *LOVApiService) GetBlockModeLovLOV(ctx context.Context, hotelId string) LOVApiGetBlockModeLovLOVRequest {
	return LOVApiGetBlockModeLovLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetBlockModeLovLOVExecute(r LOVApiGetBlockModeLovLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetBlockModeLovLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/blockModeLov"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetBlockNextStatusesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	bookingStatus string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetBlockNextStatusesLOVRequest) Authorization(authorization string) LOVApiGetBlockNextStatusesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetBlockNextStatusesLOVRequest) XAppKey(xAppKey string) LOVApiGetBlockNextStatusesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetBlockNextStatusesLOVRequest) XHotelid(xHotelid string) LOVApiGetBlockNextStatusesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetBlockNextStatusesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetBlockNextStatusesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetBlockNextStatusesLOVRequest) ParameterName(parameterName []string) LOVApiGetBlockNextStatusesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetBlockNextStatusesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetBlockNextStatusesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetBlockNextStatusesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetBlockNextStatusesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetBlockNextStatusesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetBlockNextStatusesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetBlockNextStatusesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetBlockNextStatusesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetBlockNextStatusesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetBlockNextStatusesLOVExecute(r)
}

/*
GetBlockNextStatusesLOV Fetch List Of Values for Block Next Statuses

 <p><strong>OperationId:</strong>getBlockNextStatusesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bookingStatus Value of the parameter 'bookingStatus' which is required to fetch BlockNextStatuses LOV
 @return LOVApiGetBlockNextStatusesLOVRequest
*/
func (a *LOVApiService) GetBlockNextStatusesLOV(ctx context.Context, bookingStatus string) LOVApiGetBlockNextStatusesLOVRequest {
	return LOVApiGetBlockNextStatusesLOVRequest{
		ApiService: a,
		ctx: ctx,
		bookingStatus: bookingStatus,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetBlockNextStatusesLOVExecute(r LOVApiGetBlockNextStatusesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetBlockNextStatusesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/bookingStatus/{bookingStatus}/blockNextStatuses"
	localVarPath = strings.Replace(localVarPath, "{"+"bookingStatus"+"}", url.PathEscape(parameterValueToString(r.bookingStatus, "bookingStatus")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.bookingStatus) < 1 {
		return localVarReturnValue, nil, reportError("bookingStatus must have at least 1 elements")
	}
	if strlen(r.bookingStatus) > 2000 {
		return localVarReturnValue, nil, reportError("bookingStatus must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetBlockPaymentMethodsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetBlockPaymentMethodsLOVRequest) Authorization(authorization string) LOVApiGetBlockPaymentMethodsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetBlockPaymentMethodsLOVRequest) XAppKey(xAppKey string) LOVApiGetBlockPaymentMethodsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetBlockPaymentMethodsLOVRequest) XHotelid(xHotelid string) LOVApiGetBlockPaymentMethodsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetBlockPaymentMethodsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetBlockPaymentMethodsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetBlockPaymentMethodsLOVRequest) ParameterName(parameterName []string) LOVApiGetBlockPaymentMethodsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetBlockPaymentMethodsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetBlockPaymentMethodsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetBlockPaymentMethodsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetBlockPaymentMethodsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetBlockPaymentMethodsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetBlockPaymentMethodsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetBlockPaymentMethodsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetBlockPaymentMethodsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetBlockPaymentMethodsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetBlockPaymentMethodsLOVExecute(r)
}

/*
GetBlockPaymentMethodsLOV Fetch List Of Values for Block Payment Methods

 <p><strong>OperationId:</strong>getBlockPaymentMethodsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch BlockPaymentMethods LOV
 @return LOVApiGetBlockPaymentMethodsLOVRequest
*/
func (a *LOVApiService) GetBlockPaymentMethodsLOV(ctx context.Context, hotelId string) LOVApiGetBlockPaymentMethodsLOVRequest {
	return LOVApiGetBlockPaymentMethodsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetBlockPaymentMethodsLOVExecute(r LOVApiGetBlockPaymentMethodsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetBlockPaymentMethodsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/blockPaymentMethods"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetBlockRateCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	negotiatedOnly string
	endDate string
	beginDate string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetBlockRateCodesLOVRequest) Authorization(authorization string) LOVApiGetBlockRateCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetBlockRateCodesLOVRequest) XAppKey(xAppKey string) LOVApiGetBlockRateCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetBlockRateCodesLOVRequest) XHotelid(xHotelid string) LOVApiGetBlockRateCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetBlockRateCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetBlockRateCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetBlockRateCodesLOVRequest) ParameterName(parameterName []string) LOVApiGetBlockRateCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetBlockRateCodesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetBlockRateCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetBlockRateCodesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetBlockRateCodesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetBlockRateCodesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetBlockRateCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetBlockRateCodesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetBlockRateCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetBlockRateCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetBlockRateCodesLOVExecute(r)
}

/*
GetBlockRateCodesLOV Fetch List Of Values for Block Rate Codes

 <p><strong>OperationId:</strong>getBlockRateCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param negotiatedOnly Value of the parameter 'negotiatedOnly' which is required to fetch BlockRateCodes LOV
 @param endDate Value of the parameter 'endDate' which is required to fetch BlockRateCodes LOV
 @param beginDate Value of the parameter 'beginDate' which is required to fetch BlockRateCodes LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch BlockRateCodes LOV
 @return LOVApiGetBlockRateCodesLOVRequest
*/
func (a *LOVApiService) GetBlockRateCodesLOV(ctx context.Context, negotiatedOnly string, endDate string, beginDate string, hotelId string) LOVApiGetBlockRateCodesLOVRequest {
	return LOVApiGetBlockRateCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		negotiatedOnly: negotiatedOnly,
		endDate: endDate,
		beginDate: beginDate,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetBlockRateCodesLOVExecute(r LOVApiGetBlockRateCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetBlockRateCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/beginDate/{beginDate}/endDate/{endDate}/negotiatedOnly/{negotiatedOnly}/blockRateCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"negotiatedOnly"+"}", url.PathEscape(parameterValueToString(r.negotiatedOnly, "negotiatedOnly")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"endDate"+"}", url.PathEscape(parameterValueToString(r.endDate, "endDate")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"beginDate"+"}", url.PathEscape(parameterValueToString(r.beginDate, "beginDate")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.negotiatedOnly) < 1 {
		return localVarReturnValue, nil, reportError("negotiatedOnly must have at least 1 elements")
	}
	if strlen(r.negotiatedOnly) > 2000 {
		return localVarReturnValue, nil, reportError("negotiatedOnly must have less than 2000 elements")
	}
	if strlen(r.endDate) < 1 {
		return localVarReturnValue, nil, reportError("endDate must have at least 1 elements")
	}
	if strlen(r.endDate) > 2000 {
		return localVarReturnValue, nil, reportError("endDate must have less than 2000 elements")
	}
	if strlen(r.beginDate) < 1 {
		return localVarReturnValue, nil, reportError("beginDate must have at least 1 elements")
	}
	if strlen(r.beginDate) > 2000 {
		return localVarReturnValue, nil, reportError("beginDate must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetBlockRatesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	blockId string
	departure string
	arrival string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetBlockRatesLOVRequest) Authorization(authorization string) LOVApiGetBlockRatesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetBlockRatesLOVRequest) XAppKey(xAppKey string) LOVApiGetBlockRatesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetBlockRatesLOVRequest) XHotelid(xHotelid string) LOVApiGetBlockRatesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetBlockRatesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetBlockRatesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetBlockRatesLOVRequest) ParameterName(parameterName []string) LOVApiGetBlockRatesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetBlockRatesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetBlockRatesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetBlockRatesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetBlockRatesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetBlockRatesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetBlockRatesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetBlockRatesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetBlockRatesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetBlockRatesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetBlockRatesLOVExecute(r)
}

/*
GetBlockRatesLOV Fetch List Of Values for Block Rates

 <p><strong>OperationId:</strong>getBlockRatesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockId Value of the parameter 'blockId' which is required to fetch BlockRates LOV
 @param departure Value of the parameter 'departure' which is required to fetch BlockRates LOV
 @param arrival Value of the parameter 'arrival' which is required to fetch BlockRates LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch BlockRates LOV
 @return LOVApiGetBlockRatesLOVRequest
*/
func (a *LOVApiService) GetBlockRatesLOV(ctx context.Context, blockId string, departure string, arrival string, hotelId string) LOVApiGetBlockRatesLOVRequest {
	return LOVApiGetBlockRatesLOVRequest{
		ApiService: a,
		ctx: ctx,
		blockId: blockId,
		departure: departure,
		arrival: arrival,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetBlockRatesLOVExecute(r LOVApiGetBlockRatesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetBlockRatesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/arrival/{arrival}/departure/{departure}/blockId/{blockId}/blockRates"
	localVarPath = strings.Replace(localVarPath, "{"+"blockId"+"}", url.PathEscape(parameterValueToString(r.blockId, "blockId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"departure"+"}", url.PathEscape(parameterValueToString(r.departure, "departure")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"arrival"+"}", url.PathEscape(parameterValueToString(r.arrival, "arrival")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.blockId) < 1 {
		return localVarReturnValue, nil, reportError("blockId must have at least 1 elements")
	}
	if strlen(r.blockId) > 2000 {
		return localVarReturnValue, nil, reportError("blockId must have less than 2000 elements")
	}
	if strlen(r.departure) < 1 {
		return localVarReturnValue, nil, reportError("departure must have at least 1 elements")
	}
	if strlen(r.departure) > 2000 {
		return localVarReturnValue, nil, reportError("departure must have less than 2000 elements")
	}
	if strlen(r.arrival) < 1 {
		return localVarReturnValue, nil, reportError("arrival must have at least 1 elements")
	}
	if strlen(r.arrival) > 2000 {
		return localVarReturnValue, nil, reportError("arrival must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetBlockReservationTypesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	bookingStatus string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetBlockReservationTypesLOVRequest) Authorization(authorization string) LOVApiGetBlockReservationTypesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetBlockReservationTypesLOVRequest) XAppKey(xAppKey string) LOVApiGetBlockReservationTypesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetBlockReservationTypesLOVRequest) XHotelid(xHotelid string) LOVApiGetBlockReservationTypesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetBlockReservationTypesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetBlockReservationTypesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetBlockReservationTypesLOVRequest) ParameterName(parameterName []string) LOVApiGetBlockReservationTypesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetBlockReservationTypesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetBlockReservationTypesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetBlockReservationTypesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetBlockReservationTypesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetBlockReservationTypesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetBlockReservationTypesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetBlockReservationTypesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetBlockReservationTypesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetBlockReservationTypesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetBlockReservationTypesLOVExecute(r)
}

/*
GetBlockReservationTypesLOV Fetch List Of Values for Block Reservation Types

 <p><strong>OperationId:</strong>getBlockReservationTypesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bookingStatus Value of the parameter 'bookingStatus' which is required to fetch BlockReservationTypes LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch BlockReservationTypes LOV
 @return LOVApiGetBlockReservationTypesLOVRequest
*/
func (a *LOVApiService) GetBlockReservationTypesLOV(ctx context.Context, bookingStatus string, hotelId string) LOVApiGetBlockReservationTypesLOVRequest {
	return LOVApiGetBlockReservationTypesLOVRequest{
		ApiService: a,
		ctx: ctx,
		bookingStatus: bookingStatus,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetBlockReservationTypesLOVExecute(r LOVApiGetBlockReservationTypesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetBlockReservationTypesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/bookingStatus/{bookingStatus}/blockReservationTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"bookingStatus"+"}", url.PathEscape(parameterValueToString(r.bookingStatus, "bookingStatus")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.bookingStatus) < 1 {
		return localVarReturnValue, nil, reportError("bookingStatus must have at least 1 elements")
	}
	if strlen(r.bookingStatus) > 2000 {
		return localVarReturnValue, nil, reportError("bookingStatus must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetBookingChannelRatePlansLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	channel string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetBookingChannelRatePlansLOVRequest) Authorization(authorization string) LOVApiGetBookingChannelRatePlansLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetBookingChannelRatePlansLOVRequest) XAppKey(xAppKey string) LOVApiGetBookingChannelRatePlansLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetBookingChannelRatePlansLOVRequest) XHotelid(xHotelid string) LOVApiGetBookingChannelRatePlansLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetBookingChannelRatePlansLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetBookingChannelRatePlansLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetBookingChannelRatePlansLOVRequest) ParameterName(parameterName []string) LOVApiGetBookingChannelRatePlansLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetBookingChannelRatePlansLOVRequest) ParameterValue(parameterValue []string) LOVApiGetBookingChannelRatePlansLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetBookingChannelRatePlansLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetBookingChannelRatePlansLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetBookingChannelRatePlansLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetBookingChannelRatePlansLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetBookingChannelRatePlansLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetBookingChannelRatePlansLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetBookingChannelRatePlansLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetBookingChannelRatePlansLOVExecute(r)
}

/*
GetBookingChannelRatePlansLOV Fetch List Of Values for Booking Channel Rate Plans

 <p><strong>OperationId:</strong>getBookingChannelRatePlansLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param channel Value of the parameter 'channel' which is required to fetch BookingChannelRatePlans LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch BookingChannelRatePlans LOV
 @return LOVApiGetBookingChannelRatePlansLOVRequest
*/
func (a *LOVApiService) GetBookingChannelRatePlansLOV(ctx context.Context, channel string, hotelId string) LOVApiGetBookingChannelRatePlansLOVRequest {
	return LOVApiGetBookingChannelRatePlansLOVRequest{
		ApiService: a,
		ctx: ctx,
		channel: channel,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetBookingChannelRatePlansLOVExecute(r LOVApiGetBookingChannelRatePlansLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetBookingChannelRatePlansLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/channel/{channel}/bookingChannelRatePlans"
	localVarPath = strings.Replace(localVarPath, "{"+"channel"+"}", url.PathEscape(parameterValueToString(r.channel, "channel")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.channel) < 1 {
		return localVarReturnValue, nil, reportError("channel must have at least 1 elements")
	}
	if strlen(r.channel) > 2000 {
		return localVarReturnValue, nil, reportError("channel must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetBookingChannelRoomTypesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	channel string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetBookingChannelRoomTypesLOVRequest) Authorization(authorization string) LOVApiGetBookingChannelRoomTypesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetBookingChannelRoomTypesLOVRequest) XAppKey(xAppKey string) LOVApiGetBookingChannelRoomTypesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetBookingChannelRoomTypesLOVRequest) XHotelid(xHotelid string) LOVApiGetBookingChannelRoomTypesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetBookingChannelRoomTypesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetBookingChannelRoomTypesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetBookingChannelRoomTypesLOVRequest) ParameterName(parameterName []string) LOVApiGetBookingChannelRoomTypesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetBookingChannelRoomTypesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetBookingChannelRoomTypesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetBookingChannelRoomTypesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetBookingChannelRoomTypesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetBookingChannelRoomTypesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetBookingChannelRoomTypesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetBookingChannelRoomTypesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetBookingChannelRoomTypesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetBookingChannelRoomTypesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetBookingChannelRoomTypesLOVExecute(r)
}

/*
GetBookingChannelRoomTypesLOV Fetch List Of Values for Booking Channel Room Types

 <p><strong>OperationId:</strong>getBookingChannelRoomTypesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param channel Value of the parameter 'channel' which is required to fetch BookingChannelRoomTypes LOV
 @return LOVApiGetBookingChannelRoomTypesLOVRequest
*/
func (a *LOVApiService) GetBookingChannelRoomTypesLOV(ctx context.Context, channel string) LOVApiGetBookingChannelRoomTypesLOVRequest {
	return LOVApiGetBookingChannelRoomTypesLOVRequest{
		ApiService: a,
		ctx: ctx,
		channel: channel,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetBookingChannelRoomTypesLOVExecute(r LOVApiGetBookingChannelRoomTypesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetBookingChannelRoomTypesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/channel/{channel}/bookingChannelRoomTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"channel"+"}", url.PathEscape(parameterValueToString(r.channel, "channel")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.channel) < 1 {
		return localVarReturnValue, nil, reportError("channel must have at least 1 elements")
	}
	if strlen(r.channel) > 2000 {
		return localVarReturnValue, nil, reportError("channel must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetBookingTypesIndividualsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetBookingTypesIndividualsLOVRequest) Authorization(authorization string) LOVApiGetBookingTypesIndividualsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetBookingTypesIndividualsLOVRequest) XAppKey(xAppKey string) LOVApiGetBookingTypesIndividualsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetBookingTypesIndividualsLOVRequest) XHotelid(xHotelid string) LOVApiGetBookingTypesIndividualsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetBookingTypesIndividualsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetBookingTypesIndividualsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetBookingTypesIndividualsLOVRequest) ParameterName(parameterName []string) LOVApiGetBookingTypesIndividualsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetBookingTypesIndividualsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetBookingTypesIndividualsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetBookingTypesIndividualsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetBookingTypesIndividualsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetBookingTypesIndividualsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetBookingTypesIndividualsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetBookingTypesIndividualsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetBookingTypesIndividualsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetBookingTypesIndividualsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetBookingTypesIndividualsLOVExecute(r)
}

/*
GetBookingTypesIndividualsLOV Fetch List Of Values for Booking Types Individuals

 <p><strong>OperationId:</strong>getBookingTypesIndividualsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch BookingTypesIndividuals LOV
 @return LOVApiGetBookingTypesIndividualsLOVRequest
*/
func (a *LOVApiService) GetBookingTypesIndividualsLOV(ctx context.Context, hotelId string) LOVApiGetBookingTypesIndividualsLOVRequest {
	return LOVApiGetBookingTypesIndividualsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetBookingTypesIndividualsLOVExecute(r LOVApiGetBookingTypesIndividualsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetBookingTypesIndividualsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/bookingTypesIndividuals"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetBudgetForecastCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetBudgetForecastCodesLOVRequest) Authorization(authorization string) LOVApiGetBudgetForecastCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetBudgetForecastCodesLOVRequest) XAppKey(xAppKey string) LOVApiGetBudgetForecastCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetBudgetForecastCodesLOVRequest) XHotelid(xHotelid string) LOVApiGetBudgetForecastCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetBudgetForecastCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetBudgetForecastCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetBudgetForecastCodesLOVRequest) ParameterName(parameterName []string) LOVApiGetBudgetForecastCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetBudgetForecastCodesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetBudgetForecastCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetBudgetForecastCodesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetBudgetForecastCodesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetBudgetForecastCodesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetBudgetForecastCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetBudgetForecastCodesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetBudgetForecastCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetBudgetForecastCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetBudgetForecastCodesLOVExecute(r)
}

/*
GetBudgetForecastCodesLOV Fetch List Of Values for Budget Forecast Codes

 <p><strong>OperationId:</strong>getBudgetForecastCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch BudgetForecastCodes LOV
 @return LOVApiGetBudgetForecastCodesLOVRequest
*/
func (a *LOVApiService) GetBudgetForecastCodesLOV(ctx context.Context, hotelId string) LOVApiGetBudgetForecastCodesLOVRequest {
	return LOVApiGetBudgetForecastCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetBudgetForecastCodesLOVExecute(r LOVApiGetBudgetForecastCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetBudgetForecastCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/budgetForecastCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetBudgetRateCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetBudgetRateCodesLOVRequest) Authorization(authorization string) LOVApiGetBudgetRateCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetBudgetRateCodesLOVRequest) XAppKey(xAppKey string) LOVApiGetBudgetRateCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetBudgetRateCodesLOVRequest) XHotelid(xHotelid string) LOVApiGetBudgetRateCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetBudgetRateCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetBudgetRateCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetBudgetRateCodesLOVRequest) ParameterName(parameterName []string) LOVApiGetBudgetRateCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetBudgetRateCodesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetBudgetRateCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetBudgetRateCodesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetBudgetRateCodesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetBudgetRateCodesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetBudgetRateCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetBudgetRateCodesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetBudgetRateCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetBudgetRateCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetBudgetRateCodesLOVExecute(r)
}

/*
GetBudgetRateCodesLOV Fetch List Of Values for Budget Rate Codes

 <p><strong>OperationId:</strong>getBudgetRateCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch BudgetRateCodes LOV
 @return LOVApiGetBudgetRateCodesLOVRequest
*/
func (a *LOVApiService) GetBudgetRateCodesLOV(ctx context.Context, hotelId string) LOVApiGetBudgetRateCodesLOVRequest {
	return LOVApiGetBudgetRateCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetBudgetRateCodesLOVExecute(r LOVApiGetBudgetRateCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetBudgetRateCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/budgetRateCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetBusinessEventActionTypeExtDBLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	databaseId string
	extSystem string
	module string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetBusinessEventActionTypeExtDBLOVRequest) Authorization(authorization string) LOVApiGetBusinessEventActionTypeExtDBLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetBusinessEventActionTypeExtDBLOVRequest) XAppKey(xAppKey string) LOVApiGetBusinessEventActionTypeExtDBLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetBusinessEventActionTypeExtDBLOVRequest) XHotelid(xHotelid string) LOVApiGetBusinessEventActionTypeExtDBLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetBusinessEventActionTypeExtDBLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetBusinessEventActionTypeExtDBLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetBusinessEventActionTypeExtDBLOVRequest) ParameterName(parameterName []string) LOVApiGetBusinessEventActionTypeExtDBLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetBusinessEventActionTypeExtDBLOVRequest) ParameterValue(parameterValue []string) LOVApiGetBusinessEventActionTypeExtDBLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetBusinessEventActionTypeExtDBLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetBusinessEventActionTypeExtDBLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetBusinessEventActionTypeExtDBLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetBusinessEventActionTypeExtDBLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetBusinessEventActionTypeExtDBLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetBusinessEventActionTypeExtDBLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetBusinessEventActionTypeExtDBLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetBusinessEventActionTypeExtDBLOVExecute(r)
}

/*
GetBusinessEventActionTypeExtDBLOV Fetch List Of Values for Business Event Action Type Ext DB

 <p><strong>OperationId:</strong>getBusinessEventActionTypeExtDBLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param databaseId Value of the parameter 'databaseId' which is required to fetch BusinessEventActionTypeExtDB LOV
 @param extSystem Value of the parameter 'extSystem' which is required to fetch BusinessEventActionTypeExtDB LOV
 @param module Value of the parameter 'module' which is required to fetch BusinessEventActionTypeExtDB LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch BusinessEventActionTypeExtDB LOV
 @return LOVApiGetBusinessEventActionTypeExtDBLOVRequest
*/
func (a *LOVApiService) GetBusinessEventActionTypeExtDBLOV(ctx context.Context, databaseId string, extSystem string, module string, hotelId string) LOVApiGetBusinessEventActionTypeExtDBLOVRequest {
	return LOVApiGetBusinessEventActionTypeExtDBLOVRequest{
		ApiService: a,
		ctx: ctx,
		databaseId: databaseId,
		extSystem: extSystem,
		module: module,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetBusinessEventActionTypeExtDBLOVExecute(r LOVApiGetBusinessEventActionTypeExtDBLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetBusinessEventActionTypeExtDBLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/module/{module}/extSystem/{extSystem}/databaseId/{databaseId}/businessEventActionTypeExtDB"
	localVarPath = strings.Replace(localVarPath, "{"+"databaseId"+"}", url.PathEscape(parameterValueToString(r.databaseId, "databaseId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extSystem"+"}", url.PathEscape(parameterValueToString(r.extSystem, "extSystem")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"module"+"}", url.PathEscape(parameterValueToString(r.module, "module")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.databaseId) < 1 {
		return localVarReturnValue, nil, reportError("databaseId must have at least 1 elements")
	}
	if strlen(r.databaseId) > 2000 {
		return localVarReturnValue, nil, reportError("databaseId must have less than 2000 elements")
	}
	if strlen(r.extSystem) < 1 {
		return localVarReturnValue, nil, reportError("extSystem must have at least 1 elements")
	}
	if strlen(r.extSystem) > 2000 {
		return localVarReturnValue, nil, reportError("extSystem must have less than 2000 elements")
	}
	if strlen(r.module) < 1 {
		return localVarReturnValue, nil, reportError("module must have at least 1 elements")
	}
	if strlen(r.module) > 2000 {
		return localVarReturnValue, nil, reportError("module must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetBusinessEventActionTypeLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	module string
	extSystem string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetBusinessEventActionTypeLOVRequest) Authorization(authorization string) LOVApiGetBusinessEventActionTypeLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetBusinessEventActionTypeLOVRequest) XAppKey(xAppKey string) LOVApiGetBusinessEventActionTypeLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetBusinessEventActionTypeLOVRequest) XHotelid(xHotelid string) LOVApiGetBusinessEventActionTypeLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetBusinessEventActionTypeLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetBusinessEventActionTypeLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetBusinessEventActionTypeLOVRequest) ParameterName(parameterName []string) LOVApiGetBusinessEventActionTypeLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetBusinessEventActionTypeLOVRequest) ParameterValue(parameterValue []string) LOVApiGetBusinessEventActionTypeLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetBusinessEventActionTypeLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetBusinessEventActionTypeLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetBusinessEventActionTypeLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetBusinessEventActionTypeLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetBusinessEventActionTypeLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetBusinessEventActionTypeLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetBusinessEventActionTypeLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetBusinessEventActionTypeLOVExecute(r)
}

/*
GetBusinessEventActionTypeLOV Fetch List Of Values for Business Event Action Type

 <p><strong>OperationId:</strong>getBusinessEventActionTypeLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param module Value of the parameter 'module' which is required to fetch BusinessEventActionType LOV
 @param extSystem Value of the parameter 'extSystem' which is required to fetch BusinessEventActionType LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch BusinessEventActionType LOV
 @return LOVApiGetBusinessEventActionTypeLOVRequest
*/
func (a *LOVApiService) GetBusinessEventActionTypeLOV(ctx context.Context, module string, extSystem string, hotelId string) LOVApiGetBusinessEventActionTypeLOVRequest {
	return LOVApiGetBusinessEventActionTypeLOVRequest{
		ApiService: a,
		ctx: ctx,
		module: module,
		extSystem: extSystem,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetBusinessEventActionTypeLOVExecute(r LOVApiGetBusinessEventActionTypeLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetBusinessEventActionTypeLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/extSystem/{extSystem}/module/{module}/businessEventActionType"
	localVarPath = strings.Replace(localVarPath, "{"+"module"+"}", url.PathEscape(parameterValueToString(r.module, "module")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extSystem"+"}", url.PathEscape(parameterValueToString(r.extSystem, "extSystem")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.module) < 1 {
		return localVarReturnValue, nil, reportError("module must have at least 1 elements")
	}
	if strlen(r.module) > 2000 {
		return localVarReturnValue, nil, reportError("module must have less than 2000 elements")
	}
	if strlen(r.extSystem) < 1 {
		return localVarReturnValue, nil, reportError("extSystem must have at least 1 elements")
	}
	if strlen(r.extSystem) > 2000 {
		return localVarReturnValue, nil, reportError("extSystem must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetCampaignActivityTypesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetCampaignActivityTypesLOVRequest) Authorization(authorization string) LOVApiGetCampaignActivityTypesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetCampaignActivityTypesLOVRequest) XAppKey(xAppKey string) LOVApiGetCampaignActivityTypesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetCampaignActivityTypesLOVRequest) XHotelid(xHotelid string) LOVApiGetCampaignActivityTypesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetCampaignActivityTypesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetCampaignActivityTypesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetCampaignActivityTypesLOVRequest) ParameterName(parameterName []string) LOVApiGetCampaignActivityTypesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetCampaignActivityTypesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetCampaignActivityTypesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetCampaignActivityTypesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetCampaignActivityTypesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetCampaignActivityTypesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetCampaignActivityTypesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetCampaignActivityTypesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetCampaignActivityTypesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetCampaignActivityTypesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetCampaignActivityTypesLOVExecute(r)
}

/*
GetCampaignActivityTypesLOV Fetch List Of Values for Campaign Activity Types

 <p><strong>OperationId:</strong>getCampaignActivityTypesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch CampaignActivityTypes LOV
 @return LOVApiGetCampaignActivityTypesLOVRequest
*/
func (a *LOVApiService) GetCampaignActivityTypesLOV(ctx context.Context, hotelId string) LOVApiGetCampaignActivityTypesLOVRequest {
	return LOVApiGetCampaignActivityTypesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetCampaignActivityTypesLOVExecute(r LOVApiGetCampaignActivityTypesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetCampaignActivityTypesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/campaignActivityTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetCashRegisterIDLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetCashRegisterIDLOVRequest) Authorization(authorization string) LOVApiGetCashRegisterIDLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetCashRegisterIDLOVRequest) XAppKey(xAppKey string) LOVApiGetCashRegisterIDLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetCashRegisterIDLOVRequest) XHotelid(xHotelid string) LOVApiGetCashRegisterIDLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetCashRegisterIDLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetCashRegisterIDLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetCashRegisterIDLOVRequest) ParameterName(parameterName []string) LOVApiGetCashRegisterIDLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetCashRegisterIDLOVRequest) ParameterValue(parameterValue []string) LOVApiGetCashRegisterIDLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetCashRegisterIDLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetCashRegisterIDLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetCashRegisterIDLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetCashRegisterIDLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetCashRegisterIDLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetCashRegisterIDLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetCashRegisterIDLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetCashRegisterIDLOVExecute(r)
}

/*
GetCashRegisterIDLOV Fetch List Of Values for Cash Register ID

 <p><strong>OperationId:</strong>getCashRegisterIDLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch CashRegisterID LOV
 @return LOVApiGetCashRegisterIDLOVRequest
*/
func (a *LOVApiService) GetCashRegisterIDLOV(ctx context.Context, hotelId string) LOVApiGetCashRegisterIDLOVRequest {
	return LOVApiGetCashRegisterIDLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetCashRegisterIDLOVExecute(r LOVApiGetCashRegisterIDLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetCashRegisterIDLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/cashRegisterId"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetCashierHotelsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	cashierId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetCashierHotelsLOVRequest) Authorization(authorization string) LOVApiGetCashierHotelsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetCashierHotelsLOVRequest) XAppKey(xAppKey string) LOVApiGetCashierHotelsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetCashierHotelsLOVRequest) XHotelid(xHotelid string) LOVApiGetCashierHotelsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetCashierHotelsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetCashierHotelsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetCashierHotelsLOVRequest) ParameterName(parameterName []string) LOVApiGetCashierHotelsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetCashierHotelsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetCashierHotelsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetCashierHotelsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetCashierHotelsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetCashierHotelsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetCashierHotelsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetCashierHotelsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetCashierHotelsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetCashierHotelsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetCashierHotelsLOVExecute(r)
}

/*
GetCashierHotelsLOV Fetch List Of Values for Cashier Hotels

 <p><strong>OperationId:</strong>getCashierHotelsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cashierId Value of the parameter 'cashierId' which is required to fetch CashierHotels LOV
 @return LOVApiGetCashierHotelsLOVRequest
*/
func (a *LOVApiService) GetCashierHotelsLOV(ctx context.Context, cashierId string) LOVApiGetCashierHotelsLOVRequest {
	return LOVApiGetCashierHotelsLOVRequest{
		ApiService: a,
		ctx: ctx,
		cashierId: cashierId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetCashierHotelsLOVExecute(r LOVApiGetCashierHotelsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetCashierHotelsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/cashierId/{cashierId}/cashierHotels"
	localVarPath = strings.Replace(localVarPath, "{"+"cashierId"+"}", url.PathEscape(parameterValueToString(r.cashierId, "cashierId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.cashierId) < 1 {
		return localVarReturnValue, nil, reportError("cashierId must have at least 1 elements")
	}
	if strlen(r.cashierId) > 2000 {
		return localVarReturnValue, nil, reportError("cashierId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetCatBudgetTypeEventCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	catBudgetType string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetCatBudgetTypeEventCodesLOVRequest) Authorization(authorization string) LOVApiGetCatBudgetTypeEventCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetCatBudgetTypeEventCodesLOVRequest) XAppKey(xAppKey string) LOVApiGetCatBudgetTypeEventCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetCatBudgetTypeEventCodesLOVRequest) XHotelid(xHotelid string) LOVApiGetCatBudgetTypeEventCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetCatBudgetTypeEventCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetCatBudgetTypeEventCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetCatBudgetTypeEventCodesLOVRequest) ParameterName(parameterName []string) LOVApiGetCatBudgetTypeEventCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetCatBudgetTypeEventCodesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetCatBudgetTypeEventCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetCatBudgetTypeEventCodesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetCatBudgetTypeEventCodesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetCatBudgetTypeEventCodesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetCatBudgetTypeEventCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetCatBudgetTypeEventCodesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetCatBudgetTypeEventCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetCatBudgetTypeEventCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetCatBudgetTypeEventCodesLOVExecute(r)
}

/*
GetCatBudgetTypeEventCodesLOV Fetch List Of Values for Cat Budget Type Event Codes

 <p><strong>OperationId:</strong>getCatBudgetTypeEventCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param catBudgetType Value of the parameter 'catBudgetType' which is required to fetch CatBudgetTypeEventCodes LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch CatBudgetTypeEventCodes LOV
 @return LOVApiGetCatBudgetTypeEventCodesLOVRequest
*/
func (a *LOVApiService) GetCatBudgetTypeEventCodesLOV(ctx context.Context, catBudgetType string, hotelId string) LOVApiGetCatBudgetTypeEventCodesLOVRequest {
	return LOVApiGetCatBudgetTypeEventCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		catBudgetType: catBudgetType,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetCatBudgetTypeEventCodesLOVExecute(r LOVApiGetCatBudgetTypeEventCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetCatBudgetTypeEventCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/catBudgetType/{catBudgetType}/catBudgetTypeEventCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"catBudgetType"+"}", url.PathEscape(parameterValueToString(r.catBudgetType, "catBudgetType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.catBudgetType) < 1 {
		return localVarReturnValue, nil, reportError("catBudgetType must have at least 1 elements")
	}
	if strlen(r.catBudgetType) > 2000 {
		return localVarReturnValue, nil, reportError("catBudgetType must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetCatBudgetTypeMarketCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	catBudgetType string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetCatBudgetTypeMarketCodesLOVRequest) Authorization(authorization string) LOVApiGetCatBudgetTypeMarketCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetCatBudgetTypeMarketCodesLOVRequest) XAppKey(xAppKey string) LOVApiGetCatBudgetTypeMarketCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetCatBudgetTypeMarketCodesLOVRequest) XHotelid(xHotelid string) LOVApiGetCatBudgetTypeMarketCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetCatBudgetTypeMarketCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetCatBudgetTypeMarketCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetCatBudgetTypeMarketCodesLOVRequest) ParameterName(parameterName []string) LOVApiGetCatBudgetTypeMarketCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetCatBudgetTypeMarketCodesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetCatBudgetTypeMarketCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetCatBudgetTypeMarketCodesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetCatBudgetTypeMarketCodesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetCatBudgetTypeMarketCodesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetCatBudgetTypeMarketCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetCatBudgetTypeMarketCodesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetCatBudgetTypeMarketCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetCatBudgetTypeMarketCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetCatBudgetTypeMarketCodesLOVExecute(r)
}

/*
GetCatBudgetTypeMarketCodesLOV Fetch List Of Values for Cat Budget Type Market Codes

 <p><strong>OperationId:</strong>getCatBudgetTypeMarketCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param catBudgetType Value of the parameter 'catBudgetType' which is required to fetch CatBudgetTypeMarketCodes LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch CatBudgetTypeMarketCodes LOV
 @return LOVApiGetCatBudgetTypeMarketCodesLOVRequest
*/
func (a *LOVApiService) GetCatBudgetTypeMarketCodesLOV(ctx context.Context, catBudgetType string, hotelId string) LOVApiGetCatBudgetTypeMarketCodesLOVRequest {
	return LOVApiGetCatBudgetTypeMarketCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		catBudgetType: catBudgetType,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetCatBudgetTypeMarketCodesLOVExecute(r LOVApiGetCatBudgetTypeMarketCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetCatBudgetTypeMarketCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/catBudgetType/{catBudgetType}/catBudgetTypeMarketCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"catBudgetType"+"}", url.PathEscape(parameterValueToString(r.catBudgetType, "catBudgetType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.catBudgetType) < 1 {
		return localVarReturnValue, nil, reportError("catBudgetType must have at least 1 elements")
	}
	if strlen(r.catBudgetType) > 2000 {
		return localVarReturnValue, nil, reportError("catBudgetType must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetCatBudgetTypeMealCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	catBudgetType string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetCatBudgetTypeMealCodesLOVRequest) Authorization(authorization string) LOVApiGetCatBudgetTypeMealCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetCatBudgetTypeMealCodesLOVRequest) XAppKey(xAppKey string) LOVApiGetCatBudgetTypeMealCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetCatBudgetTypeMealCodesLOVRequest) XHotelid(xHotelid string) LOVApiGetCatBudgetTypeMealCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetCatBudgetTypeMealCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetCatBudgetTypeMealCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetCatBudgetTypeMealCodesLOVRequest) ParameterName(parameterName []string) LOVApiGetCatBudgetTypeMealCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetCatBudgetTypeMealCodesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetCatBudgetTypeMealCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetCatBudgetTypeMealCodesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetCatBudgetTypeMealCodesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetCatBudgetTypeMealCodesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetCatBudgetTypeMealCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetCatBudgetTypeMealCodesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetCatBudgetTypeMealCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetCatBudgetTypeMealCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetCatBudgetTypeMealCodesLOVExecute(r)
}

/*
GetCatBudgetTypeMealCodesLOV Fetch List Of Values for Cat Budget Type Meal Codes

 <p><strong>OperationId:</strong>getCatBudgetTypeMealCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param catBudgetType Value of the parameter 'catBudgetType' which is required to fetch CatBudgetTypeMealCodes LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch CatBudgetTypeMealCodes LOV
 @return LOVApiGetCatBudgetTypeMealCodesLOVRequest
*/
func (a *LOVApiService) GetCatBudgetTypeMealCodesLOV(ctx context.Context, catBudgetType string, hotelId string) LOVApiGetCatBudgetTypeMealCodesLOVRequest {
	return LOVApiGetCatBudgetTypeMealCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		catBudgetType: catBudgetType,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetCatBudgetTypeMealCodesLOVExecute(r LOVApiGetCatBudgetTypeMealCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetCatBudgetTypeMealCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/catBudgetType/{catBudgetType}/catBudgetTypeMealCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"catBudgetType"+"}", url.PathEscape(parameterValueToString(r.catBudgetType, "catBudgetType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.catBudgetType) < 1 {
		return localVarReturnValue, nil, reportError("catBudgetType must have at least 1 elements")
	}
	if strlen(r.catBudgetType) > 2000 {
		return localVarReturnValue, nil, reportError("catBudgetType must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetCatBudgetTypeRevenueCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	catBudgetType string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetCatBudgetTypeRevenueCodesLOVRequest) Authorization(authorization string) LOVApiGetCatBudgetTypeRevenueCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetCatBudgetTypeRevenueCodesLOVRequest) XAppKey(xAppKey string) LOVApiGetCatBudgetTypeRevenueCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetCatBudgetTypeRevenueCodesLOVRequest) XHotelid(xHotelid string) LOVApiGetCatBudgetTypeRevenueCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetCatBudgetTypeRevenueCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetCatBudgetTypeRevenueCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetCatBudgetTypeRevenueCodesLOVRequest) ParameterName(parameterName []string) LOVApiGetCatBudgetTypeRevenueCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetCatBudgetTypeRevenueCodesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetCatBudgetTypeRevenueCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetCatBudgetTypeRevenueCodesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetCatBudgetTypeRevenueCodesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetCatBudgetTypeRevenueCodesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetCatBudgetTypeRevenueCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetCatBudgetTypeRevenueCodesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetCatBudgetTypeRevenueCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetCatBudgetTypeRevenueCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetCatBudgetTypeRevenueCodesLOVExecute(r)
}

/*
GetCatBudgetTypeRevenueCodesLOV Fetch List Of Values for Cat Budget Type Revenue Codes

 <p><strong>OperationId:</strong>getCatBudgetTypeRevenueCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param catBudgetType Value of the parameter 'catBudgetType' which is required to fetch CatBudgetTypeRevenueCodes LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch CatBudgetTypeRevenueCodes LOV
 @return LOVApiGetCatBudgetTypeRevenueCodesLOVRequest
*/
func (a *LOVApiService) GetCatBudgetTypeRevenueCodesLOV(ctx context.Context, catBudgetType string, hotelId string) LOVApiGetCatBudgetTypeRevenueCodesLOVRequest {
	return LOVApiGetCatBudgetTypeRevenueCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		catBudgetType: catBudgetType,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetCatBudgetTypeRevenueCodesLOVExecute(r LOVApiGetCatBudgetTypeRevenueCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetCatBudgetTypeRevenueCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/catBudgetType/{catBudgetType}/catBudgetTypeRevenueCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"catBudgetType"+"}", url.PathEscape(parameterValueToString(r.catBudgetType, "catBudgetType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.catBudgetType) < 1 {
		return localVarReturnValue, nil, reportError("catBudgetType must have at least 1 elements")
	}
	if strlen(r.catBudgetType) > 2000 {
		return localVarReturnValue, nil, reportError("catBudgetType must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetCateringBudgetTypesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	active string
	catering string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetCateringBudgetTypesLOVRequest) Authorization(authorization string) LOVApiGetCateringBudgetTypesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetCateringBudgetTypesLOVRequest) XAppKey(xAppKey string) LOVApiGetCateringBudgetTypesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetCateringBudgetTypesLOVRequest) XHotelid(xHotelid string) LOVApiGetCateringBudgetTypesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetCateringBudgetTypesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetCateringBudgetTypesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetCateringBudgetTypesLOVRequest) ParameterName(parameterName []string) LOVApiGetCateringBudgetTypesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetCateringBudgetTypesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetCateringBudgetTypesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetCateringBudgetTypesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetCateringBudgetTypesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetCateringBudgetTypesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetCateringBudgetTypesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetCateringBudgetTypesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetCateringBudgetTypesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetCateringBudgetTypesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetCateringBudgetTypesLOVExecute(r)
}

/*
GetCateringBudgetTypesLOV Fetch List Of Values for Catering Budget Types

 <p><strong>OperationId:</strong>getCateringBudgetTypesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param active Value of the parameter 'active' which is required to fetch CateringBudgetTypes LOV
 @param catering Value of the parameter 'catering' which is required to fetch CateringBudgetTypes LOV
 @return LOVApiGetCateringBudgetTypesLOVRequest
*/
func (a *LOVApiService) GetCateringBudgetTypesLOV(ctx context.Context, active string, catering string) LOVApiGetCateringBudgetTypesLOVRequest {
	return LOVApiGetCateringBudgetTypesLOVRequest{
		ApiService: a,
		ctx: ctx,
		active: active,
		catering: catering,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetCateringBudgetTypesLOVExecute(r LOVApiGetCateringBudgetTypesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetCateringBudgetTypesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/catering/{catering}/active/{active}/cateringBudgetTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"active"+"}", url.PathEscape(parameterValueToString(r.active, "active")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"catering"+"}", url.PathEscape(parameterValueToString(r.catering, "catering")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.active) < 1 {
		return localVarReturnValue, nil, reportError("active must have at least 1 elements")
	}
	if strlen(r.active) > 2000 {
		return localVarReturnValue, nil, reportError("active must have less than 2000 elements")
	}
	if strlen(r.catering) < 1 {
		return localVarReturnValue, nil, reportError("catering must have at least 1 elements")
	}
	if strlen(r.catering) > 2000 {
		return localVarReturnValue, nil, reportError("catering must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetCateringCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	codeType string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetCateringCodesLOVRequest) Authorization(authorization string) LOVApiGetCateringCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetCateringCodesLOVRequest) XAppKey(xAppKey string) LOVApiGetCateringCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetCateringCodesLOVRequest) XHotelid(xHotelid string) LOVApiGetCateringCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetCateringCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetCateringCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetCateringCodesLOVRequest) ParameterName(parameterName []string) LOVApiGetCateringCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetCateringCodesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetCateringCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetCateringCodesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetCateringCodesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetCateringCodesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetCateringCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetCateringCodesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetCateringCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetCateringCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetCateringCodesLOVExecute(r)
}

/*
GetCateringCodesLOV Fetch List Of Values for Catering Codes

 <p><strong>OperationId:</strong>getCateringCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param codeType Value of the parameter 'codeType' which is required to fetch CateringCodes LOV
 @return LOVApiGetCateringCodesLOVRequest
*/
func (a *LOVApiService) GetCateringCodesLOV(ctx context.Context, codeType string) LOVApiGetCateringCodesLOVRequest {
	return LOVApiGetCateringCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		codeType: codeType,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetCateringCodesLOVExecute(r LOVApiGetCateringCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetCateringCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/codeType/{codeType}/cateringCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"codeType"+"}", url.PathEscape(parameterValueToString(r.codeType, "codeType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.codeType) < 1 {
		return localVarReturnValue, nil, reportError("codeType must have at least 1 elements")
	}
	if strlen(r.codeType) > 2000 {
		return localVarReturnValue, nil, reportError("codeType must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetCateringEventStatusLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	waitList string
	newEvent string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetCateringEventStatusLOVRequest) Authorization(authorization string) LOVApiGetCateringEventStatusLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetCateringEventStatusLOVRequest) XAppKey(xAppKey string) LOVApiGetCateringEventStatusLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetCateringEventStatusLOVRequest) XHotelid(xHotelid string) LOVApiGetCateringEventStatusLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetCateringEventStatusLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetCateringEventStatusLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetCateringEventStatusLOVRequest) ParameterName(parameterName []string) LOVApiGetCateringEventStatusLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetCateringEventStatusLOVRequest) ParameterValue(parameterValue []string) LOVApiGetCateringEventStatusLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetCateringEventStatusLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetCateringEventStatusLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetCateringEventStatusLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetCateringEventStatusLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetCateringEventStatusLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetCateringEventStatusLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetCateringEventStatusLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetCateringEventStatusLOVExecute(r)
}

/*
GetCateringEventStatusLOV Fetch List Of Values for Catering Event Status

 <p><strong>OperationId:</strong>getCateringEventStatusLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param waitList Value of the parameter 'waitList' which is required to fetch CateringEventStatus LOV
 @param newEvent Value of the parameter 'newEvent' which is required to fetch CateringEventStatus LOV
 @return LOVApiGetCateringEventStatusLOVRequest
*/
func (a *LOVApiService) GetCateringEventStatusLOV(ctx context.Context, waitList string, newEvent string) LOVApiGetCateringEventStatusLOVRequest {
	return LOVApiGetCateringEventStatusLOVRequest{
		ApiService: a,
		ctx: ctx,
		waitList: waitList,
		newEvent: newEvent,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetCateringEventStatusLOVExecute(r LOVApiGetCateringEventStatusLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetCateringEventStatusLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/newEvent/{newEvent}/waitList/{waitList}/cateringEventStatus"
	localVarPath = strings.Replace(localVarPath, "{"+"waitList"+"}", url.PathEscape(parameterValueToString(r.waitList, "waitList")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"newEvent"+"}", url.PathEscape(parameterValueToString(r.newEvent, "newEvent")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.waitList) < 1 {
		return localVarReturnValue, nil, reportError("waitList must have at least 1 elements")
	}
	if strlen(r.waitList) > 2000 {
		return localVarReturnValue, nil, reportError("waitList must have less than 2000 elements")
	}
	if strlen(r.newEvent) < 1 {
		return localVarReturnValue, nil, reportError("newEvent must have at least 1 elements")
	}
	if strlen(r.newEvent) > 2000 {
		return localVarReturnValue, nil, reportError("newEvent must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetCateringPackageCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	radioType string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetCateringPackageCodesLOVRequest) Authorization(authorization string) LOVApiGetCateringPackageCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetCateringPackageCodesLOVRequest) XAppKey(xAppKey string) LOVApiGetCateringPackageCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetCateringPackageCodesLOVRequest) XHotelid(xHotelid string) LOVApiGetCateringPackageCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetCateringPackageCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetCateringPackageCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetCateringPackageCodesLOVRequest) ParameterName(parameterName []string) LOVApiGetCateringPackageCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetCateringPackageCodesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetCateringPackageCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetCateringPackageCodesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetCateringPackageCodesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetCateringPackageCodesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetCateringPackageCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetCateringPackageCodesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetCateringPackageCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetCateringPackageCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetCateringPackageCodesLOVExecute(r)
}

/*
GetCateringPackageCodesLOV Fetch List Of Values for Catering Package Codes

 <p><strong>OperationId:</strong>getCateringPackageCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch CateringPackageCodes LOV
 @param radioType Value of the parameter 'radioType' which is required to fetch CateringPackageCodes LOV
 @return LOVApiGetCateringPackageCodesLOVRequest
*/
func (a *LOVApiService) GetCateringPackageCodesLOV(ctx context.Context, hotelId string, radioType string) LOVApiGetCateringPackageCodesLOVRequest {
	return LOVApiGetCateringPackageCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
		radioType: radioType,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetCateringPackageCodesLOVExecute(r LOVApiGetCateringPackageCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetCateringPackageCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/radioType/{radioType}/hotels/{hotelId}/cateringPackageCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"radioType"+"}", url.PathEscape(parameterValueToString(r.radioType, "radioType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if strlen(r.radioType) < 1 {
		return localVarReturnValue, nil, reportError("radioType must have at least 1 elements")
	}
	if strlen(r.radioType) > 2000 {
		return localVarReturnValue, nil, reportError("radioType must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetCateringPackagePriceCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetCateringPackagePriceCodesLOVRequest) Authorization(authorization string) LOVApiGetCateringPackagePriceCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetCateringPackagePriceCodesLOVRequest) XAppKey(xAppKey string) LOVApiGetCateringPackagePriceCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetCateringPackagePriceCodesLOVRequest) XHotelid(xHotelid string) LOVApiGetCateringPackagePriceCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetCateringPackagePriceCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetCateringPackagePriceCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetCateringPackagePriceCodesLOVRequest) ParameterName(parameterName []string) LOVApiGetCateringPackagePriceCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetCateringPackagePriceCodesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetCateringPackagePriceCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetCateringPackagePriceCodesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetCateringPackagePriceCodesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetCateringPackagePriceCodesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetCateringPackagePriceCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetCateringPackagePriceCodesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetCateringPackagePriceCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetCateringPackagePriceCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetCateringPackagePriceCodesLOVExecute(r)
}

/*
GetCateringPackagePriceCodesLOV Fetch List Of Values for Catering Package Price Codes

 <p><strong>OperationId:</strong>getCateringPackagePriceCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch CateringPackagePriceCodes LOV
 @return LOVApiGetCateringPackagePriceCodesLOVRequest
*/
func (a *LOVApiService) GetCateringPackagePriceCodesLOV(ctx context.Context, hotelId string) LOVApiGetCateringPackagePriceCodesLOVRequest {
	return LOVApiGetCateringPackagePriceCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetCateringPackagePriceCodesLOVExecute(r LOVApiGetCateringPackagePriceCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetCateringPackagePriceCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/cateringPackagePriceCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetCateringPackageRevenueConfigEventTypeLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	pkgLinkId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetCateringPackageRevenueConfigEventTypeLOVRequest) Authorization(authorization string) LOVApiGetCateringPackageRevenueConfigEventTypeLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetCateringPackageRevenueConfigEventTypeLOVRequest) XAppKey(xAppKey string) LOVApiGetCateringPackageRevenueConfigEventTypeLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetCateringPackageRevenueConfigEventTypeLOVRequest) XHotelid(xHotelid string) LOVApiGetCateringPackageRevenueConfigEventTypeLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetCateringPackageRevenueConfigEventTypeLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetCateringPackageRevenueConfigEventTypeLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetCateringPackageRevenueConfigEventTypeLOVRequest) ParameterName(parameterName []string) LOVApiGetCateringPackageRevenueConfigEventTypeLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetCateringPackageRevenueConfigEventTypeLOVRequest) ParameterValue(parameterValue []string) LOVApiGetCateringPackageRevenueConfigEventTypeLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetCateringPackageRevenueConfigEventTypeLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetCateringPackageRevenueConfigEventTypeLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetCateringPackageRevenueConfigEventTypeLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetCateringPackageRevenueConfigEventTypeLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetCateringPackageRevenueConfigEventTypeLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetCateringPackageRevenueConfigEventTypeLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetCateringPackageRevenueConfigEventTypeLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetCateringPackageRevenueConfigEventTypeLOVExecute(r)
}

/*
GetCateringPackageRevenueConfigEventTypeLOV Fetch List Of Values for Catering Package Revenue Config Event Type

 <p><strong>OperationId:</strong>getCateringPackageRevenueConfigEventTypeLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pkgLinkId Value of the parameter 'pkgLinkId' which is required to fetch CateringPackageRevenueConfigEventType LOV
 @return LOVApiGetCateringPackageRevenueConfigEventTypeLOVRequest
*/
func (a *LOVApiService) GetCateringPackageRevenueConfigEventTypeLOV(ctx context.Context, pkgLinkId string) LOVApiGetCateringPackageRevenueConfigEventTypeLOVRequest {
	return LOVApiGetCateringPackageRevenueConfigEventTypeLOVRequest{
		ApiService: a,
		ctx: ctx,
		pkgLinkId: pkgLinkId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetCateringPackageRevenueConfigEventTypeLOVExecute(r LOVApiGetCateringPackageRevenueConfigEventTypeLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetCateringPackageRevenueConfigEventTypeLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/pkgLinkId/{pkgLinkId}/cateringPackageRevenueConfigEventType"
	localVarPath = strings.Replace(localVarPath, "{"+"pkgLinkId"+"}", url.PathEscape(parameterValueToString(r.pkgLinkId, "pkgLinkId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.pkgLinkId) < 1 {
		return localVarReturnValue, nil, reportError("pkgLinkId must have at least 1 elements")
	}
	if strlen(r.pkgLinkId) > 2000 {
		return localVarReturnValue, nil, reportError("pkgLinkId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetCateringPackageRevenueEventTypeLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	pkgId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetCateringPackageRevenueEventTypeLOVRequest) Authorization(authorization string) LOVApiGetCateringPackageRevenueEventTypeLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetCateringPackageRevenueEventTypeLOVRequest) XAppKey(xAppKey string) LOVApiGetCateringPackageRevenueEventTypeLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetCateringPackageRevenueEventTypeLOVRequest) XHotelid(xHotelid string) LOVApiGetCateringPackageRevenueEventTypeLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetCateringPackageRevenueEventTypeLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetCateringPackageRevenueEventTypeLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetCateringPackageRevenueEventTypeLOVRequest) ParameterName(parameterName []string) LOVApiGetCateringPackageRevenueEventTypeLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetCateringPackageRevenueEventTypeLOVRequest) ParameterValue(parameterValue []string) LOVApiGetCateringPackageRevenueEventTypeLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetCateringPackageRevenueEventTypeLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetCateringPackageRevenueEventTypeLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetCateringPackageRevenueEventTypeLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetCateringPackageRevenueEventTypeLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetCateringPackageRevenueEventTypeLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetCateringPackageRevenueEventTypeLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetCateringPackageRevenueEventTypeLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetCateringPackageRevenueEventTypeLOVExecute(r)
}

/*
GetCateringPackageRevenueEventTypeLOV Fetch List Of Values for Catering Package Revenue Event Type

 <p><strong>OperationId:</strong>getCateringPackageRevenueEventTypeLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pkgId Value of the parameter 'pkgId' which is required to fetch CateringPackageRevenueEventType LOV
 @return LOVApiGetCateringPackageRevenueEventTypeLOVRequest
*/
func (a *LOVApiService) GetCateringPackageRevenueEventTypeLOV(ctx context.Context, pkgId string) LOVApiGetCateringPackageRevenueEventTypeLOVRequest {
	return LOVApiGetCateringPackageRevenueEventTypeLOVRequest{
		ApiService: a,
		ctx: ctx,
		pkgId: pkgId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetCateringPackageRevenueEventTypeLOVExecute(r LOVApiGetCateringPackageRevenueEventTypeLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetCateringPackageRevenueEventTypeLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/pkgId/{pkgId}/cateringPackageRevenueEventType"
	localVarPath = strings.Replace(localVarPath, "{"+"pkgId"+"}", url.PathEscape(parameterValueToString(r.pkgId, "pkgId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.pkgId) < 1 {
		return localVarReturnValue, nil, reportError("pkgId must have at least 1 elements")
	}
	if strlen(r.pkgId) > 2000 {
		return localVarReturnValue, nil, reportError("pkgId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetCateringSetupStylesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	space string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetCateringSetupStylesLOVRequest) Authorization(authorization string) LOVApiGetCateringSetupStylesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetCateringSetupStylesLOVRequest) XAppKey(xAppKey string) LOVApiGetCateringSetupStylesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetCateringSetupStylesLOVRequest) XHotelid(xHotelid string) LOVApiGetCateringSetupStylesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetCateringSetupStylesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetCateringSetupStylesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetCateringSetupStylesLOVRequest) ParameterName(parameterName []string) LOVApiGetCateringSetupStylesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetCateringSetupStylesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetCateringSetupStylesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetCateringSetupStylesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetCateringSetupStylesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetCateringSetupStylesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetCateringSetupStylesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetCateringSetupStylesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetCateringSetupStylesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetCateringSetupStylesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetCateringSetupStylesLOVExecute(r)
}

/*
GetCateringSetupStylesLOV Fetch List Of Values for Catering Setup Styles

 <p><strong>OperationId:</strong>getCateringSetupStylesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param space Value of the parameter 'space' which is required to fetch CateringSetupStyles LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch CateringSetupStyles LOV
 @return LOVApiGetCateringSetupStylesLOVRequest
*/
func (a *LOVApiService) GetCateringSetupStylesLOV(ctx context.Context, space string, hotelId string) LOVApiGetCateringSetupStylesLOVRequest {
	return LOVApiGetCateringSetupStylesLOVRequest{
		ApiService: a,
		ctx: ctx,
		space: space,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetCateringSetupStylesLOVExecute(r LOVApiGetCateringSetupStylesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetCateringSetupStylesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/space/{space}/cateringSetupStyles"
	localVarPath = strings.Replace(localVarPath, "{"+"space"+"}", url.PathEscape(parameterValueToString(r.space, "space")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.space) < 1 {
		return localVarReturnValue, nil, reportError("space must have at least 1 elements")
	}
	if strlen(r.space) > 2000 {
		return localVarReturnValue, nil, reportError("space must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetCateringStatusCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	exclusionList string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetCateringStatusCodesLOVRequest) Authorization(authorization string) LOVApiGetCateringStatusCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetCateringStatusCodesLOVRequest) XAppKey(xAppKey string) LOVApiGetCateringStatusCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetCateringStatusCodesLOVRequest) XHotelid(xHotelid string) LOVApiGetCateringStatusCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetCateringStatusCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetCateringStatusCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetCateringStatusCodesLOVRequest) ParameterName(parameterName []string) LOVApiGetCateringStatusCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetCateringStatusCodesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetCateringStatusCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetCateringStatusCodesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetCateringStatusCodesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetCateringStatusCodesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetCateringStatusCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetCateringStatusCodesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetCateringStatusCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetCateringStatusCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetCateringStatusCodesLOVExecute(r)
}

/*
GetCateringStatusCodesLOV Fetch List Of Values for Catering Status Codes

 <p><strong>OperationId:</strong>getCateringStatusCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param exclusionList Value of the parameter 'exclusionList' which is required to fetch CateringStatusCodes LOV
 @return LOVApiGetCateringStatusCodesLOVRequest
*/
func (a *LOVApiService) GetCateringStatusCodesLOV(ctx context.Context, exclusionList string) LOVApiGetCateringStatusCodesLOVRequest {
	return LOVApiGetCateringStatusCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		exclusionList: exclusionList,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetCateringStatusCodesLOVExecute(r LOVApiGetCateringStatusCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetCateringStatusCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/exclusionList/{exclusionList}/cateringStatusCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"exclusionList"+"}", url.PathEscape(parameterValueToString(r.exclusionList, "exclusionList")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.exclusionList) < 1 {
		return localVarReturnValue, nil, reportError("exclusionList must have at least 1 elements")
	}
	if strlen(r.exclusionList) > 2000 {
		return localVarReturnValue, nil, reportError("exclusionList must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetChainLanguagesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	chainCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetChainLanguagesLOVRequest) Authorization(authorization string) LOVApiGetChainLanguagesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetChainLanguagesLOVRequest) XAppKey(xAppKey string) LOVApiGetChainLanguagesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetChainLanguagesLOVRequest) XHotelid(xHotelid string) LOVApiGetChainLanguagesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetChainLanguagesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetChainLanguagesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetChainLanguagesLOVRequest) ParameterName(parameterName []string) LOVApiGetChainLanguagesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetChainLanguagesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetChainLanguagesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetChainLanguagesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetChainLanguagesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetChainLanguagesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetChainLanguagesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetChainLanguagesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetChainLanguagesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetChainLanguagesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetChainLanguagesLOVExecute(r)
}

/*
GetChainLanguagesLOV Fetch List Of Values for Chain Languages

 <p><strong>OperationId:</strong>getChainLanguagesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param chainCode Value of the parameter 'chainCode' which is required to fetch ChainLanguages LOV
 @return LOVApiGetChainLanguagesLOVRequest
*/
func (a *LOVApiService) GetChainLanguagesLOV(ctx context.Context, chainCode string) LOVApiGetChainLanguagesLOVRequest {
	return LOVApiGetChainLanguagesLOVRequest{
		ApiService: a,
		ctx: ctx,
		chainCode: chainCode,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetChainLanguagesLOVExecute(r LOVApiGetChainLanguagesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetChainLanguagesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/chainCode/{chainCode}/chainLanguages"
	localVarPath = strings.Replace(localVarPath, "{"+"chainCode"+"}", url.PathEscape(parameterValueToString(r.chainCode, "chainCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.chainCode) < 1 {
		return localVarReturnValue, nil, reportError("chainCode must have at least 1 elements")
	}
	if strlen(r.chainCode) > 2000 {
		return localVarReturnValue, nil, reportError("chainCode must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetChannelCardTypeMappingCardTypeLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetChannelCardTypeMappingCardTypeLOVRequest) Authorization(authorization string) LOVApiGetChannelCardTypeMappingCardTypeLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetChannelCardTypeMappingCardTypeLOVRequest) XAppKey(xAppKey string) LOVApiGetChannelCardTypeMappingCardTypeLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetChannelCardTypeMappingCardTypeLOVRequest) XHotelid(xHotelid string) LOVApiGetChannelCardTypeMappingCardTypeLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetChannelCardTypeMappingCardTypeLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetChannelCardTypeMappingCardTypeLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetChannelCardTypeMappingCardTypeLOVRequest) ParameterName(parameterName []string) LOVApiGetChannelCardTypeMappingCardTypeLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetChannelCardTypeMappingCardTypeLOVRequest) ParameterValue(parameterValue []string) LOVApiGetChannelCardTypeMappingCardTypeLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetChannelCardTypeMappingCardTypeLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetChannelCardTypeMappingCardTypeLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetChannelCardTypeMappingCardTypeLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetChannelCardTypeMappingCardTypeLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetChannelCardTypeMappingCardTypeLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetChannelCardTypeMappingCardTypeLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetChannelCardTypeMappingCardTypeLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetChannelCardTypeMappingCardTypeLOVExecute(r)
}

/*
GetChannelCardTypeMappingCardTypeLOV Fetch List Of Values for Channel Card Type Mapping Card Type

 <p><strong>OperationId:</strong>getChannelCardTypeMappingCardTypeLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ChannelCardTypeMappingCardType LOV
 @return LOVApiGetChannelCardTypeMappingCardTypeLOVRequest
*/
func (a *LOVApiService) GetChannelCardTypeMappingCardTypeLOV(ctx context.Context, hotelId string) LOVApiGetChannelCardTypeMappingCardTypeLOVRequest {
	return LOVApiGetChannelCardTypeMappingCardTypeLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetChannelCardTypeMappingCardTypeLOVExecute(r LOVApiGetChannelCardTypeMappingCardTypeLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetChannelCardTypeMappingCardTypeLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/channelCardTypeMappingCardType"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetChannelCardTypeMappingChannelCardTypeLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	cardType string
	gdsHost string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetChannelCardTypeMappingChannelCardTypeLOVRequest) Authorization(authorization string) LOVApiGetChannelCardTypeMappingChannelCardTypeLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetChannelCardTypeMappingChannelCardTypeLOVRequest) XAppKey(xAppKey string) LOVApiGetChannelCardTypeMappingChannelCardTypeLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetChannelCardTypeMappingChannelCardTypeLOVRequest) XHotelid(xHotelid string) LOVApiGetChannelCardTypeMappingChannelCardTypeLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetChannelCardTypeMappingChannelCardTypeLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetChannelCardTypeMappingChannelCardTypeLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetChannelCardTypeMappingChannelCardTypeLOVRequest) ParameterName(parameterName []string) LOVApiGetChannelCardTypeMappingChannelCardTypeLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetChannelCardTypeMappingChannelCardTypeLOVRequest) ParameterValue(parameterValue []string) LOVApiGetChannelCardTypeMappingChannelCardTypeLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetChannelCardTypeMappingChannelCardTypeLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetChannelCardTypeMappingChannelCardTypeLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetChannelCardTypeMappingChannelCardTypeLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetChannelCardTypeMappingChannelCardTypeLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetChannelCardTypeMappingChannelCardTypeLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetChannelCardTypeMappingChannelCardTypeLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetChannelCardTypeMappingChannelCardTypeLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetChannelCardTypeMappingChannelCardTypeLOVExecute(r)
}

/*
GetChannelCardTypeMappingChannelCardTypeLOV Fetch List Of Values for Channel Card Type Mapping Channel Card Type

 <p><strong>OperationId:</strong>getChannelCardTypeMappingChannelCardTypeLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cardType Value of the parameter 'cardType' which is required to fetch ChannelCardTypeMappingChannelCardType LOV
 @param gdsHost Value of the parameter 'gdsHost' which is required to fetch ChannelCardTypeMappingChannelCardType LOV
 @return LOVApiGetChannelCardTypeMappingChannelCardTypeLOVRequest
*/
func (a *LOVApiService) GetChannelCardTypeMappingChannelCardTypeLOV(ctx context.Context, cardType string, gdsHost string) LOVApiGetChannelCardTypeMappingChannelCardTypeLOVRequest {
	return LOVApiGetChannelCardTypeMappingChannelCardTypeLOVRequest{
		ApiService: a,
		ctx: ctx,
		cardType: cardType,
		gdsHost: gdsHost,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetChannelCardTypeMappingChannelCardTypeLOVExecute(r LOVApiGetChannelCardTypeMappingChannelCardTypeLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetChannelCardTypeMappingChannelCardTypeLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/gdsHost/{gdsHost}/cardType/{cardType}/channelCardTypeMappingChannelCardType"
	localVarPath = strings.Replace(localVarPath, "{"+"cardType"+"}", url.PathEscape(parameterValueToString(r.cardType, "cardType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"gdsHost"+"}", url.PathEscape(parameterValueToString(r.gdsHost, "gdsHost")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.cardType) < 1 {
		return localVarReturnValue, nil, reportError("cardType must have at least 1 elements")
	}
	if strlen(r.cardType) > 2000 {
		return localVarReturnValue, nil, reportError("cardType must have less than 2000 elements")
	}
	if strlen(r.gdsHost) < 1 {
		return localVarReturnValue, nil, reportError("gdsHost must have at least 1 elements")
	}
	if strlen(r.gdsHost) > 2000 {
		return localVarReturnValue, nil, reportError("gdsHost must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetChannelCardTypeMappingGdsHostLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetChannelCardTypeMappingGdsHostLOVRequest) Authorization(authorization string) LOVApiGetChannelCardTypeMappingGdsHostLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetChannelCardTypeMappingGdsHostLOVRequest) XAppKey(xAppKey string) LOVApiGetChannelCardTypeMappingGdsHostLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetChannelCardTypeMappingGdsHostLOVRequest) XHotelid(xHotelid string) LOVApiGetChannelCardTypeMappingGdsHostLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetChannelCardTypeMappingGdsHostLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetChannelCardTypeMappingGdsHostLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetChannelCardTypeMappingGdsHostLOVRequest) ParameterName(parameterName []string) LOVApiGetChannelCardTypeMappingGdsHostLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetChannelCardTypeMappingGdsHostLOVRequest) ParameterValue(parameterValue []string) LOVApiGetChannelCardTypeMappingGdsHostLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetChannelCardTypeMappingGdsHostLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetChannelCardTypeMappingGdsHostLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetChannelCardTypeMappingGdsHostLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetChannelCardTypeMappingGdsHostLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetChannelCardTypeMappingGdsHostLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetChannelCardTypeMappingGdsHostLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetChannelCardTypeMappingGdsHostLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetChannelCardTypeMappingGdsHostLOVExecute(r)
}

/*
GetChannelCardTypeMappingGdsHostLOV Fetch List Of Values for Channel Card Type Mapping Gds Host

 <p><strong>OperationId:</strong>getChannelCardTypeMappingGdsHostLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ChannelCardTypeMappingGdsHost LOV
 @return LOVApiGetChannelCardTypeMappingGdsHostLOVRequest
*/
func (a *LOVApiService) GetChannelCardTypeMappingGdsHostLOV(ctx context.Context, hotelId string) LOVApiGetChannelCardTypeMappingGdsHostLOVRequest {
	return LOVApiGetChannelCardTypeMappingGdsHostLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetChannelCardTypeMappingGdsHostLOVExecute(r LOVApiGetChannelCardTypeMappingGdsHostLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetChannelCardTypeMappingGdsHostLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/channelCardTypeMappingGdsHost"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetChannelConfigRateCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	roomType string
	bookingChannelCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetChannelConfigRateCodesLOVRequest) Authorization(authorization string) LOVApiGetChannelConfigRateCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetChannelConfigRateCodesLOVRequest) XAppKey(xAppKey string) LOVApiGetChannelConfigRateCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetChannelConfigRateCodesLOVRequest) XHotelid(xHotelid string) LOVApiGetChannelConfigRateCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetChannelConfigRateCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetChannelConfigRateCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetChannelConfigRateCodesLOVRequest) ParameterName(parameterName []string) LOVApiGetChannelConfigRateCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetChannelConfigRateCodesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetChannelConfigRateCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetChannelConfigRateCodesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetChannelConfigRateCodesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetChannelConfigRateCodesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetChannelConfigRateCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetChannelConfigRateCodesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetChannelConfigRateCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetChannelConfigRateCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetChannelConfigRateCodesLOVExecute(r)
}

/*
GetChannelConfigRateCodesLOV Fetch List Of Values for Channel Config Rate Codes

 <p><strong>OperationId:</strong>getChannelConfigRateCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param roomType Value of the parameter 'roomType' which is required to fetch ChannelConfigRateCodes LOV
 @param bookingChannelCode Value of the parameter 'bookingChannelCode' which is required to fetch ChannelConfigRateCodes LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ChannelConfigRateCodes LOV
 @return LOVApiGetChannelConfigRateCodesLOVRequest
*/
func (a *LOVApiService) GetChannelConfigRateCodesLOV(ctx context.Context, roomType string, bookingChannelCode string, hotelId string) LOVApiGetChannelConfigRateCodesLOVRequest {
	return LOVApiGetChannelConfigRateCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		roomType: roomType,
		bookingChannelCode: bookingChannelCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetChannelConfigRateCodesLOVExecute(r LOVApiGetChannelConfigRateCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetChannelConfigRateCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/bookingChannels/{bookingChannelCode}/roomType/{roomType}/channelConfigRateCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"roomType"+"}", url.PathEscape(parameterValueToString(r.roomType, "roomType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"bookingChannelCode"+"}", url.PathEscape(parameterValueToString(r.bookingChannelCode, "bookingChannelCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.roomType) < 1 {
		return localVarReturnValue, nil, reportError("roomType must have at least 1 elements")
	}
	if strlen(r.roomType) > 2000 {
		return localVarReturnValue, nil, reportError("roomType must have less than 2000 elements")
	}
	if strlen(r.bookingChannelCode) < 1 {
		return localVarReturnValue, nil, reportError("bookingChannelCode must have at least 1 elements")
	}
	if strlen(r.bookingChannelCode) > 2000 {
		return localVarReturnValue, nil, reportError("bookingChannelCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetChannelParametersLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	channelCode string
	settingName string
	levelType string
	levelCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetChannelParametersLOVRequest) Authorization(authorization string) LOVApiGetChannelParametersLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetChannelParametersLOVRequest) XAppKey(xAppKey string) LOVApiGetChannelParametersLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetChannelParametersLOVRequest) XHotelid(xHotelid string) LOVApiGetChannelParametersLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetChannelParametersLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetChannelParametersLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetChannelParametersLOVRequest) ParameterName(parameterName []string) LOVApiGetChannelParametersLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetChannelParametersLOVRequest) ParameterValue(parameterValue []string) LOVApiGetChannelParametersLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetChannelParametersLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetChannelParametersLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetChannelParametersLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetChannelParametersLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetChannelParametersLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetChannelParametersLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetChannelParametersLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetChannelParametersLOVExecute(r)
}

/*
GetChannelParametersLOV Fetch List Of Values for Channel Parameters

 <p><strong>OperationId:</strong>getChannelParametersLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param channelCode Value of the parameter 'channelCode' which is required to fetch ChannelParameters LOV
 @param settingName Value of the parameter 'settingName' which is required to fetch ChannelParameters LOV
 @param levelType Value of the parameter 'levelType' which is required to fetch ChannelParameters LOV
 @param levelCode Value of the parameter 'levelCode' which is required to fetch ChannelParameters LOV
 @return LOVApiGetChannelParametersLOVRequest
*/
func (a *LOVApiService) GetChannelParametersLOV(ctx context.Context, channelCode string, settingName string, levelType string, levelCode string) LOVApiGetChannelParametersLOVRequest {
	return LOVApiGetChannelParametersLOVRequest{
		ApiService: a,
		ctx: ctx,
		channelCode: channelCode,
		settingName: settingName,
		levelType: levelType,
		levelCode: levelCode,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetChannelParametersLOVExecute(r LOVApiGetChannelParametersLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetChannelParametersLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/levelCode/{levelCode}/levelType/{levelType}/settingName/{settingName}/channelCode/{channelCode}/channelParameters"
	localVarPath = strings.Replace(localVarPath, "{"+"channelCode"+"}", url.PathEscape(parameterValueToString(r.channelCode, "channelCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"settingName"+"}", url.PathEscape(parameterValueToString(r.settingName, "settingName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"levelType"+"}", url.PathEscape(parameterValueToString(r.levelType, "levelType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"levelCode"+"}", url.PathEscape(parameterValueToString(r.levelCode, "levelCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.channelCode) < 1 {
		return localVarReturnValue, nil, reportError("channelCode must have at least 1 elements")
	}
	if strlen(r.channelCode) > 2000 {
		return localVarReturnValue, nil, reportError("channelCode must have less than 2000 elements")
	}
	if strlen(r.settingName) < 1 {
		return localVarReturnValue, nil, reportError("settingName must have at least 1 elements")
	}
	if strlen(r.settingName) > 2000 {
		return localVarReturnValue, nil, reportError("settingName must have less than 2000 elements")
	}
	if strlen(r.levelType) < 1 {
		return localVarReturnValue, nil, reportError("levelType must have at least 1 elements")
	}
	if strlen(r.levelType) > 2000 {
		return localVarReturnValue, nil, reportError("levelType must have less than 2000 elements")
	}
	if strlen(r.levelCode) < 1 {
		return localVarReturnValue, nil, reportError("levelCode must have at least 1 elements")
	}
	if strlen(r.levelCode) > 2000 {
		return localVarReturnValue, nil, reportError("levelCode must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetClaimMembershipDetailsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	profileId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetClaimMembershipDetailsLOVRequest) Authorization(authorization string) LOVApiGetClaimMembershipDetailsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetClaimMembershipDetailsLOVRequest) XAppKey(xAppKey string) LOVApiGetClaimMembershipDetailsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetClaimMembershipDetailsLOVRequest) XHotelid(xHotelid string) LOVApiGetClaimMembershipDetailsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetClaimMembershipDetailsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetClaimMembershipDetailsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetClaimMembershipDetailsLOVRequest) ParameterName(parameterName []string) LOVApiGetClaimMembershipDetailsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetClaimMembershipDetailsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetClaimMembershipDetailsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetClaimMembershipDetailsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetClaimMembershipDetailsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetClaimMembershipDetailsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetClaimMembershipDetailsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetClaimMembershipDetailsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetClaimMembershipDetailsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetClaimMembershipDetailsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetClaimMembershipDetailsLOVExecute(r)
}

/*
GetClaimMembershipDetailsLOV Fetch List Of Values for Claim Membership Details

 <p><strong>OperationId:</strong>getClaimMembershipDetailsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param profileId Value of the parameter 'profileId' which is required to fetch ClaimMembershipDetails LOV
 @return LOVApiGetClaimMembershipDetailsLOVRequest
*/
func (a *LOVApiService) GetClaimMembershipDetailsLOV(ctx context.Context, profileId string) LOVApiGetClaimMembershipDetailsLOVRequest {
	return LOVApiGetClaimMembershipDetailsLOVRequest{
		ApiService: a,
		ctx: ctx,
		profileId: profileId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetClaimMembershipDetailsLOVExecute(r LOVApiGetClaimMembershipDetailsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetClaimMembershipDetailsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/profiles/{profileId}/claimMembershipDetails"
	localVarPath = strings.Replace(localVarPath, "{"+"profileId"+"}", url.PathEscape(parameterValueToString(r.profileId, "profileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.profileId) < 1 {
		return localVarReturnValue, nil, reportError("profileId must have at least 1 elements")
	}
	if strlen(r.profileId) > 2000 {
		return localVarReturnValue, nil, reportError("profileId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetCommissionCodeLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetCommissionCodeLOVRequest) Authorization(authorization string) LOVApiGetCommissionCodeLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetCommissionCodeLOVRequest) XAppKey(xAppKey string) LOVApiGetCommissionCodeLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetCommissionCodeLOVRequest) XHotelid(xHotelid string) LOVApiGetCommissionCodeLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetCommissionCodeLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetCommissionCodeLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetCommissionCodeLOVRequest) ParameterName(parameterName []string) LOVApiGetCommissionCodeLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetCommissionCodeLOVRequest) ParameterValue(parameterValue []string) LOVApiGetCommissionCodeLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetCommissionCodeLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetCommissionCodeLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetCommissionCodeLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetCommissionCodeLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetCommissionCodeLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetCommissionCodeLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetCommissionCodeLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetCommissionCodeLOVExecute(r)
}

/*
GetCommissionCodeLOV Fetch List Of Values for Commission Code

 <p><strong>OperationId:</strong>getCommissionCodeLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch CommissionCode LOV
 @return LOVApiGetCommissionCodeLOVRequest
*/
func (a *LOVApiService) GetCommissionCodeLOV(ctx context.Context, hotelId string) LOVApiGetCommissionCodeLOVRequest {
	return LOVApiGetCommissionCodeLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetCommissionCodeLOVExecute(r LOVApiGetCommissionCodeLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetCommissionCodeLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/commissionCode"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetCommissionTxnCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetCommissionTxnCodesLOVRequest) Authorization(authorization string) LOVApiGetCommissionTxnCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetCommissionTxnCodesLOVRequest) XAppKey(xAppKey string) LOVApiGetCommissionTxnCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetCommissionTxnCodesLOVRequest) XHotelid(xHotelid string) LOVApiGetCommissionTxnCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetCommissionTxnCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetCommissionTxnCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetCommissionTxnCodesLOVRequest) ParameterName(parameterName []string) LOVApiGetCommissionTxnCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetCommissionTxnCodesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetCommissionTxnCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetCommissionTxnCodesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetCommissionTxnCodesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetCommissionTxnCodesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetCommissionTxnCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetCommissionTxnCodesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetCommissionTxnCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetCommissionTxnCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetCommissionTxnCodesLOVExecute(r)
}

/*
GetCommissionTxnCodesLOV Fetch List Of Values for Commission Txn Codes

 <p><strong>OperationId:</strong>getCommissionTxnCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch CommissionTxnCodes LOV
 @return LOVApiGetCommissionTxnCodesLOVRequest
*/
func (a *LOVApiService) GetCommissionTxnCodesLOV(ctx context.Context, hotelId string) LOVApiGetCommissionTxnCodesLOVRequest {
	return LOVApiGetCommissionTxnCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetCommissionTxnCodesLOVExecute(r LOVApiGetCommissionTxnCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetCommissionTxnCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/commissionTxnCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetCompAuthorizersLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetCompAuthorizersLOVRequest) Authorization(authorization string) LOVApiGetCompAuthorizersLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetCompAuthorizersLOVRequest) XAppKey(xAppKey string) LOVApiGetCompAuthorizersLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetCompAuthorizersLOVRequest) XHotelid(xHotelid string) LOVApiGetCompAuthorizersLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetCompAuthorizersLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetCompAuthorizersLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetCompAuthorizersLOVRequest) ParameterName(parameterName []string) LOVApiGetCompAuthorizersLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetCompAuthorizersLOVRequest) ParameterValue(parameterValue []string) LOVApiGetCompAuthorizersLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetCompAuthorizersLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetCompAuthorizersLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetCompAuthorizersLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetCompAuthorizersLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetCompAuthorizersLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetCompAuthorizersLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetCompAuthorizersLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetCompAuthorizersLOVExecute(r)
}

/*
GetCompAuthorizersLOV Fetch List Of Values for Comp Authorizers

 <p><strong>OperationId:</strong>getCompAuthorizersLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch CompAuthorizers LOV
 @return LOVApiGetCompAuthorizersLOVRequest
*/
func (a *LOVApiService) GetCompAuthorizersLOV(ctx context.Context, hotelId string) LOVApiGetCompAuthorizersLOVRequest {
	return LOVApiGetCompAuthorizersLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetCompAuthorizersLOVExecute(r LOVApiGetCompAuthorizersLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetCompAuthorizersLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/compAuthorizers"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetCompTypesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetCompTypesLOVRequest) Authorization(authorization string) LOVApiGetCompTypesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetCompTypesLOVRequest) XAppKey(xAppKey string) LOVApiGetCompTypesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetCompTypesLOVRequest) XHotelid(xHotelid string) LOVApiGetCompTypesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetCompTypesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetCompTypesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetCompTypesLOVRequest) ParameterName(parameterName []string) LOVApiGetCompTypesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetCompTypesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetCompTypesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetCompTypesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetCompTypesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetCompTypesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetCompTypesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetCompTypesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetCompTypesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetCompTypesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetCompTypesLOVExecute(r)
}

/*
GetCompTypesLOV Fetch List Of Values for Comp Types

 <p><strong>OperationId:</strong>getCompTypesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch CompTypes LOV
 @return LOVApiGetCompTypesLOVRequest
*/
func (a *LOVApiService) GetCompTypesLOV(ctx context.Context, hotelId string) LOVApiGetCompTypesLOVRequest {
	return LOVApiGetCompTypesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetCompTypesLOVExecute(r LOVApiGetCompTypesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetCompTypesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/compTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetCompaniesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetCompaniesLOVRequest) Authorization(authorization string) LOVApiGetCompaniesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetCompaniesLOVRequest) XAppKey(xAppKey string) LOVApiGetCompaniesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetCompaniesLOVRequest) XHotelid(xHotelid string) LOVApiGetCompaniesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetCompaniesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetCompaniesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetCompaniesLOVRequest) ParameterName(parameterName []string) LOVApiGetCompaniesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetCompaniesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetCompaniesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetCompaniesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetCompaniesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetCompaniesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetCompaniesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetCompaniesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetCompaniesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetCompaniesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetCompaniesLOVExecute(r)
}

/*
GetCompaniesLOV Fetch List Of Values for Companies

 <p><strong>OperationId:</strong>getCompaniesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch Companies LOV
 @return LOVApiGetCompaniesLOVRequest
*/
func (a *LOVApiService) GetCompaniesLOV(ctx context.Context, hotelId string) LOVApiGetCompaniesLOVRequest {
	return LOVApiGetCompaniesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetCompaniesLOVExecute(r LOVApiGetCompaniesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetCompaniesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/companies"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetConfLetterReportsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetConfLetterReportsLOVRequest) Authorization(authorization string) LOVApiGetConfLetterReportsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetConfLetterReportsLOVRequest) XAppKey(xAppKey string) LOVApiGetConfLetterReportsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetConfLetterReportsLOVRequest) XHotelid(xHotelid string) LOVApiGetConfLetterReportsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetConfLetterReportsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetConfLetterReportsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetConfLetterReportsLOVRequest) ParameterName(parameterName []string) LOVApiGetConfLetterReportsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetConfLetterReportsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetConfLetterReportsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetConfLetterReportsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetConfLetterReportsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetConfLetterReportsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetConfLetterReportsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetConfLetterReportsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetConfLetterReportsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetConfLetterReportsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetConfLetterReportsLOVExecute(r)
}

/*
GetConfLetterReportsLOV Fetch List Of Values for Conf Letter Reports

 <p><strong>OperationId:</strong>getConfLetterReportsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ConfLetterReports LOV
 @return LOVApiGetConfLetterReportsLOVRequest
*/
func (a *LOVApiService) GetConfLetterReportsLOV(ctx context.Context, hotelId string) LOVApiGetConfLetterReportsLOVRequest {
	return LOVApiGetConfLetterReportsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetConfLetterReportsLOVExecute(r LOVApiGetConfLetterReportsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetConfLetterReportsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/confLetterReports"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetConfigAdvDynamicBaseRatePlansLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	daily string
	tiered string
	currentRateCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetConfigAdvDynamicBaseRatePlansLOVRequest) Authorization(authorization string) LOVApiGetConfigAdvDynamicBaseRatePlansLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetConfigAdvDynamicBaseRatePlansLOVRequest) XAppKey(xAppKey string) LOVApiGetConfigAdvDynamicBaseRatePlansLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetConfigAdvDynamicBaseRatePlansLOVRequest) XHotelid(xHotelid string) LOVApiGetConfigAdvDynamicBaseRatePlansLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetConfigAdvDynamicBaseRatePlansLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetConfigAdvDynamicBaseRatePlansLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetConfigAdvDynamicBaseRatePlansLOVRequest) ParameterName(parameterName []string) LOVApiGetConfigAdvDynamicBaseRatePlansLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetConfigAdvDynamicBaseRatePlansLOVRequest) ParameterValue(parameterValue []string) LOVApiGetConfigAdvDynamicBaseRatePlansLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetConfigAdvDynamicBaseRatePlansLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetConfigAdvDynamicBaseRatePlansLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetConfigAdvDynamicBaseRatePlansLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetConfigAdvDynamicBaseRatePlansLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetConfigAdvDynamicBaseRatePlansLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetConfigAdvDynamicBaseRatePlansLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetConfigAdvDynamicBaseRatePlansLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetConfigAdvDynamicBaseRatePlansLOVExecute(r)
}

/*
GetConfigAdvDynamicBaseRatePlansLOV Fetch List Of Values for Config Adv Dynamic Base Rate Plans

 <p><strong>OperationId:</strong>getConfigAdvDynamicBaseRatePlansLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param daily Value of the parameter 'daily' which is required to fetch ConfigAdvDynamicBaseRatePlans LOV
 @param tiered Value of the parameter 'tiered' which is required to fetch ConfigAdvDynamicBaseRatePlans LOV
 @param currentRateCode Value of the parameter 'currentRateCode' which is required to fetch ConfigAdvDynamicBaseRatePlans LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ConfigAdvDynamicBaseRatePlans LOV
 @return LOVApiGetConfigAdvDynamicBaseRatePlansLOVRequest
*/
func (a *LOVApiService) GetConfigAdvDynamicBaseRatePlansLOV(ctx context.Context, daily string, tiered string, currentRateCode string, hotelId string) LOVApiGetConfigAdvDynamicBaseRatePlansLOVRequest {
	return LOVApiGetConfigAdvDynamicBaseRatePlansLOVRequest{
		ApiService: a,
		ctx: ctx,
		daily: daily,
		tiered: tiered,
		currentRateCode: currentRateCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetConfigAdvDynamicBaseRatePlansLOVExecute(r LOVApiGetConfigAdvDynamicBaseRatePlansLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetConfigAdvDynamicBaseRatePlansLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/currentRateCode/{currentRateCode}/tiered/{tiered}/daily/{daily}/configAdvDynamicBaseRatePlans"
	localVarPath = strings.Replace(localVarPath, "{"+"daily"+"}", url.PathEscape(parameterValueToString(r.daily, "daily")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tiered"+"}", url.PathEscape(parameterValueToString(r.tiered, "tiered")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"currentRateCode"+"}", url.PathEscape(parameterValueToString(r.currentRateCode, "currentRateCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.daily) < 1 {
		return localVarReturnValue, nil, reportError("daily must have at least 1 elements")
	}
	if strlen(r.daily) > 2000 {
		return localVarReturnValue, nil, reportError("daily must have less than 2000 elements")
	}
	if strlen(r.tiered) < 1 {
		return localVarReturnValue, nil, reportError("tiered must have at least 1 elements")
	}
	if strlen(r.tiered) > 2000 {
		return localVarReturnValue, nil, reportError("tiered must have less than 2000 elements")
	}
	if strlen(r.currentRateCode) < 1 {
		return localVarReturnValue, nil, reportError("currentRateCode must have at least 1 elements")
	}
	if strlen(r.currentRateCode) > 2000 {
		return localVarReturnValue, nil, reportError("currentRateCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetConfigBaseRatePlansLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	tiered string
	daily string
	currencyCode string
	currentRateCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetConfigBaseRatePlansLOVRequest) Authorization(authorization string) LOVApiGetConfigBaseRatePlansLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetConfigBaseRatePlansLOVRequest) XAppKey(xAppKey string) LOVApiGetConfigBaseRatePlansLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetConfigBaseRatePlansLOVRequest) XHotelid(xHotelid string) LOVApiGetConfigBaseRatePlansLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetConfigBaseRatePlansLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetConfigBaseRatePlansLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetConfigBaseRatePlansLOVRequest) ParameterName(parameterName []string) LOVApiGetConfigBaseRatePlansLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetConfigBaseRatePlansLOVRequest) ParameterValue(parameterValue []string) LOVApiGetConfigBaseRatePlansLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetConfigBaseRatePlansLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetConfigBaseRatePlansLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetConfigBaseRatePlansLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetConfigBaseRatePlansLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetConfigBaseRatePlansLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetConfigBaseRatePlansLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetConfigBaseRatePlansLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetConfigBaseRatePlansLOVExecute(r)
}

/*
GetConfigBaseRatePlansLOV Fetch List Of Values for Config Base Rate Plans

 <p><strong>OperationId:</strong>getConfigBaseRatePlansLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tiered Value of the parameter 'tiered' which is required to fetch ConfigBaseRatePlans LOV
 @param daily Value of the parameter 'daily' which is required to fetch ConfigBaseRatePlans LOV
 @param currencyCode Value of the parameter 'currencyCode' which is required to fetch ConfigBaseRatePlans LOV
 @param currentRateCode Value of the parameter 'currentRateCode' which is required to fetch ConfigBaseRatePlans LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ConfigBaseRatePlans LOV
 @return LOVApiGetConfigBaseRatePlansLOVRequest
*/
func (a *LOVApiService) GetConfigBaseRatePlansLOV(ctx context.Context, tiered string, daily string, currencyCode string, currentRateCode string, hotelId string) LOVApiGetConfigBaseRatePlansLOVRequest {
	return LOVApiGetConfigBaseRatePlansLOVRequest{
		ApiService: a,
		ctx: ctx,
		tiered: tiered,
		daily: daily,
		currencyCode: currencyCode,
		currentRateCode: currentRateCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetConfigBaseRatePlansLOVExecute(r LOVApiGetConfigBaseRatePlansLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetConfigBaseRatePlansLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/currentRateCode/{currentRateCode}/currencyCode/{currencyCode}/daily/{daily}/tiered/{tiered}/configBaseRatePlans"
	localVarPath = strings.Replace(localVarPath, "{"+"tiered"+"}", url.PathEscape(parameterValueToString(r.tiered, "tiered")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"daily"+"}", url.PathEscape(parameterValueToString(r.daily, "daily")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"currencyCode"+"}", url.PathEscape(parameterValueToString(r.currencyCode, "currencyCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"currentRateCode"+"}", url.PathEscape(parameterValueToString(r.currentRateCode, "currentRateCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.tiered) < 1 {
		return localVarReturnValue, nil, reportError("tiered must have at least 1 elements")
	}
	if strlen(r.tiered) > 2000 {
		return localVarReturnValue, nil, reportError("tiered must have less than 2000 elements")
	}
	if strlen(r.daily) < 1 {
		return localVarReturnValue, nil, reportError("daily must have at least 1 elements")
	}
	if strlen(r.daily) > 2000 {
		return localVarReturnValue, nil, reportError("daily must have less than 2000 elements")
	}
	if strlen(r.currencyCode) < 1 {
		return localVarReturnValue, nil, reportError("currencyCode must have at least 1 elements")
	}
	if strlen(r.currencyCode) > 2000 {
		return localVarReturnValue, nil, reportError("currencyCode must have less than 2000 elements")
	}
	if strlen(r.currentRateCode) < 1 {
		return localVarReturnValue, nil, reportError("currentRateCode must have at least 1 elements")
	}
	if strlen(r.currentRateCode) > 2000 {
		return localVarReturnValue, nil, reportError("currentRateCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetConfigDynamicBaseRatePlansLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	currentRateCode string
	tiered string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetConfigDynamicBaseRatePlansLOVRequest) Authorization(authorization string) LOVApiGetConfigDynamicBaseRatePlansLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetConfigDynamicBaseRatePlansLOVRequest) XAppKey(xAppKey string) LOVApiGetConfigDynamicBaseRatePlansLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetConfigDynamicBaseRatePlansLOVRequest) XHotelid(xHotelid string) LOVApiGetConfigDynamicBaseRatePlansLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetConfigDynamicBaseRatePlansLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetConfigDynamicBaseRatePlansLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetConfigDynamicBaseRatePlansLOVRequest) ParameterName(parameterName []string) LOVApiGetConfigDynamicBaseRatePlansLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetConfigDynamicBaseRatePlansLOVRequest) ParameterValue(parameterValue []string) LOVApiGetConfigDynamicBaseRatePlansLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetConfigDynamicBaseRatePlansLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetConfigDynamicBaseRatePlansLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetConfigDynamicBaseRatePlansLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetConfigDynamicBaseRatePlansLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetConfigDynamicBaseRatePlansLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetConfigDynamicBaseRatePlansLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetConfigDynamicBaseRatePlansLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetConfigDynamicBaseRatePlansLOVExecute(r)
}

/*
GetConfigDynamicBaseRatePlansLOV Fetch List Of Values for Config Dynamic Base Rate Plans

 <p><strong>OperationId:</strong>getConfigDynamicBaseRatePlansLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param currentRateCode Value of the parameter 'currentRateCode' which is required to fetch ConfigDynamicBaseRatePlans LOV
 @param tiered Value of the parameter 'tiered' which is required to fetch ConfigDynamicBaseRatePlans LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ConfigDynamicBaseRatePlans LOV
 @return LOVApiGetConfigDynamicBaseRatePlansLOVRequest
*/
func (a *LOVApiService) GetConfigDynamicBaseRatePlansLOV(ctx context.Context, currentRateCode string, tiered string, hotelId string) LOVApiGetConfigDynamicBaseRatePlansLOVRequest {
	return LOVApiGetConfigDynamicBaseRatePlansLOVRequest{
		ApiService: a,
		ctx: ctx,
		currentRateCode: currentRateCode,
		tiered: tiered,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetConfigDynamicBaseRatePlansLOVExecute(r LOVApiGetConfigDynamicBaseRatePlansLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetConfigDynamicBaseRatePlansLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/tiered/{tiered}/currentRateCode/{currentRateCode}/configDynamicBaseRatePlans"
	localVarPath = strings.Replace(localVarPath, "{"+"currentRateCode"+"}", url.PathEscape(parameterValueToString(r.currentRateCode, "currentRateCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tiered"+"}", url.PathEscape(parameterValueToString(r.tiered, "tiered")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.currentRateCode) < 1 {
		return localVarReturnValue, nil, reportError("currentRateCode must have at least 1 elements")
	}
	if strlen(r.currentRateCode) > 2000 {
		return localVarReturnValue, nil, reportError("currentRateCode must have less than 2000 elements")
	}
	if strlen(r.tiered) < 1 {
		return localVarReturnValue, nil, reportError("tiered must have at least 1 elements")
	}
	if strlen(r.tiered) > 2000 {
		return localVarReturnValue, nil, reportError("tiered must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetConfigReportsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	moduleName string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetConfigReportsLOVRequest) Authorization(authorization string) LOVApiGetConfigReportsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetConfigReportsLOVRequest) XAppKey(xAppKey string) LOVApiGetConfigReportsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetConfigReportsLOVRequest) XHotelid(xHotelid string) LOVApiGetConfigReportsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetConfigReportsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetConfigReportsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetConfigReportsLOVRequest) ParameterName(parameterName []string) LOVApiGetConfigReportsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetConfigReportsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetConfigReportsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetConfigReportsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetConfigReportsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetConfigReportsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetConfigReportsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetConfigReportsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetConfigReportsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetConfigReportsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetConfigReportsLOVExecute(r)
}

/*
GetConfigReportsLOV Fetch List Of Values for Config Reports

 <p><strong>OperationId:</strong>getConfigReportsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param moduleName Value of the parameter 'moduleName' which is required to fetch ConfigReports LOV
 @return LOVApiGetConfigReportsLOVRequest
*/
func (a *LOVApiService) GetConfigReportsLOV(ctx context.Context, moduleName string) LOVApiGetConfigReportsLOVRequest {
	return LOVApiGetConfigReportsLOVRequest{
		ApiService: a,
		ctx: ctx,
		moduleName: moduleName,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetConfigReportsLOVExecute(r LOVApiGetConfigReportsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetConfigReportsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/moduleName/{moduleName}/configReports"
	localVarPath = strings.Replace(localVarPath, "{"+"moduleName"+"}", url.PathEscape(parameterValueToString(r.moduleName, "moduleName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.moduleName) < 1 {
		return localVarReturnValue, nil, reportError("moduleName must have at least 1 elements")
	}
	if strlen(r.moduleName) > 2000 {
		return localVarReturnValue, nil, reportError("moduleName must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetConnectingSuitesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	roomNumber string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetConnectingSuitesLOVRequest) Authorization(authorization string) LOVApiGetConnectingSuitesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetConnectingSuitesLOVRequest) XAppKey(xAppKey string) LOVApiGetConnectingSuitesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetConnectingSuitesLOVRequest) XHotelid(xHotelid string) LOVApiGetConnectingSuitesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetConnectingSuitesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetConnectingSuitesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetConnectingSuitesLOVRequest) ParameterName(parameterName []string) LOVApiGetConnectingSuitesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetConnectingSuitesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetConnectingSuitesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetConnectingSuitesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetConnectingSuitesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetConnectingSuitesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetConnectingSuitesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetConnectingSuitesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetConnectingSuitesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetConnectingSuitesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetConnectingSuitesLOVExecute(r)
}

/*
GetConnectingSuitesLOV Fetch List Of Values for Connecting Suites

 <p><strong>OperationId:</strong>getConnectingSuitesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param roomNumber Value of the parameter 'roomNumber' which is required to fetch ConnectingSuites LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ConnectingSuites LOV
 @return LOVApiGetConnectingSuitesLOVRequest
*/
func (a *LOVApiService) GetConnectingSuitesLOV(ctx context.Context, roomNumber string, hotelId string) LOVApiGetConnectingSuitesLOVRequest {
	return LOVApiGetConnectingSuitesLOVRequest{
		ApiService: a,
		ctx: ctx,
		roomNumber: roomNumber,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetConnectingSuitesLOVExecute(r LOVApiGetConnectingSuitesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetConnectingSuitesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/roomNumber/{roomNumber}/connectingSuites"
	localVarPath = strings.Replace(localVarPath, "{"+"roomNumber"+"}", url.PathEscape(parameterValueToString(r.roomNumber, "roomNumber")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.roomNumber) < 1 {
		return localVarReturnValue, nil, reportError("roomNumber must have at least 1 elements")
	}
	if strlen(r.roomNumber) > 2000 {
		return localVarReturnValue, nil, reportError("roomNumber must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetCreditCardTypesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetCreditCardTypesLOVRequest) Authorization(authorization string) LOVApiGetCreditCardTypesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetCreditCardTypesLOVRequest) XAppKey(xAppKey string) LOVApiGetCreditCardTypesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetCreditCardTypesLOVRequest) XHotelid(xHotelid string) LOVApiGetCreditCardTypesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetCreditCardTypesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetCreditCardTypesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetCreditCardTypesLOVRequest) ParameterName(parameterName []string) LOVApiGetCreditCardTypesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetCreditCardTypesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetCreditCardTypesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetCreditCardTypesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetCreditCardTypesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetCreditCardTypesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetCreditCardTypesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetCreditCardTypesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetCreditCardTypesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetCreditCardTypesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetCreditCardTypesLOVExecute(r)
}

/*
GetCreditCardTypesLOV Fetch List Of Values for Credit Card Types

 <p><strong>OperationId:</strong>getCreditCardTypesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch CreditCardTypes LOV
 @return LOVApiGetCreditCardTypesLOVRequest
*/
func (a *LOVApiService) GetCreditCardTypesLOV(ctx context.Context, hotelId string) LOVApiGetCreditCardTypesLOVRequest {
	return LOVApiGetCreditCardTypesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetCreditCardTypesLOVExecute(r LOVApiGetCreditCardTypesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetCreditCardTypesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/creditCardTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetCroUsersLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	userId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetCroUsersLOVRequest) Authorization(authorization string) LOVApiGetCroUsersLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetCroUsersLOVRequest) XAppKey(xAppKey string) LOVApiGetCroUsersLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetCroUsersLOVRequest) XHotelid(xHotelid string) LOVApiGetCroUsersLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetCroUsersLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetCroUsersLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetCroUsersLOVRequest) ParameterName(parameterName []string) LOVApiGetCroUsersLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetCroUsersLOVRequest) ParameterValue(parameterValue []string) LOVApiGetCroUsersLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetCroUsersLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetCroUsersLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetCroUsersLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetCroUsersLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetCroUsersLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetCroUsersLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetCroUsersLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetCroUsersLOVExecute(r)
}

/*
GetCroUsersLOV Fetch List Of Values for Cro Users

 <p><strong>OperationId:</strong>getCroUsersLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId Value of the parameter 'userId' which is required to fetch CroUsers LOV
 @return LOVApiGetCroUsersLOVRequest
*/
func (a *LOVApiService) GetCroUsersLOV(ctx context.Context, userId string) LOVApiGetCroUsersLOVRequest {
	return LOVApiGetCroUsersLOVRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetCroUsersLOVExecute(r LOVApiGetCroUsersLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetCroUsersLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/userId/{userId}/croUsers"
	localVarPath = strings.Replace(localVarPath, "{"+"userId"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.userId) < 1 {
		return localVarReturnValue, nil, reportError("userId must have at least 1 elements")
	}
	if strlen(r.userId) > 2000 {
		return localVarReturnValue, nil, reportError("userId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetCurrencyExchangeRatesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	exchangeType string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetCurrencyExchangeRatesLOVRequest) Authorization(authorization string) LOVApiGetCurrencyExchangeRatesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetCurrencyExchangeRatesLOVRequest) XAppKey(xAppKey string) LOVApiGetCurrencyExchangeRatesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetCurrencyExchangeRatesLOVRequest) XHotelid(xHotelid string) LOVApiGetCurrencyExchangeRatesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetCurrencyExchangeRatesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetCurrencyExchangeRatesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetCurrencyExchangeRatesLOVRequest) ParameterName(parameterName []string) LOVApiGetCurrencyExchangeRatesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetCurrencyExchangeRatesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetCurrencyExchangeRatesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetCurrencyExchangeRatesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetCurrencyExchangeRatesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetCurrencyExchangeRatesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetCurrencyExchangeRatesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetCurrencyExchangeRatesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetCurrencyExchangeRatesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetCurrencyExchangeRatesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetCurrencyExchangeRatesLOVExecute(r)
}

/*
GetCurrencyExchangeRatesLOV Fetch List Of Values for Currency Exchange Rates

 <p><strong>OperationId:</strong>getCurrencyExchangeRatesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param exchangeType Value of the parameter 'exchangeType' which is required to fetch CurrencyExchangeRates LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch CurrencyExchangeRates LOV
 @return LOVApiGetCurrencyExchangeRatesLOVRequest
*/
func (a *LOVApiService) GetCurrencyExchangeRatesLOV(ctx context.Context, exchangeType string, hotelId string) LOVApiGetCurrencyExchangeRatesLOVRequest {
	return LOVApiGetCurrencyExchangeRatesLOVRequest{
		ApiService: a,
		ctx: ctx,
		exchangeType: exchangeType,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetCurrencyExchangeRatesLOVExecute(r LOVApiGetCurrencyExchangeRatesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetCurrencyExchangeRatesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/exchangeType/{exchangeType}/currencyExchangeRates"
	localVarPath = strings.Replace(localVarPath, "{"+"exchangeType"+"}", url.PathEscape(parameterValueToString(r.exchangeType, "exchangeType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.exchangeType) < 1 {
		return localVarReturnValue, nil, reportError("exchangeType must have at least 1 elements")
	}
	if strlen(r.exchangeType) > 2000 {
		return localVarReturnValue, nil, reportError("exchangeType must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetCurrencyFormatsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	decimal string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetCurrencyFormatsLOVRequest) Authorization(authorization string) LOVApiGetCurrencyFormatsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetCurrencyFormatsLOVRequest) XAppKey(xAppKey string) LOVApiGetCurrencyFormatsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetCurrencyFormatsLOVRequest) XHotelid(xHotelid string) LOVApiGetCurrencyFormatsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetCurrencyFormatsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetCurrencyFormatsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetCurrencyFormatsLOVRequest) ParameterName(parameterName []string) LOVApiGetCurrencyFormatsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetCurrencyFormatsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetCurrencyFormatsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetCurrencyFormatsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetCurrencyFormatsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetCurrencyFormatsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetCurrencyFormatsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetCurrencyFormatsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetCurrencyFormatsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetCurrencyFormatsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetCurrencyFormatsLOVExecute(r)
}

/*
GetCurrencyFormatsLOV Fetch List Of Values for Currency Formats

 <p><strong>OperationId:</strong>getCurrencyFormatsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param decimal Value of the parameter 'decimal' which is required to fetch CurrencyFormats LOV
 @return LOVApiGetCurrencyFormatsLOVRequest
*/
func (a *LOVApiService) GetCurrencyFormatsLOV(ctx context.Context, decimal string) LOVApiGetCurrencyFormatsLOVRequest {
	return LOVApiGetCurrencyFormatsLOVRequest{
		ApiService: a,
		ctx: ctx,
		decimal: decimal,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetCurrencyFormatsLOVExecute(r LOVApiGetCurrencyFormatsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetCurrencyFormatsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/decimal/{decimal}/currencyFormats"
	localVarPath = strings.Replace(localVarPath, "{"+"decimal"+"}", url.PathEscape(parameterValueToString(r.decimal, "decimal")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.decimal) < 1 {
		return localVarReturnValue, nil, reportError("decimal must have at least 1 elements")
	}
	if strlen(r.decimal) > 2000 {
		return localVarReturnValue, nil, reportError("decimal must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetCustomNumberConfigCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetCustomNumberConfigCodesLOVRequest) Authorization(authorization string) LOVApiGetCustomNumberConfigCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetCustomNumberConfigCodesLOVRequest) XAppKey(xAppKey string) LOVApiGetCustomNumberConfigCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetCustomNumberConfigCodesLOVRequest) XHotelid(xHotelid string) LOVApiGetCustomNumberConfigCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetCustomNumberConfigCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetCustomNumberConfigCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetCustomNumberConfigCodesLOVRequest) ParameterName(parameterName []string) LOVApiGetCustomNumberConfigCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetCustomNumberConfigCodesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetCustomNumberConfigCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetCustomNumberConfigCodesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetCustomNumberConfigCodesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetCustomNumberConfigCodesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetCustomNumberConfigCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetCustomNumberConfigCodesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetCustomNumberConfigCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetCustomNumberConfigCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetCustomNumberConfigCodesLOVExecute(r)
}

/*
GetCustomNumberConfigCodesLOV Fetch List Of Values for Custom Number Config Codes

 <p><strong>OperationId:</strong>getCustomNumberConfigCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch CustomNumberConfigCodes LOV
 @return LOVApiGetCustomNumberConfigCodesLOVRequest
*/
func (a *LOVApiService) GetCustomNumberConfigCodesLOV(ctx context.Context, hotelId string) LOVApiGetCustomNumberConfigCodesLOVRequest {
	return LOVApiGetCustomNumberConfigCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetCustomNumberConfigCodesLOVExecute(r LOVApiGetCustomNumberConfigCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetCustomNumberConfigCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/customNumberConfigCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetCustomRoomTranslationLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	dbfLogo string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetCustomRoomTranslationLOVRequest) Authorization(authorization string) LOVApiGetCustomRoomTranslationLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetCustomRoomTranslationLOVRequest) XAppKey(xAppKey string) LOVApiGetCustomRoomTranslationLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetCustomRoomTranslationLOVRequest) XHotelid(xHotelid string) LOVApiGetCustomRoomTranslationLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetCustomRoomTranslationLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetCustomRoomTranslationLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetCustomRoomTranslationLOVRequest) ParameterName(parameterName []string) LOVApiGetCustomRoomTranslationLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetCustomRoomTranslationLOVRequest) ParameterValue(parameterValue []string) LOVApiGetCustomRoomTranslationLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetCustomRoomTranslationLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetCustomRoomTranslationLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetCustomRoomTranslationLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetCustomRoomTranslationLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetCustomRoomTranslationLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetCustomRoomTranslationLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetCustomRoomTranslationLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetCustomRoomTranslationLOVExecute(r)
}

/*
GetCustomRoomTranslationLOV Fetch List Of Values for Custom Room Translation

 <p><strong>OperationId:</strong>getCustomRoomTranslationLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param dbfLogo Value of the parameter 'dbfLogo' which is required to fetch CustomRoomTranslation LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch CustomRoomTranslation LOV
 @return LOVApiGetCustomRoomTranslationLOVRequest
*/
func (a *LOVApiService) GetCustomRoomTranslationLOV(ctx context.Context, dbfLogo string, hotelId string) LOVApiGetCustomRoomTranslationLOVRequest {
	return LOVApiGetCustomRoomTranslationLOVRequest{
		ApiService: a,
		ctx: ctx,
		dbfLogo: dbfLogo,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetCustomRoomTranslationLOVExecute(r LOVApiGetCustomRoomTranslationLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetCustomRoomTranslationLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/dbfLogo/{dbfLogo}/customRoomTranslation"
	localVarPath = strings.Replace(localVarPath, "{"+"dbfLogo"+"}", url.PathEscape(parameterValueToString(r.dbfLogo, "dbfLogo")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.dbfLogo) < 1 {
		return localVarReturnValue, nil, reportError("dbfLogo must have at least 1 elements")
	}
	if strlen(r.dbfLogo) > 2000 {
		return localVarReturnValue, nil, reportError("dbfLogo must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetDepositCancelRulesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	policyType string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetDepositCancelRulesLOVRequest) Authorization(authorization string) LOVApiGetDepositCancelRulesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetDepositCancelRulesLOVRequest) XAppKey(xAppKey string) LOVApiGetDepositCancelRulesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetDepositCancelRulesLOVRequest) XHotelid(xHotelid string) LOVApiGetDepositCancelRulesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetDepositCancelRulesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetDepositCancelRulesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetDepositCancelRulesLOVRequest) ParameterName(parameterName []string) LOVApiGetDepositCancelRulesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetDepositCancelRulesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetDepositCancelRulesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetDepositCancelRulesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetDepositCancelRulesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetDepositCancelRulesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetDepositCancelRulesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetDepositCancelRulesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetDepositCancelRulesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetDepositCancelRulesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetDepositCancelRulesLOVExecute(r)
}

/*
GetDepositCancelRulesLOV Fetch List Of Values for Deposit Cancel Rules

 <p><strong>OperationId:</strong>getDepositCancelRulesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param policyType Value of the parameter 'policyType' which is required to fetch DepositCancelRules LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch DepositCancelRules LOV
 @return LOVApiGetDepositCancelRulesLOVRequest
*/
func (a *LOVApiService) GetDepositCancelRulesLOV(ctx context.Context, policyType string, hotelId string) LOVApiGetDepositCancelRulesLOVRequest {
	return LOVApiGetDepositCancelRulesLOVRequest{
		ApiService: a,
		ctx: ctx,
		policyType: policyType,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetDepositCancelRulesLOVExecute(r LOVApiGetDepositCancelRulesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetDepositCancelRulesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/policyType/{policyType}/depositCancelRules"
	localVarPath = strings.Replace(localVarPath, "{"+"policyType"+"}", url.PathEscape(parameterValueToString(r.policyType, "policyType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.policyType) < 1 {
		return localVarReturnValue, nil, reportError("policyType must have at least 1 elements")
	}
	if strlen(r.policyType) > 2000 {
		return localVarReturnValue, nil, reportError("policyType must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetDepositCancelRulesMultiHotelLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	policyType string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetDepositCancelRulesMultiHotelLOVRequest) Authorization(authorization string) LOVApiGetDepositCancelRulesMultiHotelLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetDepositCancelRulesMultiHotelLOVRequest) XAppKey(xAppKey string) LOVApiGetDepositCancelRulesMultiHotelLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetDepositCancelRulesMultiHotelLOVRequest) XHotelid(xHotelid string) LOVApiGetDepositCancelRulesMultiHotelLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetDepositCancelRulesMultiHotelLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetDepositCancelRulesMultiHotelLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetDepositCancelRulesMultiHotelLOVRequest) ParameterName(parameterName []string) LOVApiGetDepositCancelRulesMultiHotelLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetDepositCancelRulesMultiHotelLOVRequest) ParameterValue(parameterValue []string) LOVApiGetDepositCancelRulesMultiHotelLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetDepositCancelRulesMultiHotelLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetDepositCancelRulesMultiHotelLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetDepositCancelRulesMultiHotelLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetDepositCancelRulesMultiHotelLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetDepositCancelRulesMultiHotelLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetDepositCancelRulesMultiHotelLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetDepositCancelRulesMultiHotelLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetDepositCancelRulesMultiHotelLOVExecute(r)
}

/*
GetDepositCancelRulesMultiHotelLOV Fetch List Of Values for Deposit Cancel Rules Multi Hotel

 <p><strong>OperationId:</strong>getDepositCancelRulesMultiHotelLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param policyType Value of the parameter 'policyType' which is required to fetch DepositCancelRulesMultiHotel LOV
 @return LOVApiGetDepositCancelRulesMultiHotelLOVRequest
*/
func (a *LOVApiService) GetDepositCancelRulesMultiHotelLOV(ctx context.Context, policyType string) LOVApiGetDepositCancelRulesMultiHotelLOVRequest {
	return LOVApiGetDepositCancelRulesMultiHotelLOVRequest{
		ApiService: a,
		ctx: ctx,
		policyType: policyType,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetDepositCancelRulesMultiHotelLOVExecute(r LOVApiGetDepositCancelRulesMultiHotelLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetDepositCancelRulesMultiHotelLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/policyType/{policyType}/depositCancelRulesMultiHotel"
	localVarPath = strings.Replace(localVarPath, "{"+"policyType"+"}", url.PathEscape(parameterValueToString(r.policyType, "policyType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.policyType) < 1 {
		return localVarReturnValue, nil, reportError("policyType must have at least 1 elements")
	}
	if strlen(r.policyType) > 2000 {
		return localVarReturnValue, nil, reportError("policyType must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetDeviceCodeMappingValuesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	externalCode string
	codeType string
	deviceCode string
	deviceType string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetDeviceCodeMappingValuesLOVRequest) Authorization(authorization string) LOVApiGetDeviceCodeMappingValuesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetDeviceCodeMappingValuesLOVRequest) XAppKey(xAppKey string) LOVApiGetDeviceCodeMappingValuesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetDeviceCodeMappingValuesLOVRequest) XHotelid(xHotelid string) LOVApiGetDeviceCodeMappingValuesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetDeviceCodeMappingValuesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetDeviceCodeMappingValuesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetDeviceCodeMappingValuesLOVRequest) ParameterName(parameterName []string) LOVApiGetDeviceCodeMappingValuesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetDeviceCodeMappingValuesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetDeviceCodeMappingValuesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetDeviceCodeMappingValuesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetDeviceCodeMappingValuesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetDeviceCodeMappingValuesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetDeviceCodeMappingValuesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetDeviceCodeMappingValuesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetDeviceCodeMappingValuesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetDeviceCodeMappingValuesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetDeviceCodeMappingValuesLOVExecute(r)
}

/*
GetDeviceCodeMappingValuesLOV Fetch List Of Values for Device Code Mapping Values

 <p><strong>OperationId:</strong>getDeviceCodeMappingValuesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param externalCode Value of the parameter 'externalCode' which is required to fetch DeviceCodeMappingValues LOV
 @param codeType Value of the parameter 'codeType' which is required to fetch DeviceCodeMappingValues LOV
 @param deviceCode Value of the parameter 'deviceCode' which is required to fetch DeviceCodeMappingValues LOV
 @param deviceType Value of the parameter 'deviceType' which is required to fetch DeviceCodeMappingValues LOV
 @return LOVApiGetDeviceCodeMappingValuesLOVRequest
*/
func (a *LOVApiService) GetDeviceCodeMappingValuesLOV(ctx context.Context, externalCode string, codeType string, deviceCode string, deviceType string) LOVApiGetDeviceCodeMappingValuesLOVRequest {
	return LOVApiGetDeviceCodeMappingValuesLOVRequest{
		ApiService: a,
		ctx: ctx,
		externalCode: externalCode,
		codeType: codeType,
		deviceCode: deviceCode,
		deviceType: deviceType,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetDeviceCodeMappingValuesLOVExecute(r LOVApiGetDeviceCodeMappingValuesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetDeviceCodeMappingValuesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/deviceType/{deviceType}/deviceCode/{deviceCode}/codeType/{codeType}/externalCode/{externalCode}/deviceCodeMappingValues"
	localVarPath = strings.Replace(localVarPath, "{"+"externalCode"+"}", url.PathEscape(parameterValueToString(r.externalCode, "externalCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"codeType"+"}", url.PathEscape(parameterValueToString(r.codeType, "codeType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"deviceCode"+"}", url.PathEscape(parameterValueToString(r.deviceCode, "deviceCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"deviceType"+"}", url.PathEscape(parameterValueToString(r.deviceType, "deviceType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.externalCode) < 1 {
		return localVarReturnValue, nil, reportError("externalCode must have at least 1 elements")
	}
	if strlen(r.externalCode) > 2000 {
		return localVarReturnValue, nil, reportError("externalCode must have less than 2000 elements")
	}
	if strlen(r.codeType) < 1 {
		return localVarReturnValue, nil, reportError("codeType must have at least 1 elements")
	}
	if strlen(r.codeType) > 2000 {
		return localVarReturnValue, nil, reportError("codeType must have less than 2000 elements")
	}
	if strlen(r.deviceCode) < 1 {
		return localVarReturnValue, nil, reportError("deviceCode must have at least 1 elements")
	}
	if strlen(r.deviceCode) > 2000 {
		return localVarReturnValue, nil, reportError("deviceCode must have less than 2000 elements")
	}
	if strlen(r.deviceType) < 1 {
		return localVarReturnValue, nil, reportError("deviceType must have at least 1 elements")
	}
	if strlen(r.deviceType) > 2000 {
		return localVarReturnValue, nil, reportError("deviceType must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetDeviceLocationsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetDeviceLocationsLOVRequest) Authorization(authorization string) LOVApiGetDeviceLocationsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetDeviceLocationsLOVRequest) XAppKey(xAppKey string) LOVApiGetDeviceLocationsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetDeviceLocationsLOVRequest) XHotelid(xHotelid string) LOVApiGetDeviceLocationsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetDeviceLocationsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetDeviceLocationsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetDeviceLocationsLOVRequest) ParameterName(parameterName []string) LOVApiGetDeviceLocationsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetDeviceLocationsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetDeviceLocationsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetDeviceLocationsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetDeviceLocationsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetDeviceLocationsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetDeviceLocationsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetDeviceLocationsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetDeviceLocationsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetDeviceLocationsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetDeviceLocationsLOVExecute(r)
}

/*
GetDeviceLocationsLOV Fetch List Of Values for Device Locations

 <p><strong>OperationId:</strong>getDeviceLocationsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch DeviceLocations LOV
 @return LOVApiGetDeviceLocationsLOVRequest
*/
func (a *LOVApiService) GetDeviceLocationsLOV(ctx context.Context, hotelId string) LOVApiGetDeviceLocationsLOVRequest {
	return LOVApiGetDeviceLocationsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetDeviceLocationsLOVExecute(r LOVApiGetDeviceLocationsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetDeviceLocationsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/deviceLocations"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetDietaryPreferencesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetDietaryPreferencesLOVRequest) Authorization(authorization string) LOVApiGetDietaryPreferencesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetDietaryPreferencesLOVRequest) XAppKey(xAppKey string) LOVApiGetDietaryPreferencesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetDietaryPreferencesLOVRequest) XHotelid(xHotelid string) LOVApiGetDietaryPreferencesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetDietaryPreferencesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetDietaryPreferencesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetDietaryPreferencesLOVRequest) ParameterName(parameterName []string) LOVApiGetDietaryPreferencesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetDietaryPreferencesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetDietaryPreferencesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetDietaryPreferencesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetDietaryPreferencesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetDietaryPreferencesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetDietaryPreferencesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetDietaryPreferencesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetDietaryPreferencesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetDietaryPreferencesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetDietaryPreferencesLOVExecute(r)
}

/*
GetDietaryPreferencesLOV Fetch List Of Values for Dietary Preferences

 <p><strong>OperationId:</strong>getDietaryPreferencesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch DietaryPreferences LOV
 @return LOVApiGetDietaryPreferencesLOVRequest
*/
func (a *LOVApiService) GetDietaryPreferencesLOV(ctx context.Context, hotelId string) LOVApiGetDietaryPreferencesLOVRequest {
	return LOVApiGetDietaryPreferencesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetDietaryPreferencesLOVExecute(r LOVApiGetDietaryPreferencesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetDietaryPreferencesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/dietaryPreferences"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetDistributionTemplatesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	location string
	locationType string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetDistributionTemplatesLOVRequest) Authorization(authorization string) LOVApiGetDistributionTemplatesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetDistributionTemplatesLOVRequest) XAppKey(xAppKey string) LOVApiGetDistributionTemplatesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetDistributionTemplatesLOVRequest) XHotelid(xHotelid string) LOVApiGetDistributionTemplatesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetDistributionTemplatesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetDistributionTemplatesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetDistributionTemplatesLOVRequest) ParameterName(parameterName []string) LOVApiGetDistributionTemplatesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetDistributionTemplatesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetDistributionTemplatesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetDistributionTemplatesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetDistributionTemplatesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetDistributionTemplatesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetDistributionTemplatesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetDistributionTemplatesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetDistributionTemplatesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetDistributionTemplatesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetDistributionTemplatesLOVExecute(r)
}

/*
GetDistributionTemplatesLOV Fetch List Of Values for Distribution Templates

 <p><strong>OperationId:</strong>getDistributionTemplatesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param location Value of the parameter 'location' which is required to fetch DistributionTemplates LOV
 @param locationType Value of the parameter 'locationType' which is required to fetch DistributionTemplates LOV
 @return LOVApiGetDistributionTemplatesLOVRequest
*/
func (a *LOVApiService) GetDistributionTemplatesLOV(ctx context.Context, location string, locationType string) LOVApiGetDistributionTemplatesLOVRequest {
	return LOVApiGetDistributionTemplatesLOVRequest{
		ApiService: a,
		ctx: ctx,
		location: location,
		locationType: locationType,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetDistributionTemplatesLOVExecute(r LOVApiGetDistributionTemplatesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetDistributionTemplatesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/locationType/{locationType}/location/{location}/distributionTemplates"
	localVarPath = strings.Replace(localVarPath, "{"+"location"+"}", url.PathEscape(parameterValueToString(r.location, "location")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationType"+"}", url.PathEscape(parameterValueToString(r.locationType, "locationType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.location) < 1 {
		return localVarReturnValue, nil, reportError("location must have at least 1 elements")
	}
	if strlen(r.location) > 2000 {
		return localVarReturnValue, nil, reportError("location must have less than 2000 elements")
	}
	if strlen(r.locationType) < 1 {
		return localVarReturnValue, nil, reportError("locationType must have at least 1 elements")
	}
	if strlen(r.locationType) > 2000 {
		return localVarReturnValue, nil, reportError("locationType must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetECertificateGroupEntityLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	entityName string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetECertificateGroupEntityLOVRequest) Authorization(authorization string) LOVApiGetECertificateGroupEntityLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetECertificateGroupEntityLOVRequest) XAppKey(xAppKey string) LOVApiGetECertificateGroupEntityLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetECertificateGroupEntityLOVRequest) XHotelid(xHotelid string) LOVApiGetECertificateGroupEntityLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetECertificateGroupEntityLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetECertificateGroupEntityLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetECertificateGroupEntityLOVRequest) ParameterName(parameterName []string) LOVApiGetECertificateGroupEntityLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetECertificateGroupEntityLOVRequest) ParameterValue(parameterValue []string) LOVApiGetECertificateGroupEntityLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetECertificateGroupEntityLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetECertificateGroupEntityLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetECertificateGroupEntityLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetECertificateGroupEntityLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetECertificateGroupEntityLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetECertificateGroupEntityLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetECertificateGroupEntityLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetECertificateGroupEntityLOVExecute(r)
}

/*
GetECertificateGroupEntityLOV Fetch List Of Values for ECertificate Group Entity

 <p><strong>OperationId:</strong>getECertificateGroupEntityLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param entityName Value of the parameter 'entityName' which is required to fetch ECertificateGroupEntity LOV
 @return LOVApiGetECertificateGroupEntityLOVRequest
*/
func (a *LOVApiService) GetECertificateGroupEntityLOV(ctx context.Context, entityName string) LOVApiGetECertificateGroupEntityLOVRequest {
	return LOVApiGetECertificateGroupEntityLOVRequest{
		ApiService: a,
		ctx: ctx,
		entityName: entityName,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetECertificateGroupEntityLOVExecute(r LOVApiGetECertificateGroupEntityLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetECertificateGroupEntityLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/entityName/{entityName}/eCertificateGroupEntity"
	localVarPath = strings.Replace(localVarPath, "{"+"entityName"+"}", url.PathEscape(parameterValueToString(r.entityName, "entityName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.entityName) < 1 {
		return localVarReturnValue, nil, reportError("entityName must have at least 1 elements")
	}
	if strlen(r.entityName) > 2000 {
		return localVarReturnValue, nil, reportError("entityName must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetECouponLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetECouponLOVRequest) Authorization(authorization string) LOVApiGetECouponLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetECouponLOVRequest) XAppKey(xAppKey string) LOVApiGetECouponLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetECouponLOVRequest) XHotelid(xHotelid string) LOVApiGetECouponLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetECouponLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetECouponLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetECouponLOVRequest) ParameterName(parameterName []string) LOVApiGetECouponLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetECouponLOVRequest) ParameterValue(parameterValue []string) LOVApiGetECouponLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetECouponLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetECouponLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetECouponLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetECouponLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetECouponLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetECouponLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetECouponLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetECouponLOVExecute(r)
}

/*
GetECouponLOV Fetch List Of Values for ECoupon

 <p><strong>OperationId:</strong>getECouponLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ECoupon LOV
 @return LOVApiGetECouponLOVRequest
*/
func (a *LOVApiService) GetECouponLOV(ctx context.Context, hotelId string) LOVApiGetECouponLOVRequest {
	return LOVApiGetECouponLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetECouponLOVExecute(r LOVApiGetECouponLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetECouponLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/eCoupon"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetECouponRateCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetECouponRateCodesLOVRequest) Authorization(authorization string) LOVApiGetECouponRateCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetECouponRateCodesLOVRequest) XAppKey(xAppKey string) LOVApiGetECouponRateCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetECouponRateCodesLOVRequest) XHotelid(xHotelid string) LOVApiGetECouponRateCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetECouponRateCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetECouponRateCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetECouponRateCodesLOVRequest) ParameterName(parameterName []string) LOVApiGetECouponRateCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetECouponRateCodesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetECouponRateCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetECouponRateCodesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetECouponRateCodesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetECouponRateCodesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetECouponRateCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetECouponRateCodesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetECouponRateCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetECouponRateCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetECouponRateCodesLOVExecute(r)
}

/*
GetECouponRateCodesLOV Fetch List Of Values for ECoupon Rate Codes

 <p><strong>OperationId:</strong>getECouponRateCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ECouponRateCodes LOV
 @return LOVApiGetECouponRateCodesLOVRequest
*/
func (a *LOVApiService) GetECouponRateCodesLOV(ctx context.Context, hotelId string) LOVApiGetECouponRateCodesLOVRequest {
	return LOVApiGetECouponRateCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetECouponRateCodesLOVExecute(r LOVApiGetECouponRateCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetECouponRateCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/eCouponRateCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetEcouponResvRoomLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetEcouponResvRoomLOVRequest) Authorization(authorization string) LOVApiGetEcouponResvRoomLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetEcouponResvRoomLOVRequest) XAppKey(xAppKey string) LOVApiGetEcouponResvRoomLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetEcouponResvRoomLOVRequest) XHotelid(xHotelid string) LOVApiGetEcouponResvRoomLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetEcouponResvRoomLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetEcouponResvRoomLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetEcouponResvRoomLOVRequest) ParameterName(parameterName []string) LOVApiGetEcouponResvRoomLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetEcouponResvRoomLOVRequest) ParameterValue(parameterValue []string) LOVApiGetEcouponResvRoomLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetEcouponResvRoomLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetEcouponResvRoomLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetEcouponResvRoomLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetEcouponResvRoomLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetEcouponResvRoomLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetEcouponResvRoomLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetEcouponResvRoomLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetEcouponResvRoomLOVExecute(r)
}

/*
GetEcouponResvRoomLOV Fetch List Of Values for Ecoupon Resv Room

 <p><strong>OperationId:</strong>getEcouponResvRoomLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch EcouponResvRoom LOV
 @return LOVApiGetEcouponResvRoomLOVRequest
*/
func (a *LOVApiService) GetEcouponResvRoomLOV(ctx context.Context, hotelId string) LOVApiGetEcouponResvRoomLOVRequest {
	return LOVApiGetEcouponResvRoomLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetEcouponResvRoomLOVExecute(r LOVApiGetEcouponResvRoomLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetEcouponResvRoomLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/ecouponResvRoom"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetEndOfDayReportsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	beforeIncomeAudit string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetEndOfDayReportsLOVRequest) Authorization(authorization string) LOVApiGetEndOfDayReportsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetEndOfDayReportsLOVRequest) XAppKey(xAppKey string) LOVApiGetEndOfDayReportsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetEndOfDayReportsLOVRequest) XHotelid(xHotelid string) LOVApiGetEndOfDayReportsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetEndOfDayReportsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetEndOfDayReportsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetEndOfDayReportsLOVRequest) ParameterName(parameterName []string) LOVApiGetEndOfDayReportsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetEndOfDayReportsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetEndOfDayReportsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetEndOfDayReportsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetEndOfDayReportsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetEndOfDayReportsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetEndOfDayReportsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetEndOfDayReportsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetEndOfDayReportsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetEndOfDayReportsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetEndOfDayReportsLOVExecute(r)
}

/*
GetEndOfDayReportsLOV Fetch List Of Values for End Of Day Reports

 <p><strong>OperationId:</strong>getEndOfDayReportsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param beforeIncomeAudit Value of the parameter 'beforeIncomeAudit' which is required to fetch EndOfDayReports LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch EndOfDayReports LOV
 @return LOVApiGetEndOfDayReportsLOVRequest
*/
func (a *LOVApiService) GetEndOfDayReportsLOV(ctx context.Context, beforeIncomeAudit string, hotelId string) LOVApiGetEndOfDayReportsLOVRequest {
	return LOVApiGetEndOfDayReportsLOVRequest{
		ApiService: a,
		ctx: ctx,
		beforeIncomeAudit: beforeIncomeAudit,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetEndOfDayReportsLOVExecute(r LOVApiGetEndOfDayReportsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetEndOfDayReportsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/beforeIncomeAudit/{beforeIncomeAudit}/endOfDayReports"
	localVarPath = strings.Replace(localVarPath, "{"+"beforeIncomeAudit"+"}", url.PathEscape(parameterValueToString(r.beforeIncomeAudit, "beforeIncomeAudit")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.beforeIncomeAudit) < 1 {
		return localVarReturnValue, nil, reportError("beforeIncomeAudit must have at least 1 elements")
	}
	if strlen(r.beforeIncomeAudit) > 2000 {
		return localVarReturnValue, nil, reportError("beforeIncomeAudit must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetEnrollmentMatchCommunicationTypeLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	type_ string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetEnrollmentMatchCommunicationTypeLOVRequest) Authorization(authorization string) LOVApiGetEnrollmentMatchCommunicationTypeLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetEnrollmentMatchCommunicationTypeLOVRequest) XAppKey(xAppKey string) LOVApiGetEnrollmentMatchCommunicationTypeLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetEnrollmentMatchCommunicationTypeLOVRequest) XHotelid(xHotelid string) LOVApiGetEnrollmentMatchCommunicationTypeLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetEnrollmentMatchCommunicationTypeLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetEnrollmentMatchCommunicationTypeLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetEnrollmentMatchCommunicationTypeLOVRequest) ParameterName(parameterName []string) LOVApiGetEnrollmentMatchCommunicationTypeLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetEnrollmentMatchCommunicationTypeLOVRequest) ParameterValue(parameterValue []string) LOVApiGetEnrollmentMatchCommunicationTypeLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetEnrollmentMatchCommunicationTypeLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetEnrollmentMatchCommunicationTypeLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetEnrollmentMatchCommunicationTypeLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetEnrollmentMatchCommunicationTypeLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetEnrollmentMatchCommunicationTypeLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetEnrollmentMatchCommunicationTypeLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetEnrollmentMatchCommunicationTypeLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetEnrollmentMatchCommunicationTypeLOVExecute(r)
}

/*
GetEnrollmentMatchCommunicationTypeLOV Fetch List Of Values for Enrollment Match Communication Type

 <p><strong>OperationId:</strong>getEnrollmentMatchCommunicationTypeLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param type_ Value of the parameter 'type' which is required to fetch EnrollmentMatchCommunicationType LOV
 @return LOVApiGetEnrollmentMatchCommunicationTypeLOVRequest
*/
func (a *LOVApiService) GetEnrollmentMatchCommunicationTypeLOV(ctx context.Context, type_ string) LOVApiGetEnrollmentMatchCommunicationTypeLOVRequest {
	return LOVApiGetEnrollmentMatchCommunicationTypeLOVRequest{
		ApiService: a,
		ctx: ctx,
		type_: type_,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetEnrollmentMatchCommunicationTypeLOVExecute(r LOVApiGetEnrollmentMatchCommunicationTypeLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetEnrollmentMatchCommunicationTypeLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/type/{type}/enrollmentMatchCommunicationType"
	localVarPath = strings.Replace(localVarPath, "{"+"type"+"}", url.PathEscape(parameterValueToString(r.type_, "type_")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.type_) < 1 {
		return localVarReturnValue, nil, reportError("type_ must have at least 1 elements")
	}
	if strlen(r.type_) > 2000 {
		return localVarReturnValue, nil, reportError("type_ must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetEventGroupsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetEventGroupsLOVRequest) Authorization(authorization string) LOVApiGetEventGroupsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetEventGroupsLOVRequest) XAppKey(xAppKey string) LOVApiGetEventGroupsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetEventGroupsLOVRequest) XHotelid(xHotelid string) LOVApiGetEventGroupsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetEventGroupsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetEventGroupsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetEventGroupsLOVRequest) ParameterName(parameterName []string) LOVApiGetEventGroupsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetEventGroupsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetEventGroupsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetEventGroupsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetEventGroupsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetEventGroupsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetEventGroupsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetEventGroupsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetEventGroupsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetEventGroupsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetEventGroupsLOVExecute(r)
}

/*
GetEventGroupsLOV Fetch List Of Values for Event Groups

 <p><strong>OperationId:</strong>getEventGroupsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch EventGroups LOV
 @return LOVApiGetEventGroupsLOVRequest
*/
func (a *LOVApiService) GetEventGroupsLOV(ctx context.Context, hotelId string) LOVApiGetEventGroupsLOVRequest {
	return LOVApiGetEventGroupsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetEventGroupsLOVExecute(r LOVApiGetEventGroupsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetEventGroupsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/eventGroups"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetEventLocationsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetEventLocationsLOVRequest) Authorization(authorization string) LOVApiGetEventLocationsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetEventLocationsLOVRequest) XAppKey(xAppKey string) LOVApiGetEventLocationsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetEventLocationsLOVRequest) XHotelid(xHotelid string) LOVApiGetEventLocationsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetEventLocationsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetEventLocationsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetEventLocationsLOVRequest) ParameterName(parameterName []string) LOVApiGetEventLocationsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetEventLocationsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetEventLocationsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetEventLocationsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetEventLocationsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetEventLocationsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetEventLocationsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetEventLocationsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetEventLocationsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetEventLocationsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetEventLocationsLOVExecute(r)
}

/*
GetEventLocationsLOV Fetch List Of Values for Event Locations

 <p><strong>OperationId:</strong>getEventLocationsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch EventLocations LOV
 @return LOVApiGetEventLocationsLOVRequest
*/
func (a *LOVApiService) GetEventLocationsLOV(ctx context.Context, hotelId string) LOVApiGetEventLocationsLOVRequest {
	return LOVApiGetEventLocationsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetEventLocationsLOVExecute(r LOVApiGetEventLocationsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetEventLocationsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/eventLocations"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetEventRateCodeLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	space string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetEventRateCodeLOVRequest) Authorization(authorization string) LOVApiGetEventRateCodeLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetEventRateCodeLOVRequest) XAppKey(xAppKey string) LOVApiGetEventRateCodeLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetEventRateCodeLOVRequest) XHotelid(xHotelid string) LOVApiGetEventRateCodeLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetEventRateCodeLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetEventRateCodeLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetEventRateCodeLOVRequest) ParameterName(parameterName []string) LOVApiGetEventRateCodeLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetEventRateCodeLOVRequest) ParameterValue(parameterValue []string) LOVApiGetEventRateCodeLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetEventRateCodeLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetEventRateCodeLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetEventRateCodeLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetEventRateCodeLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetEventRateCodeLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetEventRateCodeLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetEventRateCodeLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetEventRateCodeLOVExecute(r)
}

/*
GetEventRateCodeLOV Fetch List Of Values for Event Rate Code

 <p><strong>OperationId:</strong>getEventRateCodeLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param space Value of the parameter 'space' which is required to fetch EventRateCode LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch EventRateCode LOV
 @return LOVApiGetEventRateCodeLOVRequest
*/
func (a *LOVApiService) GetEventRateCodeLOV(ctx context.Context, space string, hotelId string) LOVApiGetEventRateCodeLOVRequest {
	return LOVApiGetEventRateCodeLOVRequest{
		ApiService: a,
		ctx: ctx,
		space: space,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetEventRateCodeLOVExecute(r LOVApiGetEventRateCodeLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetEventRateCodeLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/space/{space}/eventRateCode"
	localVarPath = strings.Replace(localVarPath, "{"+"space"+"}", url.PathEscape(parameterValueToString(r.space, "space")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.space) < 1 {
		return localVarReturnValue, nil, reportError("space must have at least 1 elements")
	}
	if strlen(r.space) > 2000 {
		return localVarReturnValue, nil, reportError("space must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetEventSetupStylesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	room string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetEventSetupStylesLOVRequest) Authorization(authorization string) LOVApiGetEventSetupStylesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetEventSetupStylesLOVRequest) XAppKey(xAppKey string) LOVApiGetEventSetupStylesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetEventSetupStylesLOVRequest) XHotelid(xHotelid string) LOVApiGetEventSetupStylesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetEventSetupStylesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetEventSetupStylesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetEventSetupStylesLOVRequest) ParameterName(parameterName []string) LOVApiGetEventSetupStylesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetEventSetupStylesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetEventSetupStylesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetEventSetupStylesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetEventSetupStylesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetEventSetupStylesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetEventSetupStylesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetEventSetupStylesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetEventSetupStylesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetEventSetupStylesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetEventSetupStylesLOVExecute(r)
}

/*
GetEventSetupStylesLOV Fetch List Of Values for Event Setup Styles

 <p><strong>OperationId:</strong>getEventSetupStylesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param room Value of the parameter 'room' which is required to fetch EventSetupStyles LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch EventSetupStyles LOV
 @return LOVApiGetEventSetupStylesLOVRequest
*/
func (a *LOVApiService) GetEventSetupStylesLOV(ctx context.Context, room string, hotelId string) LOVApiGetEventSetupStylesLOVRequest {
	return LOVApiGetEventSetupStylesLOVRequest{
		ApiService: a,
		ctx: ctx,
		room: room,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetEventSetupStylesLOVExecute(r LOVApiGetEventSetupStylesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetEventSetupStylesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/room/{room}/eventSetupStyles"
	localVarPath = strings.Replace(localVarPath, "{"+"room"+"}", url.PathEscape(parameterValueToString(r.room, "room")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.room) < 1 {
		return localVarReturnValue, nil, reportError("room must have at least 1 elements")
	}
	if strlen(r.room) > 2000 {
		return localVarReturnValue, nil, reportError("room must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetEventStatusCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	exclusionList string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetEventStatusCodesLOVRequest) Authorization(authorization string) LOVApiGetEventStatusCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetEventStatusCodesLOVRequest) XAppKey(xAppKey string) LOVApiGetEventStatusCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetEventStatusCodesLOVRequest) XHotelid(xHotelid string) LOVApiGetEventStatusCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetEventStatusCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetEventStatusCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetEventStatusCodesLOVRequest) ParameterName(parameterName []string) LOVApiGetEventStatusCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetEventStatusCodesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetEventStatusCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetEventStatusCodesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetEventStatusCodesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetEventStatusCodesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetEventStatusCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetEventStatusCodesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetEventStatusCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetEventStatusCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetEventStatusCodesLOVExecute(r)
}

/*
GetEventStatusCodesLOV Fetch List Of Values for Event Status Codes

 <p><strong>OperationId:</strong>getEventStatusCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param exclusionList Value of the parameter 'exclusionList' which is required to fetch EventStatusCodes LOV
 @return LOVApiGetEventStatusCodesLOVRequest
*/
func (a *LOVApiService) GetEventStatusCodesLOV(ctx context.Context, exclusionList string) LOVApiGetEventStatusCodesLOVRequest {
	return LOVApiGetEventStatusCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		exclusionList: exclusionList,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetEventStatusCodesLOVExecute(r LOVApiGetEventStatusCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetEventStatusCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/exclusionList/{exclusionList}/eventStatusCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"exclusionList"+"}", url.PathEscape(parameterValueToString(r.exclusionList, "exclusionList")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.exclusionList) < 1 {
		return localVarReturnValue, nil, reportError("exclusionList must have at least 1 elements")
	}
	if strlen(r.exclusionList) > 2000 {
		return localVarReturnValue, nil, reportError("exclusionList must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetExchangeTypesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	currencyCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetExchangeTypesLOVRequest) Authorization(authorization string) LOVApiGetExchangeTypesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetExchangeTypesLOVRequest) XAppKey(xAppKey string) LOVApiGetExchangeTypesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetExchangeTypesLOVRequest) XHotelid(xHotelid string) LOVApiGetExchangeTypesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetExchangeTypesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetExchangeTypesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetExchangeTypesLOVRequest) ParameterName(parameterName []string) LOVApiGetExchangeTypesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetExchangeTypesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetExchangeTypesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetExchangeTypesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetExchangeTypesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetExchangeTypesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetExchangeTypesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetExchangeTypesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetExchangeTypesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetExchangeTypesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetExchangeTypesLOVExecute(r)
}

/*
GetExchangeTypesLOV Fetch List Of Values for Exchange Types

 <p><strong>OperationId:</strong>getExchangeTypesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param currencyCode Value of the parameter 'currencyCode' which is required to fetch ExchangeTypes LOV
 @return LOVApiGetExchangeTypesLOVRequest
*/
func (a *LOVApiService) GetExchangeTypesLOV(ctx context.Context, currencyCode string) LOVApiGetExchangeTypesLOVRequest {
	return LOVApiGetExchangeTypesLOVRequest{
		ApiService: a,
		ctx: ctx,
		currencyCode: currencyCode,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetExchangeTypesLOVExecute(r LOVApiGetExchangeTypesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetExchangeTypesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/currencyCode/{currencyCode}/exchangeTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"currencyCode"+"}", url.PathEscape(parameterValueToString(r.currencyCode, "currencyCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.currencyCode) < 1 {
		return localVarReturnValue, nil, reportError("currencyCode must have at least 1 elements")
	}
	if strlen(r.currencyCode) > 2000 {
		return localVarReturnValue, nil, reportError("currencyCode must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetExportMappingCodesToLinkLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	configType string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetExportMappingCodesToLinkLOVRequest) Authorization(authorization string) LOVApiGetExportMappingCodesToLinkLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetExportMappingCodesToLinkLOVRequest) XAppKey(xAppKey string) LOVApiGetExportMappingCodesToLinkLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetExportMappingCodesToLinkLOVRequest) XHotelid(xHotelid string) LOVApiGetExportMappingCodesToLinkLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetExportMappingCodesToLinkLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetExportMappingCodesToLinkLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetExportMappingCodesToLinkLOVRequest) ParameterName(parameterName []string) LOVApiGetExportMappingCodesToLinkLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetExportMappingCodesToLinkLOVRequest) ParameterValue(parameterValue []string) LOVApiGetExportMappingCodesToLinkLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetExportMappingCodesToLinkLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetExportMappingCodesToLinkLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetExportMappingCodesToLinkLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetExportMappingCodesToLinkLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetExportMappingCodesToLinkLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetExportMappingCodesToLinkLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetExportMappingCodesToLinkLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetExportMappingCodesToLinkLOVExecute(r)
}

/*
GetExportMappingCodesToLinkLOV Fetch List Of Values for Export Mapping Codes To Link

 <p><strong>OperationId:</strong>getExportMappingCodesToLinkLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param configType Value of the parameter 'configType' which is required to fetch ExportMappingCodesToLink LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ExportMappingCodesToLink LOV
 @return LOVApiGetExportMappingCodesToLinkLOVRequest
*/
func (a *LOVApiService) GetExportMappingCodesToLinkLOV(ctx context.Context, configType string, hotelId string) LOVApiGetExportMappingCodesToLinkLOVRequest {
	return LOVApiGetExportMappingCodesToLinkLOVRequest{
		ApiService: a,
		ctx: ctx,
		configType: configType,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetExportMappingCodesToLinkLOVExecute(r LOVApiGetExportMappingCodesToLinkLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetExportMappingCodesToLinkLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/configType/{configType}/exportMappingCodesToLink"
	localVarPath = strings.Replace(localVarPath, "{"+"configType"+"}", url.PathEscape(parameterValueToString(r.configType, "configType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.configType) < 1 {
		return localVarReturnValue, nil, reportError("configType must have at least 1 elements")
	}
	if strlen(r.configType) > 2000 {
		return localVarReturnValue, nil, reportError("configType must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetExportMappingTypeCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetExportMappingTypeCodesLOVRequest) Authorization(authorization string) LOVApiGetExportMappingTypeCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetExportMappingTypeCodesLOVRequest) XAppKey(xAppKey string) LOVApiGetExportMappingTypeCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetExportMappingTypeCodesLOVRequest) XHotelid(xHotelid string) LOVApiGetExportMappingTypeCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetExportMappingTypeCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetExportMappingTypeCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetExportMappingTypeCodesLOVRequest) ParameterName(parameterName []string) LOVApiGetExportMappingTypeCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetExportMappingTypeCodesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetExportMappingTypeCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetExportMappingTypeCodesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetExportMappingTypeCodesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetExportMappingTypeCodesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetExportMappingTypeCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetExportMappingTypeCodesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetExportMappingTypeCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetExportMappingTypeCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetExportMappingTypeCodesLOVExecute(r)
}

/*
GetExportMappingTypeCodesLOV Fetch List Of Values for Export Mapping Type Codes

 <p><strong>OperationId:</strong>getExportMappingTypeCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ExportMappingTypeCodes LOV
 @return LOVApiGetExportMappingTypeCodesLOVRequest
*/
func (a *LOVApiService) GetExportMappingTypeCodesLOV(ctx context.Context, hotelId string) LOVApiGetExportMappingTypeCodesLOVRequest {
	return LOVApiGetExportMappingTypeCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetExportMappingTypeCodesLOVExecute(r LOVApiGetExportMappingTypeCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetExportMappingTypeCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/exportMappingTypeCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetExternalDatabaseAvailableResortsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	databaseId string
	interfaceType string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetExternalDatabaseAvailableResortsLOVRequest) Authorization(authorization string) LOVApiGetExternalDatabaseAvailableResortsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetExternalDatabaseAvailableResortsLOVRequest) XAppKey(xAppKey string) LOVApiGetExternalDatabaseAvailableResortsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetExternalDatabaseAvailableResortsLOVRequest) XHotelid(xHotelid string) LOVApiGetExternalDatabaseAvailableResortsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetExternalDatabaseAvailableResortsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetExternalDatabaseAvailableResortsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetExternalDatabaseAvailableResortsLOVRequest) ParameterName(parameterName []string) LOVApiGetExternalDatabaseAvailableResortsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetExternalDatabaseAvailableResortsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetExternalDatabaseAvailableResortsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetExternalDatabaseAvailableResortsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetExternalDatabaseAvailableResortsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetExternalDatabaseAvailableResortsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetExternalDatabaseAvailableResortsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetExternalDatabaseAvailableResortsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetExternalDatabaseAvailableResortsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetExternalDatabaseAvailableResortsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetExternalDatabaseAvailableResortsLOVExecute(r)
}

/*
GetExternalDatabaseAvailableResortsLOV Fetch List Of Values for External Database Available Resorts

 <p><strong>OperationId:</strong>getExternalDatabaseAvailableResortsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param databaseId Value of the parameter 'databaseId' which is required to fetch ExternalDatabaseAvailableResorts LOV
 @param interfaceType Value of the parameter 'interfaceType' which is required to fetch ExternalDatabaseAvailableResorts LOV
 @return LOVApiGetExternalDatabaseAvailableResortsLOVRequest
*/
func (a *LOVApiService) GetExternalDatabaseAvailableResortsLOV(ctx context.Context, databaseId string, interfaceType string) LOVApiGetExternalDatabaseAvailableResortsLOVRequest {
	return LOVApiGetExternalDatabaseAvailableResortsLOVRequest{
		ApiService: a,
		ctx: ctx,
		databaseId: databaseId,
		interfaceType: interfaceType,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetExternalDatabaseAvailableResortsLOVExecute(r LOVApiGetExternalDatabaseAvailableResortsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetExternalDatabaseAvailableResortsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/interfaceType/{interfaceType}/databaseId/{databaseId}/externalDatabaseAvailableResorts"
	localVarPath = strings.Replace(localVarPath, "{"+"databaseId"+"}", url.PathEscape(parameterValueToString(r.databaseId, "databaseId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"interfaceType"+"}", url.PathEscape(parameterValueToString(r.interfaceType, "interfaceType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.databaseId) < 1 {
		return localVarReturnValue, nil, reportError("databaseId must have at least 1 elements")
	}
	if strlen(r.databaseId) > 2000 {
		return localVarReturnValue, nil, reportError("databaseId must have less than 2000 elements")
	}
	if strlen(r.interfaceType) < 1 {
		return localVarReturnValue, nil, reportError("interfaceType must have at least 1 elements")
	}
	if strlen(r.interfaceType) > 2000 {
		return localVarReturnValue, nil, reportError("interfaceType must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetExternalReferenceTypesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetExternalReferenceTypesLOVRequest) Authorization(authorization string) LOVApiGetExternalReferenceTypesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetExternalReferenceTypesLOVRequest) XAppKey(xAppKey string) LOVApiGetExternalReferenceTypesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetExternalReferenceTypesLOVRequest) XHotelid(xHotelid string) LOVApiGetExternalReferenceTypesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetExternalReferenceTypesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetExternalReferenceTypesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetExternalReferenceTypesLOVRequest) ParameterName(parameterName []string) LOVApiGetExternalReferenceTypesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetExternalReferenceTypesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetExternalReferenceTypesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetExternalReferenceTypesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetExternalReferenceTypesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetExternalReferenceTypesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetExternalReferenceTypesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetExternalReferenceTypesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetExternalReferenceTypesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetExternalReferenceTypesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetExternalReferenceTypesLOVExecute(r)
}

/*
GetExternalReferenceTypesLOV Fetch List Of Values for External Reference Types

 <p><strong>OperationId:</strong>getExternalReferenceTypesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ExternalReferenceTypes LOV
 @return LOVApiGetExternalReferenceTypesLOVRequest
*/
func (a *LOVApiService) GetExternalReferenceTypesLOV(ctx context.Context, hotelId string) LOVApiGetExternalReferenceTypesLOVRequest {
	return LOVApiGetExternalReferenceTypesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetExternalReferenceTypesLOVExecute(r LOVApiGetExternalReferenceTypesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetExternalReferenceTypesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/externalReferenceTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetFacilityCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetFacilityCodesLOVRequest) Authorization(authorization string) LOVApiGetFacilityCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetFacilityCodesLOVRequest) XAppKey(xAppKey string) LOVApiGetFacilityCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetFacilityCodesLOVRequest) XHotelid(xHotelid string) LOVApiGetFacilityCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetFacilityCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetFacilityCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetFacilityCodesLOVRequest) ParameterName(parameterName []string) LOVApiGetFacilityCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetFacilityCodesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetFacilityCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetFacilityCodesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetFacilityCodesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetFacilityCodesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetFacilityCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetFacilityCodesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetFacilityCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetFacilityCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetFacilityCodesLOVExecute(r)
}

/*
GetFacilityCodesLOV Fetch List Of Values for Facility Codes

 <p><strong>OperationId:</strong>getFacilityCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch FacilityCodes LOV
 @return LOVApiGetFacilityCodesLOVRequest
*/
func (a *LOVApiService) GetFacilityCodesLOV(ctx context.Context, hotelId string) LOVApiGetFacilityCodesLOVRequest {
	return LOVApiGetFacilityCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetFacilityCodesLOVExecute(r LOVApiGetFacilityCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetFacilityCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/facilityCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetFacilityCodesReservationLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	facilityTask string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetFacilityCodesReservationLOVRequest) Authorization(authorization string) LOVApiGetFacilityCodesReservationLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetFacilityCodesReservationLOVRequest) XAppKey(xAppKey string) LOVApiGetFacilityCodesReservationLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetFacilityCodesReservationLOVRequest) XHotelid(xHotelid string) LOVApiGetFacilityCodesReservationLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetFacilityCodesReservationLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetFacilityCodesReservationLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetFacilityCodesReservationLOVRequest) ParameterName(parameterName []string) LOVApiGetFacilityCodesReservationLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetFacilityCodesReservationLOVRequest) ParameterValue(parameterValue []string) LOVApiGetFacilityCodesReservationLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetFacilityCodesReservationLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetFacilityCodesReservationLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetFacilityCodesReservationLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetFacilityCodesReservationLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetFacilityCodesReservationLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetFacilityCodesReservationLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetFacilityCodesReservationLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetFacilityCodesReservationLOVExecute(r)
}

/*
GetFacilityCodesReservationLOV Fetch List Of Values for Facility Codes Reservation

 <p><strong>OperationId:</strong>getFacilityCodesReservationLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param facilityTask Value of the parameter 'facilityTask' which is required to fetch FacilityCodesReservation LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch FacilityCodesReservation LOV
 @return LOVApiGetFacilityCodesReservationLOVRequest
*/
func (a *LOVApiService) GetFacilityCodesReservationLOV(ctx context.Context, facilityTask string, hotelId string) LOVApiGetFacilityCodesReservationLOVRequest {
	return LOVApiGetFacilityCodesReservationLOVRequest{
		ApiService: a,
		ctx: ctx,
		facilityTask: facilityTask,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetFacilityCodesReservationLOVExecute(r LOVApiGetFacilityCodesReservationLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetFacilityCodesReservationLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/facilityTask/{facilityTask}/facilityCodesReservation"
	localVarPath = strings.Replace(localVarPath, "{"+"facilityTask"+"}", url.PathEscape(parameterValueToString(r.facilityTask, "facilityTask")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.facilityTask) < 1 {
		return localVarReturnValue, nil, reportError("facilityTask must have at least 1 elements")
	}
	if strlen(r.facilityTask) > 2000 {
		return localVarReturnValue, nil, reportError("facilityTask must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetFacilityTasksLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetFacilityTasksLOVRequest) Authorization(authorization string) LOVApiGetFacilityTasksLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetFacilityTasksLOVRequest) XAppKey(xAppKey string) LOVApiGetFacilityTasksLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetFacilityTasksLOVRequest) XHotelid(xHotelid string) LOVApiGetFacilityTasksLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetFacilityTasksLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetFacilityTasksLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetFacilityTasksLOVRequest) ParameterName(parameterName []string) LOVApiGetFacilityTasksLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetFacilityTasksLOVRequest) ParameterValue(parameterValue []string) LOVApiGetFacilityTasksLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetFacilityTasksLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetFacilityTasksLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetFacilityTasksLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetFacilityTasksLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetFacilityTasksLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetFacilityTasksLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetFacilityTasksLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetFacilityTasksLOVExecute(r)
}

/*
GetFacilityTasksLOV Fetch List Of Values for Facility Tasks

 <p><strong>OperationId:</strong>getFacilityTasksLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch FacilityTasks LOV
 @return LOVApiGetFacilityTasksLOVRequest
*/
func (a *LOVApiService) GetFacilityTasksLOV(ctx context.Context, hotelId string) LOVApiGetFacilityTasksLOVRequest {
	return LOVApiGetFacilityTasksLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetFacilityTasksLOVExecute(r LOVApiGetFacilityTasksLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetFacilityTasksLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/facilityTasks"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetFacilityTasksRoomTypeLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	roomTypeLabel string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetFacilityTasksRoomTypeLOVRequest) Authorization(authorization string) LOVApiGetFacilityTasksRoomTypeLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetFacilityTasksRoomTypeLOVRequest) XAppKey(xAppKey string) LOVApiGetFacilityTasksRoomTypeLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetFacilityTasksRoomTypeLOVRequest) XHotelid(xHotelid string) LOVApiGetFacilityTasksRoomTypeLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetFacilityTasksRoomTypeLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetFacilityTasksRoomTypeLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetFacilityTasksRoomTypeLOVRequest) ParameterName(parameterName []string) LOVApiGetFacilityTasksRoomTypeLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetFacilityTasksRoomTypeLOVRequest) ParameterValue(parameterValue []string) LOVApiGetFacilityTasksRoomTypeLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetFacilityTasksRoomTypeLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetFacilityTasksRoomTypeLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetFacilityTasksRoomTypeLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetFacilityTasksRoomTypeLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetFacilityTasksRoomTypeLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetFacilityTasksRoomTypeLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetFacilityTasksRoomTypeLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetFacilityTasksRoomTypeLOVExecute(r)
}

/*
GetFacilityTasksRoomTypeLOV Fetch List Of Values for Facility Tasks Room Type

 <p><strong>OperationId:</strong>getFacilityTasksRoomTypeLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param roomTypeLabel Value of the parameter 'roomTypeLabel' which is required to fetch FacilityTasksRoomType LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch FacilityTasksRoomType LOV
 @return LOVApiGetFacilityTasksRoomTypeLOVRequest
*/
func (a *LOVApiService) GetFacilityTasksRoomTypeLOV(ctx context.Context, roomTypeLabel string, hotelId string) LOVApiGetFacilityTasksRoomTypeLOVRequest {
	return LOVApiGetFacilityTasksRoomTypeLOVRequest{
		ApiService: a,
		ctx: ctx,
		roomTypeLabel: roomTypeLabel,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetFacilityTasksRoomTypeLOVExecute(r LOVApiGetFacilityTasksRoomTypeLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetFacilityTasksRoomTypeLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/roomTypeLabel/{roomTypeLabel}/facilityTasksRoomType"
	localVarPath = strings.Replace(localVarPath, "{"+"roomTypeLabel"+"}", url.PathEscape(parameterValueToString(r.roomTypeLabel, "roomTypeLabel")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.roomTypeLabel) < 1 {
		return localVarReturnValue, nil, reportError("roomTypeLabel must have at least 1 elements")
	}
	if strlen(r.roomTypeLabel) > 2000 {
		return localVarReturnValue, nil, reportError("roomTypeLabel must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetFieldNameLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	changeSource string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetFieldNameLOVRequest) Authorization(authorization string) LOVApiGetFieldNameLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetFieldNameLOVRequest) XAppKey(xAppKey string) LOVApiGetFieldNameLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetFieldNameLOVRequest) XHotelid(xHotelid string) LOVApiGetFieldNameLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetFieldNameLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetFieldNameLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetFieldNameLOVRequest) ParameterName(parameterName []string) LOVApiGetFieldNameLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetFieldNameLOVRequest) ParameterValue(parameterValue []string) LOVApiGetFieldNameLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetFieldNameLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetFieldNameLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetFieldNameLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetFieldNameLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetFieldNameLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetFieldNameLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetFieldNameLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetFieldNameLOVExecute(r)
}

/*
GetFieldNameLOV Fetch List Of Values for Field Name

 <p><strong>OperationId:</strong>getFieldNameLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param changeSource Value of the parameter 'changeSource' which is required to fetch FieldName LOV
 @return LOVApiGetFieldNameLOVRequest
*/
func (a *LOVApiService) GetFieldNameLOV(ctx context.Context, changeSource string) LOVApiGetFieldNameLOVRequest {
	return LOVApiGetFieldNameLOVRequest{
		ApiService: a,
		ctx: ctx,
		changeSource: changeSource,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetFieldNameLOVExecute(r LOVApiGetFieldNameLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetFieldNameLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/changeSource/{changeSource}/fieldName"
	localVarPath = strings.Replace(localVarPath, "{"+"changeSource"+"}", url.PathEscape(parameterValueToString(r.changeSource, "changeSource")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.changeSource) < 1 {
		return localVarReturnValue, nil, reportError("changeSource must have at least 1 elements")
	}
	if strlen(r.changeSource) > 2000 {
		return localVarReturnValue, nil, reportError("changeSource must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetFiscalPaymentMethodsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetFiscalPaymentMethodsLOVRequest) Authorization(authorization string) LOVApiGetFiscalPaymentMethodsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetFiscalPaymentMethodsLOVRequest) XAppKey(xAppKey string) LOVApiGetFiscalPaymentMethodsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetFiscalPaymentMethodsLOVRequest) XHotelid(xHotelid string) LOVApiGetFiscalPaymentMethodsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetFiscalPaymentMethodsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetFiscalPaymentMethodsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetFiscalPaymentMethodsLOVRequest) ParameterName(parameterName []string) LOVApiGetFiscalPaymentMethodsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetFiscalPaymentMethodsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetFiscalPaymentMethodsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetFiscalPaymentMethodsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetFiscalPaymentMethodsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetFiscalPaymentMethodsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetFiscalPaymentMethodsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetFiscalPaymentMethodsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetFiscalPaymentMethodsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetFiscalPaymentMethodsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetFiscalPaymentMethodsLOVExecute(r)
}

/*
GetFiscalPaymentMethodsLOV Fetch List Of Values for Fiscal Payment Methods

 <p><strong>OperationId:</strong>getFiscalPaymentMethodsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch FiscalPaymentMethods LOV
 @return LOVApiGetFiscalPaymentMethodsLOVRequest
*/
func (a *LOVApiService) GetFiscalPaymentMethodsLOV(ctx context.Context, hotelId string) LOVApiGetFiscalPaymentMethodsLOVRequest {
	return LOVApiGetFiscalPaymentMethodsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetFiscalPaymentMethodsLOVExecute(r LOVApiGetFiscalPaymentMethodsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetFiscalPaymentMethodsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/fiscalPaymentMethods"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetFixedChargesTransactionCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetFixedChargesTransactionCodesLOVRequest) Authorization(authorization string) LOVApiGetFixedChargesTransactionCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetFixedChargesTransactionCodesLOVRequest) XAppKey(xAppKey string) LOVApiGetFixedChargesTransactionCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetFixedChargesTransactionCodesLOVRequest) XHotelid(xHotelid string) LOVApiGetFixedChargesTransactionCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetFixedChargesTransactionCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetFixedChargesTransactionCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetFixedChargesTransactionCodesLOVRequest) ParameterName(parameterName []string) LOVApiGetFixedChargesTransactionCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetFixedChargesTransactionCodesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetFixedChargesTransactionCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetFixedChargesTransactionCodesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetFixedChargesTransactionCodesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetFixedChargesTransactionCodesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetFixedChargesTransactionCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetFixedChargesTransactionCodesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetFixedChargesTransactionCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetFixedChargesTransactionCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetFixedChargesTransactionCodesLOVExecute(r)
}

/*
GetFixedChargesTransactionCodesLOV Fetch List Of Values for Fixed Charges Transaction Codes

 <p><strong>OperationId:</strong>getFixedChargesTransactionCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch FixedChargesTransactionCodes LOV
 @return LOVApiGetFixedChargesTransactionCodesLOVRequest
*/
func (a *LOVApiService) GetFixedChargesTransactionCodesLOV(ctx context.Context, hotelId string) LOVApiGetFixedChargesTransactionCodesLOVRequest {
	return LOVApiGetFixedChargesTransactionCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetFixedChargesTransactionCodesLOVExecute(r LOVApiGetFixedChargesTransactionCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetFixedChargesTransactionCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/fixedChargesTransactionCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetFloorsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetFloorsLOVRequest) Authorization(authorization string) LOVApiGetFloorsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetFloorsLOVRequest) XAppKey(xAppKey string) LOVApiGetFloorsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetFloorsLOVRequest) XHotelid(xHotelid string) LOVApiGetFloorsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetFloorsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetFloorsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetFloorsLOVRequest) ParameterName(parameterName []string) LOVApiGetFloorsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetFloorsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetFloorsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetFloorsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetFloorsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetFloorsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetFloorsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetFloorsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetFloorsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetFloorsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetFloorsLOVExecute(r)
}

/*
GetFloorsLOV Fetch List Of Values for Floors

 <p><strong>OperationId:</strong>getFloorsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch Floors LOV
 @return LOVApiGetFloorsLOVRequest
*/
func (a *LOVApiService) GetFloorsLOV(ctx context.Context, hotelId string) LOVApiGetFloorsLOVRequest {
	return LOVApiGetFloorsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetFloorsLOVExecute(r LOVApiGetFloorsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetFloorsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/floors"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetFolioGroupingCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	type_ string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetFolioGroupingCodesLOVRequest) Authorization(authorization string) LOVApiGetFolioGroupingCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetFolioGroupingCodesLOVRequest) XAppKey(xAppKey string) LOVApiGetFolioGroupingCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetFolioGroupingCodesLOVRequest) XHotelid(xHotelid string) LOVApiGetFolioGroupingCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetFolioGroupingCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetFolioGroupingCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetFolioGroupingCodesLOVRequest) ParameterName(parameterName []string) LOVApiGetFolioGroupingCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetFolioGroupingCodesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetFolioGroupingCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetFolioGroupingCodesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetFolioGroupingCodesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetFolioGroupingCodesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetFolioGroupingCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetFolioGroupingCodesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetFolioGroupingCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetFolioGroupingCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetFolioGroupingCodesLOVExecute(r)
}

/*
GetFolioGroupingCodesLOV Fetch List Of Values for Folio Grouping Codes

 <p><strong>OperationId:</strong>getFolioGroupingCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param type_ Value of the parameter 'type' which is required to fetch FolioGroupingCodes LOV
 @return LOVApiGetFolioGroupingCodesLOVRequest
*/
func (a *LOVApiService) GetFolioGroupingCodesLOV(ctx context.Context, type_ string) LOVApiGetFolioGroupingCodesLOVRequest {
	return LOVApiGetFolioGroupingCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		type_: type_,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetFolioGroupingCodesLOVExecute(r LOVApiGetFolioGroupingCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetFolioGroupingCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/type/{type}/folioGroupingCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"type"+"}", url.PathEscape(parameterValueToString(r.type_, "type_")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.type_) < 1 {
		return localVarReturnValue, nil, reportError("type_ must have at least 1 elements")
	}
	if strlen(r.type_) > 2000 {
		return localVarReturnValue, nil, reportError("type_ must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetFolioGroupingTransactionCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	mode string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetFolioGroupingTransactionCodesLOVRequest) Authorization(authorization string) LOVApiGetFolioGroupingTransactionCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetFolioGroupingTransactionCodesLOVRequest) XAppKey(xAppKey string) LOVApiGetFolioGroupingTransactionCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetFolioGroupingTransactionCodesLOVRequest) XHotelid(xHotelid string) LOVApiGetFolioGroupingTransactionCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetFolioGroupingTransactionCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetFolioGroupingTransactionCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetFolioGroupingTransactionCodesLOVRequest) ParameterName(parameterName []string) LOVApiGetFolioGroupingTransactionCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetFolioGroupingTransactionCodesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetFolioGroupingTransactionCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetFolioGroupingTransactionCodesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetFolioGroupingTransactionCodesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetFolioGroupingTransactionCodesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetFolioGroupingTransactionCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetFolioGroupingTransactionCodesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetFolioGroupingTransactionCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetFolioGroupingTransactionCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetFolioGroupingTransactionCodesLOVExecute(r)
}

/*
GetFolioGroupingTransactionCodesLOV Fetch List Of Values for Folio Grouping Transaction Codes

 <p><strong>OperationId:</strong>getFolioGroupingTransactionCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param mode Value of the parameter 'mode' which is required to fetch FolioGroupingTransactionCodes LOV
 @return LOVApiGetFolioGroupingTransactionCodesLOVRequest
*/
func (a *LOVApiService) GetFolioGroupingTransactionCodesLOV(ctx context.Context, mode string) LOVApiGetFolioGroupingTransactionCodesLOVRequest {
	return LOVApiGetFolioGroupingTransactionCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		mode: mode,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetFolioGroupingTransactionCodesLOVExecute(r LOVApiGetFolioGroupingTransactionCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetFolioGroupingTransactionCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/mode/{mode}/folioGroupingTransactionCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"mode"+"}", url.PathEscape(parameterValueToString(r.mode, "mode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.mode) < 1 {
		return localVarReturnValue, nil, reportError("mode must have at least 1 elements")
	}
	if strlen(r.mode) > 2000 {
		return localVarReturnValue, nil, reportError("mode must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetFolioStylesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetFolioStylesLOVRequest) Authorization(authorization string) LOVApiGetFolioStylesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetFolioStylesLOVRequest) XAppKey(xAppKey string) LOVApiGetFolioStylesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetFolioStylesLOVRequest) XHotelid(xHotelid string) LOVApiGetFolioStylesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetFolioStylesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetFolioStylesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetFolioStylesLOVRequest) ParameterName(parameterName []string) LOVApiGetFolioStylesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetFolioStylesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetFolioStylesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetFolioStylesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetFolioStylesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetFolioStylesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetFolioStylesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetFolioStylesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetFolioStylesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetFolioStylesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetFolioStylesLOVExecute(r)
}

/*
GetFolioStylesLOV Fetch List Of Values for Folio Styles

 <p><strong>OperationId:</strong>getFolioStylesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch FolioStyles LOV
 @return LOVApiGetFolioStylesLOVRequest
*/
func (a *LOVApiService) GetFolioStylesLOV(ctx context.Context, hotelId string) LOVApiGetFolioStylesLOVRequest {
	return LOVApiGetFolioStylesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetFolioStylesLOVExecute(r LOVApiGetFolioStylesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetFolioStylesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/folioStyles"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetFolioTypesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetFolioTypesLOVRequest) Authorization(authorization string) LOVApiGetFolioTypesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetFolioTypesLOVRequest) XAppKey(xAppKey string) LOVApiGetFolioTypesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetFolioTypesLOVRequest) XHotelid(xHotelid string) LOVApiGetFolioTypesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetFolioTypesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetFolioTypesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetFolioTypesLOVRequest) ParameterName(parameterName []string) LOVApiGetFolioTypesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetFolioTypesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetFolioTypesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetFolioTypesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetFolioTypesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetFolioTypesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetFolioTypesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetFolioTypesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetFolioTypesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetFolioTypesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetFolioTypesLOVExecute(r)
}

/*
GetFolioTypesLOV Fetch List Of Values for Folio Types

 <p><strong>OperationId:</strong>getFolioTypesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch FolioTypes LOV
 @return LOVApiGetFolioTypesLOVRequest
*/
func (a *LOVApiService) GetFolioTypesLOV(ctx context.Context, hotelId string) LOVApiGetFolioTypesLOVRequest {
	return LOVApiGetFolioTypesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetFolioTypesLOVExecute(r LOVApiGetFolioTypesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetFolioTypesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/folioTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetForecastGroupsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetForecastGroupsLOVRequest) Authorization(authorization string) LOVApiGetForecastGroupsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetForecastGroupsLOVRequest) XAppKey(xAppKey string) LOVApiGetForecastGroupsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetForecastGroupsLOVRequest) XHotelid(xHotelid string) LOVApiGetForecastGroupsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetForecastGroupsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetForecastGroupsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetForecastGroupsLOVRequest) ParameterName(parameterName []string) LOVApiGetForecastGroupsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetForecastGroupsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetForecastGroupsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetForecastGroupsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetForecastGroupsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetForecastGroupsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetForecastGroupsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetForecastGroupsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetForecastGroupsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetForecastGroupsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetForecastGroupsLOVExecute(r)
}

/*
GetForecastGroupsLOV Fetch List Of Values for Forecast Groups

 <p><strong>OperationId:</strong>getForecastGroupsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ForecastGroups LOV
 @return LOVApiGetForecastGroupsLOVRequest
*/
func (a *LOVApiService) GetForecastGroupsLOV(ctx context.Context, hotelId string) LOVApiGetForecastGroupsLOVRequest {
	return LOVApiGetForecastGroupsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetForecastGroupsLOVExecute(r LOVApiGetForecastGroupsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetForecastGroupsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/forecastGroups"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetForeignCurrenciesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	exchangeType string
	sell string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetForeignCurrenciesLOVRequest) Authorization(authorization string) LOVApiGetForeignCurrenciesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetForeignCurrenciesLOVRequest) XAppKey(xAppKey string) LOVApiGetForeignCurrenciesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetForeignCurrenciesLOVRequest) XHotelid(xHotelid string) LOVApiGetForeignCurrenciesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetForeignCurrenciesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetForeignCurrenciesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetForeignCurrenciesLOVRequest) ParameterName(parameterName []string) LOVApiGetForeignCurrenciesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetForeignCurrenciesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetForeignCurrenciesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetForeignCurrenciesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetForeignCurrenciesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetForeignCurrenciesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetForeignCurrenciesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetForeignCurrenciesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetForeignCurrenciesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetForeignCurrenciesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetForeignCurrenciesLOVExecute(r)
}

/*
GetForeignCurrenciesLOV Fetch List Of Values for Foreign Currencies

 <p><strong>OperationId:</strong>getForeignCurrenciesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param exchangeType Value of the parameter 'exchangeType' which is required to fetch ForeignCurrencies LOV
 @param sell Value of the parameter 'sell' which is required to fetch ForeignCurrencies LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ForeignCurrencies LOV
 @return LOVApiGetForeignCurrenciesLOVRequest
*/
func (a *LOVApiService) GetForeignCurrenciesLOV(ctx context.Context, exchangeType string, sell string, hotelId string) LOVApiGetForeignCurrenciesLOVRequest {
	return LOVApiGetForeignCurrenciesLOVRequest{
		ApiService: a,
		ctx: ctx,
		exchangeType: exchangeType,
		sell: sell,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetForeignCurrenciesLOVExecute(r LOVApiGetForeignCurrenciesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetForeignCurrenciesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/sell/{sell}/exchangeType/{exchangeType}/foreignCurrencies"
	localVarPath = strings.Replace(localVarPath, "{"+"exchangeType"+"}", url.PathEscape(parameterValueToString(r.exchangeType, "exchangeType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sell"+"}", url.PathEscape(parameterValueToString(r.sell, "sell")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.exchangeType) < 1 {
		return localVarReturnValue, nil, reportError("exchangeType must have at least 1 elements")
	}
	if strlen(r.exchangeType) > 2000 {
		return localVarReturnValue, nil, reportError("exchangeType must have less than 2000 elements")
	}
	if strlen(r.sell) < 1 {
		return localVarReturnValue, nil, reportError("sell must have at least 1 elements")
	}
	if strlen(r.sell) > 2000 {
		return localVarReturnValue, nil, reportError("sell must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetFormatLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	method string
	moduleName string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetFormatLOVRequest) Authorization(authorization string) LOVApiGetFormatLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetFormatLOVRequest) XAppKey(xAppKey string) LOVApiGetFormatLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetFormatLOVRequest) XHotelid(xHotelid string) LOVApiGetFormatLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetFormatLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetFormatLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetFormatLOVRequest) ParameterName(parameterName []string) LOVApiGetFormatLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetFormatLOVRequest) ParameterValue(parameterValue []string) LOVApiGetFormatLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetFormatLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetFormatLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetFormatLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetFormatLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetFormatLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetFormatLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetFormatLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetFormatLOVExecute(r)
}

/*
GetFormatLOV Fetch List Of Values for Format

 <p><strong>OperationId:</strong>getFormatLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param method Value of the parameter 'method' which is required to fetch Format LOV
 @param moduleName Value of the parameter 'moduleName' which is required to fetch Format LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch Format LOV
 @return LOVApiGetFormatLOVRequest
*/
func (a *LOVApiService) GetFormatLOV(ctx context.Context, method string, moduleName string, hotelId string) LOVApiGetFormatLOVRequest {
	return LOVApiGetFormatLOVRequest{
		ApiService: a,
		ctx: ctx,
		method: method,
		moduleName: moduleName,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetFormatLOVExecute(r LOVApiGetFormatLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetFormatLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/moduleName/{moduleName}/method/{method}/format"
	localVarPath = strings.Replace(localVarPath, "{"+"method"+"}", url.PathEscape(parameterValueToString(r.method, "method")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"moduleName"+"}", url.PathEscape(parameterValueToString(r.moduleName, "moduleName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.method) < 1 {
		return localVarReturnValue, nil, reportError("method must have at least 1 elements")
	}
	if strlen(r.method) > 2000 {
		return localVarReturnValue, nil, reportError("method must have less than 2000 elements")
	}
	if strlen(r.moduleName) < 1 {
		return localVarReturnValue, nil, reportError("moduleName must have at least 1 elements")
	}
	if strlen(r.moduleName) > 2000 {
		return localVarReturnValue, nil, reportError("moduleName must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetFrequencyLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	defaultDepartureTask string
	guestRequested string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetFrequencyLOVRequest) Authorization(authorization string) LOVApiGetFrequencyLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetFrequencyLOVRequest) XAppKey(xAppKey string) LOVApiGetFrequencyLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetFrequencyLOVRequest) XHotelid(xHotelid string) LOVApiGetFrequencyLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetFrequencyLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetFrequencyLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetFrequencyLOVRequest) ParameterName(parameterName []string) LOVApiGetFrequencyLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetFrequencyLOVRequest) ParameterValue(parameterValue []string) LOVApiGetFrequencyLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetFrequencyLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetFrequencyLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetFrequencyLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetFrequencyLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetFrequencyLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetFrequencyLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetFrequencyLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetFrequencyLOVExecute(r)
}

/*
GetFrequencyLOV Fetch List Of Values for Frequency

 <p><strong>OperationId:</strong>getFrequencyLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param defaultDepartureTask Value of the parameter 'defaultDepartureTask' which is required to fetch Frequency LOV
 @param guestRequested Value of the parameter 'guestRequested' which is required to fetch Frequency LOV
 @return LOVApiGetFrequencyLOVRequest
*/
func (a *LOVApiService) GetFrequencyLOV(ctx context.Context, defaultDepartureTask string, guestRequested string) LOVApiGetFrequencyLOVRequest {
	return LOVApiGetFrequencyLOVRequest{
		ApiService: a,
		ctx: ctx,
		defaultDepartureTask: defaultDepartureTask,
		guestRequested: guestRequested,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetFrequencyLOVExecute(r LOVApiGetFrequencyLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetFrequencyLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/guestRequested/{guestRequested}/defaultDepartureTask/{defaultDepartureTask}/frequency"
	localVarPath = strings.Replace(localVarPath, "{"+"defaultDepartureTask"+"}", url.PathEscape(parameterValueToString(r.defaultDepartureTask, "defaultDepartureTask")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"guestRequested"+"}", url.PathEscape(parameterValueToString(r.guestRequested, "guestRequested")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.defaultDepartureTask) < 1 {
		return localVarReturnValue, nil, reportError("defaultDepartureTask must have at least 1 elements")
	}
	if strlen(r.defaultDepartureTask) > 2000 {
		return localVarReturnValue, nil, reportError("defaultDepartureTask must have less than 2000 elements")
	}
	if strlen(r.guestRequested) < 1 {
		return localVarReturnValue, nil, reportError("guestRequested must have at least 1 elements")
	}
	if strlen(r.guestRequested) > 2000 {
		return localVarReturnValue, nil, reportError("guestRequested must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetFrequencyTypeLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	defaultDepartureTask string
	guestRequested string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetFrequencyTypeLOVRequest) Authorization(authorization string) LOVApiGetFrequencyTypeLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetFrequencyTypeLOVRequest) XAppKey(xAppKey string) LOVApiGetFrequencyTypeLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetFrequencyTypeLOVRequest) XHotelid(xHotelid string) LOVApiGetFrequencyTypeLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetFrequencyTypeLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetFrequencyTypeLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetFrequencyTypeLOVRequest) ParameterName(parameterName []string) LOVApiGetFrequencyTypeLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetFrequencyTypeLOVRequest) ParameterValue(parameterValue []string) LOVApiGetFrequencyTypeLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetFrequencyTypeLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetFrequencyTypeLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetFrequencyTypeLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetFrequencyTypeLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetFrequencyTypeLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetFrequencyTypeLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetFrequencyTypeLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetFrequencyTypeLOVExecute(r)
}

/*
GetFrequencyTypeLOV Fetch List Of Values for Frequency Type

 <p><strong>OperationId:</strong>getFrequencyTypeLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param defaultDepartureTask Value of the parameter 'defaultDepartureTask' which is required to fetch FrequencyType LOV
 @param guestRequested Value of the parameter 'guestRequested' which is required to fetch FrequencyType LOV
 @return LOVApiGetFrequencyTypeLOVRequest
*/
func (a *LOVApiService) GetFrequencyTypeLOV(ctx context.Context, defaultDepartureTask string, guestRequested string) LOVApiGetFrequencyTypeLOVRequest {
	return LOVApiGetFrequencyTypeLOVRequest{
		ApiService: a,
		ctx: ctx,
		defaultDepartureTask: defaultDepartureTask,
		guestRequested: guestRequested,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetFrequencyTypeLOVExecute(r LOVApiGetFrequencyTypeLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetFrequencyTypeLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/guestRequested/{guestRequested}/defaultDepartureTask/{defaultDepartureTask}/frequencyType"
	localVarPath = strings.Replace(localVarPath, "{"+"defaultDepartureTask"+"}", url.PathEscape(parameterValueToString(r.defaultDepartureTask, "defaultDepartureTask")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"guestRequested"+"}", url.PathEscape(parameterValueToString(r.guestRequested, "guestRequested")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.defaultDepartureTask) < 1 {
		return localVarReturnValue, nil, reportError("defaultDepartureTask must have at least 1 elements")
	}
	if strlen(r.defaultDepartureTask) > 2000 {
		return localVarReturnValue, nil, reportError("defaultDepartureTask must have less than 2000 elements")
	}
	if strlen(r.guestRequested) < 1 {
		return localVarReturnValue, nil, reportError("guestRequested must have at least 1 elements")
	}
	if strlen(r.guestRequested) > 2000 {
		return localVarReturnValue, nil, reportError("guestRequested must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetFromRoomNumberLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetFromRoomNumberLOVRequest) Authorization(authorization string) LOVApiGetFromRoomNumberLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetFromRoomNumberLOVRequest) XAppKey(xAppKey string) LOVApiGetFromRoomNumberLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetFromRoomNumberLOVRequest) XHotelid(xHotelid string) LOVApiGetFromRoomNumberLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetFromRoomNumberLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetFromRoomNumberLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetFromRoomNumberLOVRequest) ParameterName(parameterName []string) LOVApiGetFromRoomNumberLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetFromRoomNumberLOVRequest) ParameterValue(parameterValue []string) LOVApiGetFromRoomNumberLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetFromRoomNumberLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetFromRoomNumberLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetFromRoomNumberLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetFromRoomNumberLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetFromRoomNumberLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetFromRoomNumberLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetFromRoomNumberLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetFromRoomNumberLOVExecute(r)
}

/*
GetFromRoomNumberLOV Fetch List Of Values for From Room Number

 <p><strong>OperationId:</strong>getFromRoomNumberLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch FromRoomNumber LOV
 @return LOVApiGetFromRoomNumberLOVRequest
*/
func (a *LOVApiService) GetFromRoomNumberLOV(ctx context.Context, hotelId string) LOVApiGetFromRoomNumberLOVRequest {
	return LOVApiGetFromRoomNumberLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetFromRoomNumberLOVExecute(r LOVApiGetFromRoomNumberLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetFromRoomNumberLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/fromRoomNumber"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetGdsConvAmenityCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	bookingChannelCodes string
	featureType string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetGdsConvAmenityCodesLOVRequest) Authorization(authorization string) LOVApiGetGdsConvAmenityCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetGdsConvAmenityCodesLOVRequest) XAppKey(xAppKey string) LOVApiGetGdsConvAmenityCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetGdsConvAmenityCodesLOVRequest) XHotelid(xHotelid string) LOVApiGetGdsConvAmenityCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetGdsConvAmenityCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetGdsConvAmenityCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetGdsConvAmenityCodesLOVRequest) ParameterName(parameterName []string) LOVApiGetGdsConvAmenityCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetGdsConvAmenityCodesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetGdsConvAmenityCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetGdsConvAmenityCodesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetGdsConvAmenityCodesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetGdsConvAmenityCodesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetGdsConvAmenityCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetGdsConvAmenityCodesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetGdsConvAmenityCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetGdsConvAmenityCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetGdsConvAmenityCodesLOVExecute(r)
}

/*
GetGdsConvAmenityCodesLOV Fetch List Of Values for Gds Conv Amenity Codes

 <p><strong>OperationId:</strong>getGdsConvAmenityCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bookingChannelCodes Value of the parameter 'bookingChannelCodes' which is required to fetch GdsConvAmenityCodes LOV
 @param featureType Value of the parameter 'featureType' which is required to fetch GdsConvAmenityCodes LOV
 @return LOVApiGetGdsConvAmenityCodesLOVRequest
*/
func (a *LOVApiService) GetGdsConvAmenityCodesLOV(ctx context.Context, bookingChannelCodes string, featureType string) LOVApiGetGdsConvAmenityCodesLOVRequest {
	return LOVApiGetGdsConvAmenityCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		bookingChannelCodes: bookingChannelCodes,
		featureType: featureType,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetGdsConvAmenityCodesLOVExecute(r LOVApiGetGdsConvAmenityCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetGdsConvAmenityCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/featureType/{featureType}/bookingChannels/{bookingChannelCodes}/gdsConvAmenityCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"bookingChannelCodes"+"}", url.PathEscape(parameterValueToString(r.bookingChannelCodes, "bookingChannelCodes")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"featureType"+"}", url.PathEscape(parameterValueToString(r.featureType, "featureType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.bookingChannelCodes) < 1 {
		return localVarReturnValue, nil, reportError("bookingChannelCodes must have at least 1 elements")
	}
	if strlen(r.bookingChannelCodes) > 2000 {
		return localVarReturnValue, nil, reportError("bookingChannelCodes must have less than 2000 elements")
	}
	if strlen(r.featureType) < 1 {
		return localVarReturnValue, nil, reportError("featureType must have at least 1 elements")
	}
	if strlen(r.featureType) > 2000 {
		return localVarReturnValue, nil, reportError("featureType must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetGdsGuaranteeCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	bookingChannelCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetGdsGuaranteeCodesLOVRequest) Authorization(authorization string) LOVApiGetGdsGuaranteeCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetGdsGuaranteeCodesLOVRequest) XAppKey(xAppKey string) LOVApiGetGdsGuaranteeCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetGdsGuaranteeCodesLOVRequest) XHotelid(xHotelid string) LOVApiGetGdsGuaranteeCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetGdsGuaranteeCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetGdsGuaranteeCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetGdsGuaranteeCodesLOVRequest) ParameterName(parameterName []string) LOVApiGetGdsGuaranteeCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetGdsGuaranteeCodesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetGdsGuaranteeCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetGdsGuaranteeCodesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetGdsGuaranteeCodesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetGdsGuaranteeCodesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetGdsGuaranteeCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetGdsGuaranteeCodesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetGdsGuaranteeCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetGdsGuaranteeCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetGdsGuaranteeCodesLOVExecute(r)
}

/*
GetGdsGuaranteeCodesLOV Fetch List Of Values for Gds Guarantee Codes

 <p><strong>OperationId:</strong>getGdsGuaranteeCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bookingChannelCode Value of the parameter 'bookingChannelCode' which is required to fetch GdsGuaranteeCodes LOV
 @return LOVApiGetGdsGuaranteeCodesLOVRequest
*/
func (a *LOVApiService) GetGdsGuaranteeCodesLOV(ctx context.Context, bookingChannelCode string) LOVApiGetGdsGuaranteeCodesLOVRequest {
	return LOVApiGetGdsGuaranteeCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		bookingChannelCode: bookingChannelCode,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetGdsGuaranteeCodesLOVExecute(r LOVApiGetGdsGuaranteeCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetGdsGuaranteeCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/bookingChannels/{bookingChannelCode}/gdsGuaranteeCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"bookingChannelCode"+"}", url.PathEscape(parameterValueToString(r.bookingChannelCode, "bookingChannelCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.bookingChannelCode) < 1 {
		return localVarReturnValue, nil, reportError("bookingChannelCode must have at least 1 elements")
	}
	if strlen(r.bookingChannelCode) > 2000 {
		return localVarReturnValue, nil, reportError("bookingChannelCode must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetGdsHotelsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	channelType string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetGdsHotelsLOVRequest) Authorization(authorization string) LOVApiGetGdsHotelsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetGdsHotelsLOVRequest) XAppKey(xAppKey string) LOVApiGetGdsHotelsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetGdsHotelsLOVRequest) XHotelid(xHotelid string) LOVApiGetGdsHotelsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetGdsHotelsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetGdsHotelsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetGdsHotelsLOVRequest) ParameterName(parameterName []string) LOVApiGetGdsHotelsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetGdsHotelsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetGdsHotelsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetGdsHotelsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetGdsHotelsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetGdsHotelsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetGdsHotelsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetGdsHotelsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetGdsHotelsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetGdsHotelsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetGdsHotelsLOVExecute(r)
}

/*
GetGdsHotelsLOV Fetch List Of Values for Gds Hotels

 <p><strong>OperationId:</strong>getGdsHotelsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param channelType Value of the parameter 'channelType' which is required to fetch GdsHotels LOV
 @return LOVApiGetGdsHotelsLOVRequest
*/
func (a *LOVApiService) GetGdsHotelsLOV(ctx context.Context, channelType string) LOVApiGetGdsHotelsLOVRequest {
	return LOVApiGetGdsHotelsLOVRequest{
		ApiService: a,
		ctx: ctx,
		channelType: channelType,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetGdsHotelsLOVExecute(r LOVApiGetGdsHotelsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetGdsHotelsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/channelType/{channelType}/gdsHotels"
	localVarPath = strings.Replace(localVarPath, "{"+"channelType"+"}", url.PathEscape(parameterValueToString(r.channelType, "channelType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.channelType) < 1 {
		return localVarReturnValue, nil, reportError("channelType must have at least 1 elements")
	}
	if strlen(r.channelType) > 2000 {
		return localVarReturnValue, nil, reportError("channelType must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetGdsRateCategoriesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	bookingChannelCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetGdsRateCategoriesLOVRequest) Authorization(authorization string) LOVApiGetGdsRateCategoriesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetGdsRateCategoriesLOVRequest) XAppKey(xAppKey string) LOVApiGetGdsRateCategoriesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetGdsRateCategoriesLOVRequest) XHotelid(xHotelid string) LOVApiGetGdsRateCategoriesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetGdsRateCategoriesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetGdsRateCategoriesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetGdsRateCategoriesLOVRequest) ParameterName(parameterName []string) LOVApiGetGdsRateCategoriesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetGdsRateCategoriesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetGdsRateCategoriesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetGdsRateCategoriesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetGdsRateCategoriesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetGdsRateCategoriesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetGdsRateCategoriesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetGdsRateCategoriesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetGdsRateCategoriesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetGdsRateCategoriesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetGdsRateCategoriesLOVExecute(r)
}

/*
GetGdsRateCategoriesLOV Fetch List Of Values for Gds Rate Categories

 <p><strong>OperationId:</strong>getGdsRateCategoriesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bookingChannelCode Value of the parameter 'bookingChannelCode' which is required to fetch GdsRateCategories LOV
 @return LOVApiGetGdsRateCategoriesLOVRequest
*/
func (a *LOVApiService) GetGdsRateCategoriesLOV(ctx context.Context, bookingChannelCode string) LOVApiGetGdsRateCategoriesLOVRequest {
	return LOVApiGetGdsRateCategoriesLOVRequest{
		ApiService: a,
		ctx: ctx,
		bookingChannelCode: bookingChannelCode,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetGdsRateCategoriesLOVExecute(r LOVApiGetGdsRateCategoriesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetGdsRateCategoriesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/bookingChannels/{bookingChannelCode}/gdsRateCategories"
	localVarPath = strings.Replace(localVarPath, "{"+"bookingChannelCode"+"}", url.PathEscape(parameterValueToString(r.bookingChannelCode, "bookingChannelCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.bookingChannelCode) < 1 {
		return localVarReturnValue, nil, reportError("bookingChannelCode must have at least 1 elements")
	}
	if strlen(r.bookingChannelCode) > 2000 {
		return localVarReturnValue, nil, reportError("bookingChannelCode must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetGdsRateLevelsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	bookingChannelCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetGdsRateLevelsLOVRequest) Authorization(authorization string) LOVApiGetGdsRateLevelsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetGdsRateLevelsLOVRequest) XAppKey(xAppKey string) LOVApiGetGdsRateLevelsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetGdsRateLevelsLOVRequest) XHotelid(xHotelid string) LOVApiGetGdsRateLevelsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetGdsRateLevelsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetGdsRateLevelsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetGdsRateLevelsLOVRequest) ParameterName(parameterName []string) LOVApiGetGdsRateLevelsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetGdsRateLevelsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetGdsRateLevelsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetGdsRateLevelsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetGdsRateLevelsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetGdsRateLevelsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetGdsRateLevelsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetGdsRateLevelsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetGdsRateLevelsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetGdsRateLevelsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetGdsRateLevelsLOVExecute(r)
}

/*
GetGdsRateLevelsLOV Fetch List Of Values for Gds Rate Levels

 <p><strong>OperationId:</strong>getGdsRateLevelsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bookingChannelCode Value of the parameter 'bookingChannelCode' which is required to fetch GdsRateLevels LOV
 @return LOVApiGetGdsRateLevelsLOVRequest
*/
func (a *LOVApiService) GetGdsRateLevelsLOV(ctx context.Context, bookingChannelCode string) LOVApiGetGdsRateLevelsLOVRequest {
	return LOVApiGetGdsRateLevelsLOVRequest{
		ApiService: a,
		ctx: ctx,
		bookingChannelCode: bookingChannelCode,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetGdsRateLevelsLOVExecute(r LOVApiGetGdsRateLevelsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetGdsRateLevelsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/bookingChannels/{bookingChannelCode}/gdsRateLevels"
	localVarPath = strings.Replace(localVarPath, "{"+"bookingChannelCode"+"}", url.PathEscape(parameterValueToString(r.bookingChannelCode, "bookingChannelCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.bookingChannelCode) < 1 {
		return localVarReturnValue, nil, reportError("bookingChannelCode must have at least 1 elements")
	}
	if strlen(r.bookingChannelCode) > 2000 {
		return localVarReturnValue, nil, reportError("bookingChannelCode must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetGdsRoomCategoryTemplatesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	bookingChannelCodes string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetGdsRoomCategoryTemplatesLOVRequest) Authorization(authorization string) LOVApiGetGdsRoomCategoryTemplatesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetGdsRoomCategoryTemplatesLOVRequest) XAppKey(xAppKey string) LOVApiGetGdsRoomCategoryTemplatesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetGdsRoomCategoryTemplatesLOVRequest) XHotelid(xHotelid string) LOVApiGetGdsRoomCategoryTemplatesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetGdsRoomCategoryTemplatesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetGdsRoomCategoryTemplatesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetGdsRoomCategoryTemplatesLOVRequest) ParameterName(parameterName []string) LOVApiGetGdsRoomCategoryTemplatesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetGdsRoomCategoryTemplatesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetGdsRoomCategoryTemplatesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetGdsRoomCategoryTemplatesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetGdsRoomCategoryTemplatesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetGdsRoomCategoryTemplatesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetGdsRoomCategoryTemplatesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetGdsRoomCategoryTemplatesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetGdsRoomCategoryTemplatesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetGdsRoomCategoryTemplatesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetGdsRoomCategoryTemplatesLOVExecute(r)
}

/*
GetGdsRoomCategoryTemplatesLOV Fetch List Of Values for Gds Room Category Templates

 <p><strong>OperationId:</strong>getGdsRoomCategoryTemplatesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bookingChannelCodes Value of the parameter 'bookingChannelCodes' which is required to fetch GdsRoomCategoryTemplates LOV
 @return LOVApiGetGdsRoomCategoryTemplatesLOVRequest
*/
func (a *LOVApiService) GetGdsRoomCategoryTemplatesLOV(ctx context.Context, bookingChannelCodes string) LOVApiGetGdsRoomCategoryTemplatesLOVRequest {
	return LOVApiGetGdsRoomCategoryTemplatesLOVRequest{
		ApiService: a,
		ctx: ctx,
		bookingChannelCodes: bookingChannelCodes,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetGdsRoomCategoryTemplatesLOVExecute(r LOVApiGetGdsRoomCategoryTemplatesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetGdsRoomCategoryTemplatesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/bookingChannels/{bookingChannelCodes}/gdsRoomCategoryTemplates"
	localVarPath = strings.Replace(localVarPath, "{"+"bookingChannelCodes"+"}", url.PathEscape(parameterValueToString(r.bookingChannelCodes, "bookingChannelCodes")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.bookingChannelCodes) < 1 {
		return localVarReturnValue, nil, reportError("bookingChannelCodes must have at least 1 elements")
	}
	if strlen(r.bookingChannelCodes) > 2000 {
		return localVarReturnValue, nil, reportError("bookingChannelCodes must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetGemMenuItemsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetGemMenuItemsLOVRequest) Authorization(authorization string) LOVApiGetGemMenuItemsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetGemMenuItemsLOVRequest) XAppKey(xAppKey string) LOVApiGetGemMenuItemsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetGemMenuItemsLOVRequest) XHotelid(xHotelid string) LOVApiGetGemMenuItemsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetGemMenuItemsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetGemMenuItemsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetGemMenuItemsLOVRequest) ParameterName(parameterName []string) LOVApiGetGemMenuItemsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetGemMenuItemsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetGemMenuItemsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetGemMenuItemsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetGemMenuItemsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetGemMenuItemsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetGemMenuItemsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetGemMenuItemsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetGemMenuItemsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetGemMenuItemsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetGemMenuItemsLOVExecute(r)
}

/*
GetGemMenuItemsLOV Fetch List Of Values for Gem Menu Items

 <p><strong>OperationId:</strong>getGemMenuItemsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch GemMenuItems LOV
 @return LOVApiGetGemMenuItemsLOVRequest
*/
func (a *LOVApiService) GetGemMenuItemsLOV(ctx context.Context, hotelId string) LOVApiGetGemMenuItemsLOVRequest {
	return LOVApiGetGemMenuItemsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetGemMenuItemsLOVExecute(r LOVApiGetGemMenuItemsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetGemMenuItemsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/gemMenuItems"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetGenericReportsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetGenericReportsLOVRequest) Authorization(authorization string) LOVApiGetGenericReportsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetGenericReportsLOVRequest) XAppKey(xAppKey string) LOVApiGetGenericReportsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetGenericReportsLOVRequest) XHotelid(xHotelid string) LOVApiGetGenericReportsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetGenericReportsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetGenericReportsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetGenericReportsLOVRequest) ParameterName(parameterName []string) LOVApiGetGenericReportsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetGenericReportsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetGenericReportsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetGenericReportsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetGenericReportsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetGenericReportsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetGenericReportsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetGenericReportsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetGenericReportsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetGenericReportsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetGenericReportsLOVExecute(r)
}

/*
GetGenericReportsLOV Fetch List Of Values for Generic Reports

 <p><strong>OperationId:</strong>getGenericReportsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch GenericReports LOV
 @return LOVApiGetGenericReportsLOVRequest
*/
func (a *LOVApiService) GetGenericReportsLOV(ctx context.Context, hotelId string) LOVApiGetGenericReportsLOVRequest {
	return LOVApiGetGenericReportsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetGenericReportsLOVExecute(r LOVApiGetGenericReportsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetGenericReportsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/genericReports"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetGlobalAlertFieldQueryLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	sourceId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetGlobalAlertFieldQueryLOVRequest) Authorization(authorization string) LOVApiGetGlobalAlertFieldQueryLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetGlobalAlertFieldQueryLOVRequest) XAppKey(xAppKey string) LOVApiGetGlobalAlertFieldQueryLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetGlobalAlertFieldQueryLOVRequest) XHotelid(xHotelid string) LOVApiGetGlobalAlertFieldQueryLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetGlobalAlertFieldQueryLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetGlobalAlertFieldQueryLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetGlobalAlertFieldQueryLOVRequest) ParameterName(parameterName []string) LOVApiGetGlobalAlertFieldQueryLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetGlobalAlertFieldQueryLOVRequest) ParameterValue(parameterValue []string) LOVApiGetGlobalAlertFieldQueryLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetGlobalAlertFieldQueryLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetGlobalAlertFieldQueryLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetGlobalAlertFieldQueryLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetGlobalAlertFieldQueryLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetGlobalAlertFieldQueryLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetGlobalAlertFieldQueryLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetGlobalAlertFieldQueryLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetGlobalAlertFieldQueryLOVExecute(r)
}

/*
GetGlobalAlertFieldQueryLOV Fetch List Of Values for Global Alert Field Query

 <p><strong>OperationId:</strong>getGlobalAlertFieldQueryLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sourceId Value of the parameter 'sourceId' which is required to fetch GlobalAlertFieldQuery LOV
 @return LOVApiGetGlobalAlertFieldQueryLOVRequest
*/
func (a *LOVApiService) GetGlobalAlertFieldQueryLOV(ctx context.Context, sourceId string) LOVApiGetGlobalAlertFieldQueryLOVRequest {
	return LOVApiGetGlobalAlertFieldQueryLOVRequest{
		ApiService: a,
		ctx: ctx,
		sourceId: sourceId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetGlobalAlertFieldQueryLOVExecute(r LOVApiGetGlobalAlertFieldQueryLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetGlobalAlertFieldQueryLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/sourceId/{sourceId}/globalAlertFieldQuery"
	localVarPath = strings.Replace(localVarPath, "{"+"sourceId"+"}", url.PathEscape(parameterValueToString(r.sourceId, "sourceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.sourceId) < 1 {
		return localVarReturnValue, nil, reportError("sourceId must have at least 1 elements")
	}
	if strlen(r.sourceId) > 2000 {
		return localVarReturnValue, nil, reportError("sourceId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetGlobalAlertFunctionLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	fieldType string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetGlobalAlertFunctionLOVRequest) Authorization(authorization string) LOVApiGetGlobalAlertFunctionLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetGlobalAlertFunctionLOVRequest) XAppKey(xAppKey string) LOVApiGetGlobalAlertFunctionLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetGlobalAlertFunctionLOVRequest) XHotelid(xHotelid string) LOVApiGetGlobalAlertFunctionLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetGlobalAlertFunctionLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetGlobalAlertFunctionLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetGlobalAlertFunctionLOVRequest) ParameterName(parameterName []string) LOVApiGetGlobalAlertFunctionLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetGlobalAlertFunctionLOVRequest) ParameterValue(parameterValue []string) LOVApiGetGlobalAlertFunctionLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetGlobalAlertFunctionLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetGlobalAlertFunctionLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetGlobalAlertFunctionLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetGlobalAlertFunctionLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetGlobalAlertFunctionLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetGlobalAlertFunctionLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetGlobalAlertFunctionLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetGlobalAlertFunctionLOVExecute(r)
}

/*
GetGlobalAlertFunctionLOV Fetch List Of Values for Global Alert Function

 <p><strong>OperationId:</strong>getGlobalAlertFunctionLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fieldType Value of the parameter 'fieldType' which is required to fetch GlobalAlertFunction LOV
 @return LOVApiGetGlobalAlertFunctionLOVRequest
*/
func (a *LOVApiService) GetGlobalAlertFunctionLOV(ctx context.Context, fieldType string) LOVApiGetGlobalAlertFunctionLOVRequest {
	return LOVApiGetGlobalAlertFunctionLOVRequest{
		ApiService: a,
		ctx: ctx,
		fieldType: fieldType,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetGlobalAlertFunctionLOVExecute(r LOVApiGetGlobalAlertFunctionLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetGlobalAlertFunctionLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/fieldType/{fieldType}/globalAlertFunction"
	localVarPath = strings.Replace(localVarPath, "{"+"fieldType"+"}", url.PathEscape(parameterValueToString(r.fieldType, "fieldType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.fieldType) < 1 {
		return localVarReturnValue, nil, reportError("fieldType must have at least 1 elements")
	}
	if strlen(r.fieldType) > 2000 {
		return localVarReturnValue, nil, reportError("fieldType must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetGlobalAlertOperatorLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	tableName string
	fieldName string
	fieldType string
	sourceIdIn string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetGlobalAlertOperatorLOVRequest) Authorization(authorization string) LOVApiGetGlobalAlertOperatorLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetGlobalAlertOperatorLOVRequest) XAppKey(xAppKey string) LOVApiGetGlobalAlertOperatorLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetGlobalAlertOperatorLOVRequest) XHotelid(xHotelid string) LOVApiGetGlobalAlertOperatorLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetGlobalAlertOperatorLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetGlobalAlertOperatorLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetGlobalAlertOperatorLOVRequest) ParameterName(parameterName []string) LOVApiGetGlobalAlertOperatorLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetGlobalAlertOperatorLOVRequest) ParameterValue(parameterValue []string) LOVApiGetGlobalAlertOperatorLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetGlobalAlertOperatorLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetGlobalAlertOperatorLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetGlobalAlertOperatorLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetGlobalAlertOperatorLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetGlobalAlertOperatorLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetGlobalAlertOperatorLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetGlobalAlertOperatorLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetGlobalAlertOperatorLOVExecute(r)
}

/*
GetGlobalAlertOperatorLOV Fetch List Of Values for Global Alert Operator

 <p><strong>OperationId:</strong>getGlobalAlertOperatorLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tableName Value of the parameter 'tableName' which is required to fetch GlobalAlertOperator LOV
 @param fieldName Value of the parameter 'fieldName' which is required to fetch GlobalAlertOperator LOV
 @param fieldType Value of the parameter 'fieldType' which is required to fetch GlobalAlertOperator LOV
 @param sourceIdIn Value of the parameter 'sourceIdIn' which is required to fetch GlobalAlertOperator LOV
 @return LOVApiGetGlobalAlertOperatorLOVRequest
*/
func (a *LOVApiService) GetGlobalAlertOperatorLOV(ctx context.Context, tableName string, fieldName string, fieldType string, sourceIdIn string) LOVApiGetGlobalAlertOperatorLOVRequest {
	return LOVApiGetGlobalAlertOperatorLOVRequest{
		ApiService: a,
		ctx: ctx,
		tableName: tableName,
		fieldName: fieldName,
		fieldType: fieldType,
		sourceIdIn: sourceIdIn,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetGlobalAlertOperatorLOVExecute(r LOVApiGetGlobalAlertOperatorLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetGlobalAlertOperatorLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/sourceIdIn/{sourceIdIn}/fieldType/{fieldType}/fieldName/{fieldName}/tableName/{tableName}/globalAlertOperator"
	localVarPath = strings.Replace(localVarPath, "{"+"tableName"+"}", url.PathEscape(parameterValueToString(r.tableName, "tableName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"fieldName"+"}", url.PathEscape(parameterValueToString(r.fieldName, "fieldName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"fieldType"+"}", url.PathEscape(parameterValueToString(r.fieldType, "fieldType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sourceIdIn"+"}", url.PathEscape(parameterValueToString(r.sourceIdIn, "sourceIdIn")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.tableName) < 1 {
		return localVarReturnValue, nil, reportError("tableName must have at least 1 elements")
	}
	if strlen(r.tableName) > 2000 {
		return localVarReturnValue, nil, reportError("tableName must have less than 2000 elements")
	}
	if strlen(r.fieldName) < 1 {
		return localVarReturnValue, nil, reportError("fieldName must have at least 1 elements")
	}
	if strlen(r.fieldName) > 2000 {
		return localVarReturnValue, nil, reportError("fieldName must have less than 2000 elements")
	}
	if strlen(r.fieldType) < 1 {
		return localVarReturnValue, nil, reportError("fieldType must have at least 1 elements")
	}
	if strlen(r.fieldType) > 2000 {
		return localVarReturnValue, nil, reportError("fieldType must have less than 2000 elements")
	}
	if strlen(r.sourceIdIn) < 1 {
		return localVarReturnValue, nil, reportError("sourceIdIn must have at least 1 elements")
	}
	if strlen(r.sourceIdIn) > 2000 {
		return localVarReturnValue, nil, reportError("sourceIdIn must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetGridTypesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	bookingStatus string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetGridTypesLOVRequest) Authorization(authorization string) LOVApiGetGridTypesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetGridTypesLOVRequest) XAppKey(xAppKey string) LOVApiGetGridTypesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetGridTypesLOVRequest) XHotelid(xHotelid string) LOVApiGetGridTypesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetGridTypesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetGridTypesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetGridTypesLOVRequest) ParameterName(parameterName []string) LOVApiGetGridTypesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetGridTypesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetGridTypesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetGridTypesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetGridTypesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetGridTypesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetGridTypesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetGridTypesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetGridTypesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetGridTypesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetGridTypesLOVExecute(r)
}

/*
GetGridTypesLOV Fetch List Of Values for Grid Types

 <p><strong>OperationId:</strong>getGridTypesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bookingStatus Value of the parameter 'bookingStatus' which is required to fetch GridTypes LOV
 @return LOVApiGetGridTypesLOVRequest
*/
func (a *LOVApiService) GetGridTypesLOV(ctx context.Context, bookingStatus string) LOVApiGetGridTypesLOVRequest {
	return LOVApiGetGridTypesLOVRequest{
		ApiService: a,
		ctx: ctx,
		bookingStatus: bookingStatus,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetGridTypesLOVExecute(r LOVApiGetGridTypesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetGridTypesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/bookingStatus/{bookingStatus}/gridTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"bookingStatus"+"}", url.PathEscape(parameterValueToString(r.bookingStatus, "bookingStatus")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.bookingStatus) < 1 {
		return localVarReturnValue, nil, reportError("bookingStatus must have at least 1 elements")
	}
	if strlen(r.bookingStatus) > 2000 {
		return localVarReturnValue, nil, reportError("bookingStatus must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetGroupArrivalsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetGroupArrivalsLOVRequest) Authorization(authorization string) LOVApiGetGroupArrivalsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetGroupArrivalsLOVRequest) XAppKey(xAppKey string) LOVApiGetGroupArrivalsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetGroupArrivalsLOVRequest) XHotelid(xHotelid string) LOVApiGetGroupArrivalsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetGroupArrivalsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetGroupArrivalsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetGroupArrivalsLOVRequest) ParameterName(parameterName []string) LOVApiGetGroupArrivalsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetGroupArrivalsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetGroupArrivalsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetGroupArrivalsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetGroupArrivalsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetGroupArrivalsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetGroupArrivalsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetGroupArrivalsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetGroupArrivalsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetGroupArrivalsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetGroupArrivalsLOVExecute(r)
}

/*
GetGroupArrivalsLOV Fetch List Of Values for Group Arrivals

 <p><strong>OperationId:</strong>getGroupArrivalsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch GroupArrivals LOV
 @return LOVApiGetGroupArrivalsLOVRequest
*/
func (a *LOVApiService) GetGroupArrivalsLOV(ctx context.Context, hotelId string) LOVApiGetGroupArrivalsLOVRequest {
	return LOVApiGetGroupArrivalsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetGroupArrivalsLOVExecute(r LOVApiGetGroupArrivalsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetGroupArrivalsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/groupArrivals"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetGroupsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetGroupsLOVRequest) Authorization(authorization string) LOVApiGetGroupsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetGroupsLOVRequest) XAppKey(xAppKey string) LOVApiGetGroupsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetGroupsLOVRequest) XHotelid(xHotelid string) LOVApiGetGroupsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetGroupsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetGroupsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetGroupsLOVRequest) ParameterName(parameterName []string) LOVApiGetGroupsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetGroupsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetGroupsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetGroupsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetGroupsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetGroupsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetGroupsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetGroupsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetGroupsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetGroupsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetGroupsLOVExecute(r)
}

/*
GetGroupsLOV Fetch List Of Values for Groups

 <p><strong>OperationId:</strong>getGroupsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch Groups LOV
 @return LOVApiGetGroupsLOVRequest
*/
func (a *LOVApiService) GetGroupsLOV(ctx context.Context, hotelId string) LOVApiGetGroupsLOVRequest {
	return LOVApiGetGroupsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetGroupsLOVExecute(r LOVApiGetGroupsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetGroupsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/groups"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetGuestMessagesMultiHotelLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetGuestMessagesMultiHotelLOVRequest) Authorization(authorization string) LOVApiGetGuestMessagesMultiHotelLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetGuestMessagesMultiHotelLOVRequest) XAppKey(xAppKey string) LOVApiGetGuestMessagesMultiHotelLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetGuestMessagesMultiHotelLOVRequest) XHotelid(xHotelid string) LOVApiGetGuestMessagesMultiHotelLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetGuestMessagesMultiHotelLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetGuestMessagesMultiHotelLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetGuestMessagesMultiHotelLOVRequest) ParameterName(parameterName []string) LOVApiGetGuestMessagesMultiHotelLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetGuestMessagesMultiHotelLOVRequest) ParameterValue(parameterValue []string) LOVApiGetGuestMessagesMultiHotelLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetGuestMessagesMultiHotelLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetGuestMessagesMultiHotelLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetGuestMessagesMultiHotelLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetGuestMessagesMultiHotelLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetGuestMessagesMultiHotelLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetGuestMessagesMultiHotelLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetGuestMessagesMultiHotelLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetGuestMessagesMultiHotelLOVExecute(r)
}

/*
GetGuestMessagesMultiHotelLOV Fetch List Of Values for Guest Messages Multi Hotel

 <p><strong>OperationId:</strong>getGuestMessagesMultiHotelLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch GuestMessagesMultiHotel LOV
 @return LOVApiGetGuestMessagesMultiHotelLOVRequest
*/
func (a *LOVApiService) GetGuestMessagesMultiHotelLOV(ctx context.Context, hotelId string) LOVApiGetGuestMessagesMultiHotelLOVRequest {
	return LOVApiGetGuestMessagesMultiHotelLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetGuestMessagesMultiHotelLOVExecute(r LOVApiGetGuestMessagesMultiHotelLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetGuestMessagesMultiHotelLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/guestMessagesMultiHotel"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetGuestMessagesQuickTextsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetGuestMessagesQuickTextsLOVRequest) Authorization(authorization string) LOVApiGetGuestMessagesQuickTextsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetGuestMessagesQuickTextsLOVRequest) XAppKey(xAppKey string) LOVApiGetGuestMessagesQuickTextsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetGuestMessagesQuickTextsLOVRequest) XHotelid(xHotelid string) LOVApiGetGuestMessagesQuickTextsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetGuestMessagesQuickTextsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetGuestMessagesQuickTextsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetGuestMessagesQuickTextsLOVRequest) ParameterName(parameterName []string) LOVApiGetGuestMessagesQuickTextsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetGuestMessagesQuickTextsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetGuestMessagesQuickTextsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetGuestMessagesQuickTextsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetGuestMessagesQuickTextsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetGuestMessagesQuickTextsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetGuestMessagesQuickTextsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetGuestMessagesQuickTextsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetGuestMessagesQuickTextsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetGuestMessagesQuickTextsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetGuestMessagesQuickTextsLOVExecute(r)
}

/*
GetGuestMessagesQuickTextsLOV Fetch List Of Values for Guest Messages Quick Texts

 <p><strong>OperationId:</strong>getGuestMessagesQuickTextsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch GuestMessagesQuickTexts LOV
 @return LOVApiGetGuestMessagesQuickTextsLOVRequest
*/
func (a *LOVApiService) GetGuestMessagesQuickTextsLOV(ctx context.Context, hotelId string) LOVApiGetGuestMessagesQuickTextsLOVRequest {
	return LOVApiGetGuestMessagesQuickTextsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetGuestMessagesQuickTextsLOVExecute(r LOVApiGetGuestMessagesQuickTextsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetGuestMessagesQuickTextsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/guestMessagesQuickTexts"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetHKAttendantsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetHKAttendantsLOVRequest) Authorization(authorization string) LOVApiGetHKAttendantsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetHKAttendantsLOVRequest) XAppKey(xAppKey string) LOVApiGetHKAttendantsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetHKAttendantsLOVRequest) XHotelid(xHotelid string) LOVApiGetHKAttendantsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetHKAttendantsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetHKAttendantsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetHKAttendantsLOVRequest) ParameterName(parameterName []string) LOVApiGetHKAttendantsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetHKAttendantsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetHKAttendantsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetHKAttendantsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetHKAttendantsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetHKAttendantsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetHKAttendantsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetHKAttendantsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetHKAttendantsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetHKAttendantsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetHKAttendantsLOVExecute(r)
}

/*
GetHKAttendantsLOV Fetch List Of Values for HKAttendants

 <p><strong>OperationId:</strong>getHKAttendantsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch HKAttendants LOV
 @return LOVApiGetHKAttendantsLOVRequest
*/
func (a *LOVApiService) GetHKAttendantsLOV(ctx context.Context, hotelId string) LOVApiGetHKAttendantsLOVRequest {
	return LOVApiGetHKAttendantsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetHKAttendantsLOVExecute(r LOVApiGetHKAttendantsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetHKAttendantsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/hkAttendants"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetHKAttendantsMobileLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetHKAttendantsMobileLOVRequest) Authorization(authorization string) LOVApiGetHKAttendantsMobileLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetHKAttendantsMobileLOVRequest) XAppKey(xAppKey string) LOVApiGetHKAttendantsMobileLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetHKAttendantsMobileLOVRequest) XHotelid(xHotelid string) LOVApiGetHKAttendantsMobileLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetHKAttendantsMobileLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetHKAttendantsMobileLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetHKAttendantsMobileLOVRequest) ParameterName(parameterName []string) LOVApiGetHKAttendantsMobileLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetHKAttendantsMobileLOVRequest) ParameterValue(parameterValue []string) LOVApiGetHKAttendantsMobileLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetHKAttendantsMobileLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetHKAttendantsMobileLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetHKAttendantsMobileLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetHKAttendantsMobileLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetHKAttendantsMobileLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetHKAttendantsMobileLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetHKAttendantsMobileLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetHKAttendantsMobileLOVExecute(r)
}

/*
GetHKAttendantsMobileLOV Fetch List Of Values for HKAttendants Mobile

 <p><strong>OperationId:</strong>getHKAttendantsMobileLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch HKAttendantsMobile LOV
 @return LOVApiGetHKAttendantsMobileLOVRequest
*/
func (a *LOVApiService) GetHKAttendantsMobileLOV(ctx context.Context, hotelId string) LOVApiGetHKAttendantsMobileLOVRequest {
	return LOVApiGetHKAttendantsMobileLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetHKAttendantsMobileLOVExecute(r LOVApiGetHKAttendantsMobileLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetHKAttendantsMobileLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/hkAttendantsMobile"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetHKScheduledAttendantsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	businessDate string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetHKScheduledAttendantsLOVRequest) Authorization(authorization string) LOVApiGetHKScheduledAttendantsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetHKScheduledAttendantsLOVRequest) XAppKey(xAppKey string) LOVApiGetHKScheduledAttendantsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetHKScheduledAttendantsLOVRequest) XHotelid(xHotelid string) LOVApiGetHKScheduledAttendantsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetHKScheduledAttendantsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetHKScheduledAttendantsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetHKScheduledAttendantsLOVRequest) ParameterName(parameterName []string) LOVApiGetHKScheduledAttendantsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetHKScheduledAttendantsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetHKScheduledAttendantsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetHKScheduledAttendantsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetHKScheduledAttendantsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetHKScheduledAttendantsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetHKScheduledAttendantsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetHKScheduledAttendantsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetHKScheduledAttendantsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetHKScheduledAttendantsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetHKScheduledAttendantsLOVExecute(r)
}

/*
GetHKScheduledAttendantsLOV Fetch List Of Values for HKScheduled Attendants

 <p><strong>OperationId:</strong>getHKScheduledAttendantsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param businessDate Value of the parameter 'businessDate' which is required to fetch HKScheduledAttendants LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch HKScheduledAttendants LOV
 @return LOVApiGetHKScheduledAttendantsLOVRequest
*/
func (a *LOVApiService) GetHKScheduledAttendantsLOV(ctx context.Context, businessDate string, hotelId string) LOVApiGetHKScheduledAttendantsLOVRequest {
	return LOVApiGetHKScheduledAttendantsLOVRequest{
		ApiService: a,
		ctx: ctx,
		businessDate: businessDate,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetHKScheduledAttendantsLOVExecute(r LOVApiGetHKScheduledAttendantsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetHKScheduledAttendantsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/businessDate/{businessDate}/hkScheduledAttendants"
	localVarPath = strings.Replace(localVarPath, "{"+"businessDate"+"}", url.PathEscape(parameterValueToString(r.businessDate, "businessDate")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.businessDate) < 1 {
		return localVarReturnValue, nil, reportError("businessDate must have at least 1 elements")
	}
	if strlen(r.businessDate) > 2000 {
		return localVarReturnValue, nil, reportError("businessDate must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetHKTaskBreakOutLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetHKTaskBreakOutLOVRequest) Authorization(authorization string) LOVApiGetHKTaskBreakOutLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetHKTaskBreakOutLOVRequest) XAppKey(xAppKey string) LOVApiGetHKTaskBreakOutLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetHKTaskBreakOutLOVRequest) XHotelid(xHotelid string) LOVApiGetHKTaskBreakOutLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetHKTaskBreakOutLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetHKTaskBreakOutLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetHKTaskBreakOutLOVRequest) ParameterName(parameterName []string) LOVApiGetHKTaskBreakOutLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetHKTaskBreakOutLOVRequest) ParameterValue(parameterValue []string) LOVApiGetHKTaskBreakOutLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetHKTaskBreakOutLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetHKTaskBreakOutLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetHKTaskBreakOutLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetHKTaskBreakOutLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetHKTaskBreakOutLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetHKTaskBreakOutLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetHKTaskBreakOutLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetHKTaskBreakOutLOVExecute(r)
}

/*
GetHKTaskBreakOutLOV Fetch List Of Values for HKTask Break Out

 <p><strong>OperationId:</strong>getHKTaskBreakOutLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch HKTaskBreakOut LOV
 @return LOVApiGetHKTaskBreakOutLOVRequest
*/
func (a *LOVApiService) GetHKTaskBreakOutLOV(ctx context.Context, hotelId string) LOVApiGetHKTaskBreakOutLOVRequest {
	return LOVApiGetHKTaskBreakOutLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetHKTaskBreakOutLOVExecute(r LOVApiGetHKTaskBreakOutLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetHKTaskBreakOutLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/hkTaskBreakOut"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetHKTaskCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetHKTaskCodesLOVRequest) Authorization(authorization string) LOVApiGetHKTaskCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetHKTaskCodesLOVRequest) XAppKey(xAppKey string) LOVApiGetHKTaskCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetHKTaskCodesLOVRequest) XHotelid(xHotelid string) LOVApiGetHKTaskCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetHKTaskCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetHKTaskCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetHKTaskCodesLOVRequest) ParameterName(parameterName []string) LOVApiGetHKTaskCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetHKTaskCodesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetHKTaskCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetHKTaskCodesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetHKTaskCodesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetHKTaskCodesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetHKTaskCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetHKTaskCodesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetHKTaskCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetHKTaskCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetHKTaskCodesLOVExecute(r)
}

/*
GetHKTaskCodesLOV Fetch List Of Values for HKTask Codes

 <p><strong>OperationId:</strong>getHKTaskCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch HKTaskCodes LOV
 @return LOVApiGetHKTaskCodesLOVRequest
*/
func (a *LOVApiService) GetHKTaskCodesLOV(ctx context.Context, hotelId string) LOVApiGetHKTaskCodesLOVRequest {
	return LOVApiGetHKTaskCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetHKTaskCodesLOVExecute(r LOVApiGetHKTaskCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetHKTaskCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/hkTaskCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetHKTaskSheetsNoLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	breakOutId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetHKTaskSheetsNoLOVRequest) Authorization(authorization string) LOVApiGetHKTaskSheetsNoLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetHKTaskSheetsNoLOVRequest) XAppKey(xAppKey string) LOVApiGetHKTaskSheetsNoLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetHKTaskSheetsNoLOVRequest) XHotelid(xHotelid string) LOVApiGetHKTaskSheetsNoLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetHKTaskSheetsNoLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetHKTaskSheetsNoLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetHKTaskSheetsNoLOVRequest) ParameterName(parameterName []string) LOVApiGetHKTaskSheetsNoLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetHKTaskSheetsNoLOVRequest) ParameterValue(parameterValue []string) LOVApiGetHKTaskSheetsNoLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetHKTaskSheetsNoLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetHKTaskSheetsNoLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetHKTaskSheetsNoLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetHKTaskSheetsNoLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetHKTaskSheetsNoLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetHKTaskSheetsNoLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetHKTaskSheetsNoLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetHKTaskSheetsNoLOVExecute(r)
}

/*
GetHKTaskSheetsNoLOV Fetch List Of Values for HKTask Sheets No

 <p><strong>OperationId:</strong>getHKTaskSheetsNoLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param breakOutId Value of the parameter 'breakOutId' which is required to fetch HKTaskSheetsNo LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch HKTaskSheetsNo LOV
 @return LOVApiGetHKTaskSheetsNoLOVRequest
*/
func (a *LOVApiService) GetHKTaskSheetsNoLOV(ctx context.Context, breakOutId string, hotelId string) LOVApiGetHKTaskSheetsNoLOVRequest {
	return LOVApiGetHKTaskSheetsNoLOVRequest{
		ApiService: a,
		ctx: ctx,
		breakOutId: breakOutId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetHKTaskSheetsNoLOVExecute(r LOVApiGetHKTaskSheetsNoLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetHKTaskSheetsNoLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/breakOutId/{breakOutId}/hkTaskSheetsNo"
	localVarPath = strings.Replace(localVarPath, "{"+"breakOutId"+"}", url.PathEscape(parameterValueToString(r.breakOutId, "breakOutId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.breakOutId) < 1 {
		return localVarReturnValue, nil, reportError("breakOutId must have at least 1 elements")
	}
	if strlen(r.breakOutId) > 2000 {
		return localVarReturnValue, nil, reportError("breakOutId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetHKTaskTemplatesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetHKTaskTemplatesLOVRequest) Authorization(authorization string) LOVApiGetHKTaskTemplatesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetHKTaskTemplatesLOVRequest) XAppKey(xAppKey string) LOVApiGetHKTaskTemplatesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetHKTaskTemplatesLOVRequest) XHotelid(xHotelid string) LOVApiGetHKTaskTemplatesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetHKTaskTemplatesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetHKTaskTemplatesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetHKTaskTemplatesLOVRequest) ParameterName(parameterName []string) LOVApiGetHKTaskTemplatesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetHKTaskTemplatesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetHKTaskTemplatesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetHKTaskTemplatesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetHKTaskTemplatesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetHKTaskTemplatesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetHKTaskTemplatesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetHKTaskTemplatesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetHKTaskTemplatesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetHKTaskTemplatesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetHKTaskTemplatesLOVExecute(r)
}

/*
GetHKTaskTemplatesLOV Fetch List Of Values for HKTask Templates

 <p><strong>OperationId:</strong>getHKTaskTemplatesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch HKTaskTemplates LOV
 @return LOVApiGetHKTaskTemplatesLOVRequest
*/
func (a *LOVApiService) GetHKTaskTemplatesLOV(ctx context.Context, hotelId string) LOVApiGetHKTaskTemplatesLOVRequest {
	return LOVApiGetHKTaskTemplatesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetHKTaskTemplatesLOVExecute(r LOVApiGetHKTaskTemplatesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetHKTaskTemplatesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/hkTaskTemplates"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetHkFloorsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetHkFloorsLOVRequest) Authorization(authorization string) LOVApiGetHkFloorsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetHkFloorsLOVRequest) XAppKey(xAppKey string) LOVApiGetHkFloorsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetHkFloorsLOVRequest) XHotelid(xHotelid string) LOVApiGetHkFloorsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetHkFloorsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetHkFloorsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetHkFloorsLOVRequest) ParameterName(parameterName []string) LOVApiGetHkFloorsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetHkFloorsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetHkFloorsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetHkFloorsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetHkFloorsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetHkFloorsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetHkFloorsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetHkFloorsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetHkFloorsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetHkFloorsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetHkFloorsLOVExecute(r)
}

/*
GetHkFloorsLOV Fetch List Of Values for Hk Floors

 <p><strong>OperationId:</strong>getHkFloorsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch HkFloors LOV
 @return LOVApiGetHkFloorsLOVRequest
*/
func (a *LOVApiService) GetHkFloorsLOV(ctx context.Context, hotelId string) LOVApiGetHkFloorsLOVRequest {
	return LOVApiGetHkFloorsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetHkFloorsLOVExecute(r LOVApiGetHkFloorsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetHkFloorsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/hkFloors"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetHkRoomTypesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetHkRoomTypesLOVRequest) Authorization(authorization string) LOVApiGetHkRoomTypesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetHkRoomTypesLOVRequest) XAppKey(xAppKey string) LOVApiGetHkRoomTypesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetHkRoomTypesLOVRequest) XHotelid(xHotelid string) LOVApiGetHkRoomTypesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetHkRoomTypesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetHkRoomTypesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetHkRoomTypesLOVRequest) ParameterName(parameterName []string) LOVApiGetHkRoomTypesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetHkRoomTypesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetHkRoomTypesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetHkRoomTypesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetHkRoomTypesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetHkRoomTypesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetHkRoomTypesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetHkRoomTypesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetHkRoomTypesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetHkRoomTypesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetHkRoomTypesLOVExecute(r)
}

/*
GetHkRoomTypesLOV Fetch List Of Values for Hk Room Types

 <p><strong>OperationId:</strong>getHkRoomTypesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch HkRoomTypes LOV
 @return LOVApiGetHkRoomTypesLOVRequest
*/
func (a *LOVApiService) GetHkRoomTypesLOV(ctx context.Context, hotelId string) LOVApiGetHkRoomTypesLOVRequest {
	return LOVApiGetHkRoomTypesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetHkRoomTypesLOVExecute(r LOVApiGetHkRoomTypesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetHkRoomTypesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/hkRoomTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetHkRoomsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetHkRoomsLOVRequest) Authorization(authorization string) LOVApiGetHkRoomsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetHkRoomsLOVRequest) XAppKey(xAppKey string) LOVApiGetHkRoomsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetHkRoomsLOVRequest) XHotelid(xHotelid string) LOVApiGetHkRoomsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetHkRoomsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetHkRoomsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetHkRoomsLOVRequest) ParameterName(parameterName []string) LOVApiGetHkRoomsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetHkRoomsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetHkRoomsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetHkRoomsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetHkRoomsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetHkRoomsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetHkRoomsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetHkRoomsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetHkRoomsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetHkRoomsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetHkRoomsLOVExecute(r)
}

/*
GetHkRoomsLOV Fetch List Of Values for Hk Rooms

 <p><strong>OperationId:</strong>getHkRoomsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch HkRooms LOV
 @return LOVApiGetHkRoomsLOVRequest
*/
func (a *LOVApiService) GetHkRoomsLOV(ctx context.Context, hotelId string) LOVApiGetHkRoomsLOVRequest {
	return LOVApiGetHkRoomsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetHkRoomsLOVExecute(r LOVApiGetHkRoomsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetHkRoomsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/hkRooms"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetHotelContactCommMethodLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	contactType string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetHotelContactCommMethodLOVRequest) Authorization(authorization string) LOVApiGetHotelContactCommMethodLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetHotelContactCommMethodLOVRequest) XAppKey(xAppKey string) LOVApiGetHotelContactCommMethodLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetHotelContactCommMethodLOVRequest) XHotelid(xHotelid string) LOVApiGetHotelContactCommMethodLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetHotelContactCommMethodLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetHotelContactCommMethodLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetHotelContactCommMethodLOVRequest) ParameterName(parameterName []string) LOVApiGetHotelContactCommMethodLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetHotelContactCommMethodLOVRequest) ParameterValue(parameterValue []string) LOVApiGetHotelContactCommMethodLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetHotelContactCommMethodLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetHotelContactCommMethodLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetHotelContactCommMethodLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetHotelContactCommMethodLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetHotelContactCommMethodLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetHotelContactCommMethodLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetHotelContactCommMethodLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetHotelContactCommMethodLOVExecute(r)
}

/*
GetHotelContactCommMethodLOV Fetch List Of Values for Hotel Contact Comm Method

 <p><strong>OperationId:</strong>getHotelContactCommMethodLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contactType Value of the parameter 'contactType' which is required to fetch HotelContactCommMethod LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch HotelContactCommMethod LOV
 @return LOVApiGetHotelContactCommMethodLOVRequest
*/
func (a *LOVApiService) GetHotelContactCommMethodLOV(ctx context.Context, contactType string, hotelId string) LOVApiGetHotelContactCommMethodLOVRequest {
	return LOVApiGetHotelContactCommMethodLOVRequest{
		ApiService: a,
		ctx: ctx,
		contactType: contactType,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetHotelContactCommMethodLOVExecute(r LOVApiGetHotelContactCommMethodLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetHotelContactCommMethodLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/contactType/{contactType}/hotelContactCommMethod"
	localVarPath = strings.Replace(localVarPath, "{"+"contactType"+"}", url.PathEscape(parameterValueToString(r.contactType, "contactType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.contactType) < 1 {
		return localVarReturnValue, nil, reportError("contactType must have at least 1 elements")
	}
	if strlen(r.contactType) > 2000 {
		return localVarReturnValue, nil, reportError("contactType must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetHotelEventTypesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetHotelEventTypesLOVRequest) Authorization(authorization string) LOVApiGetHotelEventTypesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetHotelEventTypesLOVRequest) XAppKey(xAppKey string) LOVApiGetHotelEventTypesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetHotelEventTypesLOVRequest) XHotelid(xHotelid string) LOVApiGetHotelEventTypesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetHotelEventTypesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetHotelEventTypesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetHotelEventTypesLOVRequest) ParameterName(parameterName []string) LOVApiGetHotelEventTypesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetHotelEventTypesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetHotelEventTypesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetHotelEventTypesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetHotelEventTypesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetHotelEventTypesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetHotelEventTypesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetHotelEventTypesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetHotelEventTypesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetHotelEventTypesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetHotelEventTypesLOVExecute(r)
}

/*
GetHotelEventTypesLOV Fetch List Of Values for Hotel Event Types

 <p><strong>OperationId:</strong>getHotelEventTypesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch HotelEventTypes LOV
 @return LOVApiGetHotelEventTypesLOVRequest
*/
func (a *LOVApiService) GetHotelEventTypesLOV(ctx context.Context, hotelId string) LOVApiGetHotelEventTypesLOVRequest {
	return LOVApiGetHotelEventTypesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetHotelEventTypesLOVExecute(r LOVApiGetHotelEventTypesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetHotelEventTypesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/hotelEventTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetHotelInterfaceDataLineTypesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	logo string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetHotelInterfaceDataLineTypesLOVRequest) Authorization(authorization string) LOVApiGetHotelInterfaceDataLineTypesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetHotelInterfaceDataLineTypesLOVRequest) XAppKey(xAppKey string) LOVApiGetHotelInterfaceDataLineTypesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetHotelInterfaceDataLineTypesLOVRequest) XHotelid(xHotelid string) LOVApiGetHotelInterfaceDataLineTypesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetHotelInterfaceDataLineTypesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetHotelInterfaceDataLineTypesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetHotelInterfaceDataLineTypesLOVRequest) ParameterName(parameterName []string) LOVApiGetHotelInterfaceDataLineTypesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetHotelInterfaceDataLineTypesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetHotelInterfaceDataLineTypesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetHotelInterfaceDataLineTypesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetHotelInterfaceDataLineTypesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetHotelInterfaceDataLineTypesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetHotelInterfaceDataLineTypesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetHotelInterfaceDataLineTypesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetHotelInterfaceDataLineTypesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetHotelInterfaceDataLineTypesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetHotelInterfaceDataLineTypesLOVExecute(r)
}

/*
GetHotelInterfaceDataLineTypesLOV Fetch List Of Values for Hotel Interface Data Line Types

 <p><strong>OperationId:</strong>getHotelInterfaceDataLineTypesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param logo Value of the parameter 'logo' which is required to fetch HotelInterfaceDataLineTypes LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch HotelInterfaceDataLineTypes LOV
 @return LOVApiGetHotelInterfaceDataLineTypesLOVRequest
*/
func (a *LOVApiService) GetHotelInterfaceDataLineTypesLOV(ctx context.Context, logo string, hotelId string) LOVApiGetHotelInterfaceDataLineTypesLOVRequest {
	return LOVApiGetHotelInterfaceDataLineTypesLOVRequest{
		ApiService: a,
		ctx: ctx,
		logo: logo,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetHotelInterfaceDataLineTypesLOVExecute(r LOVApiGetHotelInterfaceDataLineTypesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetHotelInterfaceDataLineTypesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/logo/{logo}/hotelInterfaceDataLineTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"logo"+"}", url.PathEscape(parameterValueToString(r.logo, "logo")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.logo) < 1 {
		return localVarReturnValue, nil, reportError("logo must have at least 1 elements")
	}
	if strlen(r.logo) > 2000 {
		return localVarReturnValue, nil, reportError("logo must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetHotelInterfaceImportRoomsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetHotelInterfaceImportRoomsLOVRequest) Authorization(authorization string) LOVApiGetHotelInterfaceImportRoomsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetHotelInterfaceImportRoomsLOVRequest) XAppKey(xAppKey string) LOVApiGetHotelInterfaceImportRoomsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetHotelInterfaceImportRoomsLOVRequest) XHotelid(xHotelid string) LOVApiGetHotelInterfaceImportRoomsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetHotelInterfaceImportRoomsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetHotelInterfaceImportRoomsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetHotelInterfaceImportRoomsLOVRequest) ParameterName(parameterName []string) LOVApiGetHotelInterfaceImportRoomsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetHotelInterfaceImportRoomsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetHotelInterfaceImportRoomsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetHotelInterfaceImportRoomsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetHotelInterfaceImportRoomsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetHotelInterfaceImportRoomsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetHotelInterfaceImportRoomsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetHotelInterfaceImportRoomsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetHotelInterfaceImportRoomsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetHotelInterfaceImportRoomsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetHotelInterfaceImportRoomsLOVExecute(r)
}

/*
GetHotelInterfaceImportRoomsLOV Fetch List Of Values for Hotel Interface Import Rooms

 <p><strong>OperationId:</strong>getHotelInterfaceImportRoomsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch HotelInterfaceImportRooms LOV
 @return LOVApiGetHotelInterfaceImportRoomsLOVRequest
*/
func (a *LOVApiService) GetHotelInterfaceImportRoomsLOV(ctx context.Context, hotelId string) LOVApiGetHotelInterfaceImportRoomsLOVRequest {
	return LOVApiGetHotelInterfaceImportRoomsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetHotelInterfaceImportRoomsLOVExecute(r LOVApiGetHotelInterfaceImportRoomsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetHotelInterfaceImportRoomsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/hotelInterfaceImportRooms"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetHotelRateTierLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetHotelRateTierLOVRequest) Authorization(authorization string) LOVApiGetHotelRateTierLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetHotelRateTierLOVRequest) XAppKey(xAppKey string) LOVApiGetHotelRateTierLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetHotelRateTierLOVRequest) XHotelid(xHotelid string) LOVApiGetHotelRateTierLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetHotelRateTierLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetHotelRateTierLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetHotelRateTierLOVRequest) ParameterName(parameterName []string) LOVApiGetHotelRateTierLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetHotelRateTierLOVRequest) ParameterValue(parameterValue []string) LOVApiGetHotelRateTierLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetHotelRateTierLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetHotelRateTierLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetHotelRateTierLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetHotelRateTierLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetHotelRateTierLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetHotelRateTierLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetHotelRateTierLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetHotelRateTierLOVExecute(r)
}

/*
GetHotelRateTierLOV Fetch List Of Values for Hotel Rate Tier

 <p><strong>OperationId:</strong>getHotelRateTierLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch HotelRateTier LOV
 @return LOVApiGetHotelRateTierLOVRequest
*/
func (a *LOVApiService) GetHotelRateTierLOV(ctx context.Context, hotelId string) LOVApiGetHotelRateTierLOVRequest {
	return LOVApiGetHotelRateTierLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetHotelRateTierLOVExecute(r LOVApiGetHotelRateTierLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetHotelRateTierLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/hotelRateTier"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetHotelsForARProfileLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	profileId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetHotelsForARProfileLOVRequest) Authorization(authorization string) LOVApiGetHotelsForARProfileLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetHotelsForARProfileLOVRequest) XAppKey(xAppKey string) LOVApiGetHotelsForARProfileLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetHotelsForARProfileLOVRequest) XHotelid(xHotelid string) LOVApiGetHotelsForARProfileLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetHotelsForARProfileLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetHotelsForARProfileLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetHotelsForARProfileLOVRequest) ParameterName(parameterName []string) LOVApiGetHotelsForARProfileLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetHotelsForARProfileLOVRequest) ParameterValue(parameterValue []string) LOVApiGetHotelsForARProfileLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetHotelsForARProfileLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetHotelsForARProfileLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetHotelsForARProfileLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetHotelsForARProfileLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetHotelsForARProfileLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetHotelsForARProfileLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetHotelsForARProfileLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetHotelsForARProfileLOVExecute(r)
}

/*
GetHotelsForARProfileLOV Fetch List Of Values for Hotels For ARProfile

 <p><strong>OperationId:</strong>getHotelsForARProfileLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param profileId Value of the parameter 'profileId' which is required to fetch HotelsForARProfile LOV
 @return LOVApiGetHotelsForARProfileLOVRequest
*/
func (a *LOVApiService) GetHotelsForARProfileLOV(ctx context.Context, profileId string) LOVApiGetHotelsForARProfileLOVRequest {
	return LOVApiGetHotelsForARProfileLOVRequest{
		ApiService: a,
		ctx: ctx,
		profileId: profileId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetHotelsForARProfileLOVExecute(r LOVApiGetHotelsForARProfileLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetHotelsForARProfileLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/profiles/{profileId}/hotelsForARProfile"
	localVarPath = strings.Replace(localVarPath, "{"+"profileId"+"}", url.PathEscape(parameterValueToString(r.profileId, "profileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.profileId) < 1 {
		return localVarReturnValue, nil, reportError("profileId must have at least 1 elements")
	}
	if strlen(r.profileId) > 2000 {
		return localVarReturnValue, nil, reportError("profileId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetHotelsForSnCLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	cateringEvents string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetHotelsForSnCLOVRequest) Authorization(authorization string) LOVApiGetHotelsForSnCLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetHotelsForSnCLOVRequest) XAppKey(xAppKey string) LOVApiGetHotelsForSnCLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetHotelsForSnCLOVRequest) XHotelid(xHotelid string) LOVApiGetHotelsForSnCLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetHotelsForSnCLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetHotelsForSnCLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetHotelsForSnCLOVRequest) ParameterName(parameterName []string) LOVApiGetHotelsForSnCLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetHotelsForSnCLOVRequest) ParameterValue(parameterValue []string) LOVApiGetHotelsForSnCLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetHotelsForSnCLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetHotelsForSnCLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetHotelsForSnCLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetHotelsForSnCLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetHotelsForSnCLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetHotelsForSnCLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetHotelsForSnCLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetHotelsForSnCLOVExecute(r)
}

/*
GetHotelsForSnCLOV Fetch List Of Values for Hotels For Sn C

 <p><strong>OperationId:</strong>getHotelsForSnCLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cateringEvents Value of the parameter 'cateringEvents' which is required to fetch HotelsForSnC LOV
 @return LOVApiGetHotelsForSnCLOVRequest
*/
func (a *LOVApiService) GetHotelsForSnCLOV(ctx context.Context, cateringEvents string) LOVApiGetHotelsForSnCLOVRequest {
	return LOVApiGetHotelsForSnCLOVRequest{
		ApiService: a,
		ctx: ctx,
		cateringEvents: cateringEvents,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetHotelsForSnCLOVExecute(r LOVApiGetHotelsForSnCLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetHotelsForSnCLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/cateringEvents/{cateringEvents}/hotelsForSnC"
	localVarPath = strings.Replace(localVarPath, "{"+"cateringEvents"+"}", url.PathEscape(parameterValueToString(r.cateringEvents, "cateringEvents")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.cateringEvents) < 1 {
		return localVarReturnValue, nil, reportError("cateringEvents must have at least 1 elements")
	}
	if strlen(r.cateringEvents) > 2000 {
		return localVarReturnValue, nil, reportError("cateringEvents must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetHouseKeepingRoomsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetHouseKeepingRoomsLOVRequest) Authorization(authorization string) LOVApiGetHouseKeepingRoomsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetHouseKeepingRoomsLOVRequest) XAppKey(xAppKey string) LOVApiGetHouseKeepingRoomsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetHouseKeepingRoomsLOVRequest) XHotelid(xHotelid string) LOVApiGetHouseKeepingRoomsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetHouseKeepingRoomsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetHouseKeepingRoomsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetHouseKeepingRoomsLOVRequest) ParameterName(parameterName []string) LOVApiGetHouseKeepingRoomsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetHouseKeepingRoomsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetHouseKeepingRoomsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetHouseKeepingRoomsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetHouseKeepingRoomsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetHouseKeepingRoomsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetHouseKeepingRoomsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetHouseKeepingRoomsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetHouseKeepingRoomsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetHouseKeepingRoomsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetHouseKeepingRoomsLOVExecute(r)
}

/*
GetHouseKeepingRoomsLOV Fetch List Of Values for House Keeping Rooms

 <p><strong>OperationId:</strong>getHouseKeepingRoomsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch HouseKeepingRooms LOV
 @return LOVApiGetHouseKeepingRoomsLOVRequest
*/
func (a *LOVApiService) GetHouseKeepingRoomsLOV(ctx context.Context, hotelId string) LOVApiGetHouseKeepingRoomsLOVRequest {
	return LOVApiGetHouseKeepingRoomsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetHouseKeepingRoomsLOVExecute(r LOVApiGetHouseKeepingRoomsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetHouseKeepingRoomsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/houseKeepingRooms"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetHouseKeepingSectionsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetHouseKeepingSectionsLOVRequest) Authorization(authorization string) LOVApiGetHouseKeepingSectionsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetHouseKeepingSectionsLOVRequest) XAppKey(xAppKey string) LOVApiGetHouseKeepingSectionsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetHouseKeepingSectionsLOVRequest) XHotelid(xHotelid string) LOVApiGetHouseKeepingSectionsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetHouseKeepingSectionsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetHouseKeepingSectionsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetHouseKeepingSectionsLOVRequest) ParameterName(parameterName []string) LOVApiGetHouseKeepingSectionsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetHouseKeepingSectionsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetHouseKeepingSectionsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetHouseKeepingSectionsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetHouseKeepingSectionsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetHouseKeepingSectionsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetHouseKeepingSectionsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetHouseKeepingSectionsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetHouseKeepingSectionsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetHouseKeepingSectionsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetHouseKeepingSectionsLOVExecute(r)
}

/*
GetHouseKeepingSectionsLOV Fetch List Of Values for House Keeping Sections

 <p><strong>OperationId:</strong>getHouseKeepingSectionsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch HouseKeepingSections LOV
 @return LOVApiGetHouseKeepingSectionsLOVRequest
*/
func (a *LOVApiService) GetHouseKeepingSectionsLOV(ctx context.Context, hotelId string) LOVApiGetHouseKeepingSectionsLOVRequest {
	return LOVApiGetHouseKeepingSectionsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetHouseKeepingSectionsLOVExecute(r LOVApiGetHouseKeepingSectionsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetHouseKeepingSectionsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/houseKeepingSections"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetHousekeepingCreditRulesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetHousekeepingCreditRulesLOVRequest) Authorization(authorization string) LOVApiGetHousekeepingCreditRulesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetHousekeepingCreditRulesLOVRequest) XAppKey(xAppKey string) LOVApiGetHousekeepingCreditRulesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetHousekeepingCreditRulesLOVRequest) XHotelid(xHotelid string) LOVApiGetHousekeepingCreditRulesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetHousekeepingCreditRulesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetHousekeepingCreditRulesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetHousekeepingCreditRulesLOVRequest) ParameterName(parameterName []string) LOVApiGetHousekeepingCreditRulesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetHousekeepingCreditRulesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetHousekeepingCreditRulesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetHousekeepingCreditRulesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetHousekeepingCreditRulesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetHousekeepingCreditRulesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetHousekeepingCreditRulesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetHousekeepingCreditRulesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetHousekeepingCreditRulesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetHousekeepingCreditRulesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetHousekeepingCreditRulesLOVExecute(r)
}

/*
GetHousekeepingCreditRulesLOV Fetch List Of Values for Housekeeping Credit Rules

 <p><strong>OperationId:</strong>getHousekeepingCreditRulesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch HousekeepingCreditRules LOV
 @return LOVApiGetHousekeepingCreditRulesLOVRequest
*/
func (a *LOVApiService) GetHousekeepingCreditRulesLOV(ctx context.Context, hotelId string) LOVApiGetHousekeepingCreditRulesLOVRequest {
	return LOVApiGetHousekeepingCreditRulesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetHousekeepingCreditRulesLOVExecute(r LOVApiGetHousekeepingCreditRulesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetHousekeepingCreditRulesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/housekeepingCreditRules"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetIfcRightsViewLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	category string
	ifcId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetIfcRightsViewLOVRequest) Authorization(authorization string) LOVApiGetIfcRightsViewLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetIfcRightsViewLOVRequest) XAppKey(xAppKey string) LOVApiGetIfcRightsViewLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetIfcRightsViewLOVRequest) XHotelid(xHotelid string) LOVApiGetIfcRightsViewLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetIfcRightsViewLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetIfcRightsViewLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetIfcRightsViewLOVRequest) ParameterName(parameterName []string) LOVApiGetIfcRightsViewLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetIfcRightsViewLOVRequest) ParameterValue(parameterValue []string) LOVApiGetIfcRightsViewLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetIfcRightsViewLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetIfcRightsViewLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetIfcRightsViewLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetIfcRightsViewLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetIfcRightsViewLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetIfcRightsViewLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetIfcRightsViewLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetIfcRightsViewLOVExecute(r)
}

/*
GetIfcRightsViewLOV Fetch List Of Values for Ifc Rights View

 <p><strong>OperationId:</strong>getIfcRightsViewLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param category Value of the parameter 'category' which is required to fetch IfcRightsView LOV
 @param ifcId Value of the parameter 'ifcId' which is required to fetch IfcRightsView LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch IfcRightsView LOV
 @return LOVApiGetIfcRightsViewLOVRequest
*/
func (a *LOVApiService) GetIfcRightsViewLOV(ctx context.Context, category string, ifcId string, hotelId string) LOVApiGetIfcRightsViewLOVRequest {
	return LOVApiGetIfcRightsViewLOVRequest{
		ApiService: a,
		ctx: ctx,
		category: category,
		ifcId: ifcId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetIfcRightsViewLOVExecute(r LOVApiGetIfcRightsViewLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetIfcRightsViewLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/ifcId/{ifcId}/category/{category}/ifcRightsView"
	localVarPath = strings.Replace(localVarPath, "{"+"category"+"}", url.PathEscape(parameterValueToString(r.category, "category")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ifcId"+"}", url.PathEscape(parameterValueToString(r.ifcId, "ifcId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.category) < 1 {
		return localVarReturnValue, nil, reportError("category must have at least 1 elements")
	}
	if strlen(r.category) > 2000 {
		return localVarReturnValue, nil, reportError("category must have less than 2000 elements")
	}
	if strlen(r.ifcId) < 1 {
		return localVarReturnValue, nil, reportError("ifcId must have at least 1 elements")
	}
	if strlen(r.ifcId) > 2000 {
		return localVarReturnValue, nil, reportError("ifcId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetImbalanceVerificationTypesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetImbalanceVerificationTypesLOVRequest) Authorization(authorization string) LOVApiGetImbalanceVerificationTypesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetImbalanceVerificationTypesLOVRequest) XAppKey(xAppKey string) LOVApiGetImbalanceVerificationTypesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetImbalanceVerificationTypesLOVRequest) XHotelid(xHotelid string) LOVApiGetImbalanceVerificationTypesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetImbalanceVerificationTypesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetImbalanceVerificationTypesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetImbalanceVerificationTypesLOVRequest) ParameterName(parameterName []string) LOVApiGetImbalanceVerificationTypesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetImbalanceVerificationTypesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetImbalanceVerificationTypesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetImbalanceVerificationTypesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetImbalanceVerificationTypesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetImbalanceVerificationTypesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetImbalanceVerificationTypesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetImbalanceVerificationTypesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetImbalanceVerificationTypesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetImbalanceVerificationTypesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetImbalanceVerificationTypesLOVExecute(r)
}

/*
GetImbalanceVerificationTypesLOV Fetch List Of Values for Imbalance Verification Types

 <p><strong>OperationId:</strong>getImbalanceVerificationTypesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ImbalanceVerificationTypes LOV
 @return LOVApiGetImbalanceVerificationTypesLOVRequest
*/
func (a *LOVApiService) GetImbalanceVerificationTypesLOV(ctx context.Context, hotelId string) LOVApiGetImbalanceVerificationTypesLOVRequest {
	return LOVApiGetImbalanceVerificationTypesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetImbalanceVerificationTypesLOVExecute(r LOVApiGetImbalanceVerificationTypesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetImbalanceVerificationTypesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/imbalanceVerificationTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetInterfaceAutoBalanceLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetInterfaceAutoBalanceLOVRequest) Authorization(authorization string) LOVApiGetInterfaceAutoBalanceLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetInterfaceAutoBalanceLOVRequest) XAppKey(xAppKey string) LOVApiGetInterfaceAutoBalanceLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetInterfaceAutoBalanceLOVRequest) XHotelid(xHotelid string) LOVApiGetInterfaceAutoBalanceLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetInterfaceAutoBalanceLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetInterfaceAutoBalanceLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetInterfaceAutoBalanceLOVRequest) ParameterName(parameterName []string) LOVApiGetInterfaceAutoBalanceLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetInterfaceAutoBalanceLOVRequest) ParameterValue(parameterValue []string) LOVApiGetInterfaceAutoBalanceLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetInterfaceAutoBalanceLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetInterfaceAutoBalanceLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetInterfaceAutoBalanceLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetInterfaceAutoBalanceLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetInterfaceAutoBalanceLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetInterfaceAutoBalanceLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetInterfaceAutoBalanceLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetInterfaceAutoBalanceLOVExecute(r)
}

/*
GetInterfaceAutoBalanceLOV Fetch List Of Values for Interface Auto Balance

 <p><strong>OperationId:</strong>getInterfaceAutoBalanceLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch InterfaceAutoBalance LOV
 @return LOVApiGetInterfaceAutoBalanceLOVRequest
*/
func (a *LOVApiService) GetInterfaceAutoBalanceLOV(ctx context.Context, hotelId string) LOVApiGetInterfaceAutoBalanceLOVRequest {
	return LOVApiGetInterfaceAutoBalanceLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetInterfaceAutoBalanceLOVExecute(r LOVApiGetInterfaceAutoBalanceLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetInterfaceAutoBalanceLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/interfaceAutoBalance"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetInterfaceDataRequestMarketCodeLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetInterfaceDataRequestMarketCodeLOVRequest) Authorization(authorization string) LOVApiGetInterfaceDataRequestMarketCodeLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetInterfaceDataRequestMarketCodeLOVRequest) XAppKey(xAppKey string) LOVApiGetInterfaceDataRequestMarketCodeLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetInterfaceDataRequestMarketCodeLOVRequest) XHotelid(xHotelid string) LOVApiGetInterfaceDataRequestMarketCodeLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetInterfaceDataRequestMarketCodeLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetInterfaceDataRequestMarketCodeLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetInterfaceDataRequestMarketCodeLOVRequest) ParameterName(parameterName []string) LOVApiGetInterfaceDataRequestMarketCodeLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetInterfaceDataRequestMarketCodeLOVRequest) ParameterValue(parameterValue []string) LOVApiGetInterfaceDataRequestMarketCodeLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetInterfaceDataRequestMarketCodeLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetInterfaceDataRequestMarketCodeLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetInterfaceDataRequestMarketCodeLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetInterfaceDataRequestMarketCodeLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetInterfaceDataRequestMarketCodeLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetInterfaceDataRequestMarketCodeLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetInterfaceDataRequestMarketCodeLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetInterfaceDataRequestMarketCodeLOVExecute(r)
}

/*
GetInterfaceDataRequestMarketCodeLOV Fetch List Of Values for Interface Data Request Market Code

 <p><strong>OperationId:</strong>getInterfaceDataRequestMarketCodeLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch InterfaceDataRequestMarketCode LOV
 @return LOVApiGetInterfaceDataRequestMarketCodeLOVRequest
*/
func (a *LOVApiService) GetInterfaceDataRequestMarketCodeLOV(ctx context.Context, hotelId string) LOVApiGetInterfaceDataRequestMarketCodeLOVRequest {
	return LOVApiGetInterfaceDataRequestMarketCodeLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetInterfaceDataRequestMarketCodeLOVExecute(r LOVApiGetInterfaceDataRequestMarketCodeLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetInterfaceDataRequestMarketCodeLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/interfaceDataRequestMarketCode"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetInterfaceDataRequestMarketGroupLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetInterfaceDataRequestMarketGroupLOVRequest) Authorization(authorization string) LOVApiGetInterfaceDataRequestMarketGroupLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetInterfaceDataRequestMarketGroupLOVRequest) XAppKey(xAppKey string) LOVApiGetInterfaceDataRequestMarketGroupLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetInterfaceDataRequestMarketGroupLOVRequest) XHotelid(xHotelid string) LOVApiGetInterfaceDataRequestMarketGroupLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetInterfaceDataRequestMarketGroupLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetInterfaceDataRequestMarketGroupLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetInterfaceDataRequestMarketGroupLOVRequest) ParameterName(parameterName []string) LOVApiGetInterfaceDataRequestMarketGroupLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetInterfaceDataRequestMarketGroupLOVRequest) ParameterValue(parameterValue []string) LOVApiGetInterfaceDataRequestMarketGroupLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetInterfaceDataRequestMarketGroupLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetInterfaceDataRequestMarketGroupLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetInterfaceDataRequestMarketGroupLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetInterfaceDataRequestMarketGroupLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetInterfaceDataRequestMarketGroupLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetInterfaceDataRequestMarketGroupLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetInterfaceDataRequestMarketGroupLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetInterfaceDataRequestMarketGroupLOVExecute(r)
}

/*
GetInterfaceDataRequestMarketGroupLOV Fetch List Of Values for Interface Data Request Market Group

 <p><strong>OperationId:</strong>getInterfaceDataRequestMarketGroupLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch InterfaceDataRequestMarketGroup LOV
 @return LOVApiGetInterfaceDataRequestMarketGroupLOVRequest
*/
func (a *LOVApiService) GetInterfaceDataRequestMarketGroupLOV(ctx context.Context, hotelId string) LOVApiGetInterfaceDataRequestMarketGroupLOVRequest {
	return LOVApiGetInterfaceDataRequestMarketGroupLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetInterfaceDataRequestMarketGroupLOVExecute(r LOVApiGetInterfaceDataRequestMarketGroupLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetInterfaceDataRequestMarketGroupLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/interfaceDataRequestMarketGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetInterfaceDataRequestRoomClassLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetInterfaceDataRequestRoomClassLOVRequest) Authorization(authorization string) LOVApiGetInterfaceDataRequestRoomClassLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetInterfaceDataRequestRoomClassLOVRequest) XAppKey(xAppKey string) LOVApiGetInterfaceDataRequestRoomClassLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetInterfaceDataRequestRoomClassLOVRequest) XHotelid(xHotelid string) LOVApiGetInterfaceDataRequestRoomClassLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetInterfaceDataRequestRoomClassLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetInterfaceDataRequestRoomClassLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetInterfaceDataRequestRoomClassLOVRequest) ParameterName(parameterName []string) LOVApiGetInterfaceDataRequestRoomClassLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetInterfaceDataRequestRoomClassLOVRequest) ParameterValue(parameterValue []string) LOVApiGetInterfaceDataRequestRoomClassLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetInterfaceDataRequestRoomClassLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetInterfaceDataRequestRoomClassLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetInterfaceDataRequestRoomClassLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetInterfaceDataRequestRoomClassLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetInterfaceDataRequestRoomClassLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetInterfaceDataRequestRoomClassLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetInterfaceDataRequestRoomClassLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetInterfaceDataRequestRoomClassLOVExecute(r)
}

/*
GetInterfaceDataRequestRoomClassLOV Fetch List Of Values for Interface Data Request Room Class

 <p><strong>OperationId:</strong>getInterfaceDataRequestRoomClassLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch InterfaceDataRequestRoomClass LOV
 @return LOVApiGetInterfaceDataRequestRoomClassLOVRequest
*/
func (a *LOVApiService) GetInterfaceDataRequestRoomClassLOV(ctx context.Context, hotelId string) LOVApiGetInterfaceDataRequestRoomClassLOVRequest {
	return LOVApiGetInterfaceDataRequestRoomClassLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetInterfaceDataRequestRoomClassLOVExecute(r LOVApiGetInterfaceDataRequestRoomClassLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetInterfaceDataRequestRoomClassLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/interfaceDataRequestRoomClass"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetInterfaceDataRequestRoomTypesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetInterfaceDataRequestRoomTypesLOVRequest) Authorization(authorization string) LOVApiGetInterfaceDataRequestRoomTypesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetInterfaceDataRequestRoomTypesLOVRequest) XAppKey(xAppKey string) LOVApiGetInterfaceDataRequestRoomTypesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetInterfaceDataRequestRoomTypesLOVRequest) XHotelid(xHotelid string) LOVApiGetInterfaceDataRequestRoomTypesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetInterfaceDataRequestRoomTypesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetInterfaceDataRequestRoomTypesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetInterfaceDataRequestRoomTypesLOVRequest) ParameterName(parameterName []string) LOVApiGetInterfaceDataRequestRoomTypesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetInterfaceDataRequestRoomTypesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetInterfaceDataRequestRoomTypesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetInterfaceDataRequestRoomTypesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetInterfaceDataRequestRoomTypesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetInterfaceDataRequestRoomTypesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetInterfaceDataRequestRoomTypesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetInterfaceDataRequestRoomTypesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetInterfaceDataRequestRoomTypesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetInterfaceDataRequestRoomTypesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetInterfaceDataRequestRoomTypesLOVExecute(r)
}

/*
GetInterfaceDataRequestRoomTypesLOV Fetch List Of Values for Interface Data Request Room Types

 <p><strong>OperationId:</strong>getInterfaceDataRequestRoomTypesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch InterfaceDataRequestRoomTypes LOV
 @return LOVApiGetInterfaceDataRequestRoomTypesLOVRequest
*/
func (a *LOVApiService) GetInterfaceDataRequestRoomTypesLOV(ctx context.Context, hotelId string) LOVApiGetInterfaceDataRequestRoomTypesLOVRequest {
	return LOVApiGetInterfaceDataRequestRoomTypesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetInterfaceDataRequestRoomTypesLOVExecute(r LOVApiGetInterfaceDataRequestRoomTypesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetInterfaceDataRequestRoomTypesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/interfaceDataRequestRoomTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetInterfaceDataRequestSourceCodeLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetInterfaceDataRequestSourceCodeLOVRequest) Authorization(authorization string) LOVApiGetInterfaceDataRequestSourceCodeLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetInterfaceDataRequestSourceCodeLOVRequest) XAppKey(xAppKey string) LOVApiGetInterfaceDataRequestSourceCodeLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetInterfaceDataRequestSourceCodeLOVRequest) XHotelid(xHotelid string) LOVApiGetInterfaceDataRequestSourceCodeLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetInterfaceDataRequestSourceCodeLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetInterfaceDataRequestSourceCodeLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetInterfaceDataRequestSourceCodeLOVRequest) ParameterName(parameterName []string) LOVApiGetInterfaceDataRequestSourceCodeLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetInterfaceDataRequestSourceCodeLOVRequest) ParameterValue(parameterValue []string) LOVApiGetInterfaceDataRequestSourceCodeLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetInterfaceDataRequestSourceCodeLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetInterfaceDataRequestSourceCodeLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetInterfaceDataRequestSourceCodeLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetInterfaceDataRequestSourceCodeLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetInterfaceDataRequestSourceCodeLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetInterfaceDataRequestSourceCodeLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetInterfaceDataRequestSourceCodeLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetInterfaceDataRequestSourceCodeLOVExecute(r)
}

/*
GetInterfaceDataRequestSourceCodeLOV Fetch List Of Values for Interface Data Request Source Code

 <p><strong>OperationId:</strong>getInterfaceDataRequestSourceCodeLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch InterfaceDataRequestSourceCode LOV
 @return LOVApiGetInterfaceDataRequestSourceCodeLOVRequest
*/
func (a *LOVApiService) GetInterfaceDataRequestSourceCodeLOV(ctx context.Context, hotelId string) LOVApiGetInterfaceDataRequestSourceCodeLOVRequest {
	return LOVApiGetInterfaceDataRequestSourceCodeLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetInterfaceDataRequestSourceCodeLOVExecute(r LOVApiGetInterfaceDataRequestSourceCodeLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetInterfaceDataRequestSourceCodeLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/interfaceDataRequestSourceCode"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetInterfaceDataRequestSourceGroupLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetInterfaceDataRequestSourceGroupLOVRequest) Authorization(authorization string) LOVApiGetInterfaceDataRequestSourceGroupLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetInterfaceDataRequestSourceGroupLOVRequest) XAppKey(xAppKey string) LOVApiGetInterfaceDataRequestSourceGroupLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetInterfaceDataRequestSourceGroupLOVRequest) XHotelid(xHotelid string) LOVApiGetInterfaceDataRequestSourceGroupLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetInterfaceDataRequestSourceGroupLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetInterfaceDataRequestSourceGroupLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetInterfaceDataRequestSourceGroupLOVRequest) ParameterName(parameterName []string) LOVApiGetInterfaceDataRequestSourceGroupLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetInterfaceDataRequestSourceGroupLOVRequest) ParameterValue(parameterValue []string) LOVApiGetInterfaceDataRequestSourceGroupLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetInterfaceDataRequestSourceGroupLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetInterfaceDataRequestSourceGroupLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetInterfaceDataRequestSourceGroupLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetInterfaceDataRequestSourceGroupLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetInterfaceDataRequestSourceGroupLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetInterfaceDataRequestSourceGroupLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetInterfaceDataRequestSourceGroupLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetInterfaceDataRequestSourceGroupLOVExecute(r)
}

/*
GetInterfaceDataRequestSourceGroupLOV Fetch List Of Values for Interface Data Request Source Group

 <p><strong>OperationId:</strong>getInterfaceDataRequestSourceGroupLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch InterfaceDataRequestSourceGroup LOV
 @return LOVApiGetInterfaceDataRequestSourceGroupLOVRequest
*/
func (a *LOVApiService) GetInterfaceDataRequestSourceGroupLOV(ctx context.Context, hotelId string) LOVApiGetInterfaceDataRequestSourceGroupLOVRequest {
	return LOVApiGetInterfaceDataRequestSourceGroupLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetInterfaceDataRequestSourceGroupLOVExecute(r LOVApiGetInterfaceDataRequestSourceGroupLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetInterfaceDataRequestSourceGroupLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/interfaceDataRequestSourceGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetInterfacePseudoRoomLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetInterfacePseudoRoomLOVRequest) Authorization(authorization string) LOVApiGetInterfacePseudoRoomLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetInterfacePseudoRoomLOVRequest) XAppKey(xAppKey string) LOVApiGetInterfacePseudoRoomLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetInterfacePseudoRoomLOVRequest) XHotelid(xHotelid string) LOVApiGetInterfacePseudoRoomLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetInterfacePseudoRoomLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetInterfacePseudoRoomLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetInterfacePseudoRoomLOVRequest) ParameterName(parameterName []string) LOVApiGetInterfacePseudoRoomLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetInterfacePseudoRoomLOVRequest) ParameterValue(parameterValue []string) LOVApiGetInterfacePseudoRoomLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetInterfacePseudoRoomLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetInterfacePseudoRoomLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetInterfacePseudoRoomLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetInterfacePseudoRoomLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetInterfacePseudoRoomLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetInterfacePseudoRoomLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetInterfacePseudoRoomLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetInterfacePseudoRoomLOVExecute(r)
}

/*
GetInterfacePseudoRoomLOV Fetch List Of Values for Interface Pseudo Room

 <p><strong>OperationId:</strong>getInterfacePseudoRoomLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch InterfacePseudoRoom LOV
 @return LOVApiGetInterfacePseudoRoomLOVRequest
*/
func (a *LOVApiService) GetInterfacePseudoRoomLOV(ctx context.Context, hotelId string) LOVApiGetInterfacePseudoRoomLOVRequest {
	return LOVApiGetInterfacePseudoRoomLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetInterfacePseudoRoomLOVExecute(r LOVApiGetInterfacePseudoRoomLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetInterfacePseudoRoomLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/interfacePseudoRoom"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetInterfaceResyncFunctionSpaceLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetInterfaceResyncFunctionSpaceLOVRequest) Authorization(authorization string) LOVApiGetInterfaceResyncFunctionSpaceLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetInterfaceResyncFunctionSpaceLOVRequest) XAppKey(xAppKey string) LOVApiGetInterfaceResyncFunctionSpaceLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetInterfaceResyncFunctionSpaceLOVRequest) XHotelid(xHotelid string) LOVApiGetInterfaceResyncFunctionSpaceLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetInterfaceResyncFunctionSpaceLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetInterfaceResyncFunctionSpaceLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetInterfaceResyncFunctionSpaceLOVRequest) ParameterName(parameterName []string) LOVApiGetInterfaceResyncFunctionSpaceLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetInterfaceResyncFunctionSpaceLOVRequest) ParameterValue(parameterValue []string) LOVApiGetInterfaceResyncFunctionSpaceLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetInterfaceResyncFunctionSpaceLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetInterfaceResyncFunctionSpaceLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetInterfaceResyncFunctionSpaceLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetInterfaceResyncFunctionSpaceLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetInterfaceResyncFunctionSpaceLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetInterfaceResyncFunctionSpaceLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetInterfaceResyncFunctionSpaceLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetInterfaceResyncFunctionSpaceLOVExecute(r)
}

/*
GetInterfaceResyncFunctionSpaceLOV Fetch List Of Values for Interface Resync Function Space

 <p><strong>OperationId:</strong>getInterfaceResyncFunctionSpaceLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch InterfaceResyncFunctionSpace LOV
 @return LOVApiGetInterfaceResyncFunctionSpaceLOVRequest
*/
func (a *LOVApiService) GetInterfaceResyncFunctionSpaceLOV(ctx context.Context, hotelId string) LOVApiGetInterfaceResyncFunctionSpaceLOVRequest {
	return LOVApiGetInterfaceResyncFunctionSpaceLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetInterfaceResyncFunctionSpaceLOVExecute(r LOVApiGetInterfaceResyncFunctionSpaceLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetInterfaceResyncFunctionSpaceLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/interfaceResyncFunctionSpace"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetInterfaceResyncOwnerContractLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetInterfaceResyncOwnerContractLOVRequest) Authorization(authorization string) LOVApiGetInterfaceResyncOwnerContractLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetInterfaceResyncOwnerContractLOVRequest) XAppKey(xAppKey string) LOVApiGetInterfaceResyncOwnerContractLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetInterfaceResyncOwnerContractLOVRequest) XHotelid(xHotelid string) LOVApiGetInterfaceResyncOwnerContractLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetInterfaceResyncOwnerContractLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetInterfaceResyncOwnerContractLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetInterfaceResyncOwnerContractLOVRequest) ParameterName(parameterName []string) LOVApiGetInterfaceResyncOwnerContractLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetInterfaceResyncOwnerContractLOVRequest) ParameterValue(parameterValue []string) LOVApiGetInterfaceResyncOwnerContractLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetInterfaceResyncOwnerContractLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetInterfaceResyncOwnerContractLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetInterfaceResyncOwnerContractLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetInterfaceResyncOwnerContractLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetInterfaceResyncOwnerContractLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetInterfaceResyncOwnerContractLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetInterfaceResyncOwnerContractLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetInterfaceResyncOwnerContractLOVExecute(r)
}

/*
GetInterfaceResyncOwnerContractLOV Fetch List Of Values for Interface Resync Owner Contract

 <p><strong>OperationId:</strong>getInterfaceResyncOwnerContractLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch InterfaceResyncOwnerContract LOV
 @return LOVApiGetInterfaceResyncOwnerContractLOVRequest
*/
func (a *LOVApiService) GetInterfaceResyncOwnerContractLOV(ctx context.Context, hotelId string) LOVApiGetInterfaceResyncOwnerContractLOVRequest {
	return LOVApiGetInterfaceResyncOwnerContractLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetInterfaceResyncOwnerContractLOVExecute(r LOVApiGetInterfaceResyncOwnerContractLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetInterfaceResyncOwnerContractLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/interfaceResyncOwnerContract"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetInterfaceResyncOwnerContractRoomLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetInterfaceResyncOwnerContractRoomLOVRequest) Authorization(authorization string) LOVApiGetInterfaceResyncOwnerContractRoomLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetInterfaceResyncOwnerContractRoomLOVRequest) XAppKey(xAppKey string) LOVApiGetInterfaceResyncOwnerContractRoomLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetInterfaceResyncOwnerContractRoomLOVRequest) XHotelid(xHotelid string) LOVApiGetInterfaceResyncOwnerContractRoomLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetInterfaceResyncOwnerContractRoomLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetInterfaceResyncOwnerContractRoomLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetInterfaceResyncOwnerContractRoomLOVRequest) ParameterName(parameterName []string) LOVApiGetInterfaceResyncOwnerContractRoomLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetInterfaceResyncOwnerContractRoomLOVRequest) ParameterValue(parameterValue []string) LOVApiGetInterfaceResyncOwnerContractRoomLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetInterfaceResyncOwnerContractRoomLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetInterfaceResyncOwnerContractRoomLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetInterfaceResyncOwnerContractRoomLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetInterfaceResyncOwnerContractRoomLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetInterfaceResyncOwnerContractRoomLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetInterfaceResyncOwnerContractRoomLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetInterfaceResyncOwnerContractRoomLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetInterfaceResyncOwnerContractRoomLOVExecute(r)
}

/*
GetInterfaceResyncOwnerContractRoomLOV Fetch List Of Values for Interface Resync Owner Contract Room

 <p><strong>OperationId:</strong>getInterfaceResyncOwnerContractRoomLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch InterfaceResyncOwnerContractRoom LOV
 @return LOVApiGetInterfaceResyncOwnerContractRoomLOVRequest
*/
func (a *LOVApiService) GetInterfaceResyncOwnerContractRoomLOV(ctx context.Context, hotelId string) LOVApiGetInterfaceResyncOwnerContractRoomLOVRequest {
	return LOVApiGetInterfaceResyncOwnerContractRoomLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetInterfaceResyncOwnerContractRoomLOVExecute(r LOVApiGetInterfaceResyncOwnerContractRoomLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetInterfaceResyncOwnerContractRoomLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/interfaceResyncOwnerContractRoom"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetInterfaceResyncProductsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetInterfaceResyncProductsLOVRequest) Authorization(authorization string) LOVApiGetInterfaceResyncProductsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetInterfaceResyncProductsLOVRequest) XAppKey(xAppKey string) LOVApiGetInterfaceResyncProductsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetInterfaceResyncProductsLOVRequest) XHotelid(xHotelid string) LOVApiGetInterfaceResyncProductsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetInterfaceResyncProductsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetInterfaceResyncProductsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetInterfaceResyncProductsLOVRequest) ParameterName(parameterName []string) LOVApiGetInterfaceResyncProductsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetInterfaceResyncProductsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetInterfaceResyncProductsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetInterfaceResyncProductsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetInterfaceResyncProductsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetInterfaceResyncProductsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetInterfaceResyncProductsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetInterfaceResyncProductsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetInterfaceResyncProductsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetInterfaceResyncProductsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetInterfaceResyncProductsLOVExecute(r)
}

/*
GetInterfaceResyncProductsLOV Fetch List Of Values for Interface Resync Products

 <p><strong>OperationId:</strong>getInterfaceResyncProductsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch InterfaceResyncProducts LOV
 @return LOVApiGetInterfaceResyncProductsLOVRequest
*/
func (a *LOVApiService) GetInterfaceResyncProductsLOV(ctx context.Context, hotelId string) LOVApiGetInterfaceResyncProductsLOVRequest {
	return LOVApiGetInterfaceResyncProductsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetInterfaceResyncProductsLOVExecute(r LOVApiGetInterfaceResyncProductsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetInterfaceResyncProductsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/interfaceResyncProducts"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetInterfaceRevenueCodeLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	logo string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetInterfaceRevenueCodeLOVRequest) Authorization(authorization string) LOVApiGetInterfaceRevenueCodeLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetInterfaceRevenueCodeLOVRequest) XAppKey(xAppKey string) LOVApiGetInterfaceRevenueCodeLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetInterfaceRevenueCodeLOVRequest) XHotelid(xHotelid string) LOVApiGetInterfaceRevenueCodeLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetInterfaceRevenueCodeLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetInterfaceRevenueCodeLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetInterfaceRevenueCodeLOVRequest) ParameterName(parameterName []string) LOVApiGetInterfaceRevenueCodeLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetInterfaceRevenueCodeLOVRequest) ParameterValue(parameterValue []string) LOVApiGetInterfaceRevenueCodeLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetInterfaceRevenueCodeLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetInterfaceRevenueCodeLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetInterfaceRevenueCodeLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetInterfaceRevenueCodeLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetInterfaceRevenueCodeLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetInterfaceRevenueCodeLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetInterfaceRevenueCodeLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetInterfaceRevenueCodeLOVExecute(r)
}

/*
GetInterfaceRevenueCodeLOV Fetch List Of Values for Interface Revenue Code

 <p><strong>OperationId:</strong>getInterfaceRevenueCodeLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param logo Value of the parameter 'logo' which is required to fetch InterfaceRevenueCode LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch InterfaceRevenueCode LOV
 @return LOVApiGetInterfaceRevenueCodeLOVRequest
*/
func (a *LOVApiService) GetInterfaceRevenueCodeLOV(ctx context.Context, logo string, hotelId string) LOVApiGetInterfaceRevenueCodeLOVRequest {
	return LOVApiGetInterfaceRevenueCodeLOVRequest{
		ApiService: a,
		ctx: ctx,
		logo: logo,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetInterfaceRevenueCodeLOVExecute(r LOVApiGetInterfaceRevenueCodeLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetInterfaceRevenueCodeLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/logo/{logo}/interfaceRevenueCode"
	localVarPath = strings.Replace(localVarPath, "{"+"logo"+"}", url.PathEscape(parameterValueToString(r.logo, "logo")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.logo) < 1 {
		return localVarReturnValue, nil, reportError("logo must have at least 1 elements")
	}
	if strlen(r.logo) > 2000 {
		return localVarReturnValue, nil, reportError("logo must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetInterfaceTabColumnsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	tableName string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetInterfaceTabColumnsLOVRequest) Authorization(authorization string) LOVApiGetInterfaceTabColumnsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetInterfaceTabColumnsLOVRequest) XAppKey(xAppKey string) LOVApiGetInterfaceTabColumnsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetInterfaceTabColumnsLOVRequest) XHotelid(xHotelid string) LOVApiGetInterfaceTabColumnsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetInterfaceTabColumnsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetInterfaceTabColumnsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetInterfaceTabColumnsLOVRequest) ParameterName(parameterName []string) LOVApiGetInterfaceTabColumnsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetInterfaceTabColumnsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetInterfaceTabColumnsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetInterfaceTabColumnsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetInterfaceTabColumnsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetInterfaceTabColumnsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetInterfaceTabColumnsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetInterfaceTabColumnsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetInterfaceTabColumnsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetInterfaceTabColumnsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetInterfaceTabColumnsLOVExecute(r)
}

/*
GetInterfaceTabColumnsLOV Fetch List Of Values for Interface Tab Columns

 <p><strong>OperationId:</strong>getInterfaceTabColumnsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tableName Value of the parameter 'tableName' which is required to fetch InterfaceTabColumns LOV
 @return LOVApiGetInterfaceTabColumnsLOVRequest
*/
func (a *LOVApiService) GetInterfaceTabColumnsLOV(ctx context.Context, tableName string) LOVApiGetInterfaceTabColumnsLOVRequest {
	return LOVApiGetInterfaceTabColumnsLOVRequest{
		ApiService: a,
		ctx: ctx,
		tableName: tableName,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetInterfaceTabColumnsLOVExecute(r LOVApiGetInterfaceTabColumnsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetInterfaceTabColumnsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/tableName/{tableName}/interfaceTabColumns"
	localVarPath = strings.Replace(localVarPath, "{"+"tableName"+"}", url.PathEscape(parameterValueToString(r.tableName, "tableName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.tableName) < 1 {
		return localVarReturnValue, nil, reportError("tableName must have at least 1 elements")
	}
	if strlen(r.tableName) > 2000 {
		return localVarReturnValue, nil, reportError("tableName must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetInterfaceTrxCodesAllChargesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetInterfaceTrxCodesAllChargesLOVRequest) Authorization(authorization string) LOVApiGetInterfaceTrxCodesAllChargesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetInterfaceTrxCodesAllChargesLOVRequest) XAppKey(xAppKey string) LOVApiGetInterfaceTrxCodesAllChargesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetInterfaceTrxCodesAllChargesLOVRequest) XHotelid(xHotelid string) LOVApiGetInterfaceTrxCodesAllChargesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetInterfaceTrxCodesAllChargesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetInterfaceTrxCodesAllChargesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetInterfaceTrxCodesAllChargesLOVRequest) ParameterName(parameterName []string) LOVApiGetInterfaceTrxCodesAllChargesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetInterfaceTrxCodesAllChargesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetInterfaceTrxCodesAllChargesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetInterfaceTrxCodesAllChargesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetInterfaceTrxCodesAllChargesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetInterfaceTrxCodesAllChargesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetInterfaceTrxCodesAllChargesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetInterfaceTrxCodesAllChargesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetInterfaceTrxCodesAllChargesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetInterfaceTrxCodesAllChargesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetInterfaceTrxCodesAllChargesLOVExecute(r)
}

/*
GetInterfaceTrxCodesAllChargesLOV Fetch List Of Values for Interface Trx Codes All Charges

 <p><strong>OperationId:</strong>getInterfaceTrxCodesAllChargesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch InterfaceTrxCodesAllCharges LOV
 @return LOVApiGetInterfaceTrxCodesAllChargesLOVRequest
*/
func (a *LOVApiService) GetInterfaceTrxCodesAllChargesLOV(ctx context.Context, hotelId string) LOVApiGetInterfaceTrxCodesAllChargesLOVRequest {
	return LOVApiGetInterfaceTrxCodesAllChargesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetInterfaceTrxCodesAllChargesLOVExecute(r LOVApiGetInterfaceTrxCodesAllChargesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetInterfaceTrxCodesAllChargesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/interfaceTrxCodesAllCharges"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetInterfaceTrxCodesMinibarLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetInterfaceTrxCodesMinibarLOVRequest) Authorization(authorization string) LOVApiGetInterfaceTrxCodesMinibarLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetInterfaceTrxCodesMinibarLOVRequest) XAppKey(xAppKey string) LOVApiGetInterfaceTrxCodesMinibarLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetInterfaceTrxCodesMinibarLOVRequest) XHotelid(xHotelid string) LOVApiGetInterfaceTrxCodesMinibarLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetInterfaceTrxCodesMinibarLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetInterfaceTrxCodesMinibarLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetInterfaceTrxCodesMinibarLOVRequest) ParameterName(parameterName []string) LOVApiGetInterfaceTrxCodesMinibarLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetInterfaceTrxCodesMinibarLOVRequest) ParameterValue(parameterValue []string) LOVApiGetInterfaceTrxCodesMinibarLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetInterfaceTrxCodesMinibarLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetInterfaceTrxCodesMinibarLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetInterfaceTrxCodesMinibarLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetInterfaceTrxCodesMinibarLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetInterfaceTrxCodesMinibarLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetInterfaceTrxCodesMinibarLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetInterfaceTrxCodesMinibarLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetInterfaceTrxCodesMinibarLOVExecute(r)
}

/*
GetInterfaceTrxCodesMinibarLOV Fetch List Of Values for Interface Trx Codes Minibar

 <p><strong>OperationId:</strong>getInterfaceTrxCodesMinibarLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch InterfaceTrxCodesMinibar LOV
 @return LOVApiGetInterfaceTrxCodesMinibarLOVRequest
*/
func (a *LOVApiService) GetInterfaceTrxCodesMinibarLOV(ctx context.Context, hotelId string) LOVApiGetInterfaceTrxCodesMinibarLOVRequest {
	return LOVApiGetInterfaceTrxCodesMinibarLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetInterfaceTrxCodesMinibarLOVExecute(r LOVApiGetInterfaceTrxCodesMinibarLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetInterfaceTrxCodesMinibarLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/interfaceTrxCodesMinibar"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetInvItemsClassesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetInvItemsClassesLOVRequest) Authorization(authorization string) LOVApiGetInvItemsClassesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetInvItemsClassesLOVRequest) XAppKey(xAppKey string) LOVApiGetInvItemsClassesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetInvItemsClassesLOVRequest) XHotelid(xHotelid string) LOVApiGetInvItemsClassesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetInvItemsClassesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetInvItemsClassesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetInvItemsClassesLOVRequest) ParameterName(parameterName []string) LOVApiGetInvItemsClassesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetInvItemsClassesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetInvItemsClassesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetInvItemsClassesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetInvItemsClassesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetInvItemsClassesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetInvItemsClassesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetInvItemsClassesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetInvItemsClassesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetInvItemsClassesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetInvItemsClassesLOVExecute(r)
}

/*
GetInvItemsClassesLOV Fetch List Of Values for Inv Items Classes

 <p><strong>OperationId:</strong>getInvItemsClassesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch InvItemsClasses LOV
 @return LOVApiGetInvItemsClassesLOVRequest
*/
func (a *LOVApiService) GetInvItemsClassesLOV(ctx context.Context, hotelId string) LOVApiGetInvItemsClassesLOVRequest {
	return LOVApiGetInvItemsClassesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetInvItemsClassesLOVExecute(r LOVApiGetInvItemsClassesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetInvItemsClassesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/invItemsClasses"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetInvItemsPoolsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetInvItemsPoolsLOVRequest) Authorization(authorization string) LOVApiGetInvItemsPoolsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetInvItemsPoolsLOVRequest) XAppKey(xAppKey string) LOVApiGetInvItemsPoolsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetInvItemsPoolsLOVRequest) XHotelid(xHotelid string) LOVApiGetInvItemsPoolsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetInvItemsPoolsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetInvItemsPoolsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetInvItemsPoolsLOVRequest) ParameterName(parameterName []string) LOVApiGetInvItemsPoolsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetInvItemsPoolsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetInvItemsPoolsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetInvItemsPoolsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetInvItemsPoolsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetInvItemsPoolsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetInvItemsPoolsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetInvItemsPoolsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetInvItemsPoolsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetInvItemsPoolsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetInvItemsPoolsLOVExecute(r)
}

/*
GetInvItemsPoolsLOV Fetch List Of Values for Inv Items Pools

 <p><strong>OperationId:</strong>getInvItemsPoolsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch InvItemsPools LOV
 @return LOVApiGetInvItemsPoolsLOVRequest
*/
func (a *LOVApiService) GetInvItemsPoolsLOV(ctx context.Context, hotelId string) LOVApiGetInvItemsPoolsLOVRequest {
	return LOVApiGetInvItemsPoolsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetInvItemsPoolsLOVExecute(r LOVApiGetInvItemsPoolsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetInvItemsPoolsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/invItemsPools"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetInventoryItemAttributesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	itemId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetInventoryItemAttributesLOVRequest) Authorization(authorization string) LOVApiGetInventoryItemAttributesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetInventoryItemAttributesLOVRequest) XAppKey(xAppKey string) LOVApiGetInventoryItemAttributesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetInventoryItemAttributesLOVRequest) XHotelid(xHotelid string) LOVApiGetInventoryItemAttributesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetInventoryItemAttributesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetInventoryItemAttributesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetInventoryItemAttributesLOVRequest) ParameterName(parameterName []string) LOVApiGetInventoryItemAttributesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetInventoryItemAttributesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetInventoryItemAttributesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetInventoryItemAttributesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetInventoryItemAttributesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetInventoryItemAttributesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetInventoryItemAttributesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetInventoryItemAttributesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetInventoryItemAttributesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetInventoryItemAttributesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetInventoryItemAttributesLOVExecute(r)
}

/*
GetInventoryItemAttributesLOV Fetch List Of Values for Inventory Item Attributes

 <p><strong>OperationId:</strong>getInventoryItemAttributesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param itemId Value of the parameter 'itemId' which is required to fetch InventoryItemAttributes LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch InventoryItemAttributes LOV
 @return LOVApiGetInventoryItemAttributesLOVRequest
*/
func (a *LOVApiService) GetInventoryItemAttributesLOV(ctx context.Context, itemId string, hotelId string) LOVApiGetInventoryItemAttributesLOVRequest {
	return LOVApiGetInventoryItemAttributesLOVRequest{
		ApiService: a,
		ctx: ctx,
		itemId: itemId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetInventoryItemAttributesLOVExecute(r LOVApiGetInventoryItemAttributesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetInventoryItemAttributesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/itemId/{itemId}/inventoryItemAttributes"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.itemId) < 1 {
		return localVarReturnValue, nil, reportError("itemId must have at least 1 elements")
	}
	if strlen(r.itemId) > 2000 {
		return localVarReturnValue, nil, reportError("itemId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetInventoryItemRatesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	itemId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetInventoryItemRatesLOVRequest) Authorization(authorization string) LOVApiGetInventoryItemRatesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetInventoryItemRatesLOVRequest) XAppKey(xAppKey string) LOVApiGetInventoryItemRatesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetInventoryItemRatesLOVRequest) XHotelid(xHotelid string) LOVApiGetInventoryItemRatesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetInventoryItemRatesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetInventoryItemRatesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetInventoryItemRatesLOVRequest) ParameterName(parameterName []string) LOVApiGetInventoryItemRatesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetInventoryItemRatesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetInventoryItemRatesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetInventoryItemRatesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetInventoryItemRatesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetInventoryItemRatesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetInventoryItemRatesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetInventoryItemRatesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetInventoryItemRatesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetInventoryItemRatesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetInventoryItemRatesLOVExecute(r)
}

/*
GetInventoryItemRatesLOV Fetch List Of Values for Inventory Item Rates

 <p><strong>OperationId:</strong>getInventoryItemRatesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param itemId Value of the parameter 'itemId' which is required to fetch InventoryItemRates LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch InventoryItemRates LOV
 @return LOVApiGetInventoryItemRatesLOVRequest
*/
func (a *LOVApiService) GetInventoryItemRatesLOV(ctx context.Context, itemId string, hotelId string) LOVApiGetInventoryItemRatesLOVRequest {
	return LOVApiGetInventoryItemRatesLOVRequest{
		ApiService: a,
		ctx: ctx,
		itemId: itemId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetInventoryItemRatesLOVExecute(r LOVApiGetInventoryItemRatesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetInventoryItemRatesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/itemId/{itemId}/inventoryItemRates"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.itemId) < 1 {
		return localVarReturnValue, nil, reportError("itemId must have at least 1 elements")
	}
	if strlen(r.itemId) > 2000 {
		return localVarReturnValue, nil, reportError("itemId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetInventoryItemTemplateItemsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetInventoryItemTemplateItemsLOVRequest) Authorization(authorization string) LOVApiGetInventoryItemTemplateItemsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetInventoryItemTemplateItemsLOVRequest) XAppKey(xAppKey string) LOVApiGetInventoryItemTemplateItemsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetInventoryItemTemplateItemsLOVRequest) XHotelid(xHotelid string) LOVApiGetInventoryItemTemplateItemsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetInventoryItemTemplateItemsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetInventoryItemTemplateItemsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetInventoryItemTemplateItemsLOVRequest) ParameterName(parameterName []string) LOVApiGetInventoryItemTemplateItemsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetInventoryItemTemplateItemsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetInventoryItemTemplateItemsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetInventoryItemTemplateItemsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetInventoryItemTemplateItemsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetInventoryItemTemplateItemsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetInventoryItemTemplateItemsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetInventoryItemTemplateItemsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetInventoryItemTemplateItemsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetInventoryItemTemplateItemsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetInventoryItemTemplateItemsLOVExecute(r)
}

/*
GetInventoryItemTemplateItemsLOV Fetch List Of Values for Inventory Item Template Items

 <p><strong>OperationId:</strong>getInventoryItemTemplateItemsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch InventoryItemTemplateItems LOV
 @return LOVApiGetInventoryItemTemplateItemsLOVRequest
*/
func (a *LOVApiService) GetInventoryItemTemplateItemsLOV(ctx context.Context, hotelId string) LOVApiGetInventoryItemTemplateItemsLOVRequest {
	return LOVApiGetInventoryItemTemplateItemsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetInventoryItemTemplateItemsLOVExecute(r LOVApiGetInventoryItemTemplateItemsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetInventoryItemTemplateItemsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/inventoryItemTemplateItems"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetInventoryItemsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	sellInEvent string
	sellInReservation string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetInventoryItemsLOVRequest) Authorization(authorization string) LOVApiGetInventoryItemsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetInventoryItemsLOVRequest) XAppKey(xAppKey string) LOVApiGetInventoryItemsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetInventoryItemsLOVRequest) XHotelid(xHotelid string) LOVApiGetInventoryItemsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetInventoryItemsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetInventoryItemsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetInventoryItemsLOVRequest) ParameterName(parameterName []string) LOVApiGetInventoryItemsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetInventoryItemsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetInventoryItemsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetInventoryItemsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetInventoryItemsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetInventoryItemsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetInventoryItemsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetInventoryItemsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetInventoryItemsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetInventoryItemsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetInventoryItemsLOVExecute(r)
}

/*
GetInventoryItemsLOV Fetch List Of Values for Inventory Items

 <p><strong>OperationId:</strong>getInventoryItemsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sellInEvent Value of the parameter 'sellInEvent' which is required to fetch InventoryItems LOV
 @param sellInReservation Value of the parameter 'sellInReservation' which is required to fetch InventoryItems LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch InventoryItems LOV
 @return LOVApiGetInventoryItemsLOVRequest
*/
func (a *LOVApiService) GetInventoryItemsLOV(ctx context.Context, sellInEvent string, sellInReservation string, hotelId string) LOVApiGetInventoryItemsLOVRequest {
	return LOVApiGetInventoryItemsLOVRequest{
		ApiService: a,
		ctx: ctx,
		sellInEvent: sellInEvent,
		sellInReservation: sellInReservation,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetInventoryItemsLOVExecute(r LOVApiGetInventoryItemsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetInventoryItemsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/sellInReservation/{sellInReservation}/sellInEvent/{sellInEvent}/inventoryItems"
	localVarPath = strings.Replace(localVarPath, "{"+"sellInEvent"+"}", url.PathEscape(parameterValueToString(r.sellInEvent, "sellInEvent")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sellInReservation"+"}", url.PathEscape(parameterValueToString(r.sellInReservation, "sellInReservation")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.sellInEvent) < 1 {
		return localVarReturnValue, nil, reportError("sellInEvent must have at least 1 elements")
	}
	if strlen(r.sellInEvent) > 2000 {
		return localVarReturnValue, nil, reportError("sellInEvent must have less than 2000 elements")
	}
	if strlen(r.sellInReservation) < 1 {
		return localVarReturnValue, nil, reportError("sellInReservation must have at least 1 elements")
	}
	if strlen(r.sellInReservation) > 2000 {
		return localVarReturnValue, nil, reportError("sellInReservation must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetItemClassesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetItemClassesLOVRequest) Authorization(authorization string) LOVApiGetItemClassesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetItemClassesLOVRequest) XAppKey(xAppKey string) LOVApiGetItemClassesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetItemClassesLOVRequest) XHotelid(xHotelid string) LOVApiGetItemClassesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetItemClassesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetItemClassesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetItemClassesLOVRequest) ParameterName(parameterName []string) LOVApiGetItemClassesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetItemClassesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetItemClassesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetItemClassesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetItemClassesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetItemClassesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetItemClassesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetItemClassesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetItemClassesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetItemClassesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetItemClassesLOVExecute(r)
}

/*
GetItemClassesLOV Fetch List Of Values for Item Classes

 <p><strong>OperationId:</strong>getItemClassesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ItemClasses LOV
 @return LOVApiGetItemClassesLOVRequest
*/
func (a *LOVApiService) GetItemClassesLOV(ctx context.Context, hotelId string) LOVApiGetItemClassesLOVRequest {
	return LOVApiGetItemClassesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetItemClassesLOVExecute(r LOVApiGetItemClassesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetItemClassesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/itemClasses"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetItemCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetItemCodesLOVRequest) Authorization(authorization string) LOVApiGetItemCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetItemCodesLOVRequest) XAppKey(xAppKey string) LOVApiGetItemCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetItemCodesLOVRequest) XHotelid(xHotelid string) LOVApiGetItemCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetItemCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetItemCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetItemCodesLOVRequest) ParameterName(parameterName []string) LOVApiGetItemCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetItemCodesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetItemCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetItemCodesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetItemCodesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetItemCodesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetItemCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetItemCodesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetItemCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetItemCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetItemCodesLOVExecute(r)
}

/*
GetItemCodesLOV Fetch List Of Values for Item Codes

 <p><strong>OperationId:</strong>getItemCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ItemCodes LOV
 @return LOVApiGetItemCodesLOVRequest
*/
func (a *LOVApiService) GetItemCodesLOV(ctx context.Context, hotelId string) LOVApiGetItemCodesLOVRequest {
	return LOVApiGetItemCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetItemCodesLOVExecute(r LOVApiGetItemCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetItemCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/itemCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetItemPriceCodeLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	itemId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetItemPriceCodeLOVRequest) Authorization(authorization string) LOVApiGetItemPriceCodeLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetItemPriceCodeLOVRequest) XAppKey(xAppKey string) LOVApiGetItemPriceCodeLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetItemPriceCodeLOVRequest) XHotelid(xHotelid string) LOVApiGetItemPriceCodeLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetItemPriceCodeLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetItemPriceCodeLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetItemPriceCodeLOVRequest) ParameterName(parameterName []string) LOVApiGetItemPriceCodeLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetItemPriceCodeLOVRequest) ParameterValue(parameterValue []string) LOVApiGetItemPriceCodeLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetItemPriceCodeLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetItemPriceCodeLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetItemPriceCodeLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetItemPriceCodeLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetItemPriceCodeLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetItemPriceCodeLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetItemPriceCodeLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetItemPriceCodeLOVExecute(r)
}

/*
GetItemPriceCodeLOV Fetch List Of Values for Item Price Code

 <p><strong>OperationId:</strong>getItemPriceCodeLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param itemId Value of the parameter 'itemId' which is required to fetch ItemPriceCode LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ItemPriceCode LOV
 @return LOVApiGetItemPriceCodeLOVRequest
*/
func (a *LOVApiService) GetItemPriceCodeLOV(ctx context.Context, itemId string, hotelId string) LOVApiGetItemPriceCodeLOVRequest {
	return LOVApiGetItemPriceCodeLOVRequest{
		ApiService: a,
		ctx: ctx,
		itemId: itemId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetItemPriceCodeLOVExecute(r LOVApiGetItemPriceCodeLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetItemPriceCodeLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/itemId/{itemId}/itemPriceCode"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.itemId) < 1 {
		return localVarReturnValue, nil, reportError("itemId must have at least 1 elements")
	}
	if strlen(r.itemId) > 2000 {
		return localVarReturnValue, nil, reportError("itemId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetItemVendorLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	itemId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetItemVendorLOVRequest) Authorization(authorization string) LOVApiGetItemVendorLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetItemVendorLOVRequest) XAppKey(xAppKey string) LOVApiGetItemVendorLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetItemVendorLOVRequest) XHotelid(xHotelid string) LOVApiGetItemVendorLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetItemVendorLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetItemVendorLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetItemVendorLOVRequest) ParameterName(parameterName []string) LOVApiGetItemVendorLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetItemVendorLOVRequest) ParameterValue(parameterValue []string) LOVApiGetItemVendorLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetItemVendorLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetItemVendorLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetItemVendorLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetItemVendorLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetItemVendorLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetItemVendorLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetItemVendorLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetItemVendorLOVExecute(r)
}

/*
GetItemVendorLOV Fetch List Of Values for Item Vendor

 <p><strong>OperationId:</strong>getItemVendorLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param itemId Value of the parameter 'itemId' which is required to fetch ItemVendor LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ItemVendor LOV
 @return LOVApiGetItemVendorLOVRequest
*/
func (a *LOVApiService) GetItemVendorLOV(ctx context.Context, itemId string, hotelId string) LOVApiGetItemVendorLOVRequest {
	return LOVApiGetItemVendorLOVRequest{
		ApiService: a,
		ctx: ctx,
		itemId: itemId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetItemVendorLOVExecute(r LOVApiGetItemVendorLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetItemVendorLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/itemId/{itemId}/itemVendor"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.itemId) < 1 {
		return localVarReturnValue, nil, reportError("itemId must have at least 1 elements")
	}
	if strlen(r.itemId) > 2000 {
		return localVarReturnValue, nil, reportError("itemId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetJobTitlesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetJobTitlesLOVRequest) Authorization(authorization string) LOVApiGetJobTitlesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetJobTitlesLOVRequest) XAppKey(xAppKey string) LOVApiGetJobTitlesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetJobTitlesLOVRequest) XHotelid(xHotelid string) LOVApiGetJobTitlesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetJobTitlesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetJobTitlesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetJobTitlesLOVRequest) ParameterName(parameterName []string) LOVApiGetJobTitlesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetJobTitlesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetJobTitlesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetJobTitlesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetJobTitlesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetJobTitlesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetJobTitlesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetJobTitlesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetJobTitlesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetJobTitlesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetJobTitlesLOVExecute(r)
}

/*
GetJobTitlesLOV Fetch List Of Values for Job Titles

 <p><strong>OperationId:</strong>getJobTitlesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch JobTitles LOV
 @return LOVApiGetJobTitlesLOVRequest
*/
func (a *LOVApiService) GetJobTitlesLOV(ctx context.Context, hotelId string) LOVApiGetJobTitlesLOVRequest {
	return LOVApiGetJobTitlesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetJobTitlesLOVExecute(r LOVApiGetJobTitlesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetJobTitlesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/jobTitles"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetKeyOptionsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetKeyOptionsLOVRequest) Authorization(authorization string) LOVApiGetKeyOptionsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetKeyOptionsLOVRequest) XAppKey(xAppKey string) LOVApiGetKeyOptionsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetKeyOptionsLOVRequest) XHotelid(xHotelid string) LOVApiGetKeyOptionsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetKeyOptionsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetKeyOptionsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetKeyOptionsLOVRequest) ParameterName(parameterName []string) LOVApiGetKeyOptionsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetKeyOptionsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetKeyOptionsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetKeyOptionsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetKeyOptionsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetKeyOptionsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetKeyOptionsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetKeyOptionsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetKeyOptionsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetKeyOptionsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetKeyOptionsLOVExecute(r)
}

/*
GetKeyOptionsLOV Fetch List Of Values for Key Options

 <p><strong>OperationId:</strong>getKeyOptionsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch KeyOptions LOV
 @return LOVApiGetKeyOptionsLOVRequest
*/
func (a *LOVApiService) GetKeyOptionsLOV(ctx context.Context, hotelId string) LOVApiGetKeyOptionsLOVRequest {
	return LOVApiGetKeyOptionsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetKeyOptionsLOVExecute(r LOVApiGetKeyOptionsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetKeyOptionsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/keyOptions"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetLOVNamesRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetLOVNamesRequest) Authorization(authorization string) LOVApiGetLOVNamesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetLOVNamesRequest) XAppKey(xAppKey string) LOVApiGetLOVNamesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetLOVNamesRequest) XHotelid(xHotelid string) LOVApiGetLOVNamesRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r LOVApiGetLOVNamesRequest) XExternalsystem(xExternalsystem string) LOVApiGetLOVNamesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetLOVNamesRequest) AcceptLanguage(acceptLanguage string) LOVApiGetLOVNamesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetLOVNamesRequest) Execute() (*ListOfValueNames, *http.Response, error) {
	return r.ApiService.GetLOVNamesExecute(r)
}

/*
GetLOVNames Fetch Names

 <p><strong>OperationId:</strong>getLOVNames</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LOVApiGetLOVNamesRequest
*/
func (a *LOVApiService) GetLOVNames(ctx context.Context) LOVApiGetLOVNamesRequest {
	return LOVApiGetLOVNamesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListOfValueNames
func (a *LOVApiService) GetLOVNamesExecute(r LOVApiGetLOVNamesRequest) (*ListOfValueNames, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValueNames
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetLOVNames")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetLicensesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetLicensesLOVRequest) Authorization(authorization string) LOVApiGetLicensesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetLicensesLOVRequest) XAppKey(xAppKey string) LOVApiGetLicensesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetLicensesLOVRequest) XHotelid(xHotelid string) LOVApiGetLicensesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetLicensesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetLicensesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetLicensesLOVRequest) ParameterName(parameterName []string) LOVApiGetLicensesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetLicensesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetLicensesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetLicensesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetLicensesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetLicensesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetLicensesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetLicensesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetLicensesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetLicensesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetLicensesLOVExecute(r)
}

/*
GetLicensesLOV Fetch List Of Values for Licenses

 <p><strong>OperationId:</strong>getLicensesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch Licenses LOV
 @return LOVApiGetLicensesLOVRequest
*/
func (a *LOVApiService) GetLicensesLOV(ctx context.Context, hotelId string) LOVApiGetLicensesLOVRequest {
	return LOVApiGetLicensesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetLicensesLOVExecute(r LOVApiGetLicensesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetLicensesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/licenses"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetListOfValuesRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	name string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetListOfValuesRequest) Authorization(authorization string) LOVApiGetListOfValuesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetListOfValuesRequest) XAppKey(xAppKey string) LOVApiGetListOfValuesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetListOfValuesRequest) XHotelid(xHotelid string) LOVApiGetListOfValuesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetListOfValuesRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetListOfValuesRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetListOfValuesRequest) ParameterName(parameterName []string) LOVApiGetListOfValuesRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetListOfValuesRequest) ParameterValue(parameterValue []string) LOVApiGetListOfValuesRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetListOfValuesRequest) ExcludeCodes(excludeCodes []string) LOVApiGetListOfValuesRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetListOfValuesRequest) XExternalsystem(xExternalsystem string) LOVApiGetListOfValuesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetListOfValuesRequest) AcceptLanguage(acceptLanguage string) LOVApiGetListOfValuesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetListOfValuesRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetListOfValuesExecute(r)
}

/*
GetListOfValues Fetch List Of Values for the given name of the LOV

 <p><strong>OperationId:</strong>getListOfValues</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name LOV Name which is required to fetch the values
 @return LOVApiGetListOfValuesRequest
*/
func (a *LOVApiService) GetListOfValues(ctx context.Context, name string) LOVApiGetListOfValuesRequest {
	return LOVApiGetListOfValuesRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetListOfValuesExecute(r LOVApiGetListOfValuesRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetListOfValues")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.name) < 1 {
		return localVarReturnValue, nil, reportError("name must have at least 1 elements")
	}
	if strlen(r.name) > 2000 {
		return localVarReturnValue, nil, reportError("name must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetLocatorQuickTextsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetLocatorQuickTextsLOVRequest) Authorization(authorization string) LOVApiGetLocatorQuickTextsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetLocatorQuickTextsLOVRequest) XAppKey(xAppKey string) LOVApiGetLocatorQuickTextsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetLocatorQuickTextsLOVRequest) XHotelid(xHotelid string) LOVApiGetLocatorQuickTextsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetLocatorQuickTextsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetLocatorQuickTextsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetLocatorQuickTextsLOVRequest) ParameterName(parameterName []string) LOVApiGetLocatorQuickTextsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetLocatorQuickTextsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetLocatorQuickTextsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetLocatorQuickTextsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetLocatorQuickTextsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetLocatorQuickTextsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetLocatorQuickTextsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetLocatorQuickTextsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetLocatorQuickTextsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetLocatorQuickTextsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetLocatorQuickTextsLOVExecute(r)
}

/*
GetLocatorQuickTextsLOV Fetch List Of Values for Locator Quick Texts

 <p><strong>OperationId:</strong>getLocatorQuickTextsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch LocatorQuickTexts LOV
 @return LOVApiGetLocatorQuickTextsLOVRequest
*/
func (a *LOVApiService) GetLocatorQuickTextsLOV(ctx context.Context, hotelId string) LOVApiGetLocatorQuickTextsLOVRequest {
	return LOVApiGetLocatorQuickTextsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetLocatorQuickTextsLOVExecute(r LOVApiGetLocatorQuickTextsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetLocatorQuickTextsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/locatorQuickTexts"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetMailGenericLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	sourceIdIn string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetMailGenericLOVRequest) Authorization(authorization string) LOVApiGetMailGenericLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetMailGenericLOVRequest) XAppKey(xAppKey string) LOVApiGetMailGenericLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetMailGenericLOVRequest) XHotelid(xHotelid string) LOVApiGetMailGenericLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetMailGenericLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetMailGenericLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetMailGenericLOVRequest) ParameterName(parameterName []string) LOVApiGetMailGenericLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetMailGenericLOVRequest) ParameterValue(parameterValue []string) LOVApiGetMailGenericLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetMailGenericLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetMailGenericLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetMailGenericLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetMailGenericLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetMailGenericLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetMailGenericLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetMailGenericLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetMailGenericLOVExecute(r)
}

/*
GetMailGenericLOV Fetch List Of Values for Mail Generic

 <p><strong>OperationId:</strong>getMailGenericLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sourceIdIn Value of the parameter 'sourceIdIn' which is required to fetch MailGeneric LOV
 @return LOVApiGetMailGenericLOVRequest
*/
func (a *LOVApiService) GetMailGenericLOV(ctx context.Context, sourceIdIn string) LOVApiGetMailGenericLOVRequest {
	return LOVApiGetMailGenericLOVRequest{
		ApiService: a,
		ctx: ctx,
		sourceIdIn: sourceIdIn,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetMailGenericLOVExecute(r LOVApiGetMailGenericLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetMailGenericLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/sourceIdIn/{sourceIdIn}/mailGeneric"
	localVarPath = strings.Replace(localVarPath, "{"+"sourceIdIn"+"}", url.PathEscape(parameterValueToString(r.sourceIdIn, "sourceIdIn")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.sourceIdIn) < 1 {
		return localVarReturnValue, nil, reportError("sourceIdIn must have at least 1 elements")
	}
	if strlen(r.sourceIdIn) > 2000 {
		return localVarReturnValue, nil, reportError("sourceIdIn must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetManagerReportDetailsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetManagerReportDetailsLOVRequest) Authorization(authorization string) LOVApiGetManagerReportDetailsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetManagerReportDetailsLOVRequest) XAppKey(xAppKey string) LOVApiGetManagerReportDetailsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetManagerReportDetailsLOVRequest) XHotelid(xHotelid string) LOVApiGetManagerReportDetailsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetManagerReportDetailsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetManagerReportDetailsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetManagerReportDetailsLOVRequest) ParameterName(parameterName []string) LOVApiGetManagerReportDetailsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetManagerReportDetailsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetManagerReportDetailsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetManagerReportDetailsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetManagerReportDetailsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetManagerReportDetailsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetManagerReportDetailsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetManagerReportDetailsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetManagerReportDetailsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetManagerReportDetailsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetManagerReportDetailsLOVExecute(r)
}

/*
GetManagerReportDetailsLOV Fetch List Of Values for Manager Report Details

 <p><strong>OperationId:</strong>getManagerReportDetailsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ManagerReportDetails LOV
 @return LOVApiGetManagerReportDetailsLOVRequest
*/
func (a *LOVApiService) GetManagerReportDetailsLOV(ctx context.Context, hotelId string) LOVApiGetManagerReportDetailsLOVRequest {
	return LOVApiGetManagerReportDetailsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetManagerReportDetailsLOVExecute(r LOVApiGetManagerReportDetailsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetManagerReportDetailsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/managerReportDetails"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetManagersReportsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetManagersReportsLOVRequest) Authorization(authorization string) LOVApiGetManagersReportsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetManagersReportsLOVRequest) XAppKey(xAppKey string) LOVApiGetManagersReportsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetManagersReportsLOVRequest) XHotelid(xHotelid string) LOVApiGetManagersReportsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetManagersReportsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetManagersReportsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetManagersReportsLOVRequest) ParameterName(parameterName []string) LOVApiGetManagersReportsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetManagersReportsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetManagersReportsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetManagersReportsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetManagersReportsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetManagersReportsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetManagersReportsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetManagersReportsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetManagersReportsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetManagersReportsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetManagersReportsLOVExecute(r)
}

/*
GetManagersReportsLOV Fetch List Of Values for Managers Reports

 <p><strong>OperationId:</strong>getManagersReportsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ManagersReports LOV
 @return LOVApiGetManagersReportsLOVRequest
*/
func (a *LOVApiService) GetManagersReportsLOV(ctx context.Context, hotelId string) LOVApiGetManagersReportsLOVRequest {
	return LOVApiGetManagersReportsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetManagersReportsLOVExecute(r LOVApiGetManagersReportsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetManagersReportsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/managersReports"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetMarketGroupsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetMarketGroupsLOVRequest) Authorization(authorization string) LOVApiGetMarketGroupsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetMarketGroupsLOVRequest) XAppKey(xAppKey string) LOVApiGetMarketGroupsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetMarketGroupsLOVRequest) XHotelid(xHotelid string) LOVApiGetMarketGroupsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetMarketGroupsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetMarketGroupsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetMarketGroupsLOVRequest) ParameterName(parameterName []string) LOVApiGetMarketGroupsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetMarketGroupsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetMarketGroupsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetMarketGroupsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetMarketGroupsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetMarketGroupsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetMarketGroupsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetMarketGroupsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetMarketGroupsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetMarketGroupsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetMarketGroupsLOVExecute(r)
}

/*
GetMarketGroupsLOV Fetch List Of Values for Market Groups

 <p><strong>OperationId:</strong>getMarketGroupsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch MarketGroups LOV
 @return LOVApiGetMarketGroupsLOVRequest
*/
func (a *LOVApiService) GetMarketGroupsLOV(ctx context.Context, hotelId string) LOVApiGetMarketGroupsLOVRequest {
	return LOVApiGetMarketGroupsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetMarketGroupsLOVExecute(r LOVApiGetMarketGroupsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetMarketGroupsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/marketGroups"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetMarketSegmentLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetMarketSegmentLOVRequest) Authorization(authorization string) LOVApiGetMarketSegmentLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetMarketSegmentLOVRequest) XAppKey(xAppKey string) LOVApiGetMarketSegmentLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetMarketSegmentLOVRequest) XHotelid(xHotelid string) LOVApiGetMarketSegmentLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetMarketSegmentLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetMarketSegmentLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetMarketSegmentLOVRequest) ParameterName(parameterName []string) LOVApiGetMarketSegmentLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetMarketSegmentLOVRequest) ParameterValue(parameterValue []string) LOVApiGetMarketSegmentLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetMarketSegmentLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetMarketSegmentLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetMarketSegmentLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetMarketSegmentLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetMarketSegmentLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetMarketSegmentLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetMarketSegmentLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetMarketSegmentLOVExecute(r)
}

/*
GetMarketSegmentLOV Fetch List Of Values for Market Segment

 <p><strong>OperationId:</strong>getMarketSegmentLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch MarketSegment LOV
 @return LOVApiGetMarketSegmentLOVRequest
*/
func (a *LOVApiService) GetMarketSegmentLOV(ctx context.Context, hotelId string) LOVApiGetMarketSegmentLOVRequest {
	return LOVApiGetMarketSegmentLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetMarketSegmentLOVExecute(r LOVApiGetMarketSegmentLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetMarketSegmentLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/marketSegment"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetMasterBlockLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetMasterBlockLOVRequest) Authorization(authorization string) LOVApiGetMasterBlockLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetMasterBlockLOVRequest) XAppKey(xAppKey string) LOVApiGetMasterBlockLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetMasterBlockLOVRequest) XHotelid(xHotelid string) LOVApiGetMasterBlockLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetMasterBlockLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetMasterBlockLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetMasterBlockLOVRequest) ParameterName(parameterName []string) LOVApiGetMasterBlockLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetMasterBlockLOVRequest) ParameterValue(parameterValue []string) LOVApiGetMasterBlockLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetMasterBlockLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetMasterBlockLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetMasterBlockLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetMasterBlockLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetMasterBlockLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetMasterBlockLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetMasterBlockLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetMasterBlockLOVExecute(r)
}

/*
GetMasterBlockLOV Fetch List Of Values for Master Block

 <p><strong>OperationId:</strong>getMasterBlockLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch MasterBlock LOV
 @return LOVApiGetMasterBlockLOVRequest
*/
func (a *LOVApiService) GetMasterBlockLOV(ctx context.Context, hotelId string) LOVApiGetMasterBlockLOVRequest {
	return LOVApiGetMasterBlockLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetMasterBlockLOVExecute(r LOVApiGetMasterBlockLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetMasterBlockLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/masterBlock"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetMembershipAwardFinTrxLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetMembershipAwardFinTrxLOVRequest) Authorization(authorization string) LOVApiGetMembershipAwardFinTrxLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetMembershipAwardFinTrxLOVRequest) XAppKey(xAppKey string) LOVApiGetMembershipAwardFinTrxLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetMembershipAwardFinTrxLOVRequest) XHotelid(xHotelid string) LOVApiGetMembershipAwardFinTrxLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetMembershipAwardFinTrxLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetMembershipAwardFinTrxLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetMembershipAwardFinTrxLOVRequest) ParameterName(parameterName []string) LOVApiGetMembershipAwardFinTrxLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetMembershipAwardFinTrxLOVRequest) ParameterValue(parameterValue []string) LOVApiGetMembershipAwardFinTrxLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetMembershipAwardFinTrxLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetMembershipAwardFinTrxLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetMembershipAwardFinTrxLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetMembershipAwardFinTrxLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetMembershipAwardFinTrxLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetMembershipAwardFinTrxLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetMembershipAwardFinTrxLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetMembershipAwardFinTrxLOVExecute(r)
}

/*
GetMembershipAwardFinTrxLOV Fetch List Of Values for Membership Award Fin Trx

 <p><strong>OperationId:</strong>getMembershipAwardFinTrxLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch MembershipAwardFinTrx LOV
 @return LOVApiGetMembershipAwardFinTrxLOVRequest
*/
func (a *LOVApiService) GetMembershipAwardFinTrxLOV(ctx context.Context, hotelId string) LOVApiGetMembershipAwardFinTrxLOVRequest {
	return LOVApiGetMembershipAwardFinTrxLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetMembershipAwardFinTrxLOVExecute(r LOVApiGetMembershipAwardFinTrxLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetMembershipAwardFinTrxLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/membershipAwardFinTrx"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetMembershipAwardProductsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetMembershipAwardProductsLOVRequest) Authorization(authorization string) LOVApiGetMembershipAwardProductsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetMembershipAwardProductsLOVRequest) XAppKey(xAppKey string) LOVApiGetMembershipAwardProductsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetMembershipAwardProductsLOVRequest) XHotelid(xHotelid string) LOVApiGetMembershipAwardProductsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetMembershipAwardProductsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetMembershipAwardProductsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetMembershipAwardProductsLOVRequest) ParameterName(parameterName []string) LOVApiGetMembershipAwardProductsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetMembershipAwardProductsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetMembershipAwardProductsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetMembershipAwardProductsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetMembershipAwardProductsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetMembershipAwardProductsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetMembershipAwardProductsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetMembershipAwardProductsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetMembershipAwardProductsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetMembershipAwardProductsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetMembershipAwardProductsLOVExecute(r)
}

/*
GetMembershipAwardProductsLOV Fetch List Of Values for Membership Award Products

 <p><strong>OperationId:</strong>getMembershipAwardProductsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch MembershipAwardProducts LOV
 @return LOVApiGetMembershipAwardProductsLOVRequest
*/
func (a *LOVApiService) GetMembershipAwardProductsLOV(ctx context.Context, hotelId string) LOVApiGetMembershipAwardProductsLOVRequest {
	return LOVApiGetMembershipAwardProductsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetMembershipAwardProductsLOVExecute(r LOVApiGetMembershipAwardProductsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetMembershipAwardProductsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/membershipAwardProducts"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetMembershipAwardRateCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetMembershipAwardRateCodesLOVRequest) Authorization(authorization string) LOVApiGetMembershipAwardRateCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetMembershipAwardRateCodesLOVRequest) XAppKey(xAppKey string) LOVApiGetMembershipAwardRateCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetMembershipAwardRateCodesLOVRequest) XHotelid(xHotelid string) LOVApiGetMembershipAwardRateCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetMembershipAwardRateCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetMembershipAwardRateCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetMembershipAwardRateCodesLOVRequest) ParameterName(parameterName []string) LOVApiGetMembershipAwardRateCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetMembershipAwardRateCodesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetMembershipAwardRateCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetMembershipAwardRateCodesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetMembershipAwardRateCodesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetMembershipAwardRateCodesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetMembershipAwardRateCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetMembershipAwardRateCodesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetMembershipAwardRateCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetMembershipAwardRateCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetMembershipAwardRateCodesLOVExecute(r)
}

/*
GetMembershipAwardRateCodesLOV Fetch List Of Values for Membership Award Rate Codes

 <p><strong>OperationId:</strong>getMembershipAwardRateCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch MembershipAwardRateCodes LOV
 @return LOVApiGetMembershipAwardRateCodesLOVRequest
*/
func (a *LOVApiService) GetMembershipAwardRateCodesLOV(ctx context.Context, hotelId string) LOVApiGetMembershipAwardRateCodesLOVRequest {
	return LOVApiGetMembershipAwardRateCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetMembershipAwardRateCodesLOVExecute(r LOVApiGetMembershipAwardRateCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetMembershipAwardRateCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/membershipAwardRateCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetMembershipAwardUpgradeRoomGroupLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetMembershipAwardUpgradeRoomGroupLOVRequest) Authorization(authorization string) LOVApiGetMembershipAwardUpgradeRoomGroupLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetMembershipAwardUpgradeRoomGroupLOVRequest) XAppKey(xAppKey string) LOVApiGetMembershipAwardUpgradeRoomGroupLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetMembershipAwardUpgradeRoomGroupLOVRequest) XHotelid(xHotelid string) LOVApiGetMembershipAwardUpgradeRoomGroupLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetMembershipAwardUpgradeRoomGroupLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetMembershipAwardUpgradeRoomGroupLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetMembershipAwardUpgradeRoomGroupLOVRequest) ParameterName(parameterName []string) LOVApiGetMembershipAwardUpgradeRoomGroupLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetMembershipAwardUpgradeRoomGroupLOVRequest) ParameterValue(parameterValue []string) LOVApiGetMembershipAwardUpgradeRoomGroupLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetMembershipAwardUpgradeRoomGroupLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetMembershipAwardUpgradeRoomGroupLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetMembershipAwardUpgradeRoomGroupLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetMembershipAwardUpgradeRoomGroupLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetMembershipAwardUpgradeRoomGroupLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetMembershipAwardUpgradeRoomGroupLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetMembershipAwardUpgradeRoomGroupLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetMembershipAwardUpgradeRoomGroupLOVExecute(r)
}

/*
GetMembershipAwardUpgradeRoomGroupLOV Fetch List Of Values for Membership Award Upgrade Room Group

 <p><strong>OperationId:</strong>getMembershipAwardUpgradeRoomGroupLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch MembershipAwardUpgradeRoomGroup LOV
 @return LOVApiGetMembershipAwardUpgradeRoomGroupLOVRequest
*/
func (a *LOVApiService) GetMembershipAwardUpgradeRoomGroupLOV(ctx context.Context, hotelId string) LOVApiGetMembershipAwardUpgradeRoomGroupLOVRequest {
	return LOVApiGetMembershipAwardUpgradeRoomGroupLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetMembershipAwardUpgradeRoomGroupLOVExecute(r LOVApiGetMembershipAwardUpgradeRoomGroupLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetMembershipAwardUpgradeRoomGroupLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/membershipAwardUpgradeRoomGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetMembershipAwardUpgradeRoomLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetMembershipAwardUpgradeRoomLOVRequest) Authorization(authorization string) LOVApiGetMembershipAwardUpgradeRoomLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetMembershipAwardUpgradeRoomLOVRequest) XAppKey(xAppKey string) LOVApiGetMembershipAwardUpgradeRoomLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetMembershipAwardUpgradeRoomLOVRequest) XHotelid(xHotelid string) LOVApiGetMembershipAwardUpgradeRoomLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetMembershipAwardUpgradeRoomLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetMembershipAwardUpgradeRoomLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetMembershipAwardUpgradeRoomLOVRequest) ParameterName(parameterName []string) LOVApiGetMembershipAwardUpgradeRoomLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetMembershipAwardUpgradeRoomLOVRequest) ParameterValue(parameterValue []string) LOVApiGetMembershipAwardUpgradeRoomLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetMembershipAwardUpgradeRoomLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetMembershipAwardUpgradeRoomLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetMembershipAwardUpgradeRoomLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetMembershipAwardUpgradeRoomLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetMembershipAwardUpgradeRoomLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetMembershipAwardUpgradeRoomLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetMembershipAwardUpgradeRoomLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetMembershipAwardUpgradeRoomLOVExecute(r)
}

/*
GetMembershipAwardUpgradeRoomLOV Fetch List Of Values for Membership Award Upgrade Room

 <p><strong>OperationId:</strong>getMembershipAwardUpgradeRoomLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch MembershipAwardUpgradeRoom LOV
 @return LOVApiGetMembershipAwardUpgradeRoomLOVRequest
*/
func (a *LOVApiService) GetMembershipAwardUpgradeRoomLOV(ctx context.Context, hotelId string) LOVApiGetMembershipAwardUpgradeRoomLOVRequest {
	return LOVApiGetMembershipAwardUpgradeRoomLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetMembershipAwardUpgradeRoomLOVExecute(r LOVApiGetMembershipAwardUpgradeRoomLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetMembershipAwardUpgradeRoomLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/membershipAwardUpgradeRoom"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetMembershipBenefitProgramLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	membershipType string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetMembershipBenefitProgramLOVRequest) Authorization(authorization string) LOVApiGetMembershipBenefitProgramLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetMembershipBenefitProgramLOVRequest) XAppKey(xAppKey string) LOVApiGetMembershipBenefitProgramLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetMembershipBenefitProgramLOVRequest) XHotelid(xHotelid string) LOVApiGetMembershipBenefitProgramLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetMembershipBenefitProgramLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetMembershipBenefitProgramLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetMembershipBenefitProgramLOVRequest) ParameterName(parameterName []string) LOVApiGetMembershipBenefitProgramLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetMembershipBenefitProgramLOVRequest) ParameterValue(parameterValue []string) LOVApiGetMembershipBenefitProgramLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetMembershipBenefitProgramLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetMembershipBenefitProgramLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetMembershipBenefitProgramLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetMembershipBenefitProgramLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetMembershipBenefitProgramLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetMembershipBenefitProgramLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetMembershipBenefitProgramLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetMembershipBenefitProgramLOVExecute(r)
}

/*
GetMembershipBenefitProgramLOV Fetch List Of Values for Membership Benefit Program

 <p><strong>OperationId:</strong>getMembershipBenefitProgramLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param membershipType Value of the parameter 'membershipType' which is required to fetch MembershipBenefitProgram LOV
 @return LOVApiGetMembershipBenefitProgramLOVRequest
*/
func (a *LOVApiService) GetMembershipBenefitProgramLOV(ctx context.Context, membershipType string) LOVApiGetMembershipBenefitProgramLOVRequest {
	return LOVApiGetMembershipBenefitProgramLOVRequest{
		ApiService: a,
		ctx: ctx,
		membershipType: membershipType,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetMembershipBenefitProgramLOVExecute(r LOVApiGetMembershipBenefitProgramLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetMembershipBenefitProgramLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/membershipType/{membershipType}/membershipBenefitProgram"
	localVarPath = strings.Replace(localVarPath, "{"+"membershipType"+"}", url.PathEscape(parameterValueToString(r.membershipType, "membershipType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.membershipType) < 1 {
		return localVarReturnValue, nil, reportError("membershipType must have at least 1 elements")
	}
	if strlen(r.membershipType) > 2000 {
		return localVarReturnValue, nil, reportError("membershipType must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetMembershipBenefitsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	membershipType string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetMembershipBenefitsLOVRequest) Authorization(authorization string) LOVApiGetMembershipBenefitsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetMembershipBenefitsLOVRequest) XAppKey(xAppKey string) LOVApiGetMembershipBenefitsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetMembershipBenefitsLOVRequest) XHotelid(xHotelid string) LOVApiGetMembershipBenefitsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetMembershipBenefitsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetMembershipBenefitsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetMembershipBenefitsLOVRequest) ParameterName(parameterName []string) LOVApiGetMembershipBenefitsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetMembershipBenefitsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetMembershipBenefitsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetMembershipBenefitsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetMembershipBenefitsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetMembershipBenefitsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetMembershipBenefitsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetMembershipBenefitsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetMembershipBenefitsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetMembershipBenefitsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetMembershipBenefitsLOVExecute(r)
}

/*
GetMembershipBenefitsLOV Fetch List Of Values for Membership Benefits

 <p><strong>OperationId:</strong>getMembershipBenefitsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param membershipType Value of the parameter 'membershipType' which is required to fetch MembershipBenefits LOV
 @return LOVApiGetMembershipBenefitsLOVRequest
*/
func (a *LOVApiService) GetMembershipBenefitsLOV(ctx context.Context, membershipType string) LOVApiGetMembershipBenefitsLOVRequest {
	return LOVApiGetMembershipBenefitsLOVRequest{
		ApiService: a,
		ctx: ctx,
		membershipType: membershipType,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetMembershipBenefitsLOVExecute(r LOVApiGetMembershipBenefitsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetMembershipBenefitsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/membershipType/{membershipType}/membershipBenefits"
	localVarPath = strings.Replace(localVarPath, "{"+"membershipType"+"}", url.PathEscape(parameterValueToString(r.membershipType, "membershipType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.membershipType) < 1 {
		return localVarReturnValue, nil, reportError("membershipType must have at least 1 elements")
	}
	if strlen(r.membershipType) > 2000 {
		return localVarReturnValue, nil, reportError("membershipType must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetMembershipCardFeeAmountLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	membershipLevel string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetMembershipCardFeeAmountLOVRequest) Authorization(authorization string) LOVApiGetMembershipCardFeeAmountLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetMembershipCardFeeAmountLOVRequest) XAppKey(xAppKey string) LOVApiGetMembershipCardFeeAmountLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetMembershipCardFeeAmountLOVRequest) XHotelid(xHotelid string) LOVApiGetMembershipCardFeeAmountLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetMembershipCardFeeAmountLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetMembershipCardFeeAmountLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetMembershipCardFeeAmountLOVRequest) ParameterName(parameterName []string) LOVApiGetMembershipCardFeeAmountLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetMembershipCardFeeAmountLOVRequest) ParameterValue(parameterValue []string) LOVApiGetMembershipCardFeeAmountLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetMembershipCardFeeAmountLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetMembershipCardFeeAmountLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetMembershipCardFeeAmountLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetMembershipCardFeeAmountLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetMembershipCardFeeAmountLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetMembershipCardFeeAmountLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetMembershipCardFeeAmountLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetMembershipCardFeeAmountLOVExecute(r)
}

/*
GetMembershipCardFeeAmountLOV Fetch List Of Values for Membership Card Fee Amount

 <p><strong>OperationId:</strong>getMembershipCardFeeAmountLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param membershipLevel Value of the parameter 'membershipLevel' which is required to fetch MembershipCardFeeAmount LOV
 @return LOVApiGetMembershipCardFeeAmountLOVRequest
*/
func (a *LOVApiService) GetMembershipCardFeeAmountLOV(ctx context.Context, membershipLevel string) LOVApiGetMembershipCardFeeAmountLOVRequest {
	return LOVApiGetMembershipCardFeeAmountLOVRequest{
		ApiService: a,
		ctx: ctx,
		membershipLevel: membershipLevel,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetMembershipCardFeeAmountLOVExecute(r LOVApiGetMembershipCardFeeAmountLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetMembershipCardFeeAmountLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/membershipLevel/{membershipLevel}/membershipCardFeeAmount"
	localVarPath = strings.Replace(localVarPath, "{"+"membershipLevel"+"}", url.PathEscape(parameterValueToString(r.membershipLevel, "membershipLevel")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.membershipLevel) < 1 {
		return localVarReturnValue, nil, reportError("membershipLevel must have at least 1 elements")
	}
	if strlen(r.membershipLevel) > 2000 {
		return localVarReturnValue, nil, reportError("membershipLevel must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetMembershipClassTypesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	loyalty string
	airlines string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetMembershipClassTypesLOVRequest) Authorization(authorization string) LOVApiGetMembershipClassTypesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetMembershipClassTypesLOVRequest) XAppKey(xAppKey string) LOVApiGetMembershipClassTypesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetMembershipClassTypesLOVRequest) XHotelid(xHotelid string) LOVApiGetMembershipClassTypesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetMembershipClassTypesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetMembershipClassTypesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetMembershipClassTypesLOVRequest) ParameterName(parameterName []string) LOVApiGetMembershipClassTypesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetMembershipClassTypesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetMembershipClassTypesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetMembershipClassTypesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetMembershipClassTypesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetMembershipClassTypesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetMembershipClassTypesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetMembershipClassTypesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetMembershipClassTypesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetMembershipClassTypesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetMembershipClassTypesLOVExecute(r)
}

/*
GetMembershipClassTypesLOV Fetch List Of Values for Membership Class Types

 <p><strong>OperationId:</strong>getMembershipClassTypesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param loyalty Value of the parameter 'loyalty' which is required to fetch MembershipClassTypes LOV
 @param airlines Value of the parameter 'airlines' which is required to fetch MembershipClassTypes LOV
 @return LOVApiGetMembershipClassTypesLOVRequest
*/
func (a *LOVApiService) GetMembershipClassTypesLOV(ctx context.Context, loyalty string, airlines string) LOVApiGetMembershipClassTypesLOVRequest {
	return LOVApiGetMembershipClassTypesLOVRequest{
		ApiService: a,
		ctx: ctx,
		loyalty: loyalty,
		airlines: airlines,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetMembershipClassTypesLOVExecute(r LOVApiGetMembershipClassTypesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetMembershipClassTypesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/airlines/{airlines}/loyalty/{loyalty}/membershipClassTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"loyalty"+"}", url.PathEscape(parameterValueToString(r.loyalty, "loyalty")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"airlines"+"}", url.PathEscape(parameterValueToString(r.airlines, "airlines")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.loyalty) < 1 {
		return localVarReturnValue, nil, reportError("loyalty must have at least 1 elements")
	}
	if strlen(r.loyalty) > 2000 {
		return localVarReturnValue, nil, reportError("loyalty must have less than 2000 elements")
	}
	if strlen(r.airlines) < 1 {
		return localVarReturnValue, nil, reportError("airlines must have at least 1 elements")
	}
	if strlen(r.airlines) > 2000 {
		return localVarReturnValue, nil, reportError("airlines must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetMembershipMaxDowngradeLevelLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	membershipType string
	membershipLevelRank string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetMembershipMaxDowngradeLevelLOVRequest) Authorization(authorization string) LOVApiGetMembershipMaxDowngradeLevelLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetMembershipMaxDowngradeLevelLOVRequest) XAppKey(xAppKey string) LOVApiGetMembershipMaxDowngradeLevelLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetMembershipMaxDowngradeLevelLOVRequest) XHotelid(xHotelid string) LOVApiGetMembershipMaxDowngradeLevelLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetMembershipMaxDowngradeLevelLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetMembershipMaxDowngradeLevelLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetMembershipMaxDowngradeLevelLOVRequest) ParameterName(parameterName []string) LOVApiGetMembershipMaxDowngradeLevelLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetMembershipMaxDowngradeLevelLOVRequest) ParameterValue(parameterValue []string) LOVApiGetMembershipMaxDowngradeLevelLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetMembershipMaxDowngradeLevelLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetMembershipMaxDowngradeLevelLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetMembershipMaxDowngradeLevelLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetMembershipMaxDowngradeLevelLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetMembershipMaxDowngradeLevelLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetMembershipMaxDowngradeLevelLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetMembershipMaxDowngradeLevelLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetMembershipMaxDowngradeLevelLOVExecute(r)
}

/*
GetMembershipMaxDowngradeLevelLOV Fetch List Of Values for Membership Max Downgrade Level

 <p><strong>OperationId:</strong>getMembershipMaxDowngradeLevelLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param membershipType Value of the parameter 'membershipType' which is required to fetch MembershipMaxDowngradeLevel LOV
 @param membershipLevelRank Value of the parameter 'membershipLevelRank' which is required to fetch MembershipMaxDowngradeLevel LOV
 @return LOVApiGetMembershipMaxDowngradeLevelLOVRequest
*/
func (a *LOVApiService) GetMembershipMaxDowngradeLevelLOV(ctx context.Context, membershipType string, membershipLevelRank string) LOVApiGetMembershipMaxDowngradeLevelLOVRequest {
	return LOVApiGetMembershipMaxDowngradeLevelLOVRequest{
		ApiService: a,
		ctx: ctx,
		membershipType: membershipType,
		membershipLevelRank: membershipLevelRank,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetMembershipMaxDowngradeLevelLOVExecute(r LOVApiGetMembershipMaxDowngradeLevelLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetMembershipMaxDowngradeLevelLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/membershipLevelRank/{membershipLevelRank}/membershipType/{membershipType}/membershipMaxDowngradeLevel"
	localVarPath = strings.Replace(localVarPath, "{"+"membershipType"+"}", url.PathEscape(parameterValueToString(r.membershipType, "membershipType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"membershipLevelRank"+"}", url.PathEscape(parameterValueToString(r.membershipLevelRank, "membershipLevelRank")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.membershipType) < 1 {
		return localVarReturnValue, nil, reportError("membershipType must have at least 1 elements")
	}
	if strlen(r.membershipType) > 2000 {
		return localVarReturnValue, nil, reportError("membershipType must have less than 2000 elements")
	}
	if strlen(r.membershipLevelRank) < 1 {
		return localVarReturnValue, nil, reportError("membershipLevelRank must have at least 1 elements")
	}
	if strlen(r.membershipLevelRank) > 2000 {
		return localVarReturnValue, nil, reportError("membershipLevelRank must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetMembershipPointsRuleCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	membershipType string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetMembershipPointsRuleCodesLOVRequest) Authorization(authorization string) LOVApiGetMembershipPointsRuleCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetMembershipPointsRuleCodesLOVRequest) XAppKey(xAppKey string) LOVApiGetMembershipPointsRuleCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetMembershipPointsRuleCodesLOVRequest) XHotelid(xHotelid string) LOVApiGetMembershipPointsRuleCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetMembershipPointsRuleCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetMembershipPointsRuleCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetMembershipPointsRuleCodesLOVRequest) ParameterName(parameterName []string) LOVApiGetMembershipPointsRuleCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetMembershipPointsRuleCodesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetMembershipPointsRuleCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetMembershipPointsRuleCodesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetMembershipPointsRuleCodesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetMembershipPointsRuleCodesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetMembershipPointsRuleCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetMembershipPointsRuleCodesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetMembershipPointsRuleCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetMembershipPointsRuleCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetMembershipPointsRuleCodesLOVExecute(r)
}

/*
GetMembershipPointsRuleCodesLOV Fetch List Of Values for Membership Points Rule Codes

 <p><strong>OperationId:</strong>getMembershipPointsRuleCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param membershipType Value of the parameter 'membershipType' which is required to fetch MembershipPointsRuleCodes LOV
 @return LOVApiGetMembershipPointsRuleCodesLOVRequest
*/
func (a *LOVApiService) GetMembershipPointsRuleCodesLOV(ctx context.Context, membershipType string) LOVApiGetMembershipPointsRuleCodesLOVRequest {
	return LOVApiGetMembershipPointsRuleCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		membershipType: membershipType,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetMembershipPointsRuleCodesLOVExecute(r LOVApiGetMembershipPointsRuleCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetMembershipPointsRuleCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/membershipType/{membershipType}/membershipPointsRuleCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"membershipType"+"}", url.PathEscape(parameterValueToString(r.membershipType, "membershipType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.membershipType) < 1 {
		return localVarReturnValue, nil, reportError("membershipType must have at least 1 elements")
	}
	if strlen(r.membershipType) > 2000 {
		return localVarReturnValue, nil, reportError("membershipType must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetMembershipPromotionsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	membershipId string
	beginDate string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetMembershipPromotionsLOVRequest) Authorization(authorization string) LOVApiGetMembershipPromotionsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetMembershipPromotionsLOVRequest) XAppKey(xAppKey string) LOVApiGetMembershipPromotionsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetMembershipPromotionsLOVRequest) XHotelid(xHotelid string) LOVApiGetMembershipPromotionsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetMembershipPromotionsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetMembershipPromotionsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetMembershipPromotionsLOVRequest) ParameterName(parameterName []string) LOVApiGetMembershipPromotionsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetMembershipPromotionsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetMembershipPromotionsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetMembershipPromotionsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetMembershipPromotionsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetMembershipPromotionsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetMembershipPromotionsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetMembershipPromotionsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetMembershipPromotionsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetMembershipPromotionsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetMembershipPromotionsLOVExecute(r)
}

/*
GetMembershipPromotionsLOV Fetch List Of Values for Membership Promotions

 <p><strong>OperationId:</strong>getMembershipPromotionsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param membershipId Value of the parameter 'membershipId' which is required to fetch MembershipPromotions LOV
 @param beginDate Value of the parameter 'beginDate' which is required to fetch MembershipPromotions LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch MembershipPromotions LOV
 @return LOVApiGetMembershipPromotionsLOVRequest
*/
func (a *LOVApiService) GetMembershipPromotionsLOV(ctx context.Context, membershipId string, beginDate string, hotelId string) LOVApiGetMembershipPromotionsLOVRequest {
	return LOVApiGetMembershipPromotionsLOVRequest{
		ApiService: a,
		ctx: ctx,
		membershipId: membershipId,
		beginDate: beginDate,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetMembershipPromotionsLOVExecute(r LOVApiGetMembershipPromotionsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetMembershipPromotionsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/beginDate/{beginDate}/membershipId/{membershipId}/membershipPromotions"
	localVarPath = strings.Replace(localVarPath, "{"+"membershipId"+"}", url.PathEscape(parameterValueToString(r.membershipId, "membershipId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"beginDate"+"}", url.PathEscape(parameterValueToString(r.beginDate, "beginDate")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.membershipId) < 1 {
		return localVarReturnValue, nil, reportError("membershipId must have at least 1 elements")
	}
	if strlen(r.membershipId) > 2000 {
		return localVarReturnValue, nil, reportError("membershipId must have less than 2000 elements")
	}
	if strlen(r.beginDate) < 1 {
		return localVarReturnValue, nil, reportError("beginDate must have at least 1 elements")
	}
	if strlen(r.beginDate) > 2000 {
		return localVarReturnValue, nil, reportError("beginDate must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetMembershipStatementBatchListLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	membershipId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetMembershipStatementBatchListLOVRequest) Authorization(authorization string) LOVApiGetMembershipStatementBatchListLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetMembershipStatementBatchListLOVRequest) XAppKey(xAppKey string) LOVApiGetMembershipStatementBatchListLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetMembershipStatementBatchListLOVRequest) XHotelid(xHotelid string) LOVApiGetMembershipStatementBatchListLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetMembershipStatementBatchListLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetMembershipStatementBatchListLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetMembershipStatementBatchListLOVRequest) ParameterName(parameterName []string) LOVApiGetMembershipStatementBatchListLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetMembershipStatementBatchListLOVRequest) ParameterValue(parameterValue []string) LOVApiGetMembershipStatementBatchListLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetMembershipStatementBatchListLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetMembershipStatementBatchListLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetMembershipStatementBatchListLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetMembershipStatementBatchListLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetMembershipStatementBatchListLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetMembershipStatementBatchListLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetMembershipStatementBatchListLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetMembershipStatementBatchListLOVExecute(r)
}

/*
GetMembershipStatementBatchListLOV Fetch List Of Values for Membership Statement Batch List

 <p><strong>OperationId:</strong>getMembershipStatementBatchListLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param membershipId Value of the parameter 'membershipId' which is required to fetch MembershipStatementBatchList LOV
 @return LOVApiGetMembershipStatementBatchListLOVRequest
*/
func (a *LOVApiService) GetMembershipStatementBatchListLOV(ctx context.Context, membershipId string) LOVApiGetMembershipStatementBatchListLOVRequest {
	return LOVApiGetMembershipStatementBatchListLOVRequest{
		ApiService: a,
		ctx: ctx,
		membershipId: membershipId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetMembershipStatementBatchListLOVExecute(r LOVApiGetMembershipStatementBatchListLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetMembershipStatementBatchListLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/membershipId/{membershipId}/membershipStatementBatchList"
	localVarPath = strings.Replace(localVarPath, "{"+"membershipId"+"}", url.PathEscape(parameterValueToString(r.membershipId, "membershipId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.membershipId) < 1 {
		return localVarReturnValue, nil, reportError("membershipId must have at least 1 elements")
	}
	if strlen(r.membershipId) > 2000 {
		return localVarReturnValue, nil, reportError("membershipId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetMembershipTotalPointsAvailableLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	membershipId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetMembershipTotalPointsAvailableLOVRequest) Authorization(authorization string) LOVApiGetMembershipTotalPointsAvailableLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetMembershipTotalPointsAvailableLOVRequest) XAppKey(xAppKey string) LOVApiGetMembershipTotalPointsAvailableLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetMembershipTotalPointsAvailableLOVRequest) XHotelid(xHotelid string) LOVApiGetMembershipTotalPointsAvailableLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetMembershipTotalPointsAvailableLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetMembershipTotalPointsAvailableLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetMembershipTotalPointsAvailableLOVRequest) ParameterName(parameterName []string) LOVApiGetMembershipTotalPointsAvailableLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetMembershipTotalPointsAvailableLOVRequest) ParameterValue(parameterValue []string) LOVApiGetMembershipTotalPointsAvailableLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetMembershipTotalPointsAvailableLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetMembershipTotalPointsAvailableLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetMembershipTotalPointsAvailableLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetMembershipTotalPointsAvailableLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetMembershipTotalPointsAvailableLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetMembershipTotalPointsAvailableLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetMembershipTotalPointsAvailableLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetMembershipTotalPointsAvailableLOVExecute(r)
}

/*
GetMembershipTotalPointsAvailableLOV Fetch List Of Values for Membership Total Points Available

 <p><strong>OperationId:</strong>getMembershipTotalPointsAvailableLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param membershipId Value of the parameter 'membershipId' which is required to fetch MembershipTotalPointsAvailable LOV
 @return LOVApiGetMembershipTotalPointsAvailableLOVRequest
*/
func (a *LOVApiService) GetMembershipTotalPointsAvailableLOV(ctx context.Context, membershipId string) LOVApiGetMembershipTotalPointsAvailableLOVRequest {
	return LOVApiGetMembershipTotalPointsAvailableLOVRequest{
		ApiService: a,
		ctx: ctx,
		membershipId: membershipId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetMembershipTotalPointsAvailableLOVExecute(r LOVApiGetMembershipTotalPointsAvailableLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetMembershipTotalPointsAvailableLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/membershipId/{membershipId}/membershipTotalPointsAvailable"
	localVarPath = strings.Replace(localVarPath, "{"+"membershipId"+"}", url.PathEscape(parameterValueToString(r.membershipId, "membershipId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.membershipId) < 1 {
		return localVarReturnValue, nil, reportError("membershipId must have at least 1 elements")
	}
	if strlen(r.membershipId) > 2000 {
		return localVarReturnValue, nil, reportError("membershipId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetMembershipTransferPointsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	profileId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetMembershipTransferPointsLOVRequest) Authorization(authorization string) LOVApiGetMembershipTransferPointsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetMembershipTransferPointsLOVRequest) XAppKey(xAppKey string) LOVApiGetMembershipTransferPointsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetMembershipTransferPointsLOVRequest) XHotelid(xHotelid string) LOVApiGetMembershipTransferPointsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetMembershipTransferPointsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetMembershipTransferPointsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetMembershipTransferPointsLOVRequest) ParameterName(parameterName []string) LOVApiGetMembershipTransferPointsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetMembershipTransferPointsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetMembershipTransferPointsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetMembershipTransferPointsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetMembershipTransferPointsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetMembershipTransferPointsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetMembershipTransferPointsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetMembershipTransferPointsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetMembershipTransferPointsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetMembershipTransferPointsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetMembershipTransferPointsLOVExecute(r)
}

/*
GetMembershipTransferPointsLOV Fetch List Of Values for Membership Transfer Points

 <p><strong>OperationId:</strong>getMembershipTransferPointsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param profileId Value of the parameter 'profileId' which is required to fetch MembershipTransferPoints LOV
 @return LOVApiGetMembershipTransferPointsLOVRequest
*/
func (a *LOVApiService) GetMembershipTransferPointsLOV(ctx context.Context, profileId string) LOVApiGetMembershipTransferPointsLOVRequest {
	return LOVApiGetMembershipTransferPointsLOVRequest{
		ApiService: a,
		ctx: ctx,
		profileId: profileId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetMembershipTransferPointsLOVExecute(r LOVApiGetMembershipTransferPointsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetMembershipTransferPointsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/profiles/{profileId}/membershipTransferPoints"
	localVarPath = strings.Replace(localVarPath, "{"+"profileId"+"}", url.PathEscape(parameterValueToString(r.profileId, "profileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.profileId) < 1 {
		return localVarReturnValue, nil, reportError("profileId must have at least 1 elements")
	}
	if strlen(r.profileId) > 2000 {
		return localVarReturnValue, nil, reportError("profileId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetMenuClassesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetMenuClassesLOVRequest) Authorization(authorization string) LOVApiGetMenuClassesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetMenuClassesLOVRequest) XAppKey(xAppKey string) LOVApiGetMenuClassesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetMenuClassesLOVRequest) XHotelid(xHotelid string) LOVApiGetMenuClassesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetMenuClassesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetMenuClassesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetMenuClassesLOVRequest) ParameterName(parameterName []string) LOVApiGetMenuClassesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetMenuClassesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetMenuClassesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetMenuClassesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetMenuClassesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetMenuClassesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetMenuClassesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetMenuClassesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetMenuClassesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetMenuClassesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetMenuClassesLOVExecute(r)
}

/*
GetMenuClassesLOV Fetch List Of Values for Menu Classes

 <p><strong>OperationId:</strong>getMenuClassesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch MenuClasses LOV
 @return LOVApiGetMenuClassesLOVRequest
*/
func (a *LOVApiService) GetMenuClassesLOV(ctx context.Context, hotelId string) LOVApiGetMenuClassesLOVRequest {
	return LOVApiGetMenuClassesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetMenuClassesLOVExecute(r LOVApiGetMenuClassesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetMenuClassesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/menuClasses"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetMenuItemsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetMenuItemsLOVRequest) Authorization(authorization string) LOVApiGetMenuItemsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetMenuItemsLOVRequest) XAppKey(xAppKey string) LOVApiGetMenuItemsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetMenuItemsLOVRequest) XHotelid(xHotelid string) LOVApiGetMenuItemsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetMenuItemsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetMenuItemsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetMenuItemsLOVRequest) ParameterName(parameterName []string) LOVApiGetMenuItemsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetMenuItemsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetMenuItemsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetMenuItemsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetMenuItemsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetMenuItemsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetMenuItemsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetMenuItemsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetMenuItemsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetMenuItemsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetMenuItemsLOVExecute(r)
}

/*
GetMenuItemsLOV Fetch List Of Values for Menu Items

 <p><strong>OperationId:</strong>getMenuItemsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch MenuItems LOV
 @return LOVApiGetMenuItemsLOVRequest
*/
func (a *LOVApiService) GetMenuItemsLOV(ctx context.Context, hotelId string) LOVApiGetMenuItemsLOVRequest {
	return LOVApiGetMenuItemsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetMenuItemsLOVExecute(r LOVApiGetMenuItemsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetMenuItemsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/menuItems"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetMenuLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	menuClassId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetMenuLOVRequest) Authorization(authorization string) LOVApiGetMenuLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetMenuLOVRequest) XAppKey(xAppKey string) LOVApiGetMenuLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetMenuLOVRequest) XHotelid(xHotelid string) LOVApiGetMenuLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetMenuLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetMenuLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetMenuLOVRequest) ParameterName(parameterName []string) LOVApiGetMenuLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetMenuLOVRequest) ParameterValue(parameterValue []string) LOVApiGetMenuLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetMenuLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetMenuLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetMenuLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetMenuLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetMenuLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetMenuLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetMenuLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetMenuLOVExecute(r)
}

/*
GetMenuLOV Fetch List Of Values for Menu

 <p><strong>OperationId:</strong>getMenuLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param menuClassId Value of the parameter 'menuClassId' which is required to fetch Menu LOV
 @return LOVApiGetMenuLOVRequest
*/
func (a *LOVApiService) GetMenuLOV(ctx context.Context, menuClassId string) LOVApiGetMenuLOVRequest {
	return LOVApiGetMenuLOVRequest{
		ApiService: a,
		ctx: ctx,
		menuClassId: menuClassId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetMenuLOVExecute(r LOVApiGetMenuLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetMenuLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/menuClassId/{menuClassId}/menu"
	localVarPath = strings.Replace(localVarPath, "{"+"menuClassId"+"}", url.PathEscape(parameterValueToString(r.menuClassId, "menuClassId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.menuClassId) < 1 {
		return localVarReturnValue, nil, reportError("menuClassId must have at least 1 elements")
	}
	if strlen(r.menuClassId) > 2000 {
		return localVarReturnValue, nil, reportError("menuClassId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetNegotiatedRateHotelsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	profileId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetNegotiatedRateHotelsLOVRequest) Authorization(authorization string) LOVApiGetNegotiatedRateHotelsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetNegotiatedRateHotelsLOVRequest) XAppKey(xAppKey string) LOVApiGetNegotiatedRateHotelsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetNegotiatedRateHotelsLOVRequest) XHotelid(xHotelid string) LOVApiGetNegotiatedRateHotelsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetNegotiatedRateHotelsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetNegotiatedRateHotelsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetNegotiatedRateHotelsLOVRequest) ParameterName(parameterName []string) LOVApiGetNegotiatedRateHotelsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetNegotiatedRateHotelsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetNegotiatedRateHotelsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetNegotiatedRateHotelsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetNegotiatedRateHotelsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetNegotiatedRateHotelsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetNegotiatedRateHotelsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetNegotiatedRateHotelsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetNegotiatedRateHotelsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetNegotiatedRateHotelsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetNegotiatedRateHotelsLOVExecute(r)
}

/*
GetNegotiatedRateHotelsLOV Fetch List Of Values for Negotiated Rate Hotels

 <p><strong>OperationId:</strong>getNegotiatedRateHotelsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param profileId Value of the parameter 'profileId' which is required to fetch NegotiatedRateHotels LOV
 @return LOVApiGetNegotiatedRateHotelsLOVRequest
*/
func (a *LOVApiService) GetNegotiatedRateHotelsLOV(ctx context.Context, profileId string) LOVApiGetNegotiatedRateHotelsLOVRequest {
	return LOVApiGetNegotiatedRateHotelsLOVRequest{
		ApiService: a,
		ctx: ctx,
		profileId: profileId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetNegotiatedRateHotelsLOVExecute(r LOVApiGetNegotiatedRateHotelsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetNegotiatedRateHotelsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/profiles/{profileId}/negotiatedRateHotels"
	localVarPath = strings.Replace(localVarPath, "{"+"profileId"+"}", url.PathEscape(parameterValueToString(r.profileId, "profileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.profileId) < 1 {
		return localVarReturnValue, nil, reportError("profileId must have at least 1 elements")
	}
	if strlen(r.profileId) > 2000 {
		return localVarReturnValue, nil, reportError("profileId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetNegotiatedRatesHotelsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	profileId string
	rateCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetNegotiatedRatesHotelsLOVRequest) Authorization(authorization string) LOVApiGetNegotiatedRatesHotelsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetNegotiatedRatesHotelsLOVRequest) XAppKey(xAppKey string) LOVApiGetNegotiatedRatesHotelsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetNegotiatedRatesHotelsLOVRequest) XHotelid(xHotelid string) LOVApiGetNegotiatedRatesHotelsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetNegotiatedRatesHotelsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetNegotiatedRatesHotelsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetNegotiatedRatesHotelsLOVRequest) ParameterName(parameterName []string) LOVApiGetNegotiatedRatesHotelsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetNegotiatedRatesHotelsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetNegotiatedRatesHotelsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetNegotiatedRatesHotelsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetNegotiatedRatesHotelsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetNegotiatedRatesHotelsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetNegotiatedRatesHotelsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetNegotiatedRatesHotelsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetNegotiatedRatesHotelsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetNegotiatedRatesHotelsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetNegotiatedRatesHotelsLOVExecute(r)
}

/*
GetNegotiatedRatesHotelsLOV Fetch List Of Values for Negotiated Rates Hotels

 <p><strong>OperationId:</strong>getNegotiatedRatesHotelsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param profileId Value of the parameter 'profileId' which is required to fetch NegotiatedRatesHotels LOV
 @param rateCode Value of the parameter 'rateCode' which is required to fetch NegotiatedRatesHotels LOV
 @return LOVApiGetNegotiatedRatesHotelsLOVRequest
*/
func (a *LOVApiService) GetNegotiatedRatesHotelsLOV(ctx context.Context, profileId string, rateCode string) LOVApiGetNegotiatedRatesHotelsLOVRequest {
	return LOVApiGetNegotiatedRatesHotelsLOVRequest{
		ApiService: a,
		ctx: ctx,
		profileId: profileId,
		rateCode: rateCode,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetNegotiatedRatesHotelsLOVExecute(r LOVApiGetNegotiatedRatesHotelsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetNegotiatedRatesHotelsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/rateCode/{rateCode}/profiles/{profileId}/negotiatedRatesHotels"
	localVarPath = strings.Replace(localVarPath, "{"+"profileId"+"}", url.PathEscape(parameterValueToString(r.profileId, "profileId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"rateCode"+"}", url.PathEscape(parameterValueToString(r.rateCode, "rateCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.profileId) < 1 {
		return localVarReturnValue, nil, reportError("profileId must have at least 1 elements")
	}
	if strlen(r.profileId) > 2000 {
		return localVarReturnValue, nil, reportError("profileId must have less than 2000 elements")
	}
	if strlen(r.rateCode) < 1 {
		return localVarReturnValue, nil, reportError("rateCode must have at least 1 elements")
	}
	if strlen(r.rateCode) > 2000 {
		return localVarReturnValue, nil, reportError("rateCode must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetNoteTypesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	departmentType string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetNoteTypesLOVRequest) Authorization(authorization string) LOVApiGetNoteTypesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetNoteTypesLOVRequest) XAppKey(xAppKey string) LOVApiGetNoteTypesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetNoteTypesLOVRequest) XHotelid(xHotelid string) LOVApiGetNoteTypesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetNoteTypesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetNoteTypesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetNoteTypesLOVRequest) ParameterName(parameterName []string) LOVApiGetNoteTypesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetNoteTypesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetNoteTypesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetNoteTypesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetNoteTypesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetNoteTypesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetNoteTypesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetNoteTypesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetNoteTypesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetNoteTypesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetNoteTypesLOVExecute(r)
}

/*
GetNoteTypesLOV Fetch List Of Values for Note Types

 <p><strong>OperationId:</strong>getNoteTypesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param departmentType Value of the parameter 'departmentType' which is required to fetch NoteTypes LOV
 @return LOVApiGetNoteTypesLOVRequest
*/
func (a *LOVApiService) GetNoteTypesLOV(ctx context.Context, departmentType string) LOVApiGetNoteTypesLOVRequest {
	return LOVApiGetNoteTypesLOVRequest{
		ApiService: a,
		ctx: ctx,
		departmentType: departmentType,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetNoteTypesLOVExecute(r LOVApiGetNoteTypesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetNoteTypesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/departments/{departmentType}/noteTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"departmentType"+"}", url.PathEscape(parameterValueToString(r.departmentType, "departmentType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.departmentType) < 1 {
		return localVarReturnValue, nil, reportError("departmentType must have at least 1 elements")
	}
	if strlen(r.departmentType) > 2000 {
		return localVarReturnValue, nil, reportError("departmentType must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetOSAActivityTypesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetOSAActivityTypesLOVRequest) Authorization(authorization string) LOVApiGetOSAActivityTypesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetOSAActivityTypesLOVRequest) XAppKey(xAppKey string) LOVApiGetOSAActivityTypesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetOSAActivityTypesLOVRequest) XHotelid(xHotelid string) LOVApiGetOSAActivityTypesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetOSAActivityTypesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetOSAActivityTypesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetOSAActivityTypesLOVRequest) ParameterName(parameterName []string) LOVApiGetOSAActivityTypesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetOSAActivityTypesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetOSAActivityTypesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetOSAActivityTypesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetOSAActivityTypesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetOSAActivityTypesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetOSAActivityTypesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetOSAActivityTypesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetOSAActivityTypesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetOSAActivityTypesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetOSAActivityTypesLOVExecute(r)
}

/*
GetOSAActivityTypesLOV Fetch List Of Values for OSAActivity Types

 <p><strong>OperationId:</strong>getOSAActivityTypesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch OSAActivityTypes LOV
 @return LOVApiGetOSAActivityTypesLOVRequest
*/
func (a *LOVApiService) GetOSAActivityTypesLOV(ctx context.Context, hotelId string) LOVApiGetOSAActivityTypesLOVRequest {
	return LOVApiGetOSAActivityTypesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetOSAActivityTypesLOVExecute(r LOVApiGetOSAActivityTypesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetOSAActivityTypesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/osaActivityTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetOXIInterfaceReferencesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetOXIInterfaceReferencesLOVRequest) Authorization(authorization string) LOVApiGetOXIInterfaceReferencesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetOXIInterfaceReferencesLOVRequest) XAppKey(xAppKey string) LOVApiGetOXIInterfaceReferencesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetOXIInterfaceReferencesLOVRequest) XHotelid(xHotelid string) LOVApiGetOXIInterfaceReferencesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetOXIInterfaceReferencesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetOXIInterfaceReferencesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetOXIInterfaceReferencesLOVRequest) ParameterName(parameterName []string) LOVApiGetOXIInterfaceReferencesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetOXIInterfaceReferencesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetOXIInterfaceReferencesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetOXIInterfaceReferencesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetOXIInterfaceReferencesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetOXIInterfaceReferencesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetOXIInterfaceReferencesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetOXIInterfaceReferencesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetOXIInterfaceReferencesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetOXIInterfaceReferencesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetOXIInterfaceReferencesLOVExecute(r)
}

/*
GetOXIInterfaceReferencesLOV Fetch List Of Values for OXIInterface References

 <p><strong>OperationId:</strong>getOXIInterfaceReferencesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch OXIInterfaceReferences LOV
 @return LOVApiGetOXIInterfaceReferencesLOVRequest
*/
func (a *LOVApiService) GetOXIInterfaceReferencesLOV(ctx context.Context, hotelId string) LOVApiGetOXIInterfaceReferencesLOVRequest {
	return LOVApiGetOXIInterfaceReferencesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetOXIInterfaceReferencesLOVExecute(r LOVApiGetOXIInterfaceReferencesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetOXIInterfaceReferencesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/oxiInterfaceReferences"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetOXIInterfaceResortsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetOXIInterfaceResortsLOVRequest) Authorization(authorization string) LOVApiGetOXIInterfaceResortsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetOXIInterfaceResortsLOVRequest) XAppKey(xAppKey string) LOVApiGetOXIInterfaceResortsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetOXIInterfaceResortsLOVRequest) XHotelid(xHotelid string) LOVApiGetOXIInterfaceResortsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetOXIInterfaceResortsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetOXIInterfaceResortsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetOXIInterfaceResortsLOVRequest) ParameterName(parameterName []string) LOVApiGetOXIInterfaceResortsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetOXIInterfaceResortsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetOXIInterfaceResortsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetOXIInterfaceResortsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetOXIInterfaceResortsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetOXIInterfaceResortsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetOXIInterfaceResortsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetOXIInterfaceResortsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetOXIInterfaceResortsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetOXIInterfaceResortsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetOXIInterfaceResortsLOVExecute(r)
}

/*
GetOXIInterfaceResortsLOV Fetch List Of Values for OXIInterface Resorts

 <p><strong>OperationId:</strong>getOXIInterfaceResortsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch OXIInterfaceResorts LOV
 @return LOVApiGetOXIInterfaceResortsLOVRequest
*/
func (a *LOVApiService) GetOXIInterfaceResortsLOV(ctx context.Context, hotelId string) LOVApiGetOXIInterfaceResortsLOVRequest {
	return LOVApiGetOXIInterfaceResortsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetOXIInterfaceResortsLOVExecute(r LOVApiGetOXIInterfaceResortsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetOXIInterfaceResortsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/oxiInterfaceResorts"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetOXIInterfacesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetOXIInterfacesLOVRequest) Authorization(authorization string) LOVApiGetOXIInterfacesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetOXIInterfacesLOVRequest) XAppKey(xAppKey string) LOVApiGetOXIInterfacesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetOXIInterfacesLOVRequest) XHotelid(xHotelid string) LOVApiGetOXIInterfacesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetOXIInterfacesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetOXIInterfacesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetOXIInterfacesLOVRequest) ParameterName(parameterName []string) LOVApiGetOXIInterfacesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetOXIInterfacesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetOXIInterfacesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetOXIInterfacesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetOXIInterfacesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetOXIInterfacesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetOXIInterfacesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetOXIInterfacesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetOXIInterfacesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetOXIInterfacesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetOXIInterfacesLOVExecute(r)
}

/*
GetOXIInterfacesLOV Fetch List Of Values for OXIInterfaces

 <p><strong>OperationId:</strong>getOXIInterfacesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch OXIInterfaces LOV
 @return LOVApiGetOXIInterfacesLOVRequest
*/
func (a *LOVApiService) GetOXIInterfacesLOV(ctx context.Context, hotelId string) LOVApiGetOXIInterfacesLOVRequest {
	return LOVApiGetOXIInterfacesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetOXIInterfacesLOVExecute(r LOVApiGetOXIInterfacesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetOXIInterfacesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/oxiInterfaces"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetOXIResortsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	interfaceId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetOXIResortsLOVRequest) Authorization(authorization string) LOVApiGetOXIResortsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetOXIResortsLOVRequest) XAppKey(xAppKey string) LOVApiGetOXIResortsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetOXIResortsLOVRequest) XHotelid(xHotelid string) LOVApiGetOXIResortsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetOXIResortsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetOXIResortsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetOXIResortsLOVRequest) ParameterName(parameterName []string) LOVApiGetOXIResortsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetOXIResortsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetOXIResortsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetOXIResortsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetOXIResortsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetOXIResortsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetOXIResortsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetOXIResortsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetOXIResortsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetOXIResortsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetOXIResortsLOVExecute(r)
}

/*
GetOXIResortsLOV Fetch List Of Values for OXIResorts

 <p><strong>OperationId:</strong>getOXIResortsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param interfaceId Value of the parameter 'interfaceId' which is required to fetch OXIResorts LOV
 @return LOVApiGetOXIResortsLOVRequest
*/
func (a *LOVApiService) GetOXIResortsLOV(ctx context.Context, interfaceId string) LOVApiGetOXIResortsLOVRequest {
	return LOVApiGetOXIResortsLOVRequest{
		ApiService: a,
		ctx: ctx,
		interfaceId: interfaceId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetOXIResortsLOVExecute(r LOVApiGetOXIResortsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetOXIResortsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/interfaceId/{interfaceId}/oxiResorts"
	localVarPath = strings.Replace(localVarPath, "{"+"interfaceId"+"}", url.PathEscape(parameterValueToString(r.interfaceId, "interfaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.interfaceId) < 1 {
		return localVarReturnValue, nil, reportError("interfaceId must have at least 1 elements")
	}
	if strlen(r.interfaceId) > 2000 {
		return localVarReturnValue, nil, reportError("interfaceId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetOrganizationsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	actionTask string
	chainCode string
	roles string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetOrganizationsLOVRequest) Authorization(authorization string) LOVApiGetOrganizationsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetOrganizationsLOVRequest) XAppKey(xAppKey string) LOVApiGetOrganizationsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetOrganizationsLOVRequest) XHotelid(xHotelid string) LOVApiGetOrganizationsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetOrganizationsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetOrganizationsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetOrganizationsLOVRequest) ParameterName(parameterName []string) LOVApiGetOrganizationsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetOrganizationsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetOrganizationsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetOrganizationsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetOrganizationsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetOrganizationsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetOrganizationsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetOrganizationsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetOrganizationsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetOrganizationsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetOrganizationsLOVExecute(r)
}

/*
GetOrganizationsLOV Fetch List Of Values for Organizations

 <p><strong>OperationId:</strong>getOrganizationsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param actionTask Value of the parameter 'actionTask' which is required to fetch Organizations LOV
 @param chainCode Value of the parameter 'chainCode' which is required to fetch Organizations LOV
 @param roles Value of the parameter 'roles' which is required to fetch Organizations LOV
 @return LOVApiGetOrganizationsLOVRequest
*/
func (a *LOVApiService) GetOrganizationsLOV(ctx context.Context, actionTask string, chainCode string, roles string) LOVApiGetOrganizationsLOVRequest {
	return LOVApiGetOrganizationsLOVRequest{
		ApiService: a,
		ctx: ctx,
		actionTask: actionTask,
		chainCode: chainCode,
		roles: roles,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetOrganizationsLOVExecute(r LOVApiGetOrganizationsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetOrganizationsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/roles/{roles}/chainCode/{chainCode}/actionTask/{actionTask}/organizations"
	localVarPath = strings.Replace(localVarPath, "{"+"actionTask"+"}", url.PathEscape(parameterValueToString(r.actionTask, "actionTask")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"chainCode"+"}", url.PathEscape(parameterValueToString(r.chainCode, "chainCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"roles"+"}", url.PathEscape(parameterValueToString(r.roles, "roles")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.actionTask) < 1 {
		return localVarReturnValue, nil, reportError("actionTask must have at least 1 elements")
	}
	if strlen(r.actionTask) > 2000 {
		return localVarReturnValue, nil, reportError("actionTask must have less than 2000 elements")
	}
	if strlen(r.chainCode) < 1 {
		return localVarReturnValue, nil, reportError("chainCode must have at least 1 elements")
	}
	if strlen(r.chainCode) > 2000 {
		return localVarReturnValue, nil, reportError("chainCode must have less than 2000 elements")
	}
	if strlen(r.roles) < 1 {
		return localVarReturnValue, nil, reportError("roles must have at least 1 elements")
	}
	if strlen(r.roles) > 2000 {
		return localVarReturnValue, nil, reportError("roles must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetPackForecastGroupCodeLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetPackForecastGroupCodeLOVRequest) Authorization(authorization string) LOVApiGetPackForecastGroupCodeLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetPackForecastGroupCodeLOVRequest) XAppKey(xAppKey string) LOVApiGetPackForecastGroupCodeLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetPackForecastGroupCodeLOVRequest) XHotelid(xHotelid string) LOVApiGetPackForecastGroupCodeLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetPackForecastGroupCodeLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetPackForecastGroupCodeLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetPackForecastGroupCodeLOVRequest) ParameterName(parameterName []string) LOVApiGetPackForecastGroupCodeLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetPackForecastGroupCodeLOVRequest) ParameterValue(parameterValue []string) LOVApiGetPackForecastGroupCodeLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetPackForecastGroupCodeLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetPackForecastGroupCodeLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetPackForecastGroupCodeLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetPackForecastGroupCodeLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetPackForecastGroupCodeLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetPackForecastGroupCodeLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetPackForecastGroupCodeLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetPackForecastGroupCodeLOVExecute(r)
}

/*
GetPackForecastGroupCodeLOV Fetch List Of Values for Pack Forecast Group Code

 <p><strong>OperationId:</strong>getPackForecastGroupCodeLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch PackForecastGroupCode LOV
 @return LOVApiGetPackForecastGroupCodeLOVRequest
*/
func (a *LOVApiService) GetPackForecastGroupCodeLOV(ctx context.Context, hotelId string) LOVApiGetPackForecastGroupCodeLOVRequest {
	return LOVApiGetPackForecastGroupCodeLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetPackForecastGroupCodeLOVExecute(r LOVApiGetPackForecastGroupCodeLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetPackForecastGroupCodeLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/packForecastGroupCode"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetPackageArrangementAssociationLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	arrangementCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetPackageArrangementAssociationLOVRequest) Authorization(authorization string) LOVApiGetPackageArrangementAssociationLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetPackageArrangementAssociationLOVRequest) XAppKey(xAppKey string) LOVApiGetPackageArrangementAssociationLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetPackageArrangementAssociationLOVRequest) XHotelid(xHotelid string) LOVApiGetPackageArrangementAssociationLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetPackageArrangementAssociationLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetPackageArrangementAssociationLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetPackageArrangementAssociationLOVRequest) ParameterName(parameterName []string) LOVApiGetPackageArrangementAssociationLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetPackageArrangementAssociationLOVRequest) ParameterValue(parameterValue []string) LOVApiGetPackageArrangementAssociationLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetPackageArrangementAssociationLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetPackageArrangementAssociationLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetPackageArrangementAssociationLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetPackageArrangementAssociationLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetPackageArrangementAssociationLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetPackageArrangementAssociationLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetPackageArrangementAssociationLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetPackageArrangementAssociationLOVExecute(r)
}

/*
GetPackageArrangementAssociationLOV Fetch List Of Values for Package Arrangement Association

 <p><strong>OperationId:</strong>getPackageArrangementAssociationLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param arrangementCode Value of the parameter 'arrangementCode' which is required to fetch PackageArrangementAssociation LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch PackageArrangementAssociation LOV
 @return LOVApiGetPackageArrangementAssociationLOVRequest
*/
func (a *LOVApiService) GetPackageArrangementAssociationLOV(ctx context.Context, arrangementCode string, hotelId string) LOVApiGetPackageArrangementAssociationLOVRequest {
	return LOVApiGetPackageArrangementAssociationLOVRequest{
		ApiService: a,
		ctx: ctx,
		arrangementCode: arrangementCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetPackageArrangementAssociationLOVExecute(r LOVApiGetPackageArrangementAssociationLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetPackageArrangementAssociationLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/arrangementCode/{arrangementCode}/packageArrangementAssociation"
	localVarPath = strings.Replace(localVarPath, "{"+"arrangementCode"+"}", url.PathEscape(parameterValueToString(r.arrangementCode, "arrangementCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.arrangementCode) < 1 {
		return localVarReturnValue, nil, reportError("arrangementCode must have at least 1 elements")
	}
	if strlen(r.arrangementCode) > 2000 {
		return localVarReturnValue, nil, reportError("arrangementCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetParameterActiveUnderChainLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	chainCode string
	parameter string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetParameterActiveUnderChainLOVRequest) Authorization(authorization string) LOVApiGetParameterActiveUnderChainLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetParameterActiveUnderChainLOVRequest) XAppKey(xAppKey string) LOVApiGetParameterActiveUnderChainLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetParameterActiveUnderChainLOVRequest) XHotelid(xHotelid string) LOVApiGetParameterActiveUnderChainLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetParameterActiveUnderChainLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetParameterActiveUnderChainLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetParameterActiveUnderChainLOVRequest) ParameterName(parameterName []string) LOVApiGetParameterActiveUnderChainLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetParameterActiveUnderChainLOVRequest) ParameterValue(parameterValue []string) LOVApiGetParameterActiveUnderChainLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetParameterActiveUnderChainLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetParameterActiveUnderChainLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetParameterActiveUnderChainLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetParameterActiveUnderChainLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetParameterActiveUnderChainLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetParameterActiveUnderChainLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetParameterActiveUnderChainLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetParameterActiveUnderChainLOVExecute(r)
}

/*
GetParameterActiveUnderChainLOV Fetch List Of Values for Parameter Active Under Chain

 <p><strong>OperationId:</strong>getParameterActiveUnderChainLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param chainCode Value of the parameter 'chainCode' which is required to fetch ParameterActiveUnderChain LOV
 @param parameter Value of the parameter 'parameter' which is required to fetch ParameterActiveUnderChain LOV
 @return LOVApiGetParameterActiveUnderChainLOVRequest
*/
func (a *LOVApiService) GetParameterActiveUnderChainLOV(ctx context.Context, chainCode string, parameter string) LOVApiGetParameterActiveUnderChainLOVRequest {
	return LOVApiGetParameterActiveUnderChainLOVRequest{
		ApiService: a,
		ctx: ctx,
		chainCode: chainCode,
		parameter: parameter,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetParameterActiveUnderChainLOVExecute(r LOVApiGetParameterActiveUnderChainLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetParameterActiveUnderChainLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/parameterName/{parameter}/chainCode/{chainCode}/parameterActiveUnderChain"
	localVarPath = strings.Replace(localVarPath, "{"+"chainCode"+"}", url.PathEscape(parameterValueToString(r.chainCode, "chainCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"parameter"+"}", url.PathEscape(parameterValueToString(r.parameter, "parameter")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.chainCode) < 1 {
		return localVarReturnValue, nil, reportError("chainCode must have at least 1 elements")
	}
	if strlen(r.chainCode) > 2000 {
		return localVarReturnValue, nil, reportError("chainCode must have less than 2000 elements")
	}
	if strlen(r.parameter) < 1 {
		return localVarReturnValue, nil, reportError("parameter must have at least 1 elements")
	}
	if strlen(r.parameter) > 2000 {
		return localVarReturnValue, nil, reportError("parameter must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetPaymentMethodsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetPaymentMethodsLOVRequest) Authorization(authorization string) LOVApiGetPaymentMethodsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetPaymentMethodsLOVRequest) XAppKey(xAppKey string) LOVApiGetPaymentMethodsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetPaymentMethodsLOVRequest) XHotelid(xHotelid string) LOVApiGetPaymentMethodsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetPaymentMethodsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetPaymentMethodsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetPaymentMethodsLOVRequest) ParameterName(parameterName []string) LOVApiGetPaymentMethodsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetPaymentMethodsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetPaymentMethodsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetPaymentMethodsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetPaymentMethodsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetPaymentMethodsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetPaymentMethodsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetPaymentMethodsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetPaymentMethodsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetPaymentMethodsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetPaymentMethodsLOVExecute(r)
}

/*
GetPaymentMethodsLOV Fetch List Of Values for Payment Methods

 <p><strong>OperationId:</strong>getPaymentMethodsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch PaymentMethods LOV
 @return LOVApiGetPaymentMethodsLOVRequest
*/
func (a *LOVApiService) GetPaymentMethodsLOV(ctx context.Context, hotelId string) LOVApiGetPaymentMethodsLOVRequest {
	return LOVApiGetPaymentMethodsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetPaymentMethodsLOVExecute(r LOVApiGetPaymentMethodsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetPaymentMethodsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/paymentMethods"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetPaymentTypesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetPaymentTypesLOVRequest) Authorization(authorization string) LOVApiGetPaymentTypesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetPaymentTypesLOVRequest) XAppKey(xAppKey string) LOVApiGetPaymentTypesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetPaymentTypesLOVRequest) XHotelid(xHotelid string) LOVApiGetPaymentTypesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetPaymentTypesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetPaymentTypesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetPaymentTypesLOVRequest) ParameterName(parameterName []string) LOVApiGetPaymentTypesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetPaymentTypesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetPaymentTypesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetPaymentTypesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetPaymentTypesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetPaymentTypesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetPaymentTypesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetPaymentTypesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetPaymentTypesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetPaymentTypesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetPaymentTypesLOVExecute(r)
}

/*
GetPaymentTypesLOV Fetch List Of Values for Payment Types

 <p><strong>OperationId:</strong>getPaymentTypesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch PaymentTypes LOV
 @return LOVApiGetPaymentTypesLOVRequest
*/
func (a *LOVApiService) GetPaymentTypesLOV(ctx context.Context, hotelId string) LOVApiGetPaymentTypesLOVRequest {
	return LOVApiGetPaymentTypesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetPaymentTypesLOVExecute(r LOVApiGetPaymentTypesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetPaymentTypesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/paymentTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetPeriodSetupLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetPeriodSetupLOVRequest) Authorization(authorization string) LOVApiGetPeriodSetupLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetPeriodSetupLOVRequest) XAppKey(xAppKey string) LOVApiGetPeriodSetupLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetPeriodSetupLOVRequest) XHotelid(xHotelid string) LOVApiGetPeriodSetupLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetPeriodSetupLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetPeriodSetupLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetPeriodSetupLOVRequest) ParameterName(parameterName []string) LOVApiGetPeriodSetupLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetPeriodSetupLOVRequest) ParameterValue(parameterValue []string) LOVApiGetPeriodSetupLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetPeriodSetupLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetPeriodSetupLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetPeriodSetupLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetPeriodSetupLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetPeriodSetupLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetPeriodSetupLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetPeriodSetupLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetPeriodSetupLOVExecute(r)
}

/*
GetPeriodSetupLOV Fetch List Of Values for Period Setup

 <p><strong>OperationId:</strong>getPeriodSetupLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch PeriodSetup LOV
 @return LOVApiGetPeriodSetupLOVRequest
*/
func (a *LOVApiService) GetPeriodSetupLOV(ctx context.Context, hotelId string) LOVApiGetPeriodSetupLOVRequest {
	return LOVApiGetPeriodSetupLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetPeriodSetupLOVExecute(r LOVApiGetPeriodSetupLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetPeriodSetupLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/periodSetup"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetPeriodsSetupLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetPeriodsSetupLOVRequest) Authorization(authorization string) LOVApiGetPeriodsSetupLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetPeriodsSetupLOVRequest) XAppKey(xAppKey string) LOVApiGetPeriodsSetupLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetPeriodsSetupLOVRequest) XHotelid(xHotelid string) LOVApiGetPeriodsSetupLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetPeriodsSetupLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetPeriodsSetupLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetPeriodsSetupLOVRequest) ParameterName(parameterName []string) LOVApiGetPeriodsSetupLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetPeriodsSetupLOVRequest) ParameterValue(parameterValue []string) LOVApiGetPeriodsSetupLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetPeriodsSetupLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetPeriodsSetupLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetPeriodsSetupLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetPeriodsSetupLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetPeriodsSetupLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetPeriodsSetupLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetPeriodsSetupLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetPeriodsSetupLOVExecute(r)
}

/*
GetPeriodsSetupLOV Fetch List Of Values for Periods Setup

 <p><strong>OperationId:</strong>getPeriodsSetupLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch PeriodsSetup LOV
 @return LOVApiGetPeriodsSetupLOVRequest
*/
func (a *LOVApiService) GetPeriodsSetupLOV(ctx context.Context, hotelId string) LOVApiGetPeriodsSetupLOVRequest {
	return LOVApiGetPeriodsSetupLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetPeriodsSetupLOVExecute(r LOVApiGetPeriodsSetupLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetPeriodsSetupLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/periodsSetup"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetPostalCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	country string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetPostalCodesLOVRequest) Authorization(authorization string) LOVApiGetPostalCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetPostalCodesLOVRequest) XAppKey(xAppKey string) LOVApiGetPostalCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetPostalCodesLOVRequest) XHotelid(xHotelid string) LOVApiGetPostalCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetPostalCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetPostalCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetPostalCodesLOVRequest) ParameterName(parameterName []string) LOVApiGetPostalCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetPostalCodesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetPostalCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetPostalCodesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetPostalCodesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetPostalCodesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetPostalCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetPostalCodesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetPostalCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetPostalCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetPostalCodesLOVExecute(r)
}

/*
GetPostalCodesLOV Fetch List Of Values for Postal Codes

 <p><strong>OperationId:</strong>getPostalCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param country Value of the parameter 'country' which is required to fetch PostalCodes LOV
 @return LOVApiGetPostalCodesLOVRequest
*/
func (a *LOVApiService) GetPostalCodesLOV(ctx context.Context, country string) LOVApiGetPostalCodesLOVRequest {
	return LOVApiGetPostalCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		country: country,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetPostalCodesLOVExecute(r LOVApiGetPostalCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetPostalCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/country/{country}/postalCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"country"+"}", url.PathEscape(parameterValueToString(r.country, "country")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.country) < 1 {
		return localVarReturnValue, nil, reportError("country must have at least 1 elements")
	}
	if strlen(r.country) > 2000 {
		return localVarReturnValue, nil, reportError("country must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetPostingRoomLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetPostingRoomLOVRequest) Authorization(authorization string) LOVApiGetPostingRoomLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetPostingRoomLOVRequest) XAppKey(xAppKey string) LOVApiGetPostingRoomLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetPostingRoomLOVRequest) XHotelid(xHotelid string) LOVApiGetPostingRoomLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetPostingRoomLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetPostingRoomLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetPostingRoomLOVRequest) ParameterName(parameterName []string) LOVApiGetPostingRoomLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetPostingRoomLOVRequest) ParameterValue(parameterValue []string) LOVApiGetPostingRoomLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetPostingRoomLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetPostingRoomLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetPostingRoomLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetPostingRoomLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetPostingRoomLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetPostingRoomLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetPostingRoomLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetPostingRoomLOVExecute(r)
}

/*
GetPostingRoomLOV Fetch List Of Values for Posting Room

 <p><strong>OperationId:</strong>getPostingRoomLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch PostingRoom LOV
 @return LOVApiGetPostingRoomLOVRequest
*/
func (a *LOVApiService) GetPostingRoomLOV(ctx context.Context, hotelId string) LOVApiGetPostingRoomLOVRequest {
	return LOVApiGetPostingRoomLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetPostingRoomLOVExecute(r LOVApiGetPostingRoomLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetPostingRoomLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/postingRoom"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetPostingTransactionCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetPostingTransactionCodesLOVRequest) Authorization(authorization string) LOVApiGetPostingTransactionCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetPostingTransactionCodesLOVRequest) XAppKey(xAppKey string) LOVApiGetPostingTransactionCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetPostingTransactionCodesLOVRequest) XHotelid(xHotelid string) LOVApiGetPostingTransactionCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetPostingTransactionCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetPostingTransactionCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetPostingTransactionCodesLOVRequest) ParameterName(parameterName []string) LOVApiGetPostingTransactionCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetPostingTransactionCodesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetPostingTransactionCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetPostingTransactionCodesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetPostingTransactionCodesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetPostingTransactionCodesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetPostingTransactionCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetPostingTransactionCodesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetPostingTransactionCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetPostingTransactionCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetPostingTransactionCodesLOVExecute(r)
}

/*
GetPostingTransactionCodesLOV Fetch List Of Values for Posting Transaction Codes

 <p><strong>OperationId:</strong>getPostingTransactionCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch PostingTransactionCodes LOV
 @return LOVApiGetPostingTransactionCodesLOVRequest
*/
func (a *LOVApiService) GetPostingTransactionCodesLOV(ctx context.Context, hotelId string) LOVApiGetPostingTransactionCodesLOVRequest {
	return LOVApiGetPostingTransactionCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetPostingTransactionCodesLOVExecute(r LOVApiGetPostingTransactionCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetPostingTransactionCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/postingTransactionCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetPreferenceSubgroupsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	preferenceGroup string
	chainCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetPreferenceSubgroupsLOVRequest) Authorization(authorization string) LOVApiGetPreferenceSubgroupsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetPreferenceSubgroupsLOVRequest) XAppKey(xAppKey string) LOVApiGetPreferenceSubgroupsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetPreferenceSubgroupsLOVRequest) XHotelid(xHotelid string) LOVApiGetPreferenceSubgroupsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetPreferenceSubgroupsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetPreferenceSubgroupsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetPreferenceSubgroupsLOVRequest) ParameterName(parameterName []string) LOVApiGetPreferenceSubgroupsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetPreferenceSubgroupsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetPreferenceSubgroupsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetPreferenceSubgroupsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetPreferenceSubgroupsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetPreferenceSubgroupsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetPreferenceSubgroupsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetPreferenceSubgroupsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetPreferenceSubgroupsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetPreferenceSubgroupsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetPreferenceSubgroupsLOVExecute(r)
}

/*
GetPreferenceSubgroupsLOV Fetch List Of Values for Preference Subgroups

 <p><strong>OperationId:</strong>getPreferenceSubgroupsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param preferenceGroup Value of the parameter 'preferenceGroup' which is required to fetch PreferenceSubgroups LOV
 @param chainCode Value of the parameter 'chainCode' which is required to fetch PreferenceSubgroups LOV
 @return LOVApiGetPreferenceSubgroupsLOVRequest
*/
func (a *LOVApiService) GetPreferenceSubgroupsLOV(ctx context.Context, preferenceGroup string, chainCode string) LOVApiGetPreferenceSubgroupsLOVRequest {
	return LOVApiGetPreferenceSubgroupsLOVRequest{
		ApiService: a,
		ctx: ctx,
		preferenceGroup: preferenceGroup,
		chainCode: chainCode,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetPreferenceSubgroupsLOVExecute(r LOVApiGetPreferenceSubgroupsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetPreferenceSubgroupsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/chainCode/{chainCode}/preferenceGroup/{preferenceGroup}/preferenceSubgroups"
	localVarPath = strings.Replace(localVarPath, "{"+"preferenceGroup"+"}", url.PathEscape(parameterValueToString(r.preferenceGroup, "preferenceGroup")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"chainCode"+"}", url.PathEscape(parameterValueToString(r.chainCode, "chainCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.preferenceGroup) < 1 {
		return localVarReturnValue, nil, reportError("preferenceGroup must have at least 1 elements")
	}
	if strlen(r.preferenceGroup) > 2000 {
		return localVarReturnValue, nil, reportError("preferenceGroup must have less than 2000 elements")
	}
	if strlen(r.chainCode) < 1 {
		return localVarReturnValue, nil, reportError("chainCode must have at least 1 elements")
	}
	if strlen(r.chainCode) > 2000 {
		return localVarReturnValue, nil, reportError("chainCode must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetPreferencesMultiHotelsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	preferenceGroup string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetPreferencesMultiHotelsLOVRequest) Authorization(authorization string) LOVApiGetPreferencesMultiHotelsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetPreferencesMultiHotelsLOVRequest) XAppKey(xAppKey string) LOVApiGetPreferencesMultiHotelsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetPreferencesMultiHotelsLOVRequest) XHotelid(xHotelid string) LOVApiGetPreferencesMultiHotelsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetPreferencesMultiHotelsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetPreferencesMultiHotelsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetPreferencesMultiHotelsLOVRequest) ParameterName(parameterName []string) LOVApiGetPreferencesMultiHotelsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetPreferencesMultiHotelsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetPreferencesMultiHotelsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetPreferencesMultiHotelsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetPreferencesMultiHotelsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetPreferencesMultiHotelsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetPreferencesMultiHotelsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetPreferencesMultiHotelsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetPreferencesMultiHotelsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetPreferencesMultiHotelsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetPreferencesMultiHotelsLOVExecute(r)
}

/*
GetPreferencesMultiHotelsLOV Fetch List Of Values for Preferences Multi Hotels

 <p><strong>OperationId:</strong>getPreferencesMultiHotelsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param preferenceGroup Value of the parameter 'preferenceGroup' which is required to fetch PreferencesMultiHotels LOV
 @return LOVApiGetPreferencesMultiHotelsLOVRequest
*/
func (a *LOVApiService) GetPreferencesMultiHotelsLOV(ctx context.Context, preferenceGroup string) LOVApiGetPreferencesMultiHotelsLOVRequest {
	return LOVApiGetPreferencesMultiHotelsLOVRequest{
		ApiService: a,
		ctx: ctx,
		preferenceGroup: preferenceGroup,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetPreferencesMultiHotelsLOVExecute(r LOVApiGetPreferencesMultiHotelsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetPreferencesMultiHotelsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/preferenceGroup/{preferenceGroup}/preferencesMultiHotels"
	localVarPath = strings.Replace(localVarPath, "{"+"preferenceGroup"+"}", url.PathEscape(parameterValueToString(r.preferenceGroup, "preferenceGroup")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.preferenceGroup) < 1 {
		return localVarReturnValue, nil, reportError("preferenceGroup must have at least 1 elements")
	}
	if strlen(r.preferenceGroup) > 2000 {
		return localVarReturnValue, nil, reportError("preferenceGroup must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetPrepaidCardInterfacesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetPrepaidCardInterfacesLOVRequest) Authorization(authorization string) LOVApiGetPrepaidCardInterfacesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetPrepaidCardInterfacesLOVRequest) XAppKey(xAppKey string) LOVApiGetPrepaidCardInterfacesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetPrepaidCardInterfacesLOVRequest) XHotelid(xHotelid string) LOVApiGetPrepaidCardInterfacesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetPrepaidCardInterfacesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetPrepaidCardInterfacesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetPrepaidCardInterfacesLOVRequest) ParameterName(parameterName []string) LOVApiGetPrepaidCardInterfacesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetPrepaidCardInterfacesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetPrepaidCardInterfacesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetPrepaidCardInterfacesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetPrepaidCardInterfacesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetPrepaidCardInterfacesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetPrepaidCardInterfacesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetPrepaidCardInterfacesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetPrepaidCardInterfacesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetPrepaidCardInterfacesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetPrepaidCardInterfacesLOVExecute(r)
}

/*
GetPrepaidCardInterfacesLOV Fetch List Of Values for Prepaid Card Interfaces

 <p><strong>OperationId:</strong>getPrepaidCardInterfacesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch PrepaidCardInterfaces LOV
 @return LOVApiGetPrepaidCardInterfacesLOVRequest
*/
func (a *LOVApiService) GetPrepaidCardInterfacesLOV(ctx context.Context, hotelId string) LOVApiGetPrepaidCardInterfacesLOVRequest {
	return LOVApiGetPrepaidCardInterfacesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetPrepaidCardInterfacesLOVExecute(r LOVApiGetPrepaidCardInterfacesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetPrepaidCardInterfacesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/prepaidCardInterfaces"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetPrintersLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	alertPrinters string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetPrintersLOVRequest) Authorization(authorization string) LOVApiGetPrintersLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetPrintersLOVRequest) XAppKey(xAppKey string) LOVApiGetPrintersLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetPrintersLOVRequest) XHotelid(xHotelid string) LOVApiGetPrintersLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetPrintersLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetPrintersLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetPrintersLOVRequest) ParameterName(parameterName []string) LOVApiGetPrintersLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetPrintersLOVRequest) ParameterValue(parameterValue []string) LOVApiGetPrintersLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetPrintersLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetPrintersLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetPrintersLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetPrintersLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetPrintersLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetPrintersLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetPrintersLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetPrintersLOVExecute(r)
}

/*
GetPrintersLOV Fetch List Of Values for Printers

 <p><strong>OperationId:</strong>getPrintersLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param alertPrinters Value of the parameter 'alertPrinters' which is required to fetch Printers LOV
 @return LOVApiGetPrintersLOVRequest
*/
func (a *LOVApiService) GetPrintersLOV(ctx context.Context, alertPrinters string) LOVApiGetPrintersLOVRequest {
	return LOVApiGetPrintersLOVRequest{
		ApiService: a,
		ctx: ctx,
		alertPrinters: alertPrinters,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetPrintersLOVExecute(r LOVApiGetPrintersLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetPrintersLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/alertPrinters/{alertPrinters}/printers"
	localVarPath = strings.Replace(localVarPath, "{"+"alertPrinters"+"}", url.PathEscape(parameterValueToString(r.alertPrinters, "alertPrinters")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.alertPrinters) < 1 {
		return localVarReturnValue, nil, reportError("alertPrinters must have at least 1 elements")
	}
	if strlen(r.alertPrinters) > 2000 {
		return localVarReturnValue, nil, reportError("alertPrinters must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetPrioritiesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetPrioritiesLOVRequest) Authorization(authorization string) LOVApiGetPrioritiesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetPrioritiesLOVRequest) XAppKey(xAppKey string) LOVApiGetPrioritiesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetPrioritiesLOVRequest) XHotelid(xHotelid string) LOVApiGetPrioritiesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetPrioritiesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetPrioritiesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetPrioritiesLOVRequest) ParameterName(parameterName []string) LOVApiGetPrioritiesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetPrioritiesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetPrioritiesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetPrioritiesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetPrioritiesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetPrioritiesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetPrioritiesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetPrioritiesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetPrioritiesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetPrioritiesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetPrioritiesLOVExecute(r)
}

/*
GetPrioritiesLOV Fetch List Of Values for Priorities

 <p><strong>OperationId:</strong>getPrioritiesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch Priorities LOV
 @return LOVApiGetPrioritiesLOVRequest
*/
func (a *LOVApiService) GetPrioritiesLOV(ctx context.Context, hotelId string) LOVApiGetPrioritiesLOVRequest {
	return LOVApiGetPrioritiesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetPrioritiesLOVExecute(r LOVApiGetPrioritiesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetPrioritiesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/priorities"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetProfileCommunicationsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	profileId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetProfileCommunicationsLOVRequest) Authorization(authorization string) LOVApiGetProfileCommunicationsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetProfileCommunicationsLOVRequest) XAppKey(xAppKey string) LOVApiGetProfileCommunicationsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetProfileCommunicationsLOVRequest) XHotelid(xHotelid string) LOVApiGetProfileCommunicationsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetProfileCommunicationsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetProfileCommunicationsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetProfileCommunicationsLOVRequest) ParameterName(parameterName []string) LOVApiGetProfileCommunicationsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetProfileCommunicationsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetProfileCommunicationsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetProfileCommunicationsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetProfileCommunicationsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetProfileCommunicationsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetProfileCommunicationsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetProfileCommunicationsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetProfileCommunicationsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetProfileCommunicationsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetProfileCommunicationsLOVExecute(r)
}

/*
GetProfileCommunicationsLOV Fetch List Of Values for Profile Communications

 <p><strong>OperationId:</strong>getProfileCommunicationsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param profileId Value of the parameter 'profileId' which is required to fetch ProfileCommunications LOV
 @return LOVApiGetProfileCommunicationsLOVRequest
*/
func (a *LOVApiService) GetProfileCommunicationsLOV(ctx context.Context, profileId string) LOVApiGetProfileCommunicationsLOVRequest {
	return LOVApiGetProfileCommunicationsLOVRequest{
		ApiService: a,
		ctx: ctx,
		profileId: profileId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetProfileCommunicationsLOVExecute(r LOVApiGetProfileCommunicationsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetProfileCommunicationsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/profiles/{profileId}/profileCommunications"
	localVarPath = strings.Replace(localVarPath, "{"+"profileId"+"}", url.PathEscape(parameterValueToString(r.profileId, "profileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.profileId) < 1 {
		return localVarReturnValue, nil, reportError("profileId must have at least 1 elements")
	}
	if strlen(r.profileId) > 2000 {
		return localVarReturnValue, nil, reportError("profileId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetProfileEnrollmentMatchCriteriaLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	nameType string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetProfileEnrollmentMatchCriteriaLOVRequest) Authorization(authorization string) LOVApiGetProfileEnrollmentMatchCriteriaLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetProfileEnrollmentMatchCriteriaLOVRequest) XAppKey(xAppKey string) LOVApiGetProfileEnrollmentMatchCriteriaLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetProfileEnrollmentMatchCriteriaLOVRequest) XHotelid(xHotelid string) LOVApiGetProfileEnrollmentMatchCriteriaLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetProfileEnrollmentMatchCriteriaLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetProfileEnrollmentMatchCriteriaLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetProfileEnrollmentMatchCriteriaLOVRequest) ParameterName(parameterName []string) LOVApiGetProfileEnrollmentMatchCriteriaLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetProfileEnrollmentMatchCriteriaLOVRequest) ParameterValue(parameterValue []string) LOVApiGetProfileEnrollmentMatchCriteriaLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetProfileEnrollmentMatchCriteriaLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetProfileEnrollmentMatchCriteriaLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetProfileEnrollmentMatchCriteriaLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetProfileEnrollmentMatchCriteriaLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetProfileEnrollmentMatchCriteriaLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetProfileEnrollmentMatchCriteriaLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetProfileEnrollmentMatchCriteriaLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetProfileEnrollmentMatchCriteriaLOVExecute(r)
}

/*
GetProfileEnrollmentMatchCriteriaLOV Fetch List Of Values for Profile Enrollment Match Criteria

 <p><strong>OperationId:</strong>getProfileEnrollmentMatchCriteriaLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameType Value of the parameter 'nameType' which is required to fetch ProfileEnrollmentMatchCriteria LOV
 @return LOVApiGetProfileEnrollmentMatchCriteriaLOVRequest
*/
func (a *LOVApiService) GetProfileEnrollmentMatchCriteriaLOV(ctx context.Context, nameType string) LOVApiGetProfileEnrollmentMatchCriteriaLOVRequest {
	return LOVApiGetProfileEnrollmentMatchCriteriaLOVRequest{
		ApiService: a,
		ctx: ctx,
		nameType: nameType,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetProfileEnrollmentMatchCriteriaLOVExecute(r LOVApiGetProfileEnrollmentMatchCriteriaLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetProfileEnrollmentMatchCriteriaLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/nameType/{nameType}/profileEnrollmentMatchCriteria"
	localVarPath = strings.Replace(localVarPath, "{"+"nameType"+"}", url.PathEscape(parameterValueToString(r.nameType, "nameType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.nameType) < 1 {
		return localVarReturnValue, nil, reportError("nameType must have at least 1 elements")
	}
	if strlen(r.nameType) > 2000 {
		return localVarReturnValue, nil, reportError("nameType must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetProfileEnrollmentRuleDoNotMergeCriteriaLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	nameType string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetProfileEnrollmentRuleDoNotMergeCriteriaLOVRequest) Authorization(authorization string) LOVApiGetProfileEnrollmentRuleDoNotMergeCriteriaLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetProfileEnrollmentRuleDoNotMergeCriteriaLOVRequest) XAppKey(xAppKey string) LOVApiGetProfileEnrollmentRuleDoNotMergeCriteriaLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetProfileEnrollmentRuleDoNotMergeCriteriaLOVRequest) XHotelid(xHotelid string) LOVApiGetProfileEnrollmentRuleDoNotMergeCriteriaLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetProfileEnrollmentRuleDoNotMergeCriteriaLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetProfileEnrollmentRuleDoNotMergeCriteriaLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetProfileEnrollmentRuleDoNotMergeCriteriaLOVRequest) ParameterName(parameterName []string) LOVApiGetProfileEnrollmentRuleDoNotMergeCriteriaLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetProfileEnrollmentRuleDoNotMergeCriteriaLOVRequest) ParameterValue(parameterValue []string) LOVApiGetProfileEnrollmentRuleDoNotMergeCriteriaLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetProfileEnrollmentRuleDoNotMergeCriteriaLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetProfileEnrollmentRuleDoNotMergeCriteriaLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetProfileEnrollmentRuleDoNotMergeCriteriaLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetProfileEnrollmentRuleDoNotMergeCriteriaLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetProfileEnrollmentRuleDoNotMergeCriteriaLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetProfileEnrollmentRuleDoNotMergeCriteriaLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetProfileEnrollmentRuleDoNotMergeCriteriaLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetProfileEnrollmentRuleDoNotMergeCriteriaLOVExecute(r)
}

/*
GetProfileEnrollmentRuleDoNotMergeCriteriaLOV Fetch List Of Values for Profile Enrollment Rule Do Not Merge Criteria

 <p><strong>OperationId:</strong>getProfileEnrollmentRuleDoNotMergeCriteriaLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameType Value of the parameter 'nameType' which is required to fetch ProfileEnrollmentRuleDoNotMergeCriteria LOV
 @return LOVApiGetProfileEnrollmentRuleDoNotMergeCriteriaLOVRequest
*/
func (a *LOVApiService) GetProfileEnrollmentRuleDoNotMergeCriteriaLOV(ctx context.Context, nameType string) LOVApiGetProfileEnrollmentRuleDoNotMergeCriteriaLOVRequest {
	return LOVApiGetProfileEnrollmentRuleDoNotMergeCriteriaLOVRequest{
		ApiService: a,
		ctx: ctx,
		nameType: nameType,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetProfileEnrollmentRuleDoNotMergeCriteriaLOVExecute(r LOVApiGetProfileEnrollmentRuleDoNotMergeCriteriaLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetProfileEnrollmentRuleDoNotMergeCriteriaLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/nameType/{nameType}/profileEnrollmentRuleDoNotMergeCriteria"
	localVarPath = strings.Replace(localVarPath, "{"+"nameType"+"}", url.PathEscape(parameterValueToString(r.nameType, "nameType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.nameType) < 1 {
		return localVarReturnValue, nil, reportError("nameType must have at least 1 elements")
	}
	if strlen(r.nameType) > 2000 {
		return localVarReturnValue, nil, reportError("nameType must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetProfileEnrollmentRuleFilterCriteriaLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	nameType string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetProfileEnrollmentRuleFilterCriteriaLOVRequest) Authorization(authorization string) LOVApiGetProfileEnrollmentRuleFilterCriteriaLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetProfileEnrollmentRuleFilterCriteriaLOVRequest) XAppKey(xAppKey string) LOVApiGetProfileEnrollmentRuleFilterCriteriaLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetProfileEnrollmentRuleFilterCriteriaLOVRequest) XHotelid(xHotelid string) LOVApiGetProfileEnrollmentRuleFilterCriteriaLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetProfileEnrollmentRuleFilterCriteriaLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetProfileEnrollmentRuleFilterCriteriaLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetProfileEnrollmentRuleFilterCriteriaLOVRequest) ParameterName(parameterName []string) LOVApiGetProfileEnrollmentRuleFilterCriteriaLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetProfileEnrollmentRuleFilterCriteriaLOVRequest) ParameterValue(parameterValue []string) LOVApiGetProfileEnrollmentRuleFilterCriteriaLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetProfileEnrollmentRuleFilterCriteriaLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetProfileEnrollmentRuleFilterCriteriaLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetProfileEnrollmentRuleFilterCriteriaLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetProfileEnrollmentRuleFilterCriteriaLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetProfileEnrollmentRuleFilterCriteriaLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetProfileEnrollmentRuleFilterCriteriaLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetProfileEnrollmentRuleFilterCriteriaLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetProfileEnrollmentRuleFilterCriteriaLOVExecute(r)
}

/*
GetProfileEnrollmentRuleFilterCriteriaLOV Fetch List Of Values for Profile Enrollment Rule Filter Criteria

 <p><strong>OperationId:</strong>getProfileEnrollmentRuleFilterCriteriaLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nameType Value of the parameter 'nameType' which is required to fetch ProfileEnrollmentRuleFilterCriteria LOV
 @return LOVApiGetProfileEnrollmentRuleFilterCriteriaLOVRequest
*/
func (a *LOVApiService) GetProfileEnrollmentRuleFilterCriteriaLOV(ctx context.Context, nameType string) LOVApiGetProfileEnrollmentRuleFilterCriteriaLOVRequest {
	return LOVApiGetProfileEnrollmentRuleFilterCriteriaLOVRequest{
		ApiService: a,
		ctx: ctx,
		nameType: nameType,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetProfileEnrollmentRuleFilterCriteriaLOVExecute(r LOVApiGetProfileEnrollmentRuleFilterCriteriaLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetProfileEnrollmentRuleFilterCriteriaLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/nameType/{nameType}/profileEnrollmentRuleFilterCriteria"
	localVarPath = strings.Replace(localVarPath, "{"+"nameType"+"}", url.PathEscape(parameterValueToString(r.nameType, "nameType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.nameType) < 1 {
		return localVarReturnValue, nil, reportError("nameType must have at least 1 elements")
	}
	if strlen(r.nameType) > 2000 {
		return localVarReturnValue, nil, reportError("nameType must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetProfileHotelsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	taxTypeCheck string
	profileId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetProfileHotelsLOVRequest) Authorization(authorization string) LOVApiGetProfileHotelsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetProfileHotelsLOVRequest) XAppKey(xAppKey string) LOVApiGetProfileHotelsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetProfileHotelsLOVRequest) XHotelid(xHotelid string) LOVApiGetProfileHotelsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetProfileHotelsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetProfileHotelsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetProfileHotelsLOVRequest) ParameterName(parameterName []string) LOVApiGetProfileHotelsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetProfileHotelsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetProfileHotelsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetProfileHotelsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetProfileHotelsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetProfileHotelsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetProfileHotelsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetProfileHotelsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetProfileHotelsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetProfileHotelsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetProfileHotelsLOVExecute(r)
}

/*
GetProfileHotelsLOV Fetch List Of Values for Profile Hotels

 <p><strong>OperationId:</strong>getProfileHotelsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taxTypeCheck Value of the parameter 'taxTypeCheck' which is required to fetch ProfileHotels LOV
 @param profileId Value of the parameter 'profileId' which is required to fetch ProfileHotels LOV
 @return LOVApiGetProfileHotelsLOVRequest
*/
func (a *LOVApiService) GetProfileHotelsLOV(ctx context.Context, taxTypeCheck string, profileId string) LOVApiGetProfileHotelsLOVRequest {
	return LOVApiGetProfileHotelsLOVRequest{
		ApiService: a,
		ctx: ctx,
		taxTypeCheck: taxTypeCheck,
		profileId: profileId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetProfileHotelsLOVExecute(r LOVApiGetProfileHotelsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetProfileHotelsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/profiles/{profileId}/taxTypeCheck/{taxTypeCheck}/profileHotels"
	localVarPath = strings.Replace(localVarPath, "{"+"taxTypeCheck"+"}", url.PathEscape(parameterValueToString(r.taxTypeCheck, "taxTypeCheck")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"profileId"+"}", url.PathEscape(parameterValueToString(r.profileId, "profileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.taxTypeCheck) < 1 {
		return localVarReturnValue, nil, reportError("taxTypeCheck must have at least 1 elements")
	}
	if strlen(r.taxTypeCheck) > 2000 {
		return localVarReturnValue, nil, reportError("taxTypeCheck must have less than 2000 elements")
	}
	if strlen(r.profileId) < 1 {
		return localVarReturnValue, nil, reportError("profileId must have at least 1 elements")
	}
	if strlen(r.profileId) > 2000 {
		return localVarReturnValue, nil, reportError("profileId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetProfileIdentificationsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	profileId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetProfileIdentificationsLOVRequest) Authorization(authorization string) LOVApiGetProfileIdentificationsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetProfileIdentificationsLOVRequest) XAppKey(xAppKey string) LOVApiGetProfileIdentificationsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetProfileIdentificationsLOVRequest) XHotelid(xHotelid string) LOVApiGetProfileIdentificationsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetProfileIdentificationsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetProfileIdentificationsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetProfileIdentificationsLOVRequest) ParameterName(parameterName []string) LOVApiGetProfileIdentificationsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetProfileIdentificationsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetProfileIdentificationsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetProfileIdentificationsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetProfileIdentificationsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetProfileIdentificationsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetProfileIdentificationsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetProfileIdentificationsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetProfileIdentificationsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetProfileIdentificationsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetProfileIdentificationsLOVExecute(r)
}

/*
GetProfileIdentificationsLOV Fetch List Of Values for Profile Identifications

 <p><strong>OperationId:</strong>getProfileIdentificationsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param profileId Value of the parameter 'profileId' which is required to fetch ProfileIdentifications LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ProfileIdentifications LOV
 @return LOVApiGetProfileIdentificationsLOVRequest
*/
func (a *LOVApiService) GetProfileIdentificationsLOV(ctx context.Context, profileId string, hotelId string) LOVApiGetProfileIdentificationsLOVRequest {
	return LOVApiGetProfileIdentificationsLOVRequest{
		ApiService: a,
		ctx: ctx,
		profileId: profileId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetProfileIdentificationsLOVExecute(r LOVApiGetProfileIdentificationsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetProfileIdentificationsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/profiles/{profileId}/profileIdentifications"
	localVarPath = strings.Replace(localVarPath, "{"+"profileId"+"}", url.PathEscape(parameterValueToString(r.profileId, "profileId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.profileId) < 1 {
		return localVarReturnValue, nil, reportError("profileId must have at least 1 elements")
	}
	if strlen(r.profileId) > 2000 {
		return localVarReturnValue, nil, reportError("profileId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetProfileNameValidationsTypeLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	operaParam string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetProfileNameValidationsTypeLOVRequest) Authorization(authorization string) LOVApiGetProfileNameValidationsTypeLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetProfileNameValidationsTypeLOVRequest) XAppKey(xAppKey string) LOVApiGetProfileNameValidationsTypeLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetProfileNameValidationsTypeLOVRequest) XHotelid(xHotelid string) LOVApiGetProfileNameValidationsTypeLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetProfileNameValidationsTypeLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetProfileNameValidationsTypeLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetProfileNameValidationsTypeLOVRequest) ParameterName(parameterName []string) LOVApiGetProfileNameValidationsTypeLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetProfileNameValidationsTypeLOVRequest) ParameterValue(parameterValue []string) LOVApiGetProfileNameValidationsTypeLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetProfileNameValidationsTypeLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetProfileNameValidationsTypeLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetProfileNameValidationsTypeLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetProfileNameValidationsTypeLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetProfileNameValidationsTypeLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetProfileNameValidationsTypeLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetProfileNameValidationsTypeLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetProfileNameValidationsTypeLOVExecute(r)
}

/*
GetProfileNameValidationsTypeLOV Fetch List Of Values for Profile Name Validations Type

 <p><strong>OperationId:</strong>getProfileNameValidationsTypeLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param operaParam Value of the parameter 'operaParam' which is required to fetch ProfileNameValidationsType LOV
 @return LOVApiGetProfileNameValidationsTypeLOVRequest
*/
func (a *LOVApiService) GetProfileNameValidationsTypeLOV(ctx context.Context, operaParam string) LOVApiGetProfileNameValidationsTypeLOVRequest {
	return LOVApiGetProfileNameValidationsTypeLOVRequest{
		ApiService: a,
		ctx: ctx,
		operaParam: operaParam,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetProfileNameValidationsTypeLOVExecute(r LOVApiGetProfileNameValidationsTypeLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetProfileNameValidationsTypeLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/operaParam/{operaParam}/profileNameValidationsType"
	localVarPath = strings.Replace(localVarPath, "{"+"operaParam"+"}", url.PathEscape(parameterValueToString(r.operaParam, "operaParam")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.operaParam) < 1 {
		return localVarReturnValue, nil, reportError("operaParam must have at least 1 elements")
	}
	if strlen(r.operaParam) > 2000 {
		return localVarReturnValue, nil, reportError("operaParam must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetPromoGroupsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetPromoGroupsLOVRequest) Authorization(authorization string) LOVApiGetPromoGroupsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetPromoGroupsLOVRequest) XAppKey(xAppKey string) LOVApiGetPromoGroupsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetPromoGroupsLOVRequest) XHotelid(xHotelid string) LOVApiGetPromoGroupsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetPromoGroupsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetPromoGroupsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetPromoGroupsLOVRequest) ParameterName(parameterName []string) LOVApiGetPromoGroupsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetPromoGroupsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetPromoGroupsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetPromoGroupsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetPromoGroupsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetPromoGroupsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetPromoGroupsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetPromoGroupsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetPromoGroupsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetPromoGroupsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetPromoGroupsLOVExecute(r)
}

/*
GetPromoGroupsLOV Fetch List Of Values for Promo Groups

 <p><strong>OperationId:</strong>getPromoGroupsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch PromoGroups LOV
 @return LOVApiGetPromoGroupsLOVRequest
*/
func (a *LOVApiService) GetPromoGroupsLOV(ctx context.Context, hotelId string) LOVApiGetPromoGroupsLOVRequest {
	return LOVApiGetPromoGroupsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetPromoGroupsLOVExecute(r LOVApiGetPromoGroupsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetPromoGroupsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/promoGroups"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetPromoRatesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	promoCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetPromoRatesLOVRequest) Authorization(authorization string) LOVApiGetPromoRatesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetPromoRatesLOVRequest) XAppKey(xAppKey string) LOVApiGetPromoRatesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetPromoRatesLOVRequest) XHotelid(xHotelid string) LOVApiGetPromoRatesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetPromoRatesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetPromoRatesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetPromoRatesLOVRequest) ParameterName(parameterName []string) LOVApiGetPromoRatesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetPromoRatesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetPromoRatesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetPromoRatesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetPromoRatesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetPromoRatesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetPromoRatesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetPromoRatesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetPromoRatesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetPromoRatesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetPromoRatesLOVExecute(r)
}

/*
GetPromoRatesLOV Fetch List Of Values for Promo Rates

 <p><strong>OperationId:</strong>getPromoRatesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param promoCode Value of the parameter 'promoCode' which is required to fetch PromoRates LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch PromoRates LOV
 @return LOVApiGetPromoRatesLOVRequest
*/
func (a *LOVApiService) GetPromoRatesLOV(ctx context.Context, promoCode string, hotelId string) LOVApiGetPromoRatesLOVRequest {
	return LOVApiGetPromoRatesLOVRequest{
		ApiService: a,
		ctx: ctx,
		promoCode: promoCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetPromoRatesLOVExecute(r LOVApiGetPromoRatesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetPromoRatesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/promoCode/{promoCode}/promoRates"
	localVarPath = strings.Replace(localVarPath, "{"+"promoCode"+"}", url.PathEscape(parameterValueToString(r.promoCode, "promoCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.promoCode) < 1 {
		return localVarReturnValue, nil, reportError("promoCode must have at least 1 elements")
	}
	if strlen(r.promoCode) > 2000 {
		return localVarReturnValue, nil, reportError("promoCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetPropertyAmenitiesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetPropertyAmenitiesLOVRequest) Authorization(authorization string) LOVApiGetPropertyAmenitiesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetPropertyAmenitiesLOVRequest) XAppKey(xAppKey string) LOVApiGetPropertyAmenitiesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetPropertyAmenitiesLOVRequest) XHotelid(xHotelid string) LOVApiGetPropertyAmenitiesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetPropertyAmenitiesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetPropertyAmenitiesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetPropertyAmenitiesLOVRequest) ParameterName(parameterName []string) LOVApiGetPropertyAmenitiesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetPropertyAmenitiesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetPropertyAmenitiesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetPropertyAmenitiesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetPropertyAmenitiesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetPropertyAmenitiesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetPropertyAmenitiesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetPropertyAmenitiesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetPropertyAmenitiesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetPropertyAmenitiesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetPropertyAmenitiesLOVExecute(r)
}

/*
GetPropertyAmenitiesLOV Fetch List Of Values for Property Amenities

 <p><strong>OperationId:</strong>getPropertyAmenitiesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch PropertyAmenities LOV
 @return LOVApiGetPropertyAmenitiesLOVRequest
*/
func (a *LOVApiService) GetPropertyAmenitiesLOV(ctx context.Context, hotelId string) LOVApiGetPropertyAmenitiesLOVRequest {
	return LOVApiGetPropertyAmenitiesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetPropertyAmenitiesLOVExecute(r LOVApiGetPropertyAmenitiesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetPropertyAmenitiesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/propertyAmenities"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetPublisherPropertiesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	subscriber string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetPublisherPropertiesLOVRequest) Authorization(authorization string) LOVApiGetPublisherPropertiesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetPublisherPropertiesLOVRequest) XAppKey(xAppKey string) LOVApiGetPublisherPropertiesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetPublisherPropertiesLOVRequest) XHotelid(xHotelid string) LOVApiGetPublisherPropertiesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetPublisherPropertiesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetPublisherPropertiesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetPublisherPropertiesLOVRequest) ParameterName(parameterName []string) LOVApiGetPublisherPropertiesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetPublisherPropertiesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetPublisherPropertiesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetPublisherPropertiesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetPublisherPropertiesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetPublisherPropertiesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetPublisherPropertiesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetPublisherPropertiesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetPublisherPropertiesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetPublisherPropertiesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetPublisherPropertiesLOVExecute(r)
}

/*
GetPublisherPropertiesLOV Fetch List Of Values for Publisher Properties

 <p><strong>OperationId:</strong>getPublisherPropertiesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param subscriber Value of the parameter 'subscriber' which is required to fetch PublisherProperties LOV
 @return LOVApiGetPublisherPropertiesLOVRequest
*/
func (a *LOVApiService) GetPublisherPropertiesLOV(ctx context.Context, subscriber string) LOVApiGetPublisherPropertiesLOVRequest {
	return LOVApiGetPublisherPropertiesLOVRequest{
		ApiService: a,
		ctx: ctx,
		subscriber: subscriber,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetPublisherPropertiesLOVExecute(r LOVApiGetPublisherPropertiesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetPublisherPropertiesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/subscriber/{subscriber}/publisherProperties"
	localVarPath = strings.Replace(localVarPath, "{"+"subscriber"+"}", url.PathEscape(parameterValueToString(r.subscriber, "subscriber")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.subscriber) < 1 {
		return localVarReturnValue, nil, reportError("subscriber must have at least 1 elements")
	}
	if strlen(r.subscriber) > 2000 {
		return localVarReturnValue, nil, reportError("subscriber must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetQueueNameLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelCodeList string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetQueueNameLOVRequest) Authorization(authorization string) LOVApiGetQueueNameLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetQueueNameLOVRequest) XAppKey(xAppKey string) LOVApiGetQueueNameLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetQueueNameLOVRequest) XHotelid(xHotelid string) LOVApiGetQueueNameLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetQueueNameLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetQueueNameLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetQueueNameLOVRequest) ParameterName(parameterName []string) LOVApiGetQueueNameLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetQueueNameLOVRequest) ParameterValue(parameterValue []string) LOVApiGetQueueNameLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetQueueNameLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetQueueNameLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetQueueNameLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetQueueNameLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetQueueNameLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetQueueNameLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetQueueNameLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetQueueNameLOVExecute(r)
}

/*
GetQueueNameLOV Fetch List Of Values for Queue Name

 <p><strong>OperationId:</strong>getQueueNameLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelCodeList Value of the parameter 'hotelCodeList' which is required to fetch QueueName LOV
 @return LOVApiGetQueueNameLOVRequest
*/
func (a *LOVApiService) GetQueueNameLOV(ctx context.Context, hotelCodeList string) LOVApiGetQueueNameLOVRequest {
	return LOVApiGetQueueNameLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelCodeList: hotelCodeList,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetQueueNameLOVExecute(r LOVApiGetQueueNameLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetQueueNameLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotelCodeList/{hotelCodeList}/queueName"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelCodeList"+"}", url.PathEscape(parameterValueToString(r.hotelCodeList, "hotelCodeList")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelCodeList) < 1 {
		return localVarReturnValue, nil, reportError("hotelCodeList must have at least 1 elements")
	}
	if strlen(r.hotelCodeList) > 2000 {
		return localVarReturnValue, nil, reportError("hotelCodeList must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetQuickTextsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	departmentId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetQuickTextsLOVRequest) Authorization(authorization string) LOVApiGetQuickTextsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetQuickTextsLOVRequest) XAppKey(xAppKey string) LOVApiGetQuickTextsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetQuickTextsLOVRequest) XHotelid(xHotelid string) LOVApiGetQuickTextsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetQuickTextsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetQuickTextsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetQuickTextsLOVRequest) ParameterName(parameterName []string) LOVApiGetQuickTextsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetQuickTextsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetQuickTextsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetQuickTextsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetQuickTextsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetQuickTextsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetQuickTextsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetQuickTextsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetQuickTextsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetQuickTextsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetQuickTextsLOVExecute(r)
}

/*
GetQuickTextsLOV Fetch List Of Values for Quick Texts

 <p><strong>OperationId:</strong>getQuickTextsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param departmentId Value of the parameter 'departmentId' which is required to fetch QuickTexts LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch QuickTexts LOV
 @return LOVApiGetQuickTextsLOVRequest
*/
func (a *LOVApiService) GetQuickTextsLOV(ctx context.Context, departmentId string, hotelId string) LOVApiGetQuickTextsLOVRequest {
	return LOVApiGetQuickTextsLOVRequest{
		ApiService: a,
		ctx: ctx,
		departmentId: departmentId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetQuickTextsLOVExecute(r LOVApiGetQuickTextsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetQuickTextsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/departmentId/{departmentId}/quickTexts"
	localVarPath = strings.Replace(localVarPath, "{"+"departmentId"+"}", url.PathEscape(parameterValueToString(r.departmentId, "departmentId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.departmentId) < 1 {
		return localVarReturnValue, nil, reportError("departmentId must have at least 1 elements")
	}
	if strlen(r.departmentId) > 2000 {
		return localVarReturnValue, nil, reportError("departmentId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetRateCategoriesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetRateCategoriesLOVRequest) Authorization(authorization string) LOVApiGetRateCategoriesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetRateCategoriesLOVRequest) XAppKey(xAppKey string) LOVApiGetRateCategoriesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetRateCategoriesLOVRequest) XHotelid(xHotelid string) LOVApiGetRateCategoriesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetRateCategoriesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetRateCategoriesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetRateCategoriesLOVRequest) ParameterName(parameterName []string) LOVApiGetRateCategoriesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetRateCategoriesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetRateCategoriesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetRateCategoriesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetRateCategoriesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetRateCategoriesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetRateCategoriesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetRateCategoriesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetRateCategoriesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetRateCategoriesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRateCategoriesLOVExecute(r)
}

/*
GetRateCategoriesLOV Fetch List Of Values for Rate Categories

 <p><strong>OperationId:</strong>getRateCategoriesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RateCategories LOV
 @return LOVApiGetRateCategoriesLOVRequest
*/
func (a *LOVApiService) GetRateCategoriesLOV(ctx context.Context, hotelId string) LOVApiGetRateCategoriesLOVRequest {
	return LOVApiGetRateCategoriesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRateCategoriesLOVExecute(r LOVApiGetRateCategoriesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRateCategoriesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/rateCategories"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetRateCodeGlobalDescEditLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetRateCodeGlobalDescEditLOVRequest) Authorization(authorization string) LOVApiGetRateCodeGlobalDescEditLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetRateCodeGlobalDescEditLOVRequest) XAppKey(xAppKey string) LOVApiGetRateCodeGlobalDescEditLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetRateCodeGlobalDescEditLOVRequest) XHotelid(xHotelid string) LOVApiGetRateCodeGlobalDescEditLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetRateCodeGlobalDescEditLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetRateCodeGlobalDescEditLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetRateCodeGlobalDescEditLOVRequest) ParameterName(parameterName []string) LOVApiGetRateCodeGlobalDescEditLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetRateCodeGlobalDescEditLOVRequest) ParameterValue(parameterValue []string) LOVApiGetRateCodeGlobalDescEditLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetRateCodeGlobalDescEditLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetRateCodeGlobalDescEditLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetRateCodeGlobalDescEditLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetRateCodeGlobalDescEditLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetRateCodeGlobalDescEditLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetRateCodeGlobalDescEditLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetRateCodeGlobalDescEditLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRateCodeGlobalDescEditLOVExecute(r)
}

/*
GetRateCodeGlobalDescEditLOV Fetch List Of Values for Rate Code Global Desc Edit

 <p><strong>OperationId:</strong>getRateCodeGlobalDescEditLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RateCodeGlobalDescEdit LOV
 @return LOVApiGetRateCodeGlobalDescEditLOVRequest
*/
func (a *LOVApiService) GetRateCodeGlobalDescEditLOV(ctx context.Context, hotelId string) LOVApiGetRateCodeGlobalDescEditLOVRequest {
	return LOVApiGetRateCodeGlobalDescEditLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRateCodeGlobalDescEditLOVExecute(r LOVApiGetRateCodeGlobalDescEditLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRateCodeGlobalDescEditLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/rateCodeGlobalDescEdit"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetRateCodesByTypeLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	rateCodeType string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetRateCodesByTypeLOVRequest) Authorization(authorization string) LOVApiGetRateCodesByTypeLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetRateCodesByTypeLOVRequest) XAppKey(xAppKey string) LOVApiGetRateCodesByTypeLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetRateCodesByTypeLOVRequest) XHotelid(xHotelid string) LOVApiGetRateCodesByTypeLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetRateCodesByTypeLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetRateCodesByTypeLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetRateCodesByTypeLOVRequest) ParameterName(parameterName []string) LOVApiGetRateCodesByTypeLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetRateCodesByTypeLOVRequest) ParameterValue(parameterValue []string) LOVApiGetRateCodesByTypeLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetRateCodesByTypeLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetRateCodesByTypeLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetRateCodesByTypeLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetRateCodesByTypeLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetRateCodesByTypeLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetRateCodesByTypeLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetRateCodesByTypeLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRateCodesByTypeLOVExecute(r)
}

/*
GetRateCodesByTypeLOV Fetch List Of Values for Rate Codes By Type

 <p><strong>OperationId:</strong>getRateCodesByTypeLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param rateCodeType Value of the parameter 'rateCodeType' which is required to fetch RateCodesByType LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RateCodesByType LOV
 @return LOVApiGetRateCodesByTypeLOVRequest
*/
func (a *LOVApiService) GetRateCodesByTypeLOV(ctx context.Context, rateCodeType string, hotelId string) LOVApiGetRateCodesByTypeLOVRequest {
	return LOVApiGetRateCodesByTypeLOVRequest{
		ApiService: a,
		ctx: ctx,
		rateCodeType: rateCodeType,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRateCodesByTypeLOVExecute(r LOVApiGetRateCodesByTypeLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRateCodesByTypeLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/rateCodeType/{rateCodeType}/rateCodesByType"
	localVarPath = strings.Replace(localVarPath, "{"+"rateCodeType"+"}", url.PathEscape(parameterValueToString(r.rateCodeType, "rateCodeType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.rateCodeType) < 1 {
		return localVarReturnValue, nil, reportError("rateCodeType must have at least 1 elements")
	}
	if strlen(r.rateCodeType) > 2000 {
		return localVarReturnValue, nil, reportError("rateCodeType must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetRateCodesValidLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetRateCodesValidLOVRequest) Authorization(authorization string) LOVApiGetRateCodesValidLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetRateCodesValidLOVRequest) XAppKey(xAppKey string) LOVApiGetRateCodesValidLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetRateCodesValidLOVRequest) XHotelid(xHotelid string) LOVApiGetRateCodesValidLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetRateCodesValidLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetRateCodesValidLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetRateCodesValidLOVRequest) ParameterName(parameterName []string) LOVApiGetRateCodesValidLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetRateCodesValidLOVRequest) ParameterValue(parameterValue []string) LOVApiGetRateCodesValidLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetRateCodesValidLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetRateCodesValidLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetRateCodesValidLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetRateCodesValidLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetRateCodesValidLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetRateCodesValidLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetRateCodesValidLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRateCodesValidLOVExecute(r)
}

/*
GetRateCodesValidLOV Fetch List Of Values for Rate Codes Valid

 <p><strong>OperationId:</strong>getRateCodesValidLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RateCodesValid LOV
 @return LOVApiGetRateCodesValidLOVRequest
*/
func (a *LOVApiService) GetRateCodesValidLOV(ctx context.Context, hotelId string) LOVApiGetRateCodesValidLOVRequest {
	return LOVApiGetRateCodesValidLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRateCodesValidLOVExecute(r LOVApiGetRateCodesValidLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRateCodesValidLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/rateCodesValid"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetRateCommissionCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetRateCommissionCodesLOVRequest) Authorization(authorization string) LOVApiGetRateCommissionCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetRateCommissionCodesLOVRequest) XAppKey(xAppKey string) LOVApiGetRateCommissionCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetRateCommissionCodesLOVRequest) XHotelid(xHotelid string) LOVApiGetRateCommissionCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetRateCommissionCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetRateCommissionCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetRateCommissionCodesLOVRequest) ParameterName(parameterName []string) LOVApiGetRateCommissionCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetRateCommissionCodesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetRateCommissionCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetRateCommissionCodesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetRateCommissionCodesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetRateCommissionCodesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetRateCommissionCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetRateCommissionCodesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetRateCommissionCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetRateCommissionCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRateCommissionCodesLOVExecute(r)
}

/*
GetRateCommissionCodesLOV Fetch List Of Values for Rate Commission Codes

 <p><strong>OperationId:</strong>getRateCommissionCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RateCommissionCodes LOV
 @return LOVApiGetRateCommissionCodesLOVRequest
*/
func (a *LOVApiService) GetRateCommissionCodesLOV(ctx context.Context, hotelId string) LOVApiGetRateCommissionCodesLOVRequest {
	return LOVApiGetRateCommissionCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRateCommissionCodesLOVExecute(r LOVApiGetRateCommissionCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRateCommissionCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/rateCommissionCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetRateConfigCurrenciesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetRateConfigCurrenciesLOVRequest) Authorization(authorization string) LOVApiGetRateConfigCurrenciesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetRateConfigCurrenciesLOVRequest) XAppKey(xAppKey string) LOVApiGetRateConfigCurrenciesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetRateConfigCurrenciesLOVRequest) XHotelid(xHotelid string) LOVApiGetRateConfigCurrenciesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetRateConfigCurrenciesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetRateConfigCurrenciesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetRateConfigCurrenciesLOVRequest) ParameterName(parameterName []string) LOVApiGetRateConfigCurrenciesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetRateConfigCurrenciesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetRateConfigCurrenciesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetRateConfigCurrenciesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetRateConfigCurrenciesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetRateConfigCurrenciesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetRateConfigCurrenciesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetRateConfigCurrenciesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetRateConfigCurrenciesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetRateConfigCurrenciesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRateConfigCurrenciesLOVExecute(r)
}

/*
GetRateConfigCurrenciesLOV Fetch List Of Values for Rate Config Currencies

 <p><strong>OperationId:</strong>getRateConfigCurrenciesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RateConfigCurrencies LOV
 @return LOVApiGetRateConfigCurrenciesLOVRequest
*/
func (a *LOVApiService) GetRateConfigCurrenciesLOV(ctx context.Context, hotelId string) LOVApiGetRateConfigCurrenciesLOVRequest {
	return LOVApiGetRateConfigCurrenciesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRateConfigCurrenciesLOVExecute(r LOVApiGetRateConfigCurrenciesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRateConfigCurrenciesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/rateConfigCurrencies"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetRateGroupsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetRateGroupsLOVRequest) Authorization(authorization string) LOVApiGetRateGroupsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetRateGroupsLOVRequest) XAppKey(xAppKey string) LOVApiGetRateGroupsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetRateGroupsLOVRequest) XHotelid(xHotelid string) LOVApiGetRateGroupsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetRateGroupsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetRateGroupsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetRateGroupsLOVRequest) ParameterName(parameterName []string) LOVApiGetRateGroupsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetRateGroupsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetRateGroupsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetRateGroupsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetRateGroupsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetRateGroupsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetRateGroupsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetRateGroupsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetRateGroupsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetRateGroupsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRateGroupsLOVExecute(r)
}

/*
GetRateGroupsLOV Fetch List Of Values for Rate Groups

 <p><strong>OperationId:</strong>getRateGroupsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RateGroups LOV
 @return LOVApiGetRateGroupsLOVRequest
*/
func (a *LOVApiService) GetRateGroupsLOV(ctx context.Context, hotelId string) LOVApiGetRateGroupsLOVRequest {
	return LOVApiGetRateGroupsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRateGroupsLOVExecute(r LOVApiGetRateGroupsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRateGroupsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/rateGroups"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetRatePlanForMassRateLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	rateCodeType string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetRatePlanForMassRateLOVRequest) Authorization(authorization string) LOVApiGetRatePlanForMassRateLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetRatePlanForMassRateLOVRequest) XAppKey(xAppKey string) LOVApiGetRatePlanForMassRateLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetRatePlanForMassRateLOVRequest) XHotelid(xHotelid string) LOVApiGetRatePlanForMassRateLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetRatePlanForMassRateLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetRatePlanForMassRateLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetRatePlanForMassRateLOVRequest) ParameterName(parameterName []string) LOVApiGetRatePlanForMassRateLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetRatePlanForMassRateLOVRequest) ParameterValue(parameterValue []string) LOVApiGetRatePlanForMassRateLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetRatePlanForMassRateLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetRatePlanForMassRateLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetRatePlanForMassRateLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetRatePlanForMassRateLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetRatePlanForMassRateLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetRatePlanForMassRateLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetRatePlanForMassRateLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRatePlanForMassRateLOVExecute(r)
}

/*
GetRatePlanForMassRateLOV Fetch List Of Values for Rate Plan For Mass Rate

 <p><strong>OperationId:</strong>getRatePlanForMassRateLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param rateCodeType Value of the parameter 'rateCodeType' which is required to fetch RatePlanForMassRate LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RatePlanForMassRate LOV
 @return LOVApiGetRatePlanForMassRateLOVRequest
*/
func (a *LOVApiService) GetRatePlanForMassRateLOV(ctx context.Context, rateCodeType string, hotelId string) LOVApiGetRatePlanForMassRateLOVRequest {
	return LOVApiGetRatePlanForMassRateLOVRequest{
		ApiService: a,
		ctx: ctx,
		rateCodeType: rateCodeType,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRatePlanForMassRateLOVExecute(r LOVApiGetRatePlanForMassRateLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRatePlanForMassRateLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/rateCodeType/{rateCodeType}/ratePlanForMassRate"
	localVarPath = strings.Replace(localVarPath, "{"+"rateCodeType"+"}", url.PathEscape(parameterValueToString(r.rateCodeType, "rateCodeType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.rateCodeType) < 1 {
		return localVarReturnValue, nil, reportError("rateCodeType must have at least 1 elements")
	}
	if strlen(r.rateCodeType) > 2000 {
		return localVarReturnValue, nil, reportError("rateCodeType must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetRatePlansForYieldAsConfigLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	rateCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetRatePlansForYieldAsConfigLOVRequest) Authorization(authorization string) LOVApiGetRatePlansForYieldAsConfigLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetRatePlansForYieldAsConfigLOVRequest) XAppKey(xAppKey string) LOVApiGetRatePlansForYieldAsConfigLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetRatePlansForYieldAsConfigLOVRequest) XHotelid(xHotelid string) LOVApiGetRatePlansForYieldAsConfigLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetRatePlansForYieldAsConfigLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetRatePlansForYieldAsConfigLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetRatePlansForYieldAsConfigLOVRequest) ParameterName(parameterName []string) LOVApiGetRatePlansForYieldAsConfigLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetRatePlansForYieldAsConfigLOVRequest) ParameterValue(parameterValue []string) LOVApiGetRatePlansForYieldAsConfigLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetRatePlansForYieldAsConfigLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetRatePlansForYieldAsConfigLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetRatePlansForYieldAsConfigLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetRatePlansForYieldAsConfigLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetRatePlansForYieldAsConfigLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetRatePlansForYieldAsConfigLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetRatePlansForYieldAsConfigLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRatePlansForYieldAsConfigLOVExecute(r)
}

/*
GetRatePlansForYieldAsConfigLOV Fetch List Of Values for Rate Plans For Yield As Config

 <p><strong>OperationId:</strong>getRatePlansForYieldAsConfigLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param rateCode Value of the parameter 'rateCode' which is required to fetch RatePlansForYieldAsConfig LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RatePlansForYieldAsConfig LOV
 @return LOVApiGetRatePlansForYieldAsConfigLOVRequest
*/
func (a *LOVApiService) GetRatePlansForYieldAsConfigLOV(ctx context.Context, rateCode string, hotelId string) LOVApiGetRatePlansForYieldAsConfigLOVRequest {
	return LOVApiGetRatePlansForYieldAsConfigLOVRequest{
		ApiService: a,
		ctx: ctx,
		rateCode: rateCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRatePlansForYieldAsConfigLOVExecute(r LOVApiGetRatePlansForYieldAsConfigLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRatePlansForYieldAsConfigLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/rateCode/{rateCode}/ratePlansForYieldAsConfig"
	localVarPath = strings.Replace(localVarPath, "{"+"rateCode"+"}", url.PathEscape(parameterValueToString(r.rateCode, "rateCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.rateCode) < 1 {
		return localVarReturnValue, nil, reportError("rateCode must have at least 1 elements")
	}
	if strlen(r.rateCode) > 2000 {
		return localVarReturnValue, nil, reportError("rateCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetRatePlansLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetRatePlansLOVRequest) Authorization(authorization string) LOVApiGetRatePlansLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetRatePlansLOVRequest) XAppKey(xAppKey string) LOVApiGetRatePlansLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetRatePlansLOVRequest) XHotelid(xHotelid string) LOVApiGetRatePlansLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetRatePlansLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetRatePlansLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetRatePlansLOVRequest) ParameterName(parameterName []string) LOVApiGetRatePlansLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetRatePlansLOVRequest) ParameterValue(parameterValue []string) LOVApiGetRatePlansLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetRatePlansLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetRatePlansLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetRatePlansLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetRatePlansLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetRatePlansLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetRatePlansLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetRatePlansLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRatePlansLOVExecute(r)
}

/*
GetRatePlansLOV Fetch List Of Values for Rate Plans

 <p><strong>OperationId:</strong>getRatePlansLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RatePlans LOV
 @return LOVApiGetRatePlansLOVRequest
*/
func (a *LOVApiService) GetRatePlansLOV(ctx context.Context, hotelId string) LOVApiGetRatePlansLOVRequest {
	return LOVApiGetRatePlansLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRatePlansLOVExecute(r LOVApiGetRatePlansLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRatePlansLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/ratePlans"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetRepBlockCodesParamOffLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetRepBlockCodesParamOffLOVRequest) Authorization(authorization string) LOVApiGetRepBlockCodesParamOffLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetRepBlockCodesParamOffLOVRequest) XAppKey(xAppKey string) LOVApiGetRepBlockCodesParamOffLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetRepBlockCodesParamOffLOVRequest) XHotelid(xHotelid string) LOVApiGetRepBlockCodesParamOffLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetRepBlockCodesParamOffLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetRepBlockCodesParamOffLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetRepBlockCodesParamOffLOVRequest) ParameterName(parameterName []string) LOVApiGetRepBlockCodesParamOffLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetRepBlockCodesParamOffLOVRequest) ParameterValue(parameterValue []string) LOVApiGetRepBlockCodesParamOffLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetRepBlockCodesParamOffLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetRepBlockCodesParamOffLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetRepBlockCodesParamOffLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetRepBlockCodesParamOffLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetRepBlockCodesParamOffLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetRepBlockCodesParamOffLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetRepBlockCodesParamOffLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRepBlockCodesParamOffLOVExecute(r)
}

/*
GetRepBlockCodesParamOffLOV Fetch List Of Values for Rep Block Codes Param Off

 <p><strong>OperationId:</strong>getRepBlockCodesParamOffLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RepBlockCodesParamOff LOV
 @return LOVApiGetRepBlockCodesParamOffLOVRequest
*/
func (a *LOVApiService) GetRepBlockCodesParamOffLOV(ctx context.Context, hotelId string) LOVApiGetRepBlockCodesParamOffLOVRequest {
	return LOVApiGetRepBlockCodesParamOffLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRepBlockCodesParamOffLOVExecute(r LOVApiGetRepBlockCodesParamOffLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRepBlockCodesParamOffLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/repBlockCodesParamOff"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetRepBlockCodesParamOnLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetRepBlockCodesParamOnLOVRequest) Authorization(authorization string) LOVApiGetRepBlockCodesParamOnLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetRepBlockCodesParamOnLOVRequest) XAppKey(xAppKey string) LOVApiGetRepBlockCodesParamOnLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetRepBlockCodesParamOnLOVRequest) XHotelid(xHotelid string) LOVApiGetRepBlockCodesParamOnLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetRepBlockCodesParamOnLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetRepBlockCodesParamOnLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetRepBlockCodesParamOnLOVRequest) ParameterName(parameterName []string) LOVApiGetRepBlockCodesParamOnLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetRepBlockCodesParamOnLOVRequest) ParameterValue(parameterValue []string) LOVApiGetRepBlockCodesParamOnLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetRepBlockCodesParamOnLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetRepBlockCodesParamOnLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetRepBlockCodesParamOnLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetRepBlockCodesParamOnLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetRepBlockCodesParamOnLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetRepBlockCodesParamOnLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetRepBlockCodesParamOnLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRepBlockCodesParamOnLOVExecute(r)
}

/*
GetRepBlockCodesParamOnLOV Fetch List Of Values for Rep Block Codes Param On

 <p><strong>OperationId:</strong>getRepBlockCodesParamOnLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RepBlockCodesParamOn LOV
 @return LOVApiGetRepBlockCodesParamOnLOVRequest
*/
func (a *LOVApiService) GetRepBlockCodesParamOnLOV(ctx context.Context, hotelId string) LOVApiGetRepBlockCodesParamOnLOVRequest {
	return LOVApiGetRepBlockCodesParamOnLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRepBlockCodesParamOnLOVExecute(r LOVApiGetRepBlockCodesParamOnLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRepBlockCodesParamOnLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/repBlockCodesParamOn"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetRepCalendarMonthsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	year string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetRepCalendarMonthsLOVRequest) Authorization(authorization string) LOVApiGetRepCalendarMonthsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetRepCalendarMonthsLOVRequest) XAppKey(xAppKey string) LOVApiGetRepCalendarMonthsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetRepCalendarMonthsLOVRequest) XHotelid(xHotelid string) LOVApiGetRepCalendarMonthsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetRepCalendarMonthsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetRepCalendarMonthsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetRepCalendarMonthsLOVRequest) ParameterName(parameterName []string) LOVApiGetRepCalendarMonthsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetRepCalendarMonthsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetRepCalendarMonthsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetRepCalendarMonthsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetRepCalendarMonthsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetRepCalendarMonthsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetRepCalendarMonthsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetRepCalendarMonthsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetRepCalendarMonthsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetRepCalendarMonthsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRepCalendarMonthsLOVExecute(r)
}

/*
GetRepCalendarMonthsLOV Fetch List Of Values for Rep Calendar Months

 <p><strong>OperationId:</strong>getRepCalendarMonthsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param year Value of the parameter 'year' which is required to fetch RepCalendarMonths LOV
 @return LOVApiGetRepCalendarMonthsLOVRequest
*/
func (a *LOVApiService) GetRepCalendarMonthsLOV(ctx context.Context, year string) LOVApiGetRepCalendarMonthsLOVRequest {
	return LOVApiGetRepCalendarMonthsLOVRequest{
		ApiService: a,
		ctx: ctx,
		year: year,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRepCalendarMonthsLOVExecute(r LOVApiGetRepCalendarMonthsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRepCalendarMonthsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/year/{year}/repCalendarMonths"
	localVarPath = strings.Replace(localVarPath, "{"+"year"+"}", url.PathEscape(parameterValueToString(r.year, "year")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.year) < 1 {
		return localVarReturnValue, nil, reportError("year must have at least 1 elements")
	}
	if strlen(r.year) > 2000 {
		return localVarReturnValue, nil, reportError("year must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetRepCalendarWeeksLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	year string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetRepCalendarWeeksLOVRequest) Authorization(authorization string) LOVApiGetRepCalendarWeeksLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetRepCalendarWeeksLOVRequest) XAppKey(xAppKey string) LOVApiGetRepCalendarWeeksLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetRepCalendarWeeksLOVRequest) XHotelid(xHotelid string) LOVApiGetRepCalendarWeeksLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetRepCalendarWeeksLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetRepCalendarWeeksLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetRepCalendarWeeksLOVRequest) ParameterName(parameterName []string) LOVApiGetRepCalendarWeeksLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetRepCalendarWeeksLOVRequest) ParameterValue(parameterValue []string) LOVApiGetRepCalendarWeeksLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetRepCalendarWeeksLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetRepCalendarWeeksLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetRepCalendarWeeksLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetRepCalendarWeeksLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetRepCalendarWeeksLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetRepCalendarWeeksLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetRepCalendarWeeksLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRepCalendarWeeksLOVExecute(r)
}

/*
GetRepCalendarWeeksLOV Fetch List Of Values for Rep Calendar Weeks

 <p><strong>OperationId:</strong>getRepCalendarWeeksLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param year Value of the parameter 'year' which is required to fetch RepCalendarWeeks LOV
 @return LOVApiGetRepCalendarWeeksLOVRequest
*/
func (a *LOVApiService) GetRepCalendarWeeksLOV(ctx context.Context, year string) LOVApiGetRepCalendarWeeksLOVRequest {
	return LOVApiGetRepCalendarWeeksLOVRequest{
		ApiService: a,
		ctx: ctx,
		year: year,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRepCalendarWeeksLOVExecute(r LOVApiGetRepCalendarWeeksLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRepCalendarWeeksLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/year/{year}/repCalendarWeeks"
	localVarPath = strings.Replace(localVarPath, "{"+"year"+"}", url.PathEscape(parameterValueToString(r.year, "year")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.year) < 1 {
		return localVarReturnValue, nil, reportError("year must have at least 1 elements")
	}
	if strlen(r.year) > 2000 {
		return localVarReturnValue, nil, reportError("year must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetRepCalendarYearsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	period string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetRepCalendarYearsLOVRequest) Authorization(authorization string) LOVApiGetRepCalendarYearsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetRepCalendarYearsLOVRequest) XAppKey(xAppKey string) LOVApiGetRepCalendarYearsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetRepCalendarYearsLOVRequest) XHotelid(xHotelid string) LOVApiGetRepCalendarYearsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetRepCalendarYearsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetRepCalendarYearsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetRepCalendarYearsLOVRequest) ParameterName(parameterName []string) LOVApiGetRepCalendarYearsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetRepCalendarYearsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetRepCalendarYearsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetRepCalendarYearsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetRepCalendarYearsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetRepCalendarYearsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetRepCalendarYearsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetRepCalendarYearsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetRepCalendarYearsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetRepCalendarYearsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRepCalendarYearsLOVExecute(r)
}

/*
GetRepCalendarYearsLOV Fetch List Of Values for Rep Calendar Years

 <p><strong>OperationId:</strong>getRepCalendarYearsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param period Value of the parameter 'period' which is required to fetch RepCalendarYears LOV
 @return LOVApiGetRepCalendarYearsLOVRequest
*/
func (a *LOVApiService) GetRepCalendarYearsLOV(ctx context.Context, period string) LOVApiGetRepCalendarYearsLOVRequest {
	return LOVApiGetRepCalendarYearsLOVRequest{
		ApiService: a,
		ctx: ctx,
		period: period,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRepCalendarYearsLOVExecute(r LOVApiGetRepCalendarYearsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRepCalendarYearsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/period/{period}/repCalendarYears"
	localVarPath = strings.Replace(localVarPath, "{"+"period"+"}", url.PathEscape(parameterValueToString(r.period, "period")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.period) < 1 {
		return localVarReturnValue, nil, reportError("period must have at least 1 elements")
	}
	if strlen(r.period) > 2000 {
		return localVarReturnValue, nil, reportError("period must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetRepCashiersLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetRepCashiersLOVRequest) Authorization(authorization string) LOVApiGetRepCashiersLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetRepCashiersLOVRequest) XAppKey(xAppKey string) LOVApiGetRepCashiersLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetRepCashiersLOVRequest) XHotelid(xHotelid string) LOVApiGetRepCashiersLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetRepCashiersLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetRepCashiersLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetRepCashiersLOVRequest) ParameterName(parameterName []string) LOVApiGetRepCashiersLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetRepCashiersLOVRequest) ParameterValue(parameterValue []string) LOVApiGetRepCashiersLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetRepCashiersLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetRepCashiersLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetRepCashiersLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetRepCashiersLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetRepCashiersLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetRepCashiersLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetRepCashiersLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRepCashiersLOVExecute(r)
}

/*
GetRepCashiersLOV Fetch List Of Values for Rep Cashiers

 <p><strong>OperationId:</strong>getRepCashiersLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RepCashiers LOV
 @return LOVApiGetRepCashiersLOVRequest
*/
func (a *LOVApiService) GetRepCashiersLOV(ctx context.Context, hotelId string) LOVApiGetRepCashiersLOVRequest {
	return LOVApiGetRepCashiersLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRepCashiersLOVExecute(r LOVApiGetRepCashiersLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRepCashiersLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/repCashiers"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetRepContactListLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetRepContactListLOVRequest) Authorization(authorization string) LOVApiGetRepContactListLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetRepContactListLOVRequest) XAppKey(xAppKey string) LOVApiGetRepContactListLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetRepContactListLOVRequest) XHotelid(xHotelid string) LOVApiGetRepContactListLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetRepContactListLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetRepContactListLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetRepContactListLOVRequest) ParameterName(parameterName []string) LOVApiGetRepContactListLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetRepContactListLOVRequest) ParameterValue(parameterValue []string) LOVApiGetRepContactListLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetRepContactListLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetRepContactListLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetRepContactListLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetRepContactListLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetRepContactListLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetRepContactListLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetRepContactListLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRepContactListLOVExecute(r)
}

/*
GetRepContactListLOV Fetch List Of Values for Rep Contact List

 <p><strong>OperationId:</strong>getRepContactListLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RepContactList LOV
 @return LOVApiGetRepContactListLOVRequest
*/
func (a *LOVApiService) GetRepContactListLOV(ctx context.Context, hotelId string) LOVApiGetRepContactListLOVRequest {
	return LOVApiGetRepContactListLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRepContactListLOVExecute(r LOVApiGetRepContactListLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRepContactListLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/repContactList"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetRepCurrenciesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetRepCurrenciesLOVRequest) Authorization(authorization string) LOVApiGetRepCurrenciesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetRepCurrenciesLOVRequest) XAppKey(xAppKey string) LOVApiGetRepCurrenciesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetRepCurrenciesLOVRequest) XHotelid(xHotelid string) LOVApiGetRepCurrenciesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetRepCurrenciesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetRepCurrenciesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetRepCurrenciesLOVRequest) ParameterName(parameterName []string) LOVApiGetRepCurrenciesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetRepCurrenciesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetRepCurrenciesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetRepCurrenciesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetRepCurrenciesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetRepCurrenciesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetRepCurrenciesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetRepCurrenciesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetRepCurrenciesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetRepCurrenciesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRepCurrenciesLOVExecute(r)
}

/*
GetRepCurrenciesLOV Fetch List Of Values for Rep Currencies

 <p><strong>OperationId:</strong>getRepCurrenciesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RepCurrencies LOV
 @return LOVApiGetRepCurrenciesLOVRequest
*/
func (a *LOVApiService) GetRepCurrenciesLOV(ctx context.Context, hotelId string) LOVApiGetRepCurrenciesLOVRequest {
	return LOVApiGetRepCurrenciesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRepCurrenciesLOVExecute(r LOVApiGetRepCurrenciesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRepCurrenciesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/repCurrencies"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetRepDepartmentsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetRepDepartmentsLOVRequest) Authorization(authorization string) LOVApiGetRepDepartmentsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetRepDepartmentsLOVRequest) XAppKey(xAppKey string) LOVApiGetRepDepartmentsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetRepDepartmentsLOVRequest) XHotelid(xHotelid string) LOVApiGetRepDepartmentsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetRepDepartmentsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetRepDepartmentsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetRepDepartmentsLOVRequest) ParameterName(parameterName []string) LOVApiGetRepDepartmentsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetRepDepartmentsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetRepDepartmentsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetRepDepartmentsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetRepDepartmentsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetRepDepartmentsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetRepDepartmentsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetRepDepartmentsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetRepDepartmentsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetRepDepartmentsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRepDepartmentsLOVExecute(r)
}

/*
GetRepDepartmentsLOV Fetch List Of Values for Rep Departments

 <p><strong>OperationId:</strong>getRepDepartmentsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RepDepartments LOV
 @return LOVApiGetRepDepartmentsLOVRequest
*/
func (a *LOVApiService) GetRepDepartmentsLOV(ctx context.Context, hotelId string) LOVApiGetRepDepartmentsLOVRequest {
	return LOVApiGetRepDepartmentsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRepDepartmentsLOVExecute(r LOVApiGetRepDepartmentsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRepDepartmentsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/repDepartments"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetRepFiscalMonthsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	fiscalYearId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetRepFiscalMonthsLOVRequest) Authorization(authorization string) LOVApiGetRepFiscalMonthsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetRepFiscalMonthsLOVRequest) XAppKey(xAppKey string) LOVApiGetRepFiscalMonthsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetRepFiscalMonthsLOVRequest) XHotelid(xHotelid string) LOVApiGetRepFiscalMonthsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetRepFiscalMonthsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetRepFiscalMonthsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetRepFiscalMonthsLOVRequest) ParameterName(parameterName []string) LOVApiGetRepFiscalMonthsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetRepFiscalMonthsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetRepFiscalMonthsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetRepFiscalMonthsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetRepFiscalMonthsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetRepFiscalMonthsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetRepFiscalMonthsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetRepFiscalMonthsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetRepFiscalMonthsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetRepFiscalMonthsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRepFiscalMonthsLOVExecute(r)
}

/*
GetRepFiscalMonthsLOV Fetch List Of Values for Rep Fiscal Months

 <p><strong>OperationId:</strong>getRepFiscalMonthsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fiscalYearId Value of the parameter 'fiscalYearId' which is required to fetch RepFiscalMonths LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RepFiscalMonths LOV
 @return LOVApiGetRepFiscalMonthsLOVRequest
*/
func (a *LOVApiService) GetRepFiscalMonthsLOV(ctx context.Context, fiscalYearId string, hotelId string) LOVApiGetRepFiscalMonthsLOVRequest {
	return LOVApiGetRepFiscalMonthsLOVRequest{
		ApiService: a,
		ctx: ctx,
		fiscalYearId: fiscalYearId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRepFiscalMonthsLOVExecute(r LOVApiGetRepFiscalMonthsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRepFiscalMonthsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/fiscalYearId/{fiscalYearId}/repFiscalMonths"
	localVarPath = strings.Replace(localVarPath, "{"+"fiscalYearId"+"}", url.PathEscape(parameterValueToString(r.fiscalYearId, "fiscalYearId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.fiscalYearId) < 1 {
		return localVarReturnValue, nil, reportError("fiscalYearId must have at least 1 elements")
	}
	if strlen(r.fiscalYearId) > 2000 {
		return localVarReturnValue, nil, reportError("fiscalYearId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetRepFiscalWeeksLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	fiscalYearId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetRepFiscalWeeksLOVRequest) Authorization(authorization string) LOVApiGetRepFiscalWeeksLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetRepFiscalWeeksLOVRequest) XAppKey(xAppKey string) LOVApiGetRepFiscalWeeksLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetRepFiscalWeeksLOVRequest) XHotelid(xHotelid string) LOVApiGetRepFiscalWeeksLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetRepFiscalWeeksLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetRepFiscalWeeksLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetRepFiscalWeeksLOVRequest) ParameterName(parameterName []string) LOVApiGetRepFiscalWeeksLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetRepFiscalWeeksLOVRequest) ParameterValue(parameterValue []string) LOVApiGetRepFiscalWeeksLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetRepFiscalWeeksLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetRepFiscalWeeksLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetRepFiscalWeeksLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetRepFiscalWeeksLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetRepFiscalWeeksLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetRepFiscalWeeksLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetRepFiscalWeeksLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRepFiscalWeeksLOVExecute(r)
}

/*
GetRepFiscalWeeksLOV Fetch List Of Values for Rep Fiscal Weeks

 <p><strong>OperationId:</strong>getRepFiscalWeeksLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fiscalYearId Value of the parameter 'fiscalYearId' which is required to fetch RepFiscalWeeks LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RepFiscalWeeks LOV
 @return LOVApiGetRepFiscalWeeksLOVRequest
*/
func (a *LOVApiService) GetRepFiscalWeeksLOV(ctx context.Context, fiscalYearId string, hotelId string) LOVApiGetRepFiscalWeeksLOVRequest {
	return LOVApiGetRepFiscalWeeksLOVRequest{
		ApiService: a,
		ctx: ctx,
		fiscalYearId: fiscalYearId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRepFiscalWeeksLOVExecute(r LOVApiGetRepFiscalWeeksLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRepFiscalWeeksLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/fiscalYearId/{fiscalYearId}/repFiscalWeeks"
	localVarPath = strings.Replace(localVarPath, "{"+"fiscalYearId"+"}", url.PathEscape(parameterValueToString(r.fiscalYearId, "fiscalYearId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.fiscalYearId) < 1 {
		return localVarReturnValue, nil, reportError("fiscalYearId must have at least 1 elements")
	}
	if strlen(r.fiscalYearId) > 2000 {
		return localVarReturnValue, nil, reportError("fiscalYearId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetRepFiscalYearsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetRepFiscalYearsLOVRequest) Authorization(authorization string) LOVApiGetRepFiscalYearsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetRepFiscalYearsLOVRequest) XAppKey(xAppKey string) LOVApiGetRepFiscalYearsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetRepFiscalYearsLOVRequest) XHotelid(xHotelid string) LOVApiGetRepFiscalYearsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetRepFiscalYearsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetRepFiscalYearsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetRepFiscalYearsLOVRequest) ParameterName(parameterName []string) LOVApiGetRepFiscalYearsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetRepFiscalYearsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetRepFiscalYearsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetRepFiscalYearsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetRepFiscalYearsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetRepFiscalYearsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetRepFiscalYearsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetRepFiscalYearsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetRepFiscalYearsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetRepFiscalYearsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRepFiscalYearsLOVExecute(r)
}

/*
GetRepFiscalYearsLOV Fetch List Of Values for Rep Fiscal Years

 <p><strong>OperationId:</strong>getRepFiscalYearsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RepFiscalYears LOV
 @return LOVApiGetRepFiscalYearsLOVRequest
*/
func (a *LOVApiService) GetRepFiscalYearsLOV(ctx context.Context, hotelId string) LOVApiGetRepFiscalYearsLOVRequest {
	return LOVApiGetRepFiscalYearsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRepFiscalYearsLOVExecute(r LOVApiGetRepFiscalYearsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRepFiscalYearsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/repFiscalYears"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetRepForeignCurrenciesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetRepForeignCurrenciesLOVRequest) Authorization(authorization string) LOVApiGetRepForeignCurrenciesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetRepForeignCurrenciesLOVRequest) XAppKey(xAppKey string) LOVApiGetRepForeignCurrenciesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetRepForeignCurrenciesLOVRequest) XHotelid(xHotelid string) LOVApiGetRepForeignCurrenciesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetRepForeignCurrenciesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetRepForeignCurrenciesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetRepForeignCurrenciesLOVRequest) ParameterName(parameterName []string) LOVApiGetRepForeignCurrenciesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetRepForeignCurrenciesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetRepForeignCurrenciesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetRepForeignCurrenciesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetRepForeignCurrenciesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetRepForeignCurrenciesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetRepForeignCurrenciesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetRepForeignCurrenciesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetRepForeignCurrenciesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetRepForeignCurrenciesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRepForeignCurrenciesLOVExecute(r)
}

/*
GetRepForeignCurrenciesLOV Fetch List Of Values for Rep Foreign Currencies

 <p><strong>OperationId:</strong>getRepForeignCurrenciesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RepForeignCurrencies LOV
 @return LOVApiGetRepForeignCurrenciesLOVRequest
*/
func (a *LOVApiService) GetRepForeignCurrenciesLOV(ctx context.Context, hotelId string) LOVApiGetRepForeignCurrenciesLOVRequest {
	return LOVApiGetRepForeignCurrenciesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRepForeignCurrenciesLOVExecute(r LOVApiGetRepForeignCurrenciesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRepForeignCurrenciesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/repForeignCurrencies"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetRepGroupReportsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	groupName string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetRepGroupReportsLOVRequest) Authorization(authorization string) LOVApiGetRepGroupReportsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetRepGroupReportsLOVRequest) XAppKey(xAppKey string) LOVApiGetRepGroupReportsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetRepGroupReportsLOVRequest) XHotelid(xHotelid string) LOVApiGetRepGroupReportsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetRepGroupReportsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetRepGroupReportsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetRepGroupReportsLOVRequest) ParameterName(parameterName []string) LOVApiGetRepGroupReportsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetRepGroupReportsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetRepGroupReportsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetRepGroupReportsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetRepGroupReportsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetRepGroupReportsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetRepGroupReportsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetRepGroupReportsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetRepGroupReportsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetRepGroupReportsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRepGroupReportsLOVExecute(r)
}

/*
GetRepGroupReportsLOV Fetch List Of Values for Rep Group Reports

 <p><strong>OperationId:</strong>getRepGroupReportsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupName Value of the parameter 'groupName' which is required to fetch RepGroupReports LOV
 @return LOVApiGetRepGroupReportsLOVRequest
*/
func (a *LOVApiService) GetRepGroupReportsLOV(ctx context.Context, groupName string) LOVApiGetRepGroupReportsLOVRequest {
	return LOVApiGetRepGroupReportsLOVRequest{
		ApiService: a,
		ctx: ctx,
		groupName: groupName,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRepGroupReportsLOVExecute(r LOVApiGetRepGroupReportsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRepGroupReportsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/groupName/{groupName}/repGroupReports"
	localVarPath = strings.Replace(localVarPath, "{"+"groupName"+"}", url.PathEscape(parameterValueToString(r.groupName, "groupName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.groupName) < 1 {
		return localVarReturnValue, nil, reportError("groupName must have at least 1 elements")
	}
	if strlen(r.groupName) > 2000 {
		return localVarReturnValue, nil, reportError("groupName must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetRepGroupsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetRepGroupsLOVRequest) Authorization(authorization string) LOVApiGetRepGroupsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetRepGroupsLOVRequest) XAppKey(xAppKey string) LOVApiGetRepGroupsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetRepGroupsLOVRequest) XHotelid(xHotelid string) LOVApiGetRepGroupsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetRepGroupsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetRepGroupsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetRepGroupsLOVRequest) ParameterName(parameterName []string) LOVApiGetRepGroupsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetRepGroupsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetRepGroupsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetRepGroupsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetRepGroupsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetRepGroupsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetRepGroupsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetRepGroupsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetRepGroupsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetRepGroupsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRepGroupsLOVExecute(r)
}

/*
GetRepGroupsLOV Fetch List Of Values for Rep Groups

 <p><strong>OperationId:</strong>getRepGroupsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RepGroups LOV
 @return LOVApiGetRepGroupsLOVRequest
*/
func (a *LOVApiService) GetRepGroupsLOV(ctx context.Context, hotelId string) LOVApiGetRepGroupsLOVRequest {
	return LOVApiGetRepGroupsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRepGroupsLOVExecute(r LOVApiGetRepGroupsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRepGroupsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/repGroups"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetRepInventoryItemPoolsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetRepInventoryItemPoolsLOVRequest) Authorization(authorization string) LOVApiGetRepInventoryItemPoolsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetRepInventoryItemPoolsLOVRequest) XAppKey(xAppKey string) LOVApiGetRepInventoryItemPoolsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetRepInventoryItemPoolsLOVRequest) XHotelid(xHotelid string) LOVApiGetRepInventoryItemPoolsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetRepInventoryItemPoolsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetRepInventoryItemPoolsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetRepInventoryItemPoolsLOVRequest) ParameterName(parameterName []string) LOVApiGetRepInventoryItemPoolsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetRepInventoryItemPoolsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetRepInventoryItemPoolsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetRepInventoryItemPoolsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetRepInventoryItemPoolsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetRepInventoryItemPoolsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetRepInventoryItemPoolsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetRepInventoryItemPoolsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetRepInventoryItemPoolsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetRepInventoryItemPoolsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRepInventoryItemPoolsLOVExecute(r)
}

/*
GetRepInventoryItemPoolsLOV Fetch List Of Values for Rep Inventory Item Pools

 <p><strong>OperationId:</strong>getRepInventoryItemPoolsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RepInventoryItemPools LOV
 @return LOVApiGetRepInventoryItemPoolsLOVRequest
*/
func (a *LOVApiService) GetRepInventoryItemPoolsLOV(ctx context.Context, hotelId string) LOVApiGetRepInventoryItemPoolsLOVRequest {
	return LOVApiGetRepInventoryItemPoolsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRepInventoryItemPoolsLOVExecute(r LOVApiGetRepInventoryItemPoolsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRepInventoryItemPoolsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/repInventoryItemPools"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetRepMarketCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetRepMarketCodesLOVRequest) Authorization(authorization string) LOVApiGetRepMarketCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetRepMarketCodesLOVRequest) XAppKey(xAppKey string) LOVApiGetRepMarketCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetRepMarketCodesLOVRequest) XHotelid(xHotelid string) LOVApiGetRepMarketCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetRepMarketCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetRepMarketCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetRepMarketCodesLOVRequest) ParameterName(parameterName []string) LOVApiGetRepMarketCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetRepMarketCodesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetRepMarketCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetRepMarketCodesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetRepMarketCodesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetRepMarketCodesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetRepMarketCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetRepMarketCodesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetRepMarketCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetRepMarketCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRepMarketCodesLOVExecute(r)
}

/*
GetRepMarketCodesLOV Fetch List Of Values for Rep Market Codes

 <p><strong>OperationId:</strong>getRepMarketCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RepMarketCodes LOV
 @return LOVApiGetRepMarketCodesLOVRequest
*/
func (a *LOVApiService) GetRepMarketCodesLOV(ctx context.Context, hotelId string) LOVApiGetRepMarketCodesLOVRequest {
	return LOVApiGetRepMarketCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRepMarketCodesLOVExecute(r LOVApiGetRepMarketCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRepMarketCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/repMarketCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetRepOwnerCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelCodesList string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetRepOwnerCodesLOVRequest) Authorization(authorization string) LOVApiGetRepOwnerCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetRepOwnerCodesLOVRequest) XAppKey(xAppKey string) LOVApiGetRepOwnerCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetRepOwnerCodesLOVRequest) XHotelid(xHotelid string) LOVApiGetRepOwnerCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetRepOwnerCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetRepOwnerCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetRepOwnerCodesLOVRequest) ParameterName(parameterName []string) LOVApiGetRepOwnerCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetRepOwnerCodesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetRepOwnerCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetRepOwnerCodesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetRepOwnerCodesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetRepOwnerCodesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetRepOwnerCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetRepOwnerCodesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetRepOwnerCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetRepOwnerCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRepOwnerCodesLOVExecute(r)
}

/*
GetRepOwnerCodesLOV Fetch List Of Values for Rep Owner Codes

 <p><strong>OperationId:</strong>getRepOwnerCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelCodesList Value of the parameter 'hotelCodesList' which is required to fetch RepOwnerCodes LOV
 @return LOVApiGetRepOwnerCodesLOVRequest
*/
func (a *LOVApiService) GetRepOwnerCodesLOV(ctx context.Context, hotelCodesList string) LOVApiGetRepOwnerCodesLOVRequest {
	return LOVApiGetRepOwnerCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelCodesList: hotelCodesList,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRepOwnerCodesLOVExecute(r LOVApiGetRepOwnerCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRepOwnerCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotelCodesList/{hotelCodesList}/repOwnerCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelCodesList"+"}", url.PathEscape(parameterValueToString(r.hotelCodesList, "hotelCodesList")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelCodesList) < 1 {
		return localVarReturnValue, nil, reportError("hotelCodesList must have at least 1 elements")
	}
	if strlen(r.hotelCodesList) > 2000 {
		return localVarReturnValue, nil, reportError("hotelCodesList must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetRepRatePlansLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	propertyList string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetRepRatePlansLOVRequest) Authorization(authorization string) LOVApiGetRepRatePlansLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetRepRatePlansLOVRequest) XAppKey(xAppKey string) LOVApiGetRepRatePlansLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetRepRatePlansLOVRequest) XHotelid(xHotelid string) LOVApiGetRepRatePlansLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetRepRatePlansLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetRepRatePlansLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetRepRatePlansLOVRequest) ParameterName(parameterName []string) LOVApiGetRepRatePlansLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetRepRatePlansLOVRequest) ParameterValue(parameterValue []string) LOVApiGetRepRatePlansLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetRepRatePlansLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetRepRatePlansLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetRepRatePlansLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetRepRatePlansLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetRepRatePlansLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetRepRatePlansLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetRepRatePlansLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRepRatePlansLOVExecute(r)
}

/*
GetRepRatePlansLOV Fetch List Of Values for Rep Rate Plans

 <p><strong>OperationId:</strong>getRepRatePlansLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param propertyList Value of the parameter 'propertyList' which is required to fetch RepRatePlans LOV
 @return LOVApiGetRepRatePlansLOVRequest
*/
func (a *LOVApiService) GetRepRatePlansLOV(ctx context.Context, propertyList string) LOVApiGetRepRatePlansLOVRequest {
	return LOVApiGetRepRatePlansLOVRequest{
		ApiService: a,
		ctx: ctx,
		propertyList: propertyList,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRepRatePlansLOVExecute(r LOVApiGetRepRatePlansLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRepRatePlansLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/propertyList/{propertyList}/repRatePlans"
	localVarPath = strings.Replace(localVarPath, "{"+"propertyList"+"}", url.PathEscape(parameterValueToString(r.propertyList, "propertyList")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.propertyList) < 1 {
		return localVarReturnValue, nil, reportError("propertyList must have at least 1 elements")
	}
	if strlen(r.propertyList) > 2000 {
		return localVarReturnValue, nil, reportError("propertyList must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetRepRoomStatusesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetRepRoomStatusesLOVRequest) Authorization(authorization string) LOVApiGetRepRoomStatusesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetRepRoomStatusesLOVRequest) XAppKey(xAppKey string) LOVApiGetRepRoomStatusesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetRepRoomStatusesLOVRequest) XHotelid(xHotelid string) LOVApiGetRepRoomStatusesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetRepRoomStatusesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetRepRoomStatusesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetRepRoomStatusesLOVRequest) ParameterName(parameterName []string) LOVApiGetRepRoomStatusesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetRepRoomStatusesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetRepRoomStatusesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetRepRoomStatusesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetRepRoomStatusesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetRepRoomStatusesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetRepRoomStatusesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetRepRoomStatusesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetRepRoomStatusesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetRepRoomStatusesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRepRoomStatusesLOVExecute(r)
}

/*
GetRepRoomStatusesLOV Fetch List Of Values for Rep Room Statuses

 <p><strong>OperationId:</strong>getRepRoomStatusesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RepRoomStatuses LOV
 @return LOVApiGetRepRoomStatusesLOVRequest
*/
func (a *LOVApiService) GetRepRoomStatusesLOV(ctx context.Context, hotelId string) LOVApiGetRepRoomStatusesLOVRequest {
	return LOVApiGetRepRoomStatusesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRepRoomStatusesLOVExecute(r LOVApiGetRepRoomStatusesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRepRoomStatusesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/repRoomStatuses"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetRepRoomTypeMultiHotelLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelCodeList string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetRepRoomTypeMultiHotelLOVRequest) Authorization(authorization string) LOVApiGetRepRoomTypeMultiHotelLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetRepRoomTypeMultiHotelLOVRequest) XAppKey(xAppKey string) LOVApiGetRepRoomTypeMultiHotelLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetRepRoomTypeMultiHotelLOVRequest) XHotelid(xHotelid string) LOVApiGetRepRoomTypeMultiHotelLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetRepRoomTypeMultiHotelLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetRepRoomTypeMultiHotelLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetRepRoomTypeMultiHotelLOVRequest) ParameterName(parameterName []string) LOVApiGetRepRoomTypeMultiHotelLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetRepRoomTypeMultiHotelLOVRequest) ParameterValue(parameterValue []string) LOVApiGetRepRoomTypeMultiHotelLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetRepRoomTypeMultiHotelLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetRepRoomTypeMultiHotelLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetRepRoomTypeMultiHotelLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetRepRoomTypeMultiHotelLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetRepRoomTypeMultiHotelLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetRepRoomTypeMultiHotelLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetRepRoomTypeMultiHotelLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRepRoomTypeMultiHotelLOVExecute(r)
}

/*
GetRepRoomTypeMultiHotelLOV Fetch List Of Values for Rep Room Type Multi Hotel

 <p><strong>OperationId:</strong>getRepRoomTypeMultiHotelLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelCodeList Value of the parameter 'hotelCodeList' which is required to fetch RepRoomTypeMultiHotel LOV
 @return LOVApiGetRepRoomTypeMultiHotelLOVRequest
*/
func (a *LOVApiService) GetRepRoomTypeMultiHotelLOV(ctx context.Context, hotelCodeList string) LOVApiGetRepRoomTypeMultiHotelLOVRequest {
	return LOVApiGetRepRoomTypeMultiHotelLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelCodeList: hotelCodeList,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRepRoomTypeMultiHotelLOVExecute(r LOVApiGetRepRoomTypeMultiHotelLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRepRoomTypeMultiHotelLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotelCodeList/{hotelCodeList}/repRoomTypeMultiHotel"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelCodeList"+"}", url.PathEscape(parameterValueToString(r.hotelCodeList, "hotelCodeList")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelCodeList) < 1 {
		return localVarReturnValue, nil, reportError("hotelCodeList must have at least 1 elements")
	}
	if strlen(r.hotelCodeList) > 2000 {
		return localVarReturnValue, nil, reportError("hotelCodeList must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetRepRoomTypesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetRepRoomTypesLOVRequest) Authorization(authorization string) LOVApiGetRepRoomTypesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetRepRoomTypesLOVRequest) XAppKey(xAppKey string) LOVApiGetRepRoomTypesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetRepRoomTypesLOVRequest) XHotelid(xHotelid string) LOVApiGetRepRoomTypesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetRepRoomTypesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetRepRoomTypesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetRepRoomTypesLOVRequest) ParameterName(parameterName []string) LOVApiGetRepRoomTypesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetRepRoomTypesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetRepRoomTypesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetRepRoomTypesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetRepRoomTypesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetRepRoomTypesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetRepRoomTypesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetRepRoomTypesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetRepRoomTypesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetRepRoomTypesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRepRoomTypesLOVExecute(r)
}

/*
GetRepRoomTypesLOV Fetch List Of Values for Rep Room Types

 <p><strong>OperationId:</strong>getRepRoomTypesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RepRoomTypes LOV
 @return LOVApiGetRepRoomTypesLOVRequest
*/
func (a *LOVApiService) GetRepRoomTypesLOV(ctx context.Context, hotelId string) LOVApiGetRepRoomTypesLOVRequest {
	return LOVApiGetRepRoomTypesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRepRoomTypesLOVExecute(r LOVApiGetRepRoomTypesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRepRoomTypesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/repRoomTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetRepRoomsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetRepRoomsLOVRequest) Authorization(authorization string) LOVApiGetRepRoomsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetRepRoomsLOVRequest) XAppKey(xAppKey string) LOVApiGetRepRoomsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetRepRoomsLOVRequest) XHotelid(xHotelid string) LOVApiGetRepRoomsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetRepRoomsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetRepRoomsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetRepRoomsLOVRequest) ParameterName(parameterName []string) LOVApiGetRepRoomsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetRepRoomsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetRepRoomsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetRepRoomsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetRepRoomsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetRepRoomsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetRepRoomsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetRepRoomsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetRepRoomsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetRepRoomsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRepRoomsLOVExecute(r)
}

/*
GetRepRoomsLOV Fetch List Of Values for Rep Rooms

 <p><strong>OperationId:</strong>getRepRoomsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RepRooms LOV
 @return LOVApiGetRepRoomsLOVRequest
*/
func (a *LOVApiService) GetRepRoomsLOV(ctx context.Context, hotelId string) LOVApiGetRepRoomsLOVRequest {
	return LOVApiGetRepRoomsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRepRoomsLOVExecute(r LOVApiGetRepRoomsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRepRoomsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/repRooms"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetRepRoomsStatLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	toDate string
	fromDate string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetRepRoomsStatLOVRequest) Authorization(authorization string) LOVApiGetRepRoomsStatLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetRepRoomsStatLOVRequest) XAppKey(xAppKey string) LOVApiGetRepRoomsStatLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetRepRoomsStatLOVRequest) XHotelid(xHotelid string) LOVApiGetRepRoomsStatLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetRepRoomsStatLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetRepRoomsStatLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetRepRoomsStatLOVRequest) ParameterName(parameterName []string) LOVApiGetRepRoomsStatLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetRepRoomsStatLOVRequest) ParameterValue(parameterValue []string) LOVApiGetRepRoomsStatLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetRepRoomsStatLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetRepRoomsStatLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetRepRoomsStatLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetRepRoomsStatLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetRepRoomsStatLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetRepRoomsStatLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetRepRoomsStatLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRepRoomsStatLOVExecute(r)
}

/*
GetRepRoomsStatLOV Fetch List Of Values for Rep Rooms Stat

 <p><strong>OperationId:</strong>getRepRoomsStatLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param toDate Value of the parameter 'toDate' which is required to fetch RepRoomsStat LOV
 @param fromDate Value of the parameter 'fromDate' which is required to fetch RepRoomsStat LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RepRoomsStat LOV
 @return LOVApiGetRepRoomsStatLOVRequest
*/
func (a *LOVApiService) GetRepRoomsStatLOV(ctx context.Context, toDate string, fromDate string, hotelId string) LOVApiGetRepRoomsStatLOVRequest {
	return LOVApiGetRepRoomsStatLOVRequest{
		ApiService: a,
		ctx: ctx,
		toDate: toDate,
		fromDate: fromDate,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRepRoomsStatLOVExecute(r LOVApiGetRepRoomsStatLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRepRoomsStatLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/fromDate/{fromDate}/toDate/{toDate}/repRoomsStat"
	localVarPath = strings.Replace(localVarPath, "{"+"toDate"+"}", url.PathEscape(parameterValueToString(r.toDate, "toDate")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"fromDate"+"}", url.PathEscape(parameterValueToString(r.fromDate, "fromDate")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.toDate) < 1 {
		return localVarReturnValue, nil, reportError("toDate must have at least 1 elements")
	}
	if strlen(r.toDate) > 2000 {
		return localVarReturnValue, nil, reportError("toDate must have less than 2000 elements")
	}
	if strlen(r.fromDate) < 1 {
		return localVarReturnValue, nil, reportError("fromDate must have at least 1 elements")
	}
	if strlen(r.fromDate) > 2000 {
		return localVarReturnValue, nil, reportError("fromDate must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetRepServiceRequestCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetRepServiceRequestCodesLOVRequest) Authorization(authorization string) LOVApiGetRepServiceRequestCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetRepServiceRequestCodesLOVRequest) XAppKey(xAppKey string) LOVApiGetRepServiceRequestCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetRepServiceRequestCodesLOVRequest) XHotelid(xHotelid string) LOVApiGetRepServiceRequestCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetRepServiceRequestCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetRepServiceRequestCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetRepServiceRequestCodesLOVRequest) ParameterName(parameterName []string) LOVApiGetRepServiceRequestCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetRepServiceRequestCodesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetRepServiceRequestCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetRepServiceRequestCodesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetRepServiceRequestCodesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetRepServiceRequestCodesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetRepServiceRequestCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetRepServiceRequestCodesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetRepServiceRequestCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetRepServiceRequestCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRepServiceRequestCodesLOVExecute(r)
}

/*
GetRepServiceRequestCodesLOV Fetch List Of Values for Rep Service Request Codes

 <p><strong>OperationId:</strong>getRepServiceRequestCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RepServiceRequestCodes LOV
 @return LOVApiGetRepServiceRequestCodesLOVRequest
*/
func (a *LOVApiService) GetRepServiceRequestCodesLOV(ctx context.Context, hotelId string) LOVApiGetRepServiceRequestCodesLOVRequest {
	return LOVApiGetRepServiceRequestCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRepServiceRequestCodesLOVExecute(r LOVApiGetRepServiceRequestCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRepServiceRequestCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/repServiceRequestCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetRepTransactionCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetRepTransactionCodesLOVRequest) Authorization(authorization string) LOVApiGetRepTransactionCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetRepTransactionCodesLOVRequest) XAppKey(xAppKey string) LOVApiGetRepTransactionCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetRepTransactionCodesLOVRequest) XHotelid(xHotelid string) LOVApiGetRepTransactionCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetRepTransactionCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetRepTransactionCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetRepTransactionCodesLOVRequest) ParameterName(parameterName []string) LOVApiGetRepTransactionCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetRepTransactionCodesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetRepTransactionCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetRepTransactionCodesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetRepTransactionCodesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetRepTransactionCodesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetRepTransactionCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetRepTransactionCodesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetRepTransactionCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetRepTransactionCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRepTransactionCodesLOVExecute(r)
}

/*
GetRepTransactionCodesLOV Fetch List Of Values for Rep Transaction Codes

 <p><strong>OperationId:</strong>getRepTransactionCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RepTransactionCodes LOV
 @return LOVApiGetRepTransactionCodesLOVRequest
*/
func (a *LOVApiService) GetRepTransactionCodesLOV(ctx context.Context, hotelId string) LOVApiGetRepTransactionCodesLOVRequest {
	return LOVApiGetRepTransactionCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRepTransactionCodesLOVExecute(r LOVApiGetRepTransactionCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRepTransactionCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/repTransactionCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetRepTraveAgtCalendarYearLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetRepTraveAgtCalendarYearLOVRequest) Authorization(authorization string) LOVApiGetRepTraveAgtCalendarYearLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetRepTraveAgtCalendarYearLOVRequest) XAppKey(xAppKey string) LOVApiGetRepTraveAgtCalendarYearLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetRepTraveAgtCalendarYearLOVRequest) XHotelid(xHotelid string) LOVApiGetRepTraveAgtCalendarYearLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetRepTraveAgtCalendarYearLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetRepTraveAgtCalendarYearLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetRepTraveAgtCalendarYearLOVRequest) ParameterName(parameterName []string) LOVApiGetRepTraveAgtCalendarYearLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetRepTraveAgtCalendarYearLOVRequest) ParameterValue(parameterValue []string) LOVApiGetRepTraveAgtCalendarYearLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetRepTraveAgtCalendarYearLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetRepTraveAgtCalendarYearLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetRepTraveAgtCalendarYearLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetRepTraveAgtCalendarYearLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetRepTraveAgtCalendarYearLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetRepTraveAgtCalendarYearLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetRepTraveAgtCalendarYearLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRepTraveAgtCalendarYearLOVExecute(r)
}

/*
GetRepTraveAgtCalendarYearLOV Fetch List Of Values for Rep Trave Agt Calendar Year

 <p><strong>OperationId:</strong>getRepTraveAgtCalendarYearLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RepTraveAgtCalendarYear LOV
 @return LOVApiGetRepTraveAgtCalendarYearLOVRequest
*/
func (a *LOVApiService) GetRepTraveAgtCalendarYearLOV(ctx context.Context, hotelId string) LOVApiGetRepTraveAgtCalendarYearLOVRequest {
	return LOVApiGetRepTraveAgtCalendarYearLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRepTraveAgtCalendarYearLOVExecute(r LOVApiGetRepTraveAgtCalendarYearLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRepTraveAgtCalendarYearLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/repTraveAgtCalendarYear"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetReportsGenericLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	parameter string
	moduleId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetReportsGenericLOVRequest) Authorization(authorization string) LOVApiGetReportsGenericLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetReportsGenericLOVRequest) XAppKey(xAppKey string) LOVApiGetReportsGenericLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetReportsGenericLOVRequest) XHotelid(xHotelid string) LOVApiGetReportsGenericLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetReportsGenericLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetReportsGenericLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetReportsGenericLOVRequest) ParameterName(parameterName []string) LOVApiGetReportsGenericLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetReportsGenericLOVRequest) ParameterValue(parameterValue []string) LOVApiGetReportsGenericLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetReportsGenericLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetReportsGenericLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetReportsGenericLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetReportsGenericLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetReportsGenericLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetReportsGenericLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetReportsGenericLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetReportsGenericLOVExecute(r)
}

/*
GetReportsGenericLOV Fetch List Of Values for Reports Generic

 <p><strong>OperationId:</strong>getReportsGenericLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param parameter Value of the parameter 'parameter' which is required to fetch ReportsGeneric LOV
 @param moduleId Value of the parameter 'moduleId' which is required to fetch ReportsGeneric LOV
 @return LOVApiGetReportsGenericLOVRequest
*/
func (a *LOVApiService) GetReportsGenericLOV(ctx context.Context, parameter string, moduleId string) LOVApiGetReportsGenericLOVRequest {
	return LOVApiGetReportsGenericLOVRequest{
		ApiService: a,
		ctx: ctx,
		parameter: parameter,
		moduleId: moduleId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetReportsGenericLOVExecute(r LOVApiGetReportsGenericLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetReportsGenericLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/moduleId/{moduleId}/parameterName/{parameter}/reportsGeneric"
	localVarPath = strings.Replace(localVarPath, "{"+"parameter"+"}", url.PathEscape(parameterValueToString(r.parameter, "parameter")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"moduleId"+"}", url.PathEscape(parameterValueToString(r.moduleId, "moduleId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.parameter) < 1 {
		return localVarReturnValue, nil, reportError("parameter must have at least 1 elements")
	}
	if strlen(r.parameter) > 2000 {
		return localVarReturnValue, nil, reportError("parameter must have less than 2000 elements")
	}
	if strlen(r.moduleId) < 1 {
		return localVarReturnValue, nil, reportError("moduleId must have at least 1 elements")
	}
	if strlen(r.moduleId) > 2000 {
		return localVarReturnValue, nil, reportError("moduleId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetResStatReportRateCodeLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	endDate string
	beginDate string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetResStatReportRateCodeLOVRequest) Authorization(authorization string) LOVApiGetResStatReportRateCodeLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetResStatReportRateCodeLOVRequest) XAppKey(xAppKey string) LOVApiGetResStatReportRateCodeLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetResStatReportRateCodeLOVRequest) XHotelid(xHotelid string) LOVApiGetResStatReportRateCodeLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetResStatReportRateCodeLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetResStatReportRateCodeLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetResStatReportRateCodeLOVRequest) ParameterName(parameterName []string) LOVApiGetResStatReportRateCodeLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetResStatReportRateCodeLOVRequest) ParameterValue(parameterValue []string) LOVApiGetResStatReportRateCodeLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetResStatReportRateCodeLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetResStatReportRateCodeLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetResStatReportRateCodeLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetResStatReportRateCodeLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetResStatReportRateCodeLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetResStatReportRateCodeLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetResStatReportRateCodeLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetResStatReportRateCodeLOVExecute(r)
}

/*
GetResStatReportRateCodeLOV Fetch List Of Values for Res Stat Report Rate Code

 <p><strong>OperationId:</strong>getResStatReportRateCodeLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param endDate Value of the parameter 'endDate' which is required to fetch ResStatReportRateCode LOV
 @param beginDate Value of the parameter 'beginDate' which is required to fetch ResStatReportRateCode LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ResStatReportRateCode LOV
 @return LOVApiGetResStatReportRateCodeLOVRequest
*/
func (a *LOVApiService) GetResStatReportRateCodeLOV(ctx context.Context, endDate string, beginDate string, hotelId string) LOVApiGetResStatReportRateCodeLOVRequest {
	return LOVApiGetResStatReportRateCodeLOVRequest{
		ApiService: a,
		ctx: ctx,
		endDate: endDate,
		beginDate: beginDate,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetResStatReportRateCodeLOVExecute(r LOVApiGetResStatReportRateCodeLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetResStatReportRateCodeLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/beginDate/{beginDate}/endDate/{endDate}/resStatReportRateCode"
	localVarPath = strings.Replace(localVarPath, "{"+"endDate"+"}", url.PathEscape(parameterValueToString(r.endDate, "endDate")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"beginDate"+"}", url.PathEscape(parameterValueToString(r.beginDate, "beginDate")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.endDate) < 1 {
		return localVarReturnValue, nil, reportError("endDate must have at least 1 elements")
	}
	if strlen(r.endDate) > 2000 {
		return localVarReturnValue, nil, reportError("endDate must have less than 2000 elements")
	}
	if strlen(r.beginDate) < 1 {
		return localVarReturnValue, nil, reportError("beginDate must have at least 1 elements")
	}
	if strlen(r.beginDate) > 2000 {
		return localVarReturnValue, nil, reportError("beginDate must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetReservationBasedBlocksLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetReservationBasedBlocksLOVRequest) Authorization(authorization string) LOVApiGetReservationBasedBlocksLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetReservationBasedBlocksLOVRequest) XAppKey(xAppKey string) LOVApiGetReservationBasedBlocksLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetReservationBasedBlocksLOVRequest) XHotelid(xHotelid string) LOVApiGetReservationBasedBlocksLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetReservationBasedBlocksLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetReservationBasedBlocksLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetReservationBasedBlocksLOVRequest) ParameterName(parameterName []string) LOVApiGetReservationBasedBlocksLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetReservationBasedBlocksLOVRequest) ParameterValue(parameterValue []string) LOVApiGetReservationBasedBlocksLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetReservationBasedBlocksLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetReservationBasedBlocksLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetReservationBasedBlocksLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetReservationBasedBlocksLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetReservationBasedBlocksLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetReservationBasedBlocksLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetReservationBasedBlocksLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetReservationBasedBlocksLOVExecute(r)
}

/*
GetReservationBasedBlocksLOV Fetch List Of Values for Reservation Based Blocks

 <p><strong>OperationId:</strong>getReservationBasedBlocksLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ReservationBasedBlocks LOV
 @return LOVApiGetReservationBasedBlocksLOVRequest
*/
func (a *LOVApiService) GetReservationBasedBlocksLOV(ctx context.Context, hotelId string) LOVApiGetReservationBasedBlocksLOVRequest {
	return LOVApiGetReservationBasedBlocksLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetReservationBasedBlocksLOVExecute(r LOVApiGetReservationBasedBlocksLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetReservationBasedBlocksLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/reservationBasedBlocks"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetReservationBasedProfilesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetReservationBasedProfilesLOVRequest) Authorization(authorization string) LOVApiGetReservationBasedProfilesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetReservationBasedProfilesLOVRequest) XAppKey(xAppKey string) LOVApiGetReservationBasedProfilesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetReservationBasedProfilesLOVRequest) XHotelid(xHotelid string) LOVApiGetReservationBasedProfilesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetReservationBasedProfilesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetReservationBasedProfilesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetReservationBasedProfilesLOVRequest) ParameterName(parameterName []string) LOVApiGetReservationBasedProfilesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetReservationBasedProfilesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetReservationBasedProfilesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetReservationBasedProfilesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetReservationBasedProfilesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetReservationBasedProfilesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetReservationBasedProfilesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetReservationBasedProfilesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetReservationBasedProfilesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetReservationBasedProfilesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetReservationBasedProfilesLOVExecute(r)
}

/*
GetReservationBasedProfilesLOV Fetch List Of Values for Reservation Based Profiles

 <p><strong>OperationId:</strong>getReservationBasedProfilesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ReservationBasedProfiles LOV
 @return LOVApiGetReservationBasedProfilesLOVRequest
*/
func (a *LOVApiService) GetReservationBasedProfilesLOV(ctx context.Context, hotelId string) LOVApiGetReservationBasedProfilesLOVRequest {
	return LOVApiGetReservationBasedProfilesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetReservationBasedProfilesLOVExecute(r LOVApiGetReservationBasedProfilesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetReservationBasedProfilesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/reservationBasedProfiles"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetReservationPackagesGroupItemsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	group string
	arrival string
	children string
	adults string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetReservationPackagesGroupItemsLOVRequest) Authorization(authorization string) LOVApiGetReservationPackagesGroupItemsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetReservationPackagesGroupItemsLOVRequest) XAppKey(xAppKey string) LOVApiGetReservationPackagesGroupItemsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetReservationPackagesGroupItemsLOVRequest) XHotelid(xHotelid string) LOVApiGetReservationPackagesGroupItemsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetReservationPackagesGroupItemsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetReservationPackagesGroupItemsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetReservationPackagesGroupItemsLOVRequest) ParameterName(parameterName []string) LOVApiGetReservationPackagesGroupItemsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetReservationPackagesGroupItemsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetReservationPackagesGroupItemsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetReservationPackagesGroupItemsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetReservationPackagesGroupItemsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetReservationPackagesGroupItemsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetReservationPackagesGroupItemsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetReservationPackagesGroupItemsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetReservationPackagesGroupItemsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetReservationPackagesGroupItemsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetReservationPackagesGroupItemsLOVExecute(r)
}

/*
GetReservationPackagesGroupItemsLOV Fetch List Of Values for Reservation Packages Group Items

 <p><strong>OperationId:</strong>getReservationPackagesGroupItemsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param group Value of the parameter 'group' which is required to fetch ReservationPackagesGroupItems LOV
 @param arrival Value of the parameter 'arrival' which is required to fetch ReservationPackagesGroupItems LOV
 @param children Value of the parameter 'children' which is required to fetch ReservationPackagesGroupItems LOV
 @param adults Value of the parameter 'adults' which is required to fetch ReservationPackagesGroupItems LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ReservationPackagesGroupItems LOV
 @return LOVApiGetReservationPackagesGroupItemsLOVRequest
*/
func (a *LOVApiService) GetReservationPackagesGroupItemsLOV(ctx context.Context, group string, arrival string, children string, adults string, hotelId string) LOVApiGetReservationPackagesGroupItemsLOVRequest {
	return LOVApiGetReservationPackagesGroupItemsLOVRequest{
		ApiService: a,
		ctx: ctx,
		group: group,
		arrival: arrival,
		children: children,
		adults: adults,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetReservationPackagesGroupItemsLOVExecute(r LOVApiGetReservationPackagesGroupItemsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetReservationPackagesGroupItemsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/adults/{adults}/children/{children}/arrival/{arrival}/group/{group}/reservationPackagesGroupItems"
	localVarPath = strings.Replace(localVarPath, "{"+"group"+"}", url.PathEscape(parameterValueToString(r.group, "group")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"arrival"+"}", url.PathEscape(parameterValueToString(r.arrival, "arrival")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"children"+"}", url.PathEscape(parameterValueToString(r.children, "children")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"adults"+"}", url.PathEscape(parameterValueToString(r.adults, "adults")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.group) < 1 {
		return localVarReturnValue, nil, reportError("group must have at least 1 elements")
	}
	if strlen(r.group) > 2000 {
		return localVarReturnValue, nil, reportError("group must have less than 2000 elements")
	}
	if strlen(r.arrival) < 1 {
		return localVarReturnValue, nil, reportError("arrival must have at least 1 elements")
	}
	if strlen(r.arrival) > 2000 {
		return localVarReturnValue, nil, reportError("arrival must have less than 2000 elements")
	}
	if strlen(r.children) < 1 {
		return localVarReturnValue, nil, reportError("children must have at least 1 elements")
	}
	if strlen(r.children) > 2000 {
		return localVarReturnValue, nil, reportError("children must have less than 2000 elements")
	}
	if strlen(r.adults) < 1 {
		return localVarReturnValue, nil, reportError("adults must have at least 1 elements")
	}
	if strlen(r.adults) > 2000 {
		return localVarReturnValue, nil, reportError("adults must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetReservationPackagesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	departure string
	arrival string
	children string
	adults string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetReservationPackagesLOVRequest) Authorization(authorization string) LOVApiGetReservationPackagesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetReservationPackagesLOVRequest) XAppKey(xAppKey string) LOVApiGetReservationPackagesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetReservationPackagesLOVRequest) XHotelid(xHotelid string) LOVApiGetReservationPackagesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetReservationPackagesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetReservationPackagesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetReservationPackagesLOVRequest) ParameterName(parameterName []string) LOVApiGetReservationPackagesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetReservationPackagesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetReservationPackagesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetReservationPackagesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetReservationPackagesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetReservationPackagesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetReservationPackagesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetReservationPackagesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetReservationPackagesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetReservationPackagesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetReservationPackagesLOVExecute(r)
}

/*
GetReservationPackagesLOV Fetch List Of Values for Reservation Packages

 <p><strong>OperationId:</strong>getReservationPackagesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param departure Value of the parameter 'departure' which is required to fetch ReservationPackages LOV
 @param arrival Value of the parameter 'arrival' which is required to fetch ReservationPackages LOV
 @param children Value of the parameter 'children' which is required to fetch ReservationPackages LOV
 @param adults Value of the parameter 'adults' which is required to fetch ReservationPackages LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ReservationPackages LOV
 @return LOVApiGetReservationPackagesLOVRequest
*/
func (a *LOVApiService) GetReservationPackagesLOV(ctx context.Context, departure string, arrival string, children string, adults string, hotelId string) LOVApiGetReservationPackagesLOVRequest {
	return LOVApiGetReservationPackagesLOVRequest{
		ApiService: a,
		ctx: ctx,
		departure: departure,
		arrival: arrival,
		children: children,
		adults: adults,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetReservationPackagesLOVExecute(r LOVApiGetReservationPackagesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetReservationPackagesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/adults/{adults}/children/{children}/arrival/{arrival}/departure/{departure}/reservationPackages"
	localVarPath = strings.Replace(localVarPath, "{"+"departure"+"}", url.PathEscape(parameterValueToString(r.departure, "departure")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"arrival"+"}", url.PathEscape(parameterValueToString(r.arrival, "arrival")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"children"+"}", url.PathEscape(parameterValueToString(r.children, "children")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"adults"+"}", url.PathEscape(parameterValueToString(r.adults, "adults")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.departure) < 1 {
		return localVarReturnValue, nil, reportError("departure must have at least 1 elements")
	}
	if strlen(r.departure) > 2000 {
		return localVarReturnValue, nil, reportError("departure must have less than 2000 elements")
	}
	if strlen(r.arrival) < 1 {
		return localVarReturnValue, nil, reportError("arrival must have at least 1 elements")
	}
	if strlen(r.arrival) > 2000 {
		return localVarReturnValue, nil, reportError("arrival must have less than 2000 elements")
	}
	if strlen(r.children) < 1 {
		return localVarReturnValue, nil, reportError("children must have at least 1 elements")
	}
	if strlen(r.children) > 2000 {
		return localVarReturnValue, nil, reportError("children must have less than 2000 elements")
	}
	if strlen(r.adults) < 1 {
		return localVarReturnValue, nil, reportError("adults must have at least 1 elements")
	}
	if strlen(r.adults) > 2000 {
		return localVarReturnValue, nil, reportError("adults must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetReservationPreferencesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetReservationPreferencesLOVRequest) Authorization(authorization string) LOVApiGetReservationPreferencesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetReservationPreferencesLOVRequest) XAppKey(xAppKey string) LOVApiGetReservationPreferencesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetReservationPreferencesLOVRequest) XHotelid(xHotelid string) LOVApiGetReservationPreferencesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetReservationPreferencesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetReservationPreferencesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetReservationPreferencesLOVRequest) ParameterName(parameterName []string) LOVApiGetReservationPreferencesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetReservationPreferencesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetReservationPreferencesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetReservationPreferencesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetReservationPreferencesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetReservationPreferencesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetReservationPreferencesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetReservationPreferencesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetReservationPreferencesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetReservationPreferencesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetReservationPreferencesLOVExecute(r)
}

/*
GetReservationPreferencesLOV Fetch List Of Values for Reservation Preferences

 <p><strong>OperationId:</strong>getReservationPreferencesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ReservationPreferences LOV
 @return LOVApiGetReservationPreferencesLOVRequest
*/
func (a *LOVApiService) GetReservationPreferencesLOV(ctx context.Context, hotelId string) LOVApiGetReservationPreferencesLOVRequest {
	return LOVApiGetReservationPreferencesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetReservationPreferencesLOVExecute(r LOVApiGetReservationPreferencesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetReservationPreferencesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/reservationPreferences"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetReservationStatusesHotelLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetReservationStatusesHotelLOVRequest) Authorization(authorization string) LOVApiGetReservationStatusesHotelLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetReservationStatusesHotelLOVRequest) XAppKey(xAppKey string) LOVApiGetReservationStatusesHotelLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetReservationStatusesHotelLOVRequest) XHotelid(xHotelid string) LOVApiGetReservationStatusesHotelLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetReservationStatusesHotelLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetReservationStatusesHotelLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetReservationStatusesHotelLOVRequest) ParameterName(parameterName []string) LOVApiGetReservationStatusesHotelLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetReservationStatusesHotelLOVRequest) ParameterValue(parameterValue []string) LOVApiGetReservationStatusesHotelLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetReservationStatusesHotelLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetReservationStatusesHotelLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetReservationStatusesHotelLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetReservationStatusesHotelLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetReservationStatusesHotelLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetReservationStatusesHotelLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetReservationStatusesHotelLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetReservationStatusesHotelLOVExecute(r)
}

/*
GetReservationStatusesHotelLOV Fetch List Of Values for Reservation Statuses Hotel

 <p><strong>OperationId:</strong>getReservationStatusesHotelLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ReservationStatusesHotel LOV
 @return LOVApiGetReservationStatusesHotelLOVRequest
*/
func (a *LOVApiService) GetReservationStatusesHotelLOV(ctx context.Context, hotelId string) LOVApiGetReservationStatusesHotelLOVRequest {
	return LOVApiGetReservationStatusesHotelLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetReservationStatusesHotelLOVExecute(r LOVApiGetReservationStatusesHotelLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetReservationStatusesHotelLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/reservationStatusesHotel"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetReservationTicketsCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	departure string
	arrival string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetReservationTicketsCodesLOVRequest) Authorization(authorization string) LOVApiGetReservationTicketsCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetReservationTicketsCodesLOVRequest) XAppKey(xAppKey string) LOVApiGetReservationTicketsCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetReservationTicketsCodesLOVRequest) XHotelid(xHotelid string) LOVApiGetReservationTicketsCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetReservationTicketsCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetReservationTicketsCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetReservationTicketsCodesLOVRequest) ParameterName(parameterName []string) LOVApiGetReservationTicketsCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetReservationTicketsCodesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetReservationTicketsCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetReservationTicketsCodesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetReservationTicketsCodesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetReservationTicketsCodesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetReservationTicketsCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetReservationTicketsCodesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetReservationTicketsCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetReservationTicketsCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetReservationTicketsCodesLOVExecute(r)
}

/*
GetReservationTicketsCodesLOV Fetch List Of Values for Reservation Tickets Codes

 <p><strong>OperationId:</strong>getReservationTicketsCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param departure Value of the parameter 'departure' which is required to fetch ReservationTicketsCodes LOV
 @param arrival Value of the parameter 'arrival' which is required to fetch ReservationTicketsCodes LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ReservationTicketsCodes LOV
 @return LOVApiGetReservationTicketsCodesLOVRequest
*/
func (a *LOVApiService) GetReservationTicketsCodesLOV(ctx context.Context, departure string, arrival string, hotelId string) LOVApiGetReservationTicketsCodesLOVRequest {
	return LOVApiGetReservationTicketsCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		departure: departure,
		arrival: arrival,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetReservationTicketsCodesLOVExecute(r LOVApiGetReservationTicketsCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetReservationTicketsCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/arrival/{arrival}/departure/{departure}/reservationTicketsCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"departure"+"}", url.PathEscape(parameterValueToString(r.departure, "departure")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"arrival"+"}", url.PathEscape(parameterValueToString(r.arrival, "arrival")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.departure) < 1 {
		return localVarReturnValue, nil, reportError("departure must have at least 1 elements")
	}
	if strlen(r.departure) > 2000 {
		return localVarReturnValue, nil, reportError("departure must have less than 2000 elements")
	}
	if strlen(r.arrival) < 1 {
		return localVarReturnValue, nil, reportError("arrival must have at least 1 elements")
	}
	if strlen(r.arrival) > 2000 {
		return localVarReturnValue, nil, reportError("arrival must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetReservationTicketsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	resvNameId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetReservationTicketsLOVRequest) Authorization(authorization string) LOVApiGetReservationTicketsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetReservationTicketsLOVRequest) XAppKey(xAppKey string) LOVApiGetReservationTicketsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetReservationTicketsLOVRequest) XHotelid(xHotelid string) LOVApiGetReservationTicketsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetReservationTicketsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetReservationTicketsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetReservationTicketsLOVRequest) ParameterName(parameterName []string) LOVApiGetReservationTicketsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetReservationTicketsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetReservationTicketsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetReservationTicketsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetReservationTicketsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetReservationTicketsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetReservationTicketsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetReservationTicketsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetReservationTicketsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetReservationTicketsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetReservationTicketsLOVExecute(r)
}

/*
GetReservationTicketsLOV Fetch List Of Values for Reservation Tickets

 <p><strong>OperationId:</strong>getReservationTicketsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param resvNameId Value of the parameter 'resvNameId' which is required to fetch ReservationTickets LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ReservationTickets LOV
 @return LOVApiGetReservationTicketsLOVRequest
*/
func (a *LOVApiService) GetReservationTicketsLOV(ctx context.Context, resvNameId string, hotelId string) LOVApiGetReservationTicketsLOVRequest {
	return LOVApiGetReservationTicketsLOVRequest{
		ApiService: a,
		ctx: ctx,
		resvNameId: resvNameId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetReservationTicketsLOVExecute(r LOVApiGetReservationTicketsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetReservationTicketsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/resvNameId/{resvNameId}/reservationTickets"
	localVarPath = strings.Replace(localVarPath, "{"+"resvNameId"+"}", url.PathEscape(parameterValueToString(r.resvNameId, "resvNameId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.resvNameId) < 1 {
		return localVarReturnValue, nil, reportError("resvNameId must have at least 1 elements")
	}
	if strlen(r.resvNameId) > 2000 {
		return localVarReturnValue, nil, reportError("resvNameId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetResortAirportsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetResortAirportsLOVRequest) Authorization(authorization string) LOVApiGetResortAirportsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetResortAirportsLOVRequest) XAppKey(xAppKey string) LOVApiGetResortAirportsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetResortAirportsLOVRequest) XHotelid(xHotelid string) LOVApiGetResortAirportsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetResortAirportsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetResortAirportsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetResortAirportsLOVRequest) ParameterName(parameterName []string) LOVApiGetResortAirportsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetResortAirportsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetResortAirportsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetResortAirportsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetResortAirportsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetResortAirportsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetResortAirportsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetResortAirportsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetResortAirportsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetResortAirportsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetResortAirportsLOVExecute(r)
}

/*
GetResortAirportsLOV Fetch List Of Values for Resort Airports

 <p><strong>OperationId:</strong>getResortAirportsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ResortAirports LOV
 @return LOVApiGetResortAirportsLOVRequest
*/
func (a *LOVApiService) GetResortAirportsLOV(ctx context.Context, hotelId string) LOVApiGetResortAirportsLOVRequest {
	return LOVApiGetResortAirportsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetResortAirportsLOVExecute(r LOVApiGetResortAirportsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetResortAirportsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/resortAirports"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetResortCROsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetResortCROsLOVRequest) Authorization(authorization string) LOVApiGetResortCROsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetResortCROsLOVRequest) XAppKey(xAppKey string) LOVApiGetResortCROsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetResortCROsLOVRequest) XHotelid(xHotelid string) LOVApiGetResortCROsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetResortCROsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetResortCROsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetResortCROsLOVRequest) ParameterName(parameterName []string) LOVApiGetResortCROsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetResortCROsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetResortCROsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetResortCROsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetResortCROsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetResortCROsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetResortCROsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetResortCROsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetResortCROsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetResortCROsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetResortCROsLOVExecute(r)
}

/*
GetResortCROsLOV Fetch List Of Values for Resort CROs

 <p><strong>OperationId:</strong>getResortCROsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ResortCROs LOV
 @return LOVApiGetResortCROsLOVRequest
*/
func (a *LOVApiService) GetResortCROsLOV(ctx context.Context, hotelId string) LOVApiGetResortCROsLOVRequest {
	return LOVApiGetResortCROsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetResortCROsLOVExecute(r LOVApiGetResortCROsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetResortCROsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/resortCROs"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetResortGuaranteeCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetResortGuaranteeCodesLOVRequest) Authorization(authorization string) LOVApiGetResortGuaranteeCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetResortGuaranteeCodesLOVRequest) XAppKey(xAppKey string) LOVApiGetResortGuaranteeCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetResortGuaranteeCodesLOVRequest) XHotelid(xHotelid string) LOVApiGetResortGuaranteeCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetResortGuaranteeCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetResortGuaranteeCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetResortGuaranteeCodesLOVRequest) ParameterName(parameterName []string) LOVApiGetResortGuaranteeCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetResortGuaranteeCodesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetResortGuaranteeCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetResortGuaranteeCodesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetResortGuaranteeCodesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetResortGuaranteeCodesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetResortGuaranteeCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetResortGuaranteeCodesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetResortGuaranteeCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetResortGuaranteeCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetResortGuaranteeCodesLOVExecute(r)
}

/*
GetResortGuaranteeCodesLOV Fetch List Of Values for Resort Guarantee Codes

 <p><strong>OperationId:</strong>getResortGuaranteeCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ResortGuaranteeCodes LOV
 @return LOVApiGetResortGuaranteeCodesLOVRequest
*/
func (a *LOVApiService) GetResortGuaranteeCodesLOV(ctx context.Context, hotelId string) LOVApiGetResortGuaranteeCodesLOVRequest {
	return LOVApiGetResortGuaranteeCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetResortGuaranteeCodesLOVExecute(r LOVApiGetResortGuaranteeCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetResortGuaranteeCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/resortGuaranteeCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetResortInventoryItemsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	sellInEvent string
	sellInReservation string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetResortInventoryItemsLOVRequest) Authorization(authorization string) LOVApiGetResortInventoryItemsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetResortInventoryItemsLOVRequest) XAppKey(xAppKey string) LOVApiGetResortInventoryItemsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetResortInventoryItemsLOVRequest) XHotelid(xHotelid string) LOVApiGetResortInventoryItemsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetResortInventoryItemsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetResortInventoryItemsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetResortInventoryItemsLOVRequest) ParameterName(parameterName []string) LOVApiGetResortInventoryItemsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetResortInventoryItemsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetResortInventoryItemsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetResortInventoryItemsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetResortInventoryItemsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetResortInventoryItemsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetResortInventoryItemsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetResortInventoryItemsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetResortInventoryItemsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetResortInventoryItemsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetResortInventoryItemsLOVExecute(r)
}

/*
GetResortInventoryItemsLOV Fetch List Of Values for Resort Inventory Items

 <p><strong>OperationId:</strong>getResortInventoryItemsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sellInEvent Value of the parameter 'sellInEvent' which is required to fetch ResortInventoryItems LOV
 @param sellInReservation Value of the parameter 'sellInReservation' which is required to fetch ResortInventoryItems LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ResortInventoryItems LOV
 @return LOVApiGetResortInventoryItemsLOVRequest
*/
func (a *LOVApiService) GetResortInventoryItemsLOV(ctx context.Context, sellInEvent string, sellInReservation string, hotelId string) LOVApiGetResortInventoryItemsLOVRequest {
	return LOVApiGetResortInventoryItemsLOVRequest{
		ApiService: a,
		ctx: ctx,
		sellInEvent: sellInEvent,
		sellInReservation: sellInReservation,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetResortInventoryItemsLOVExecute(r LOVApiGetResortInventoryItemsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetResortInventoryItemsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/sellInReservation/{sellInReservation}/sellInEvent/{sellInEvent}/resortInventoryItems"
	localVarPath = strings.Replace(localVarPath, "{"+"sellInEvent"+"}", url.PathEscape(parameterValueToString(r.sellInEvent, "sellInEvent")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sellInReservation"+"}", url.PathEscape(parameterValueToString(r.sellInReservation, "sellInReservation")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.sellInEvent) < 1 {
		return localVarReturnValue, nil, reportError("sellInEvent must have at least 1 elements")
	}
	if strlen(r.sellInEvent) > 2000 {
		return localVarReturnValue, nil, reportError("sellInEvent must have less than 2000 elements")
	}
	if strlen(r.sellInReservation) < 1 {
		return localVarReturnValue, nil, reportError("sellInReservation must have at least 1 elements")
	}
	if strlen(r.sellInReservation) > 2000 {
		return localVarReturnValue, nil, reportError("sellInReservation must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetResortMarketCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetResortMarketCodesLOVRequest) Authorization(authorization string) LOVApiGetResortMarketCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetResortMarketCodesLOVRequest) XAppKey(xAppKey string) LOVApiGetResortMarketCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetResortMarketCodesLOVRequest) XHotelid(xHotelid string) LOVApiGetResortMarketCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetResortMarketCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetResortMarketCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetResortMarketCodesLOVRequest) ParameterName(parameterName []string) LOVApiGetResortMarketCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetResortMarketCodesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetResortMarketCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetResortMarketCodesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetResortMarketCodesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetResortMarketCodesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetResortMarketCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetResortMarketCodesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetResortMarketCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetResortMarketCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetResortMarketCodesLOVExecute(r)
}

/*
GetResortMarketCodesLOV Fetch List Of Values for Resort Market Codes

 <p><strong>OperationId:</strong>getResortMarketCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ResortMarketCodes LOV
 @return LOVApiGetResortMarketCodesLOVRequest
*/
func (a *LOVApiService) GetResortMarketCodesLOV(ctx context.Context, hotelId string) LOVApiGetResortMarketCodesLOVRequest {
	return LOVApiGetResortMarketCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetResortMarketCodesLOVExecute(r LOVApiGetResortMarketCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetResortMarketCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/resortMarketCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetResortRateClassesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetResortRateClassesLOVRequest) Authorization(authorization string) LOVApiGetResortRateClassesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetResortRateClassesLOVRequest) XAppKey(xAppKey string) LOVApiGetResortRateClassesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetResortRateClassesLOVRequest) XHotelid(xHotelid string) LOVApiGetResortRateClassesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetResortRateClassesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetResortRateClassesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetResortRateClassesLOVRequest) ParameterName(parameterName []string) LOVApiGetResortRateClassesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetResortRateClassesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetResortRateClassesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetResortRateClassesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetResortRateClassesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetResortRateClassesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetResortRateClassesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetResortRateClassesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetResortRateClassesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetResortRateClassesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetResortRateClassesLOVExecute(r)
}

/*
GetResortRateClassesLOV Fetch List Of Values for Resort Rate Classes

 <p><strong>OperationId:</strong>getResortRateClassesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ResortRateClasses LOV
 @return LOVApiGetResortRateClassesLOVRequest
*/
func (a *LOVApiService) GetResortRateClassesLOV(ctx context.Context, hotelId string) LOVApiGetResortRateClassesLOVRequest {
	return LOVApiGetResortRateClassesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetResortRateClassesLOVExecute(r LOVApiGetResortRateClassesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetResortRateClassesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/resortRateClasses"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetResortRestrictionStatusesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetResortRestrictionStatusesLOVRequest) Authorization(authorization string) LOVApiGetResortRestrictionStatusesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetResortRestrictionStatusesLOVRequest) XAppKey(xAppKey string) LOVApiGetResortRestrictionStatusesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetResortRestrictionStatusesLOVRequest) XHotelid(xHotelid string) LOVApiGetResortRestrictionStatusesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetResortRestrictionStatusesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetResortRestrictionStatusesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetResortRestrictionStatusesLOVRequest) ParameterName(parameterName []string) LOVApiGetResortRestrictionStatusesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetResortRestrictionStatusesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetResortRestrictionStatusesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetResortRestrictionStatusesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetResortRestrictionStatusesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetResortRestrictionStatusesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetResortRestrictionStatusesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetResortRestrictionStatusesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetResortRestrictionStatusesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetResortRestrictionStatusesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetResortRestrictionStatusesLOVExecute(r)
}

/*
GetResortRestrictionStatusesLOV Fetch List Of Values for Resort Restriction Statuses

 <p><strong>OperationId:</strong>getResortRestrictionStatusesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ResortRestrictionStatuses LOV
 @return LOVApiGetResortRestrictionStatusesLOVRequest
*/
func (a *LOVApiService) GetResortRestrictionStatusesLOV(ctx context.Context, hotelId string) LOVApiGetResortRestrictionStatusesLOVRequest {
	return LOVApiGetResortRestrictionStatusesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetResortRestrictionStatusesLOVExecute(r LOVApiGetResortRestrictionStatusesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetResortRestrictionStatusesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/resortRestrictionStatuses"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetResortRoomNumbersLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetResortRoomNumbersLOVRequest) Authorization(authorization string) LOVApiGetResortRoomNumbersLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetResortRoomNumbersLOVRequest) XAppKey(xAppKey string) LOVApiGetResortRoomNumbersLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetResortRoomNumbersLOVRequest) XHotelid(xHotelid string) LOVApiGetResortRoomNumbersLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetResortRoomNumbersLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetResortRoomNumbersLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetResortRoomNumbersLOVRequest) ParameterName(parameterName []string) LOVApiGetResortRoomNumbersLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetResortRoomNumbersLOVRequest) ParameterValue(parameterValue []string) LOVApiGetResortRoomNumbersLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetResortRoomNumbersLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetResortRoomNumbersLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetResortRoomNumbersLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetResortRoomNumbersLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetResortRoomNumbersLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetResortRoomNumbersLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetResortRoomNumbersLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetResortRoomNumbersLOVExecute(r)
}

/*
GetResortRoomNumbersLOV Fetch List Of Values for Resort Room Numbers

 <p><strong>OperationId:</strong>getResortRoomNumbersLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ResortRoomNumbers LOV
 @return LOVApiGetResortRoomNumbersLOVRequest
*/
func (a *LOVApiService) GetResortRoomNumbersLOV(ctx context.Context, hotelId string) LOVApiGetResortRoomNumbersLOVRequest {
	return LOVApiGetResortRoomNumbersLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetResortRoomNumbersLOVExecute(r LOVApiGetResortRoomNumbersLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetResortRoomNumbersLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/resortRoomNumbers"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetResortRoomTypesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetResortRoomTypesLOVRequest) Authorization(authorization string) LOVApiGetResortRoomTypesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetResortRoomTypesLOVRequest) XAppKey(xAppKey string) LOVApiGetResortRoomTypesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetResortRoomTypesLOVRequest) XHotelid(xHotelid string) LOVApiGetResortRoomTypesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetResortRoomTypesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetResortRoomTypesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetResortRoomTypesLOVRequest) ParameterName(parameterName []string) LOVApiGetResortRoomTypesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetResortRoomTypesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetResortRoomTypesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetResortRoomTypesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetResortRoomTypesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetResortRoomTypesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetResortRoomTypesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetResortRoomTypesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetResortRoomTypesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetResortRoomTypesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetResortRoomTypesLOVExecute(r)
}

/*
GetResortRoomTypesLOV Fetch List Of Values for Resort Room Types

 <p><strong>OperationId:</strong>getResortRoomTypesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ResortRoomTypes LOV
 @return LOVApiGetResortRoomTypesLOVRequest
*/
func (a *LOVApiService) GetResortRoomTypesLOV(ctx context.Context, hotelId string) LOVApiGetResortRoomTypesLOVRequest {
	return LOVApiGetResortRoomTypesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetResortRoomTypesLOVExecute(r LOVApiGetResortRoomTypesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetResortRoomTypesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/resortRoomTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetResortTransportationLabelsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetResortTransportationLabelsLOVRequest) Authorization(authorization string) LOVApiGetResortTransportationLabelsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetResortTransportationLabelsLOVRequest) XAppKey(xAppKey string) LOVApiGetResortTransportationLabelsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetResortTransportationLabelsLOVRequest) XHotelid(xHotelid string) LOVApiGetResortTransportationLabelsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetResortTransportationLabelsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetResortTransportationLabelsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetResortTransportationLabelsLOVRequest) ParameterName(parameterName []string) LOVApiGetResortTransportationLabelsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetResortTransportationLabelsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetResortTransportationLabelsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetResortTransportationLabelsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetResortTransportationLabelsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetResortTransportationLabelsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetResortTransportationLabelsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetResortTransportationLabelsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetResortTransportationLabelsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetResortTransportationLabelsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetResortTransportationLabelsLOVExecute(r)
}

/*
GetResortTransportationLabelsLOV Fetch List Of Values for Resort Transportation Labels

 <p><strong>OperationId:</strong>getResortTransportationLabelsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ResortTransportationLabels LOV
 @return LOVApiGetResortTransportationLabelsLOVRequest
*/
func (a *LOVApiService) GetResortTransportationLabelsLOV(ctx context.Context, hotelId string) LOVApiGetResortTransportationLabelsLOVRequest {
	return LOVApiGetResortTransportationLabelsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetResortTransportationLabelsLOVExecute(r LOVApiGetResortTransportationLabelsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetResortTransportationLabelsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/resortTransportationLabels"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetResourceItemClassesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetResourceItemClassesLOVRequest) Authorization(authorization string) LOVApiGetResourceItemClassesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetResourceItemClassesLOVRequest) XAppKey(xAppKey string) LOVApiGetResourceItemClassesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetResourceItemClassesLOVRequest) XHotelid(xHotelid string) LOVApiGetResourceItemClassesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetResourceItemClassesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetResourceItemClassesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetResourceItemClassesLOVRequest) ParameterName(parameterName []string) LOVApiGetResourceItemClassesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetResourceItemClassesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetResourceItemClassesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetResourceItemClassesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetResourceItemClassesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetResourceItemClassesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetResourceItemClassesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetResourceItemClassesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetResourceItemClassesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetResourceItemClassesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetResourceItemClassesLOVExecute(r)
}

/*
GetResourceItemClassesLOV Fetch List Of Values for Resource Item Classes

 <p><strong>OperationId:</strong>getResourceItemClassesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ResourceItemClasses LOV
 @return LOVApiGetResourceItemClassesLOVRequest
*/
func (a *LOVApiService) GetResourceItemClassesLOV(ctx context.Context, hotelId string) LOVApiGetResourceItemClassesLOVRequest {
	return LOVApiGetResourceItemClassesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetResourceItemClassesLOVExecute(r LOVApiGetResourceItemClassesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetResourceItemClassesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/resourceItemClasses"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetResvAutoAttachRulesCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetResvAutoAttachRulesCodesLOVRequest) Authorization(authorization string) LOVApiGetResvAutoAttachRulesCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetResvAutoAttachRulesCodesLOVRequest) XAppKey(xAppKey string) LOVApiGetResvAutoAttachRulesCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetResvAutoAttachRulesCodesLOVRequest) XHotelid(xHotelid string) LOVApiGetResvAutoAttachRulesCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetResvAutoAttachRulesCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetResvAutoAttachRulesCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetResvAutoAttachRulesCodesLOVRequest) ParameterName(parameterName []string) LOVApiGetResvAutoAttachRulesCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetResvAutoAttachRulesCodesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetResvAutoAttachRulesCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetResvAutoAttachRulesCodesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetResvAutoAttachRulesCodesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetResvAutoAttachRulesCodesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetResvAutoAttachRulesCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetResvAutoAttachRulesCodesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetResvAutoAttachRulesCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetResvAutoAttachRulesCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetResvAutoAttachRulesCodesLOVExecute(r)
}

/*
GetResvAutoAttachRulesCodesLOV Fetch List Of Values for Resv Auto Attach Rules Codes

 <p><strong>OperationId:</strong>getResvAutoAttachRulesCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ResvAutoAttachRulesCodes LOV
 @return LOVApiGetResvAutoAttachRulesCodesLOVRequest
*/
func (a *LOVApiService) GetResvAutoAttachRulesCodesLOV(ctx context.Context, hotelId string) LOVApiGetResvAutoAttachRulesCodesLOVRequest {
	return LOVApiGetResvAutoAttachRulesCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetResvAutoAttachRulesCodesLOVExecute(r LOVApiGetResvAutoAttachRulesCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetResvAutoAttachRulesCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/resvAutoAttachRulesCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetResvAutoAttachRulesRuleTypeLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetResvAutoAttachRulesRuleTypeLOVRequest) Authorization(authorization string) LOVApiGetResvAutoAttachRulesRuleTypeLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetResvAutoAttachRulesRuleTypeLOVRequest) XAppKey(xAppKey string) LOVApiGetResvAutoAttachRulesRuleTypeLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetResvAutoAttachRulesRuleTypeLOVRequest) XHotelid(xHotelid string) LOVApiGetResvAutoAttachRulesRuleTypeLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetResvAutoAttachRulesRuleTypeLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetResvAutoAttachRulesRuleTypeLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetResvAutoAttachRulesRuleTypeLOVRequest) ParameterName(parameterName []string) LOVApiGetResvAutoAttachRulesRuleTypeLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetResvAutoAttachRulesRuleTypeLOVRequest) ParameterValue(parameterValue []string) LOVApiGetResvAutoAttachRulesRuleTypeLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetResvAutoAttachRulesRuleTypeLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetResvAutoAttachRulesRuleTypeLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetResvAutoAttachRulesRuleTypeLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetResvAutoAttachRulesRuleTypeLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetResvAutoAttachRulesRuleTypeLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetResvAutoAttachRulesRuleTypeLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetResvAutoAttachRulesRuleTypeLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetResvAutoAttachRulesRuleTypeLOVExecute(r)
}

/*
GetResvAutoAttachRulesRuleTypeLOV Fetch List Of Values for Resv Auto Attach Rules Rule Type

 <p><strong>OperationId:</strong>getResvAutoAttachRulesRuleTypeLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ResvAutoAttachRulesRuleType LOV
 @return LOVApiGetResvAutoAttachRulesRuleTypeLOVRequest
*/
func (a *LOVApiService) GetResvAutoAttachRulesRuleTypeLOV(ctx context.Context, hotelId string) LOVApiGetResvAutoAttachRulesRuleTypeLOVRequest {
	return LOVApiGetResvAutoAttachRulesRuleTypeLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetResvAutoAttachRulesRuleTypeLOVExecute(r LOVApiGetResvAutoAttachRulesRuleTypeLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetResvAutoAttachRulesRuleTypeLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/resvAutoAttachRulesRuleType"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetResvBasedProfilesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetResvBasedProfilesLOVRequest) Authorization(authorization string) LOVApiGetResvBasedProfilesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetResvBasedProfilesLOVRequest) XAppKey(xAppKey string) LOVApiGetResvBasedProfilesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetResvBasedProfilesLOVRequest) XHotelid(xHotelid string) LOVApiGetResvBasedProfilesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetResvBasedProfilesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetResvBasedProfilesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetResvBasedProfilesLOVRequest) ParameterName(parameterName []string) LOVApiGetResvBasedProfilesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetResvBasedProfilesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetResvBasedProfilesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetResvBasedProfilesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetResvBasedProfilesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetResvBasedProfilesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetResvBasedProfilesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetResvBasedProfilesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetResvBasedProfilesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetResvBasedProfilesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetResvBasedProfilesLOVExecute(r)
}

/*
GetResvBasedProfilesLOV Fetch List Of Values for Resv Based Profiles

 <p><strong>OperationId:</strong>getResvBasedProfilesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ResvBasedProfiles LOV
 @return LOVApiGetResvBasedProfilesLOVRequest
*/
func (a *LOVApiService) GetResvBasedProfilesLOV(ctx context.Context, hotelId string) LOVApiGetResvBasedProfilesLOVRequest {
	return LOVApiGetResvBasedProfilesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetResvBasedProfilesLOVExecute(r LOVApiGetResvBasedProfilesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetResvBasedProfilesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/resvBasedProfiles"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetResvTransactionDiversionCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	resvNameId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetResvTransactionDiversionCodesLOVRequest) Authorization(authorization string) LOVApiGetResvTransactionDiversionCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetResvTransactionDiversionCodesLOVRequest) XAppKey(xAppKey string) LOVApiGetResvTransactionDiversionCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetResvTransactionDiversionCodesLOVRequest) XHotelid(xHotelid string) LOVApiGetResvTransactionDiversionCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetResvTransactionDiversionCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetResvTransactionDiversionCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetResvTransactionDiversionCodesLOVRequest) ParameterName(parameterName []string) LOVApiGetResvTransactionDiversionCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetResvTransactionDiversionCodesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetResvTransactionDiversionCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetResvTransactionDiversionCodesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetResvTransactionDiversionCodesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetResvTransactionDiversionCodesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetResvTransactionDiversionCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetResvTransactionDiversionCodesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetResvTransactionDiversionCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetResvTransactionDiversionCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetResvTransactionDiversionCodesLOVExecute(r)
}

/*
GetResvTransactionDiversionCodesLOV Fetch List Of Values for Resv Transaction Diversion Codes

 <p><strong>OperationId:</strong>getResvTransactionDiversionCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param resvNameId Value of the parameter 'resvNameId' which is required to fetch ResvTransactionDiversionCodes LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ResvTransactionDiversionCodes LOV
 @return LOVApiGetResvTransactionDiversionCodesLOVRequest
*/
func (a *LOVApiService) GetResvTransactionDiversionCodesLOV(ctx context.Context, resvNameId string, hotelId string) LOVApiGetResvTransactionDiversionCodesLOVRequest {
	return LOVApiGetResvTransactionDiversionCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		resvNameId: resvNameId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetResvTransactionDiversionCodesLOVExecute(r LOVApiGetResvTransactionDiversionCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetResvTransactionDiversionCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/resvNameId/{resvNameId}/resvTransactionDiversionCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"resvNameId"+"}", url.PathEscape(parameterValueToString(r.resvNameId, "resvNameId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.resvNameId) < 1 {
		return localVarReturnValue, nil, reportError("resvNameId must have at least 1 elements")
	}
	if strlen(r.resvNameId) > 2000 {
		return localVarReturnValue, nil, reportError("resvNameId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetRevenueBucketTrxCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	bucketType string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetRevenueBucketTrxCodesLOVRequest) Authorization(authorization string) LOVApiGetRevenueBucketTrxCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetRevenueBucketTrxCodesLOVRequest) XAppKey(xAppKey string) LOVApiGetRevenueBucketTrxCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetRevenueBucketTrxCodesLOVRequest) XHotelid(xHotelid string) LOVApiGetRevenueBucketTrxCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetRevenueBucketTrxCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetRevenueBucketTrxCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetRevenueBucketTrxCodesLOVRequest) ParameterName(parameterName []string) LOVApiGetRevenueBucketTrxCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetRevenueBucketTrxCodesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetRevenueBucketTrxCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetRevenueBucketTrxCodesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetRevenueBucketTrxCodesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetRevenueBucketTrxCodesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetRevenueBucketTrxCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetRevenueBucketTrxCodesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetRevenueBucketTrxCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetRevenueBucketTrxCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRevenueBucketTrxCodesLOVExecute(r)
}

/*
GetRevenueBucketTrxCodesLOV Fetch List Of Values for Revenue Bucket Trx Codes

 <p><strong>OperationId:</strong>getRevenueBucketTrxCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bucketType Value of the parameter 'bucketType' which is required to fetch RevenueBucketTrxCodes LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RevenueBucketTrxCodes LOV
 @return LOVApiGetRevenueBucketTrxCodesLOVRequest
*/
func (a *LOVApiService) GetRevenueBucketTrxCodesLOV(ctx context.Context, bucketType string, hotelId string) LOVApiGetRevenueBucketTrxCodesLOVRequest {
	return LOVApiGetRevenueBucketTrxCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		bucketType: bucketType,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRevenueBucketTrxCodesLOVExecute(r LOVApiGetRevenueBucketTrxCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRevenueBucketTrxCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/bucketType/{bucketType}/revenueBucketTrxCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"bucketType"+"}", url.PathEscape(parameterValueToString(r.bucketType, "bucketType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.bucketType) < 1 {
		return localVarReturnValue, nil, reportError("bucketType must have at least 1 elements")
	}
	if strlen(r.bucketType) > 2000 {
		return localVarReturnValue, nil, reportError("bucketType must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetRevenueBucketsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	type_ string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetRevenueBucketsLOVRequest) Authorization(authorization string) LOVApiGetRevenueBucketsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetRevenueBucketsLOVRequest) XAppKey(xAppKey string) LOVApiGetRevenueBucketsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetRevenueBucketsLOVRequest) XHotelid(xHotelid string) LOVApiGetRevenueBucketsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetRevenueBucketsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetRevenueBucketsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetRevenueBucketsLOVRequest) ParameterName(parameterName []string) LOVApiGetRevenueBucketsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetRevenueBucketsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetRevenueBucketsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetRevenueBucketsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetRevenueBucketsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetRevenueBucketsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetRevenueBucketsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetRevenueBucketsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetRevenueBucketsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetRevenueBucketsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRevenueBucketsLOVExecute(r)
}

/*
GetRevenueBucketsLOV Fetch List Of Values for Revenue Buckets

 <p><strong>OperationId:</strong>getRevenueBucketsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param type_ Value of the parameter 'type' which is required to fetch RevenueBuckets LOV
 @return LOVApiGetRevenueBucketsLOVRequest
*/
func (a *LOVApiService) GetRevenueBucketsLOV(ctx context.Context, type_ string) LOVApiGetRevenueBucketsLOVRequest {
	return LOVApiGetRevenueBucketsLOVRequest{
		ApiService: a,
		ctx: ctx,
		type_: type_,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRevenueBucketsLOVExecute(r LOVApiGetRevenueBucketsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRevenueBucketsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/type/{type}/revenueBuckets"
	localVarPath = strings.Replace(localVarPath, "{"+"type"+"}", url.PathEscape(parameterValueToString(r.type_, "type_")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.type_) < 1 {
		return localVarReturnValue, nil, reportError("type_ must have at least 1 elements")
	}
	if strlen(r.type_) > 2000 {
		return localVarReturnValue, nil, reportError("type_ must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetRevenueTypeMappingSpaceLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetRevenueTypeMappingSpaceLOVRequest) Authorization(authorization string) LOVApiGetRevenueTypeMappingSpaceLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetRevenueTypeMappingSpaceLOVRequest) XAppKey(xAppKey string) LOVApiGetRevenueTypeMappingSpaceLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetRevenueTypeMappingSpaceLOVRequest) XHotelid(xHotelid string) LOVApiGetRevenueTypeMappingSpaceLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetRevenueTypeMappingSpaceLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetRevenueTypeMappingSpaceLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetRevenueTypeMappingSpaceLOVRequest) ParameterName(parameterName []string) LOVApiGetRevenueTypeMappingSpaceLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetRevenueTypeMappingSpaceLOVRequest) ParameterValue(parameterValue []string) LOVApiGetRevenueTypeMappingSpaceLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetRevenueTypeMappingSpaceLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetRevenueTypeMappingSpaceLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetRevenueTypeMappingSpaceLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetRevenueTypeMappingSpaceLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetRevenueTypeMappingSpaceLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetRevenueTypeMappingSpaceLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetRevenueTypeMappingSpaceLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRevenueTypeMappingSpaceLOVExecute(r)
}

/*
GetRevenueTypeMappingSpaceLOV Fetch List Of Values for Revenue Type Mapping Space

 <p><strong>OperationId:</strong>getRevenueTypeMappingSpaceLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RevenueTypeMappingSpace LOV
 @return LOVApiGetRevenueTypeMappingSpaceLOVRequest
*/
func (a *LOVApiService) GetRevenueTypeMappingSpaceLOV(ctx context.Context, hotelId string) LOVApiGetRevenueTypeMappingSpaceLOVRequest {
	return LOVApiGetRevenueTypeMappingSpaceLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRevenueTypeMappingSpaceLOVExecute(r LOVApiGetRevenueTypeMappingSpaceLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRevenueTypeMappingSpaceLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/revenueTypeMappingSpace"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetRevenueTypeMappingTrxCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetRevenueTypeMappingTrxCodesLOVRequest) Authorization(authorization string) LOVApiGetRevenueTypeMappingTrxCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetRevenueTypeMappingTrxCodesLOVRequest) XAppKey(xAppKey string) LOVApiGetRevenueTypeMappingTrxCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetRevenueTypeMappingTrxCodesLOVRequest) XHotelid(xHotelid string) LOVApiGetRevenueTypeMappingTrxCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetRevenueTypeMappingTrxCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetRevenueTypeMappingTrxCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetRevenueTypeMappingTrxCodesLOVRequest) ParameterName(parameterName []string) LOVApiGetRevenueTypeMappingTrxCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetRevenueTypeMappingTrxCodesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetRevenueTypeMappingTrxCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetRevenueTypeMappingTrxCodesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetRevenueTypeMappingTrxCodesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetRevenueTypeMappingTrxCodesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetRevenueTypeMappingTrxCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetRevenueTypeMappingTrxCodesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetRevenueTypeMappingTrxCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetRevenueTypeMappingTrxCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRevenueTypeMappingTrxCodesLOVExecute(r)
}

/*
GetRevenueTypeMappingTrxCodesLOV Fetch List Of Values for Revenue Type Mapping Trx Codes

 <p><strong>OperationId:</strong>getRevenueTypeMappingTrxCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RevenueTypeMappingTrxCodes LOV
 @return LOVApiGetRevenueTypeMappingTrxCodesLOVRequest
*/
func (a *LOVApiService) GetRevenueTypeMappingTrxCodesLOV(ctx context.Context, hotelId string) LOVApiGetRevenueTypeMappingTrxCodesLOVRequest {
	return LOVApiGetRevenueTypeMappingTrxCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRevenueTypeMappingTrxCodesLOVExecute(r LOVApiGetRevenueTypeMappingTrxCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRevenueTypeMappingTrxCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/revenueTypeMappingTrxCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetRolesForLevelLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	levelCode string
	roleLevel string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetRolesForLevelLOVRequest) Authorization(authorization string) LOVApiGetRolesForLevelLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetRolesForLevelLOVRequest) XAppKey(xAppKey string) LOVApiGetRolesForLevelLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetRolesForLevelLOVRequest) XHotelid(xHotelid string) LOVApiGetRolesForLevelLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetRolesForLevelLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetRolesForLevelLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetRolesForLevelLOVRequest) ParameterName(parameterName []string) LOVApiGetRolesForLevelLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetRolesForLevelLOVRequest) ParameterValue(parameterValue []string) LOVApiGetRolesForLevelLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetRolesForLevelLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetRolesForLevelLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetRolesForLevelLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetRolesForLevelLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetRolesForLevelLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetRolesForLevelLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetRolesForLevelLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRolesForLevelLOVExecute(r)
}

/*
GetRolesForLevelLOV Fetch List Of Values for Roles For Level

 <p><strong>OperationId:</strong>getRolesForLevelLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param levelCode Value of the parameter 'levelCode' which is required to fetch RolesForLevel LOV
 @param roleLevel Value of the parameter 'roleLevel' which is required to fetch RolesForLevel LOV
 @return LOVApiGetRolesForLevelLOVRequest
*/
func (a *LOVApiService) GetRolesForLevelLOV(ctx context.Context, levelCode string, roleLevel string) LOVApiGetRolesForLevelLOVRequest {
	return LOVApiGetRolesForLevelLOVRequest{
		ApiService: a,
		ctx: ctx,
		levelCode: levelCode,
		roleLevel: roleLevel,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRolesForLevelLOVExecute(r LOVApiGetRolesForLevelLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRolesForLevelLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/roleLevel/{roleLevel}/levelCode/{levelCode}/rolesForLevel"
	localVarPath = strings.Replace(localVarPath, "{"+"levelCode"+"}", url.PathEscape(parameterValueToString(r.levelCode, "levelCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"roleLevel"+"}", url.PathEscape(parameterValueToString(r.roleLevel, "roleLevel")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.levelCode) < 1 {
		return localVarReturnValue, nil, reportError("levelCode must have at least 1 elements")
	}
	if strlen(r.levelCode) > 2000 {
		return localVarReturnValue, nil, reportError("levelCode must have less than 2000 elements")
	}
	if strlen(r.roleLevel) < 1 {
		return localVarReturnValue, nil, reportError("roleLevel must have at least 1 elements")
	}
	if strlen(r.roleLevel) > 2000 {
		return localVarReturnValue, nil, reportError("roleLevel must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetRoomClassCategoriesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetRoomClassCategoriesLOVRequest) Authorization(authorization string) LOVApiGetRoomClassCategoriesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetRoomClassCategoriesLOVRequest) XAppKey(xAppKey string) LOVApiGetRoomClassCategoriesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetRoomClassCategoriesLOVRequest) XHotelid(xHotelid string) LOVApiGetRoomClassCategoriesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetRoomClassCategoriesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetRoomClassCategoriesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetRoomClassCategoriesLOVRequest) ParameterName(parameterName []string) LOVApiGetRoomClassCategoriesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetRoomClassCategoriesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetRoomClassCategoriesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetRoomClassCategoriesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetRoomClassCategoriesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetRoomClassCategoriesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetRoomClassCategoriesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetRoomClassCategoriesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetRoomClassCategoriesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetRoomClassCategoriesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRoomClassCategoriesLOVExecute(r)
}

/*
GetRoomClassCategoriesLOV Fetch List Of Values for Room Class Categories

 <p><strong>OperationId:</strong>getRoomClassCategoriesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RoomClassCategories LOV
 @return LOVApiGetRoomClassCategoriesLOVRequest
*/
func (a *LOVApiService) GetRoomClassCategoriesLOV(ctx context.Context, hotelId string) LOVApiGetRoomClassCategoriesLOVRequest {
	return LOVApiGetRoomClassCategoriesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRoomClassCategoriesLOVExecute(r LOVApiGetRoomClassCategoriesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRoomClassCategoriesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/roomClassCategories"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetRoomClassMultiPropertyLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelCodeList string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetRoomClassMultiPropertyLOVRequest) Authorization(authorization string) LOVApiGetRoomClassMultiPropertyLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetRoomClassMultiPropertyLOVRequest) XAppKey(xAppKey string) LOVApiGetRoomClassMultiPropertyLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetRoomClassMultiPropertyLOVRequest) XHotelid(xHotelid string) LOVApiGetRoomClassMultiPropertyLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetRoomClassMultiPropertyLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetRoomClassMultiPropertyLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetRoomClassMultiPropertyLOVRequest) ParameterName(parameterName []string) LOVApiGetRoomClassMultiPropertyLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetRoomClassMultiPropertyLOVRequest) ParameterValue(parameterValue []string) LOVApiGetRoomClassMultiPropertyLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetRoomClassMultiPropertyLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetRoomClassMultiPropertyLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetRoomClassMultiPropertyLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetRoomClassMultiPropertyLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetRoomClassMultiPropertyLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetRoomClassMultiPropertyLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetRoomClassMultiPropertyLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRoomClassMultiPropertyLOVExecute(r)
}

/*
GetRoomClassMultiPropertyLOV Fetch List Of Values for Room Class Multi Property

 <p><strong>OperationId:</strong>getRoomClassMultiPropertyLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelCodeList Value of the parameter 'hotelCodeList' which is required to fetch RoomClassMultiProperty LOV
 @return LOVApiGetRoomClassMultiPropertyLOVRequest
*/
func (a *LOVApiService) GetRoomClassMultiPropertyLOV(ctx context.Context, hotelCodeList string) LOVApiGetRoomClassMultiPropertyLOVRequest {
	return LOVApiGetRoomClassMultiPropertyLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelCodeList: hotelCodeList,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRoomClassMultiPropertyLOVExecute(r LOVApiGetRoomClassMultiPropertyLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRoomClassMultiPropertyLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotelCodeList/{hotelCodeList}/roomClassMultiProperty"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelCodeList"+"}", url.PathEscape(parameterValueToString(r.hotelCodeList, "hotelCodeList")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelCodeList) < 1 {
		return localVarReturnValue, nil, reportError("hotelCodeList must have at least 1 elements")
	}
	if strlen(r.hotelCodeList) > 2000 {
		return localVarReturnValue, nil, reportError("hotelCodeList must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetRoomClassesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetRoomClassesLOVRequest) Authorization(authorization string) LOVApiGetRoomClassesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetRoomClassesLOVRequest) XAppKey(xAppKey string) LOVApiGetRoomClassesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetRoomClassesLOVRequest) XHotelid(xHotelid string) LOVApiGetRoomClassesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetRoomClassesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetRoomClassesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetRoomClassesLOVRequest) ParameterName(parameterName []string) LOVApiGetRoomClassesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetRoomClassesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetRoomClassesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetRoomClassesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetRoomClassesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetRoomClassesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetRoomClassesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetRoomClassesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetRoomClassesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetRoomClassesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRoomClassesLOVExecute(r)
}

/*
GetRoomClassesLOV Fetch List Of Values for Room Classes

 <p><strong>OperationId:</strong>getRoomClassesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RoomClasses LOV
 @return LOVApiGetRoomClassesLOVRequest
*/
func (a *LOVApiService) GetRoomClassesLOV(ctx context.Context, hotelId string) LOVApiGetRoomClassesLOVRequest {
	return LOVApiGetRoomClassesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRoomClassesLOVExecute(r LOVApiGetRoomClassesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRoomClassesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/roomClasses"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetRoomFeaturesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetRoomFeaturesLOVRequest) Authorization(authorization string) LOVApiGetRoomFeaturesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetRoomFeaturesLOVRequest) XAppKey(xAppKey string) LOVApiGetRoomFeaturesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetRoomFeaturesLOVRequest) XHotelid(xHotelid string) LOVApiGetRoomFeaturesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetRoomFeaturesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetRoomFeaturesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetRoomFeaturesLOVRequest) ParameterName(parameterName []string) LOVApiGetRoomFeaturesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetRoomFeaturesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetRoomFeaturesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetRoomFeaturesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetRoomFeaturesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetRoomFeaturesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetRoomFeaturesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetRoomFeaturesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetRoomFeaturesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetRoomFeaturesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRoomFeaturesLOVExecute(r)
}

/*
GetRoomFeaturesLOV Fetch List Of Values for Room Features

 <p><strong>OperationId:</strong>getRoomFeaturesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RoomFeatures LOV
 @return LOVApiGetRoomFeaturesLOVRequest
*/
func (a *LOVApiService) GetRoomFeaturesLOV(ctx context.Context, hotelId string) LOVApiGetRoomFeaturesLOVRequest {
	return LOVApiGetRoomFeaturesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRoomFeaturesLOVExecute(r LOVApiGetRoomFeaturesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRoomFeaturesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/roomFeatures"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetRoomHierarchyClassesCopyLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	property string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetRoomHierarchyClassesCopyLOVRequest) Authorization(authorization string) LOVApiGetRoomHierarchyClassesCopyLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetRoomHierarchyClassesCopyLOVRequest) XAppKey(xAppKey string) LOVApiGetRoomHierarchyClassesCopyLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetRoomHierarchyClassesCopyLOVRequest) XHotelid(xHotelid string) LOVApiGetRoomHierarchyClassesCopyLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetRoomHierarchyClassesCopyLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetRoomHierarchyClassesCopyLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetRoomHierarchyClassesCopyLOVRequest) ParameterName(parameterName []string) LOVApiGetRoomHierarchyClassesCopyLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetRoomHierarchyClassesCopyLOVRequest) ParameterValue(parameterValue []string) LOVApiGetRoomHierarchyClassesCopyLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetRoomHierarchyClassesCopyLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetRoomHierarchyClassesCopyLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetRoomHierarchyClassesCopyLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetRoomHierarchyClassesCopyLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetRoomHierarchyClassesCopyLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetRoomHierarchyClassesCopyLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetRoomHierarchyClassesCopyLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRoomHierarchyClassesCopyLOVExecute(r)
}

/*
GetRoomHierarchyClassesCopyLOV Fetch List Of Values for Room Hierarchy Classes Copy

 <p><strong>OperationId:</strong>getRoomHierarchyClassesCopyLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param property Value of the parameter 'property' which is required to fetch RoomHierarchyClassesCopy LOV
 @return LOVApiGetRoomHierarchyClassesCopyLOVRequest
*/
func (a *LOVApiService) GetRoomHierarchyClassesCopyLOV(ctx context.Context, property string) LOVApiGetRoomHierarchyClassesCopyLOVRequest {
	return LOVApiGetRoomHierarchyClassesCopyLOVRequest{
		ApiService: a,
		ctx: ctx,
		property: property,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRoomHierarchyClassesCopyLOVExecute(r LOVApiGetRoomHierarchyClassesCopyLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRoomHierarchyClassesCopyLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/property/{property}/roomHierarchyClassesCopy"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.property) < 1 {
		return localVarReturnValue, nil, reportError("property must have at least 1 elements")
	}
	if strlen(r.property) > 2000 {
		return localVarReturnValue, nil, reportError("property must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetRoomHierarchyRoomClassesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	property string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetRoomHierarchyRoomClassesLOVRequest) Authorization(authorization string) LOVApiGetRoomHierarchyRoomClassesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetRoomHierarchyRoomClassesLOVRequest) XAppKey(xAppKey string) LOVApiGetRoomHierarchyRoomClassesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetRoomHierarchyRoomClassesLOVRequest) XHotelid(xHotelid string) LOVApiGetRoomHierarchyRoomClassesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetRoomHierarchyRoomClassesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetRoomHierarchyRoomClassesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetRoomHierarchyRoomClassesLOVRequest) ParameterName(parameterName []string) LOVApiGetRoomHierarchyRoomClassesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetRoomHierarchyRoomClassesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetRoomHierarchyRoomClassesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetRoomHierarchyRoomClassesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetRoomHierarchyRoomClassesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetRoomHierarchyRoomClassesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetRoomHierarchyRoomClassesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetRoomHierarchyRoomClassesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetRoomHierarchyRoomClassesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetRoomHierarchyRoomClassesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRoomHierarchyRoomClassesLOVExecute(r)
}

/*
GetRoomHierarchyRoomClassesLOV Fetch List Of Values for Room Hierarchy Room Classes

 <p><strong>OperationId:</strong>getRoomHierarchyRoomClassesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param property Value of the parameter 'property' which is required to fetch RoomHierarchyRoomClasses LOV
 @return LOVApiGetRoomHierarchyRoomClassesLOVRequest
*/
func (a *LOVApiService) GetRoomHierarchyRoomClassesLOV(ctx context.Context, property string) LOVApiGetRoomHierarchyRoomClassesLOVRequest {
	return LOVApiGetRoomHierarchyRoomClassesLOVRequest{
		ApiService: a,
		ctx: ctx,
		property: property,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRoomHierarchyRoomClassesLOVExecute(r LOVApiGetRoomHierarchyRoomClassesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRoomHierarchyRoomClassesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/property/{property}/roomHierarchyRoomClasses"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.property) < 1 {
		return localVarReturnValue, nil, reportError("property must have at least 1 elements")
	}
	if strlen(r.property) > 2000 {
		return localVarReturnValue, nil, reportError("property must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetRoomHierarchyRoomTypesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	property string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetRoomHierarchyRoomTypesLOVRequest) Authorization(authorization string) LOVApiGetRoomHierarchyRoomTypesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetRoomHierarchyRoomTypesLOVRequest) XAppKey(xAppKey string) LOVApiGetRoomHierarchyRoomTypesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetRoomHierarchyRoomTypesLOVRequest) XHotelid(xHotelid string) LOVApiGetRoomHierarchyRoomTypesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetRoomHierarchyRoomTypesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetRoomHierarchyRoomTypesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetRoomHierarchyRoomTypesLOVRequest) ParameterName(parameterName []string) LOVApiGetRoomHierarchyRoomTypesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetRoomHierarchyRoomTypesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetRoomHierarchyRoomTypesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetRoomHierarchyRoomTypesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetRoomHierarchyRoomTypesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetRoomHierarchyRoomTypesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetRoomHierarchyRoomTypesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetRoomHierarchyRoomTypesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetRoomHierarchyRoomTypesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetRoomHierarchyRoomTypesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRoomHierarchyRoomTypesLOVExecute(r)
}

/*
GetRoomHierarchyRoomTypesLOV Fetch List Of Values for Room Hierarchy Room Types

 <p><strong>OperationId:</strong>getRoomHierarchyRoomTypesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param property Value of the parameter 'property' which is required to fetch RoomHierarchyRoomTypes LOV
 @return LOVApiGetRoomHierarchyRoomTypesLOVRequest
*/
func (a *LOVApiService) GetRoomHierarchyRoomTypesLOV(ctx context.Context, property string) LOVApiGetRoomHierarchyRoomTypesLOVRequest {
	return LOVApiGetRoomHierarchyRoomTypesLOVRequest{
		ApiService: a,
		ctx: ctx,
		property: property,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRoomHierarchyRoomTypesLOVExecute(r LOVApiGetRoomHierarchyRoomTypesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRoomHierarchyRoomTypesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/property/{property}/roomHierarchyRoomTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.property) < 1 {
		return localVarReturnValue, nil, reportError("property must have at least 1 elements")
	}
	if strlen(r.property) > 2000 {
		return localVarReturnValue, nil, reportError("property must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetRoomHierarchyTypesCopyLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	property string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetRoomHierarchyTypesCopyLOVRequest) Authorization(authorization string) LOVApiGetRoomHierarchyTypesCopyLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetRoomHierarchyTypesCopyLOVRequest) XAppKey(xAppKey string) LOVApiGetRoomHierarchyTypesCopyLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetRoomHierarchyTypesCopyLOVRequest) XHotelid(xHotelid string) LOVApiGetRoomHierarchyTypesCopyLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetRoomHierarchyTypesCopyLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetRoomHierarchyTypesCopyLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetRoomHierarchyTypesCopyLOVRequest) ParameterName(parameterName []string) LOVApiGetRoomHierarchyTypesCopyLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetRoomHierarchyTypesCopyLOVRequest) ParameterValue(parameterValue []string) LOVApiGetRoomHierarchyTypesCopyLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetRoomHierarchyTypesCopyLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetRoomHierarchyTypesCopyLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetRoomHierarchyTypesCopyLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetRoomHierarchyTypesCopyLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetRoomHierarchyTypesCopyLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetRoomHierarchyTypesCopyLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetRoomHierarchyTypesCopyLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRoomHierarchyTypesCopyLOVExecute(r)
}

/*
GetRoomHierarchyTypesCopyLOV Fetch List Of Values for Room Hierarchy Types Copy

 <p><strong>OperationId:</strong>getRoomHierarchyTypesCopyLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param property Value of the parameter 'property' which is required to fetch RoomHierarchyTypesCopy LOV
 @return LOVApiGetRoomHierarchyTypesCopyLOVRequest
*/
func (a *LOVApiService) GetRoomHierarchyTypesCopyLOV(ctx context.Context, property string) LOVApiGetRoomHierarchyTypesCopyLOVRequest {
	return LOVApiGetRoomHierarchyTypesCopyLOVRequest{
		ApiService: a,
		ctx: ctx,
		property: property,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRoomHierarchyTypesCopyLOVExecute(r LOVApiGetRoomHierarchyTypesCopyLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRoomHierarchyTypesCopyLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/property/{property}/roomHierarchyTypesCopy"
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.property) < 1 {
		return localVarReturnValue, nil, reportError("property must have at least 1 elements")
	}
	if strlen(r.property) > 2000 {
		return localVarReturnValue, nil, reportError("property must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetRoomHoldConditionsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetRoomHoldConditionsLOVRequest) Authorization(authorization string) LOVApiGetRoomHoldConditionsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetRoomHoldConditionsLOVRequest) XAppKey(xAppKey string) LOVApiGetRoomHoldConditionsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetRoomHoldConditionsLOVRequest) XHotelid(xHotelid string) LOVApiGetRoomHoldConditionsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetRoomHoldConditionsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetRoomHoldConditionsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetRoomHoldConditionsLOVRequest) ParameterName(parameterName []string) LOVApiGetRoomHoldConditionsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetRoomHoldConditionsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetRoomHoldConditionsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetRoomHoldConditionsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetRoomHoldConditionsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetRoomHoldConditionsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetRoomHoldConditionsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetRoomHoldConditionsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetRoomHoldConditionsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetRoomHoldConditionsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRoomHoldConditionsLOVExecute(r)
}

/*
GetRoomHoldConditionsLOV Fetch List Of Values for Room Hold Conditions

 <p><strong>OperationId:</strong>getRoomHoldConditionsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RoomHoldConditions LOV
 @return LOVApiGetRoomHoldConditionsLOVRequest
*/
func (a *LOVApiService) GetRoomHoldConditionsLOV(ctx context.Context, hotelId string) LOVApiGetRoomHoldConditionsLOVRequest {
	return LOVApiGetRoomHoldConditionsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRoomHoldConditionsLOVExecute(r LOVApiGetRoomHoldConditionsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRoomHoldConditionsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/roomHoldConditions"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetRoomMaintenanceLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetRoomMaintenanceLOVRequest) Authorization(authorization string) LOVApiGetRoomMaintenanceLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetRoomMaintenanceLOVRequest) XAppKey(xAppKey string) LOVApiGetRoomMaintenanceLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetRoomMaintenanceLOVRequest) XHotelid(xHotelid string) LOVApiGetRoomMaintenanceLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetRoomMaintenanceLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetRoomMaintenanceLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetRoomMaintenanceLOVRequest) ParameterName(parameterName []string) LOVApiGetRoomMaintenanceLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetRoomMaintenanceLOVRequest) ParameterValue(parameterValue []string) LOVApiGetRoomMaintenanceLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetRoomMaintenanceLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetRoomMaintenanceLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetRoomMaintenanceLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetRoomMaintenanceLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetRoomMaintenanceLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetRoomMaintenanceLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetRoomMaintenanceLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRoomMaintenanceLOVExecute(r)
}

/*
GetRoomMaintenanceLOV Fetch List Of Values for Room Maintenance

 <p><strong>OperationId:</strong>getRoomMaintenanceLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RoomMaintenance LOV
 @return LOVApiGetRoomMaintenanceLOVRequest
*/
func (a *LOVApiService) GetRoomMaintenanceLOV(ctx context.Context, hotelId string) LOVApiGetRoomMaintenanceLOVRequest {
	return LOVApiGetRoomMaintenanceLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRoomMaintenanceLOVExecute(r LOVApiGetRoomMaintenanceLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRoomMaintenanceLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/roomMaintenance"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetRoomPoolRoomTypesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	roomPool string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetRoomPoolRoomTypesLOVRequest) Authorization(authorization string) LOVApiGetRoomPoolRoomTypesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetRoomPoolRoomTypesLOVRequest) XAppKey(xAppKey string) LOVApiGetRoomPoolRoomTypesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetRoomPoolRoomTypesLOVRequest) XHotelid(xHotelid string) LOVApiGetRoomPoolRoomTypesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetRoomPoolRoomTypesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetRoomPoolRoomTypesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetRoomPoolRoomTypesLOVRequest) ParameterName(parameterName []string) LOVApiGetRoomPoolRoomTypesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetRoomPoolRoomTypesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetRoomPoolRoomTypesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetRoomPoolRoomTypesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetRoomPoolRoomTypesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetRoomPoolRoomTypesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetRoomPoolRoomTypesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetRoomPoolRoomTypesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetRoomPoolRoomTypesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetRoomPoolRoomTypesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRoomPoolRoomTypesLOVExecute(r)
}

/*
GetRoomPoolRoomTypesLOV Fetch List Of Values for Room Pool Room Types

 <p><strong>OperationId:</strong>getRoomPoolRoomTypesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param roomPool Value of the parameter 'roomPool' which is required to fetch RoomPoolRoomTypes LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RoomPoolRoomTypes LOV
 @return LOVApiGetRoomPoolRoomTypesLOVRequest
*/
func (a *LOVApiService) GetRoomPoolRoomTypesLOV(ctx context.Context, roomPool string, hotelId string) LOVApiGetRoomPoolRoomTypesLOVRequest {
	return LOVApiGetRoomPoolRoomTypesLOVRequest{
		ApiService: a,
		ctx: ctx,
		roomPool: roomPool,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRoomPoolRoomTypesLOVExecute(r LOVApiGetRoomPoolRoomTypesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRoomPoolRoomTypesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/roomPool/{roomPool}/roomPoolRoomTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"roomPool"+"}", url.PathEscape(parameterValueToString(r.roomPool, "roomPool")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.roomPool) < 1 {
		return localVarReturnValue, nil, reportError("roomPool must have at least 1 elements")
	}
	if strlen(r.roomPool) > 2000 {
		return localVarReturnValue, nil, reportError("roomPool must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetRoomPoolsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetRoomPoolsLOVRequest) Authorization(authorization string) LOVApiGetRoomPoolsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetRoomPoolsLOVRequest) XAppKey(xAppKey string) LOVApiGetRoomPoolsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetRoomPoolsLOVRequest) XHotelid(xHotelid string) LOVApiGetRoomPoolsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetRoomPoolsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetRoomPoolsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetRoomPoolsLOVRequest) ParameterName(parameterName []string) LOVApiGetRoomPoolsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetRoomPoolsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetRoomPoolsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetRoomPoolsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetRoomPoolsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetRoomPoolsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetRoomPoolsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetRoomPoolsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetRoomPoolsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetRoomPoolsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRoomPoolsLOVExecute(r)
}

/*
GetRoomPoolsLOV Fetch List Of Values for Room Pools

 <p><strong>OperationId:</strong>getRoomPoolsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RoomPools LOV
 @return LOVApiGetRoomPoolsLOVRequest
*/
func (a *LOVApiService) GetRoomPoolsLOV(ctx context.Context, hotelId string) LOVApiGetRoomPoolsLOVRequest {
	return LOVApiGetRoomPoolsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRoomPoolsLOVExecute(r LOVApiGetRoomPoolsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRoomPoolsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/roomPools"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetRoomRatesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	room string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetRoomRatesLOVRequest) Authorization(authorization string) LOVApiGetRoomRatesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetRoomRatesLOVRequest) XAppKey(xAppKey string) LOVApiGetRoomRatesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetRoomRatesLOVRequest) XHotelid(xHotelid string) LOVApiGetRoomRatesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetRoomRatesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetRoomRatesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetRoomRatesLOVRequest) ParameterName(parameterName []string) LOVApiGetRoomRatesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetRoomRatesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetRoomRatesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetRoomRatesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetRoomRatesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetRoomRatesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetRoomRatesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetRoomRatesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetRoomRatesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetRoomRatesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRoomRatesLOVExecute(r)
}

/*
GetRoomRatesLOV Fetch List Of Values for Room Rates

 <p><strong>OperationId:</strong>getRoomRatesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param room Value of the parameter 'room' which is required to fetch RoomRates LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RoomRates LOV
 @return LOVApiGetRoomRatesLOVRequest
*/
func (a *LOVApiService) GetRoomRatesLOV(ctx context.Context, room string, hotelId string) LOVApiGetRoomRatesLOVRequest {
	return LOVApiGetRoomRatesLOVRequest{
		ApiService: a,
		ctx: ctx,
		room: room,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRoomRatesLOVExecute(r LOVApiGetRoomRatesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRoomRatesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/room/{room}/roomRates"
	localVarPath = strings.Replace(localVarPath, "{"+"room"+"}", url.PathEscape(parameterValueToString(r.room, "room")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.room) < 1 {
		return localVarReturnValue, nil, reportError("room must have at least 1 elements")
	}
	if strlen(r.room) > 2000 {
		return localVarReturnValue, nil, reportError("room must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetRoomReservationStatusLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	includeDayUse string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetRoomReservationStatusLOVRequest) Authorization(authorization string) LOVApiGetRoomReservationStatusLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetRoomReservationStatusLOVRequest) XAppKey(xAppKey string) LOVApiGetRoomReservationStatusLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetRoomReservationStatusLOVRequest) XHotelid(xHotelid string) LOVApiGetRoomReservationStatusLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetRoomReservationStatusLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetRoomReservationStatusLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetRoomReservationStatusLOVRequest) ParameterName(parameterName []string) LOVApiGetRoomReservationStatusLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetRoomReservationStatusLOVRequest) ParameterValue(parameterValue []string) LOVApiGetRoomReservationStatusLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetRoomReservationStatusLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetRoomReservationStatusLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetRoomReservationStatusLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetRoomReservationStatusLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetRoomReservationStatusLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetRoomReservationStatusLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetRoomReservationStatusLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRoomReservationStatusLOVExecute(r)
}

/*
GetRoomReservationStatusLOV Fetch List Of Values for Room Reservation Status

 <p><strong>OperationId:</strong>getRoomReservationStatusLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param includeDayUse Value of the parameter 'includeDayUse' which is required to fetch RoomReservationStatus LOV
 @return LOVApiGetRoomReservationStatusLOVRequest
*/
func (a *LOVApiService) GetRoomReservationStatusLOV(ctx context.Context, includeDayUse string) LOVApiGetRoomReservationStatusLOVRequest {
	return LOVApiGetRoomReservationStatusLOVRequest{
		ApiService: a,
		ctx: ctx,
		includeDayUse: includeDayUse,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRoomReservationStatusLOVExecute(r LOVApiGetRoomReservationStatusLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRoomReservationStatusLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/includeDayUse/{includeDayUse}/roomReservationStatus"
	localVarPath = strings.Replace(localVarPath, "{"+"includeDayUse"+"}", url.PathEscape(parameterValueToString(r.includeDayUse, "includeDayUse")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.includeDayUse) < 1 {
		return localVarReturnValue, nil, reportError("includeDayUse must have at least 1 elements")
	}
	if strlen(r.includeDayUse) > 2000 {
		return localVarReturnValue, nil, reportError("includeDayUse must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetRoomRevenueTrxCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetRoomRevenueTrxCodesLOVRequest) Authorization(authorization string) LOVApiGetRoomRevenueTrxCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetRoomRevenueTrxCodesLOVRequest) XAppKey(xAppKey string) LOVApiGetRoomRevenueTrxCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetRoomRevenueTrxCodesLOVRequest) XHotelid(xHotelid string) LOVApiGetRoomRevenueTrxCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetRoomRevenueTrxCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetRoomRevenueTrxCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetRoomRevenueTrxCodesLOVRequest) ParameterName(parameterName []string) LOVApiGetRoomRevenueTrxCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetRoomRevenueTrxCodesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetRoomRevenueTrxCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetRoomRevenueTrxCodesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetRoomRevenueTrxCodesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetRoomRevenueTrxCodesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetRoomRevenueTrxCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetRoomRevenueTrxCodesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetRoomRevenueTrxCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetRoomRevenueTrxCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRoomRevenueTrxCodesLOVExecute(r)
}

/*
GetRoomRevenueTrxCodesLOV Fetch List Of Values for Room Revenue Trx Codes

 <p><strong>OperationId:</strong>getRoomRevenueTrxCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RoomRevenueTrxCodes LOV
 @return LOVApiGetRoomRevenueTrxCodesLOVRequest
*/
func (a *LOVApiService) GetRoomRevenueTrxCodesLOV(ctx context.Context, hotelId string) LOVApiGetRoomRevenueTrxCodesLOVRequest {
	return LOVApiGetRoomRevenueTrxCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRoomRevenueTrxCodesLOVExecute(r LOVApiGetRoomRevenueTrxCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRoomRevenueTrxCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/roomRevenueTrxCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetRoomRotationGroupsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetRoomRotationGroupsLOVRequest) Authorization(authorization string) LOVApiGetRoomRotationGroupsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetRoomRotationGroupsLOVRequest) XAppKey(xAppKey string) LOVApiGetRoomRotationGroupsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetRoomRotationGroupsLOVRequest) XHotelid(xHotelid string) LOVApiGetRoomRotationGroupsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetRoomRotationGroupsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetRoomRotationGroupsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetRoomRotationGroupsLOVRequest) ParameterName(parameterName []string) LOVApiGetRoomRotationGroupsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetRoomRotationGroupsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetRoomRotationGroupsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetRoomRotationGroupsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetRoomRotationGroupsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetRoomRotationGroupsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetRoomRotationGroupsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetRoomRotationGroupsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetRoomRotationGroupsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetRoomRotationGroupsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRoomRotationGroupsLOVExecute(r)
}

/*
GetRoomRotationGroupsLOV Fetch List Of Values for Room Rotation Groups

 <p><strong>OperationId:</strong>getRoomRotationGroupsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RoomRotationGroups LOV
 @return LOVApiGetRoomRotationGroupsLOVRequest
*/
func (a *LOVApiService) GetRoomRotationGroupsLOV(ctx context.Context, hotelId string) LOVApiGetRoomRotationGroupsLOVRequest {
	return LOVApiGetRoomRotationGroupsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRoomRotationGroupsLOVExecute(r LOVApiGetRoomRotationGroupsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRoomRotationGroupsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/roomRotationGroups"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetRoomRotationUnitGradesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetRoomRotationUnitGradesLOVRequest) Authorization(authorization string) LOVApiGetRoomRotationUnitGradesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetRoomRotationUnitGradesLOVRequest) XAppKey(xAppKey string) LOVApiGetRoomRotationUnitGradesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetRoomRotationUnitGradesLOVRequest) XHotelid(xHotelid string) LOVApiGetRoomRotationUnitGradesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetRoomRotationUnitGradesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetRoomRotationUnitGradesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetRoomRotationUnitGradesLOVRequest) ParameterName(parameterName []string) LOVApiGetRoomRotationUnitGradesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetRoomRotationUnitGradesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetRoomRotationUnitGradesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetRoomRotationUnitGradesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetRoomRotationUnitGradesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetRoomRotationUnitGradesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetRoomRotationUnitGradesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetRoomRotationUnitGradesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetRoomRotationUnitGradesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetRoomRotationUnitGradesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRoomRotationUnitGradesLOVExecute(r)
}

/*
GetRoomRotationUnitGradesLOV Fetch List Of Values for Room Rotation Unit Grades

 <p><strong>OperationId:</strong>getRoomRotationUnitGradesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RoomRotationUnitGrades LOV
 @return LOVApiGetRoomRotationUnitGradesLOVRequest
*/
func (a *LOVApiService) GetRoomRotationUnitGradesLOV(ctx context.Context, hotelId string) LOVApiGetRoomRotationUnitGradesLOVRequest {
	return LOVApiGetRoomRotationUnitGradesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRoomRotationUnitGradesLOVExecute(r LOVApiGetRoomRotationUnitGradesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRoomRotationUnitGradesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/roomRotationUnitGrades"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetRoomSpecialsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetRoomSpecialsLOVRequest) Authorization(authorization string) LOVApiGetRoomSpecialsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetRoomSpecialsLOVRequest) XAppKey(xAppKey string) LOVApiGetRoomSpecialsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetRoomSpecialsLOVRequest) XHotelid(xHotelid string) LOVApiGetRoomSpecialsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetRoomSpecialsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetRoomSpecialsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetRoomSpecialsLOVRequest) ParameterName(parameterName []string) LOVApiGetRoomSpecialsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetRoomSpecialsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetRoomSpecialsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetRoomSpecialsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetRoomSpecialsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetRoomSpecialsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetRoomSpecialsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetRoomSpecialsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetRoomSpecialsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetRoomSpecialsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRoomSpecialsLOVExecute(r)
}

/*
GetRoomSpecialsLOV Fetch List Of Values for Room Specials

 <p><strong>OperationId:</strong>getRoomSpecialsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RoomSpecials LOV
 @return LOVApiGetRoomSpecialsLOVRequest
*/
func (a *LOVApiService) GetRoomSpecialsLOV(ctx context.Context, hotelId string) LOVApiGetRoomSpecialsLOVRequest {
	return LOVApiGetRoomSpecialsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRoomSpecialsLOVExecute(r LOVApiGetRoomSpecialsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRoomSpecialsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/roomSpecials"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetRoomTypePoolLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetRoomTypePoolLOVRequest) Authorization(authorization string) LOVApiGetRoomTypePoolLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetRoomTypePoolLOVRequest) XAppKey(xAppKey string) LOVApiGetRoomTypePoolLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetRoomTypePoolLOVRequest) XHotelid(xHotelid string) LOVApiGetRoomTypePoolLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetRoomTypePoolLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetRoomTypePoolLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetRoomTypePoolLOVRequest) ParameterName(parameterName []string) LOVApiGetRoomTypePoolLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetRoomTypePoolLOVRequest) ParameterValue(parameterValue []string) LOVApiGetRoomTypePoolLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetRoomTypePoolLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetRoomTypePoolLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetRoomTypePoolLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetRoomTypePoolLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetRoomTypePoolLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetRoomTypePoolLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetRoomTypePoolLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRoomTypePoolLOVExecute(r)
}

/*
GetRoomTypePoolLOV Fetch List Of Values for Room Type Pool

 <p><strong>OperationId:</strong>getRoomTypePoolLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RoomTypePool LOV
 @return LOVApiGetRoomTypePoolLOVRequest
*/
func (a *LOVApiService) GetRoomTypePoolLOV(ctx context.Context, hotelId string) LOVApiGetRoomTypePoolLOVRequest {
	return LOVApiGetRoomTypePoolLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRoomTypePoolLOVExecute(r LOVApiGetRoomTypePoolLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRoomTypePoolLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/roomTypePool"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetRoomTypesForMassRateLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	ratePlanCodes string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetRoomTypesForMassRateLOVRequest) Authorization(authorization string) LOVApiGetRoomTypesForMassRateLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetRoomTypesForMassRateLOVRequest) XAppKey(xAppKey string) LOVApiGetRoomTypesForMassRateLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetRoomTypesForMassRateLOVRequest) XHotelid(xHotelid string) LOVApiGetRoomTypesForMassRateLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetRoomTypesForMassRateLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetRoomTypesForMassRateLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetRoomTypesForMassRateLOVRequest) ParameterName(parameterName []string) LOVApiGetRoomTypesForMassRateLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetRoomTypesForMassRateLOVRequest) ParameterValue(parameterValue []string) LOVApiGetRoomTypesForMassRateLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetRoomTypesForMassRateLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetRoomTypesForMassRateLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetRoomTypesForMassRateLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetRoomTypesForMassRateLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetRoomTypesForMassRateLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetRoomTypesForMassRateLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetRoomTypesForMassRateLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRoomTypesForMassRateLOVExecute(r)
}

/*
GetRoomTypesForMassRateLOV Fetch List Of Values for Room Types For Mass Rate

 <p><strong>OperationId:</strong>getRoomTypesForMassRateLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param ratePlanCodes Value of the parameter 'ratePlanCodes' which is required to fetch RoomTypesForMassRate LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RoomTypesForMassRate LOV
 @return LOVApiGetRoomTypesForMassRateLOVRequest
*/
func (a *LOVApiService) GetRoomTypesForMassRateLOV(ctx context.Context, ratePlanCodes string, hotelId string) LOVApiGetRoomTypesForMassRateLOVRequest {
	return LOVApiGetRoomTypesForMassRateLOVRequest{
		ApiService: a,
		ctx: ctx,
		ratePlanCodes: ratePlanCodes,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRoomTypesForMassRateLOVExecute(r LOVApiGetRoomTypesForMassRateLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRoomTypesForMassRateLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/ratePlanCodes/{ratePlanCodes}/roomTypesForMassRate"
	localVarPath = strings.Replace(localVarPath, "{"+"ratePlanCodes"+"}", url.PathEscape(parameterValueToString(r.ratePlanCodes, "ratePlanCodes")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.ratePlanCodes) < 1 {
		return localVarReturnValue, nil, reportError("ratePlanCodes must have at least 1 elements")
	}
	if strlen(r.ratePlanCodes) > 2000 {
		return localVarReturnValue, nil, reportError("ratePlanCodes must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetRoomTypesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetRoomTypesLOVRequest) Authorization(authorization string) LOVApiGetRoomTypesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetRoomTypesLOVRequest) XAppKey(xAppKey string) LOVApiGetRoomTypesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetRoomTypesLOVRequest) XHotelid(xHotelid string) LOVApiGetRoomTypesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetRoomTypesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetRoomTypesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetRoomTypesLOVRequest) ParameterName(parameterName []string) LOVApiGetRoomTypesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetRoomTypesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetRoomTypesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetRoomTypesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetRoomTypesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetRoomTypesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetRoomTypesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetRoomTypesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetRoomTypesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetRoomTypesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRoomTypesLOVExecute(r)
}

/*
GetRoomTypesLOV Fetch List Of Values for Room Types

 <p><strong>OperationId:</strong>getRoomTypesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RoomTypes LOV
 @return LOVApiGetRoomTypesLOVRequest
*/
func (a *LOVApiService) GetRoomTypesLOV(ctx context.Context, hotelId string) LOVApiGetRoomTypesLOVRequest {
	return LOVApiGetRoomTypesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRoomTypesLOVExecute(r LOVApiGetRoomTypesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRoomTypesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/roomTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetRoomingListHKRoomsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	departure string
	arrival string
	roomType string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetRoomingListHKRoomsLOVRequest) Authorization(authorization string) LOVApiGetRoomingListHKRoomsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetRoomingListHKRoomsLOVRequest) XAppKey(xAppKey string) LOVApiGetRoomingListHKRoomsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetRoomingListHKRoomsLOVRequest) XHotelid(xHotelid string) LOVApiGetRoomingListHKRoomsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetRoomingListHKRoomsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetRoomingListHKRoomsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetRoomingListHKRoomsLOVRequest) ParameterName(parameterName []string) LOVApiGetRoomingListHKRoomsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetRoomingListHKRoomsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetRoomingListHKRoomsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetRoomingListHKRoomsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetRoomingListHKRoomsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetRoomingListHKRoomsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetRoomingListHKRoomsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetRoomingListHKRoomsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetRoomingListHKRoomsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetRoomingListHKRoomsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRoomingListHKRoomsLOVExecute(r)
}

/*
GetRoomingListHKRoomsLOV Fetch List Of Values for Rooming List HKRooms

 <p><strong>OperationId:</strong>getRoomingListHKRoomsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param departure Value of the parameter 'departure' which is required to fetch RoomingListHKRooms LOV
 @param arrival Value of the parameter 'arrival' which is required to fetch RoomingListHKRooms LOV
 @param roomType Value of the parameter 'roomType' which is required to fetch RoomingListHKRooms LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RoomingListHKRooms LOV
 @return LOVApiGetRoomingListHKRoomsLOVRequest
*/
func (a *LOVApiService) GetRoomingListHKRoomsLOV(ctx context.Context, departure string, arrival string, roomType string, hotelId string) LOVApiGetRoomingListHKRoomsLOVRequest {
	return LOVApiGetRoomingListHKRoomsLOVRequest{
		ApiService: a,
		ctx: ctx,
		departure: departure,
		arrival: arrival,
		roomType: roomType,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRoomingListHKRoomsLOVExecute(r LOVApiGetRoomingListHKRoomsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRoomingListHKRoomsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/roomType/{roomType}/arrival/{arrival}/departure/{departure}/roomingListHKRooms"
	localVarPath = strings.Replace(localVarPath, "{"+"departure"+"}", url.PathEscape(parameterValueToString(r.departure, "departure")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"arrival"+"}", url.PathEscape(parameterValueToString(r.arrival, "arrival")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"roomType"+"}", url.PathEscape(parameterValueToString(r.roomType, "roomType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.departure) < 1 {
		return localVarReturnValue, nil, reportError("departure must have at least 1 elements")
	}
	if strlen(r.departure) > 2000 {
		return localVarReturnValue, nil, reportError("departure must have less than 2000 elements")
	}
	if strlen(r.arrival) < 1 {
		return localVarReturnValue, nil, reportError("arrival must have at least 1 elements")
	}
	if strlen(r.arrival) > 2000 {
		return localVarReturnValue, nil, reportError("arrival must have less than 2000 elements")
	}
	if strlen(r.roomType) < 1 {
		return localVarReturnValue, nil, reportError("roomType must have at least 1 elements")
	}
	if strlen(r.roomType) > 2000 {
		return localVarReturnValue, nil, reportError("roomType must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetRoomsKeyGenerationLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetRoomsKeyGenerationLOVRequest) Authorization(authorization string) LOVApiGetRoomsKeyGenerationLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetRoomsKeyGenerationLOVRequest) XAppKey(xAppKey string) LOVApiGetRoomsKeyGenerationLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetRoomsKeyGenerationLOVRequest) XHotelid(xHotelid string) LOVApiGetRoomsKeyGenerationLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetRoomsKeyGenerationLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetRoomsKeyGenerationLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetRoomsKeyGenerationLOVRequest) ParameterName(parameterName []string) LOVApiGetRoomsKeyGenerationLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetRoomsKeyGenerationLOVRequest) ParameterValue(parameterValue []string) LOVApiGetRoomsKeyGenerationLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetRoomsKeyGenerationLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetRoomsKeyGenerationLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetRoomsKeyGenerationLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetRoomsKeyGenerationLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetRoomsKeyGenerationLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetRoomsKeyGenerationLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetRoomsKeyGenerationLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRoomsKeyGenerationLOVExecute(r)
}

/*
GetRoomsKeyGenerationLOV Fetch List Of Values for Rooms Key Generation

 <p><strong>OperationId:</strong>getRoomsKeyGenerationLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RoomsKeyGeneration LOV
 @return LOVApiGetRoomsKeyGenerationLOVRequest
*/
func (a *LOVApiService) GetRoomsKeyGenerationLOV(ctx context.Context, hotelId string) LOVApiGetRoomsKeyGenerationLOVRequest {
	return LOVApiGetRoomsKeyGenerationLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRoomsKeyGenerationLOVExecute(r LOVApiGetRoomsKeyGenerationLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRoomsKeyGenerationLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/roomsKeyGeneration"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetRoomsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetRoomsLOVRequest) Authorization(authorization string) LOVApiGetRoomsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetRoomsLOVRequest) XAppKey(xAppKey string) LOVApiGetRoomsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetRoomsLOVRequest) XHotelid(xHotelid string) LOVApiGetRoomsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetRoomsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetRoomsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetRoomsLOVRequest) ParameterName(parameterName []string) LOVApiGetRoomsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetRoomsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetRoomsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetRoomsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetRoomsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetRoomsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetRoomsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetRoomsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetRoomsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetRoomsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRoomsLOVExecute(r)
}

/*
GetRoomsLOV Fetch List Of Values for Rooms

 <p><strong>OperationId:</strong>getRoomsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch Rooms LOV
 @return LOVApiGetRoomsLOVRequest
*/
func (a *LOVApiService) GetRoomsLOV(ctx context.Context, hotelId string) LOVApiGetRoomsLOVRequest {
	return LOVApiGetRoomsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRoomsLOVExecute(r LOVApiGetRoomsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRoomsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/rooms"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetRoutingInstructionsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetRoutingInstructionsLOVRequest) Authorization(authorization string) LOVApiGetRoutingInstructionsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetRoutingInstructionsLOVRequest) XAppKey(xAppKey string) LOVApiGetRoutingInstructionsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetRoutingInstructionsLOVRequest) XHotelid(xHotelid string) LOVApiGetRoutingInstructionsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetRoutingInstructionsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetRoutingInstructionsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetRoutingInstructionsLOVRequest) ParameterName(parameterName []string) LOVApiGetRoutingInstructionsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetRoutingInstructionsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetRoutingInstructionsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetRoutingInstructionsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetRoutingInstructionsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetRoutingInstructionsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetRoutingInstructionsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetRoutingInstructionsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetRoutingInstructionsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetRoutingInstructionsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetRoutingInstructionsLOVExecute(r)
}

/*
GetRoutingInstructionsLOV Fetch List Of Values for Routing Instructions

 <p><strong>OperationId:</strong>getRoutingInstructionsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch RoutingInstructions LOV
 @return LOVApiGetRoutingInstructionsLOVRequest
*/
func (a *LOVApiService) GetRoutingInstructionsLOV(ctx context.Context, hotelId string) LOVApiGetRoutingInstructionsLOVRequest {
	return LOVApiGetRoutingInstructionsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetRoutingInstructionsLOVExecute(r LOVApiGetRoutingInstructionsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetRoutingInstructionsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/routingInstructions"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetSalesManagerGoalPeriodLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetSalesManagerGoalPeriodLOVRequest) Authorization(authorization string) LOVApiGetSalesManagerGoalPeriodLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetSalesManagerGoalPeriodLOVRequest) XAppKey(xAppKey string) LOVApiGetSalesManagerGoalPeriodLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetSalesManagerGoalPeriodLOVRequest) XHotelid(xHotelid string) LOVApiGetSalesManagerGoalPeriodLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetSalesManagerGoalPeriodLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetSalesManagerGoalPeriodLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetSalesManagerGoalPeriodLOVRequest) ParameterName(parameterName []string) LOVApiGetSalesManagerGoalPeriodLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetSalesManagerGoalPeriodLOVRequest) ParameterValue(parameterValue []string) LOVApiGetSalesManagerGoalPeriodLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetSalesManagerGoalPeriodLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetSalesManagerGoalPeriodLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetSalesManagerGoalPeriodLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetSalesManagerGoalPeriodLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetSalesManagerGoalPeriodLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetSalesManagerGoalPeriodLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetSalesManagerGoalPeriodLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetSalesManagerGoalPeriodLOVExecute(r)
}

/*
GetSalesManagerGoalPeriodLOV Fetch List Of Values for Sales Manager Goal Period

 <p><strong>OperationId:</strong>getSalesManagerGoalPeriodLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch SalesManagerGoalPeriod LOV
 @return LOVApiGetSalesManagerGoalPeriodLOVRequest
*/
func (a *LOVApiService) GetSalesManagerGoalPeriodLOV(ctx context.Context, hotelId string) LOVApiGetSalesManagerGoalPeriodLOVRequest {
	return LOVApiGetSalesManagerGoalPeriodLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetSalesManagerGoalPeriodLOVExecute(r LOVApiGetSalesManagerGoalPeriodLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetSalesManagerGoalPeriodLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/salesManagerGoalPeriod"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetScheduledReportsExportLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetScheduledReportsExportLOVRequest) Authorization(authorization string) LOVApiGetScheduledReportsExportLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetScheduledReportsExportLOVRequest) XAppKey(xAppKey string) LOVApiGetScheduledReportsExportLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetScheduledReportsExportLOVRequest) XHotelid(xHotelid string) LOVApiGetScheduledReportsExportLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetScheduledReportsExportLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetScheduledReportsExportLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetScheduledReportsExportLOVRequest) ParameterName(parameterName []string) LOVApiGetScheduledReportsExportLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetScheduledReportsExportLOVRequest) ParameterValue(parameterValue []string) LOVApiGetScheduledReportsExportLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetScheduledReportsExportLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetScheduledReportsExportLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetScheduledReportsExportLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetScheduledReportsExportLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetScheduledReportsExportLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetScheduledReportsExportLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetScheduledReportsExportLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetScheduledReportsExportLOVExecute(r)
}

/*
GetScheduledReportsExportLOV Fetch List Of Values for Scheduled Reports Export

 <p><strong>OperationId:</strong>getScheduledReportsExportLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ScheduledReportsExport LOV
 @return LOVApiGetScheduledReportsExportLOVRequest
*/
func (a *LOVApiService) GetScheduledReportsExportLOV(ctx context.Context, hotelId string) LOVApiGetScheduledReportsExportLOVRequest {
	return LOVApiGetScheduledReportsExportLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetScheduledReportsExportLOVExecute(r LOVApiGetScheduledReportsExportLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetScheduledReportsExportLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/scheduledReportsExport"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetScreenCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	screenArea string
	screenType string
	chainCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetScreenCodesLOVRequest) Authorization(authorization string) LOVApiGetScreenCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetScreenCodesLOVRequest) XAppKey(xAppKey string) LOVApiGetScreenCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetScreenCodesLOVRequest) XHotelid(xHotelid string) LOVApiGetScreenCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetScreenCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetScreenCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetScreenCodesLOVRequest) ParameterName(parameterName []string) LOVApiGetScreenCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetScreenCodesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetScreenCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetScreenCodesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetScreenCodesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetScreenCodesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetScreenCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetScreenCodesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetScreenCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetScreenCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetScreenCodesLOVExecute(r)
}

/*
GetScreenCodesLOV Fetch List Of Values for Screen Codes

 <p><strong>OperationId:</strong>getScreenCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param screenArea Value of the parameter 'screenArea' which is required to fetch ScreenCodes LOV
 @param screenType Value of the parameter 'screenType' which is required to fetch ScreenCodes LOV
 @param chainCode Value of the parameter 'chainCode' which is required to fetch ScreenCodes LOV
 @return LOVApiGetScreenCodesLOVRequest
*/
func (a *LOVApiService) GetScreenCodesLOV(ctx context.Context, screenArea string, screenType string, chainCode string) LOVApiGetScreenCodesLOVRequest {
	return LOVApiGetScreenCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		screenArea: screenArea,
		screenType: screenType,
		chainCode: chainCode,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetScreenCodesLOVExecute(r LOVApiGetScreenCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetScreenCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/chainCode/{chainCode}/screenType/{screenType}/screenArea/{screenArea}/screenCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"screenArea"+"}", url.PathEscape(parameterValueToString(r.screenArea, "screenArea")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"screenType"+"}", url.PathEscape(parameterValueToString(r.screenType, "screenType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"chainCode"+"}", url.PathEscape(parameterValueToString(r.chainCode, "chainCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.screenArea) < 1 {
		return localVarReturnValue, nil, reportError("screenArea must have at least 1 elements")
	}
	if strlen(r.screenArea) > 2000 {
		return localVarReturnValue, nil, reportError("screenArea must have less than 2000 elements")
	}
	if strlen(r.screenType) < 1 {
		return localVarReturnValue, nil, reportError("screenType must have at least 1 elements")
	}
	if strlen(r.screenType) > 2000 {
		return localVarReturnValue, nil, reportError("screenType must have less than 2000 elements")
	}
	if strlen(r.chainCode) < 1 {
		return localVarReturnValue, nil, reportError("chainCode must have at least 1 elements")
	}
	if strlen(r.chainCode) > 2000 {
		return localVarReturnValue, nil, reportError("chainCode must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetScreenStyleCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	screenCode string
	chainCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetScreenStyleCodesLOVRequest) Authorization(authorization string) LOVApiGetScreenStyleCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetScreenStyleCodesLOVRequest) XAppKey(xAppKey string) LOVApiGetScreenStyleCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetScreenStyleCodesLOVRequest) XHotelid(xHotelid string) LOVApiGetScreenStyleCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetScreenStyleCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetScreenStyleCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetScreenStyleCodesLOVRequest) ParameterName(parameterName []string) LOVApiGetScreenStyleCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetScreenStyleCodesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetScreenStyleCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetScreenStyleCodesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetScreenStyleCodesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetScreenStyleCodesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetScreenStyleCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetScreenStyleCodesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetScreenStyleCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetScreenStyleCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetScreenStyleCodesLOVExecute(r)
}

/*
GetScreenStyleCodesLOV Fetch List Of Values for Screen Style Codes

 <p><strong>OperationId:</strong>getScreenStyleCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param screenCode Value of the parameter 'screenCode' which is required to fetch ScreenStyleCodes LOV
 @param chainCode Value of the parameter 'chainCode' which is required to fetch ScreenStyleCodes LOV
 @return LOVApiGetScreenStyleCodesLOVRequest
*/
func (a *LOVApiService) GetScreenStyleCodesLOV(ctx context.Context, screenCode string, chainCode string) LOVApiGetScreenStyleCodesLOVRequest {
	return LOVApiGetScreenStyleCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		screenCode: screenCode,
		chainCode: chainCode,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetScreenStyleCodesLOVExecute(r LOVApiGetScreenStyleCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetScreenStyleCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/chainCode/{chainCode}/screenCode/{screenCode}/screenStyleCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"screenCode"+"}", url.PathEscape(parameterValueToString(r.screenCode, "screenCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"chainCode"+"}", url.PathEscape(parameterValueToString(r.chainCode, "chainCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.screenCode) < 1 {
		return localVarReturnValue, nil, reportError("screenCode must have at least 1 elements")
	}
	if strlen(r.screenCode) > 2000 {
		return localVarReturnValue, nil, reportError("screenCode must have less than 2000 elements")
	}
	if strlen(r.chainCode) < 1 {
		return localVarReturnValue, nil, reportError("chainCode must have at least 1 elements")
	}
	if strlen(r.chainCode) > 2000 {
		return localVarReturnValue, nil, reportError("chainCode must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetServiceNameLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	protocol string
	outboundType string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetServiceNameLOVRequest) Authorization(authorization string) LOVApiGetServiceNameLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetServiceNameLOVRequest) XAppKey(xAppKey string) LOVApiGetServiceNameLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetServiceNameLOVRequest) XHotelid(xHotelid string) LOVApiGetServiceNameLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetServiceNameLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetServiceNameLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetServiceNameLOVRequest) ParameterName(parameterName []string) LOVApiGetServiceNameLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetServiceNameLOVRequest) ParameterValue(parameterValue []string) LOVApiGetServiceNameLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetServiceNameLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetServiceNameLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetServiceNameLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetServiceNameLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetServiceNameLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetServiceNameLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetServiceNameLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetServiceNameLOVExecute(r)
}

/*
GetServiceNameLOV Fetch List Of Values for Service Name

 <p><strong>OperationId:</strong>getServiceNameLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param protocol Value of the parameter 'protocol' which is required to fetch ServiceName LOV
 @param outboundType Value of the parameter 'outboundType' which is required to fetch ServiceName LOV
 @return LOVApiGetServiceNameLOVRequest
*/
func (a *LOVApiService) GetServiceNameLOV(ctx context.Context, protocol string, outboundType string) LOVApiGetServiceNameLOVRequest {
	return LOVApiGetServiceNameLOVRequest{
		ApiService: a,
		ctx: ctx,
		protocol: protocol,
		outboundType: outboundType,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetServiceNameLOVExecute(r LOVApiGetServiceNameLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetServiceNameLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/outboundType/{outboundType}/protocol/{protocol}/outboundServiceNames"
	localVarPath = strings.Replace(localVarPath, "{"+"protocol"+"}", url.PathEscape(parameterValueToString(r.protocol, "protocol")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"outboundType"+"}", url.PathEscape(parameterValueToString(r.outboundType, "outboundType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.protocol) < 1 {
		return localVarReturnValue, nil, reportError("protocol must have at least 1 elements")
	}
	if strlen(r.protocol) > 2000 {
		return localVarReturnValue, nil, reportError("protocol must have less than 2000 elements")
	}
	if strlen(r.outboundType) < 1 {
		return localVarReturnValue, nil, reportError("outboundType must have at least 1 elements")
	}
	if strlen(r.outboundType) > 2000 {
		return localVarReturnValue, nil, reportError("outboundType must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetServiceRequestCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetServiceRequestCodesLOVRequest) Authorization(authorization string) LOVApiGetServiceRequestCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetServiceRequestCodesLOVRequest) XAppKey(xAppKey string) LOVApiGetServiceRequestCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetServiceRequestCodesLOVRequest) XHotelid(xHotelid string) LOVApiGetServiceRequestCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetServiceRequestCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetServiceRequestCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetServiceRequestCodesLOVRequest) ParameterName(parameterName []string) LOVApiGetServiceRequestCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetServiceRequestCodesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetServiceRequestCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetServiceRequestCodesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetServiceRequestCodesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetServiceRequestCodesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetServiceRequestCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetServiceRequestCodesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetServiceRequestCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetServiceRequestCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetServiceRequestCodesLOVExecute(r)
}

/*
GetServiceRequestCodesLOV Fetch List Of Values for Service Request Codes

 <p><strong>OperationId:</strong>getServiceRequestCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ServiceRequestCodes LOV
 @return LOVApiGetServiceRequestCodesLOVRequest
*/
func (a *LOVApiService) GetServiceRequestCodesLOV(ctx context.Context, hotelId string) LOVApiGetServiceRequestCodesLOVRequest {
	return LOVApiGetServiceRequestCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetServiceRequestCodesLOVExecute(r LOVApiGetServiceRequestCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetServiceRequestCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/serviceRequestCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetSetupStylesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetSetupStylesLOVRequest) Authorization(authorization string) LOVApiGetSetupStylesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetSetupStylesLOVRequest) XAppKey(xAppKey string) LOVApiGetSetupStylesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetSetupStylesLOVRequest) XHotelid(xHotelid string) LOVApiGetSetupStylesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetSetupStylesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetSetupStylesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetSetupStylesLOVRequest) ParameterName(parameterName []string) LOVApiGetSetupStylesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetSetupStylesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetSetupStylesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetSetupStylesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetSetupStylesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetSetupStylesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetSetupStylesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetSetupStylesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetSetupStylesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetSetupStylesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetSetupStylesLOVExecute(r)
}

/*
GetSetupStylesLOV Fetch List Of Values for Setup Styles

 <p><strong>OperationId:</strong>getSetupStylesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch SetupStyles LOV
 @return LOVApiGetSetupStylesLOVRequest
*/
func (a *LOVApiService) GetSetupStylesLOV(ctx context.Context, hotelId string) LOVApiGetSetupStylesLOVRequest {
	return LOVApiGetSetupStylesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetSetupStylesLOVExecute(r LOVApiGetSetupStylesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetSetupStylesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/setupStyles"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetShiftReportsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetShiftReportsLOVRequest) Authorization(authorization string) LOVApiGetShiftReportsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetShiftReportsLOVRequest) XAppKey(xAppKey string) LOVApiGetShiftReportsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetShiftReportsLOVRequest) XHotelid(xHotelid string) LOVApiGetShiftReportsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetShiftReportsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetShiftReportsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetShiftReportsLOVRequest) ParameterName(parameterName []string) LOVApiGetShiftReportsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetShiftReportsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetShiftReportsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetShiftReportsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetShiftReportsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetShiftReportsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetShiftReportsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetShiftReportsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetShiftReportsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetShiftReportsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetShiftReportsLOVExecute(r)
}

/*
GetShiftReportsLOV Fetch List Of Values for Shift Reports

 <p><strong>OperationId:</strong>getShiftReportsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch ShiftReports LOV
 @return LOVApiGetShiftReportsLOVRequest
*/
func (a *LOVApiService) GetShiftReportsLOV(ctx context.Context, hotelId string) LOVApiGetShiftReportsLOVRequest {
	return LOVApiGetShiftReportsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetShiftReportsLOVExecute(r LOVApiGetShiftReportsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetShiftReportsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/shiftReports"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetShiftReportsNoParamLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	shiftGroupId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetShiftReportsNoParamLOVRequest) Authorization(authorization string) LOVApiGetShiftReportsNoParamLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetShiftReportsNoParamLOVRequest) XAppKey(xAppKey string) LOVApiGetShiftReportsNoParamLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetShiftReportsNoParamLOVRequest) XHotelid(xHotelid string) LOVApiGetShiftReportsNoParamLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetShiftReportsNoParamLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetShiftReportsNoParamLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetShiftReportsNoParamLOVRequest) ParameterName(parameterName []string) LOVApiGetShiftReportsNoParamLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetShiftReportsNoParamLOVRequest) ParameterValue(parameterValue []string) LOVApiGetShiftReportsNoParamLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetShiftReportsNoParamLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetShiftReportsNoParamLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetShiftReportsNoParamLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetShiftReportsNoParamLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetShiftReportsNoParamLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetShiftReportsNoParamLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetShiftReportsNoParamLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetShiftReportsNoParamLOVExecute(r)
}

/*
GetShiftReportsNoParamLOV Fetch List Of Values for Shift Reports No Param

 <p><strong>OperationId:</strong>getShiftReportsNoParamLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param shiftGroupId Value of the parameter 'shiftGroupId' which is required to fetch ShiftReportsNoParam LOV
 @return LOVApiGetShiftReportsNoParamLOVRequest
*/
func (a *LOVApiService) GetShiftReportsNoParamLOV(ctx context.Context, shiftGroupId string) LOVApiGetShiftReportsNoParamLOVRequest {
	return LOVApiGetShiftReportsNoParamLOVRequest{
		ApiService: a,
		ctx: ctx,
		shiftGroupId: shiftGroupId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetShiftReportsNoParamLOVExecute(r LOVApiGetShiftReportsNoParamLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetShiftReportsNoParamLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/shiftGroupId/{shiftGroupId}/shiftReportsNoParam"
	localVarPath = strings.Replace(localVarPath, "{"+"shiftGroupId"+"}", url.PathEscape(parameterValueToString(r.shiftGroupId, "shiftGroupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.shiftGroupId) < 1 {
		return localVarReturnValue, nil, reportError("shiftGroupId must have at least 1 elements")
	}
	if strlen(r.shiftGroupId) > 2000 {
		return localVarReturnValue, nil, reportError("shiftGroupId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetSitePlanSectionTypeLinksLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	sectionType string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetSitePlanSectionTypeLinksLOVRequest) Authorization(authorization string) LOVApiGetSitePlanSectionTypeLinksLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetSitePlanSectionTypeLinksLOVRequest) XAppKey(xAppKey string) LOVApiGetSitePlanSectionTypeLinksLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetSitePlanSectionTypeLinksLOVRequest) XHotelid(xHotelid string) LOVApiGetSitePlanSectionTypeLinksLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetSitePlanSectionTypeLinksLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetSitePlanSectionTypeLinksLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetSitePlanSectionTypeLinksLOVRequest) ParameterName(parameterName []string) LOVApiGetSitePlanSectionTypeLinksLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetSitePlanSectionTypeLinksLOVRequest) ParameterValue(parameterValue []string) LOVApiGetSitePlanSectionTypeLinksLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetSitePlanSectionTypeLinksLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetSitePlanSectionTypeLinksLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetSitePlanSectionTypeLinksLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetSitePlanSectionTypeLinksLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetSitePlanSectionTypeLinksLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetSitePlanSectionTypeLinksLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetSitePlanSectionTypeLinksLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetSitePlanSectionTypeLinksLOVExecute(r)
}

/*
GetSitePlanSectionTypeLinksLOV Fetch List Of Values for Site Plan Section Type Links

 <p><strong>OperationId:</strong>getSitePlanSectionTypeLinksLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sectionType Value of the parameter 'sectionType' which is required to fetch SitePlanSectionTypeLinks LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch SitePlanSectionTypeLinks LOV
 @return LOVApiGetSitePlanSectionTypeLinksLOVRequest
*/
func (a *LOVApiService) GetSitePlanSectionTypeLinksLOV(ctx context.Context, sectionType string, hotelId string) LOVApiGetSitePlanSectionTypeLinksLOVRequest {
	return LOVApiGetSitePlanSectionTypeLinksLOVRequest{
		ApiService: a,
		ctx: ctx,
		sectionType: sectionType,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetSitePlanSectionTypeLinksLOVExecute(r LOVApiGetSitePlanSectionTypeLinksLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetSitePlanSectionTypeLinksLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/sectionType/{sectionType}/sitePlanSectionTypeLinks"
	localVarPath = strings.Replace(localVarPath, "{"+"sectionType"+"}", url.PathEscape(parameterValueToString(r.sectionType, "sectionType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.sectionType) < 1 {
		return localVarReturnValue, nil, reportError("sectionType must have at least 1 elements")
	}
	if strlen(r.sectionType) > 2000 {
		return localVarReturnValue, nil, reportError("sectionType must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetSitePlanSectionTypesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	siteType string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetSitePlanSectionTypesLOVRequest) Authorization(authorization string) LOVApiGetSitePlanSectionTypesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetSitePlanSectionTypesLOVRequest) XAppKey(xAppKey string) LOVApiGetSitePlanSectionTypesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetSitePlanSectionTypesLOVRequest) XHotelid(xHotelid string) LOVApiGetSitePlanSectionTypesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetSitePlanSectionTypesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetSitePlanSectionTypesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetSitePlanSectionTypesLOVRequest) ParameterName(parameterName []string) LOVApiGetSitePlanSectionTypesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetSitePlanSectionTypesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetSitePlanSectionTypesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetSitePlanSectionTypesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetSitePlanSectionTypesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetSitePlanSectionTypesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetSitePlanSectionTypesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetSitePlanSectionTypesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetSitePlanSectionTypesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetSitePlanSectionTypesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetSitePlanSectionTypesLOVExecute(r)
}

/*
GetSitePlanSectionTypesLOV Fetch List Of Values for Site Plan Section Types

 <p><strong>OperationId:</strong>getSitePlanSectionTypesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteType Value of the parameter 'siteType' which is required to fetch SitePlanSectionTypes LOV
 @return LOVApiGetSitePlanSectionTypesLOVRequest
*/
func (a *LOVApiService) GetSitePlanSectionTypesLOV(ctx context.Context, siteType string) LOVApiGetSitePlanSectionTypesLOVRequest {
	return LOVApiGetSitePlanSectionTypesLOVRequest{
		ApiService: a,
		ctx: ctx,
		siteType: siteType,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetSitePlanSectionTypesLOVExecute(r LOVApiGetSitePlanSectionTypesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetSitePlanSectionTypesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/siteType/{siteType}/sitePlanSectionTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"siteType"+"}", url.PathEscape(parameterValueToString(r.siteType, "siteType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.siteType) < 1 {
		return localVarReturnValue, nil, reportError("siteType must have at least 1 elements")
	}
	if strlen(r.siteType) > 2000 {
		return localVarReturnValue, nil, reportError("siteType must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetSitePlansLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	siteType string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetSitePlansLOVRequest) Authorization(authorization string) LOVApiGetSitePlansLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetSitePlansLOVRequest) XAppKey(xAppKey string) LOVApiGetSitePlansLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetSitePlansLOVRequest) XHotelid(xHotelid string) LOVApiGetSitePlansLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetSitePlansLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetSitePlansLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetSitePlansLOVRequest) ParameterName(parameterName []string) LOVApiGetSitePlansLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetSitePlansLOVRequest) ParameterValue(parameterValue []string) LOVApiGetSitePlansLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetSitePlansLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetSitePlansLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetSitePlansLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetSitePlansLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetSitePlansLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetSitePlansLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetSitePlansLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetSitePlansLOVExecute(r)
}

/*
GetSitePlansLOV Fetch List Of Values for Site Plans

 <p><strong>OperationId:</strong>getSitePlansLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteType Value of the parameter 'siteType' which is required to fetch SitePlans LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch SitePlans LOV
 @return LOVApiGetSitePlansLOVRequest
*/
func (a *LOVApiService) GetSitePlansLOV(ctx context.Context, siteType string, hotelId string) LOVApiGetSitePlansLOVRequest {
	return LOVApiGetSitePlansLOVRequest{
		ApiService: a,
		ctx: ctx,
		siteType: siteType,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetSitePlansLOVExecute(r LOVApiGetSitePlansLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetSitePlansLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/siteType/{siteType}/sitePlans"
	localVarPath = strings.Replace(localVarPath, "{"+"siteType"+"}", url.PathEscape(parameterValueToString(r.siteType, "siteType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.siteType) < 1 {
		return localVarReturnValue, nil, reportError("siteType must have at least 1 elements")
	}
	if strlen(r.siteType) > 2000 {
		return localVarReturnValue, nil, reportError("siteType must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetSourceGroupsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	includeInactive string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetSourceGroupsLOVRequest) Authorization(authorization string) LOVApiGetSourceGroupsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetSourceGroupsLOVRequest) XAppKey(xAppKey string) LOVApiGetSourceGroupsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetSourceGroupsLOVRequest) XHotelid(xHotelid string) LOVApiGetSourceGroupsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetSourceGroupsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetSourceGroupsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetSourceGroupsLOVRequest) ParameterName(parameterName []string) LOVApiGetSourceGroupsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetSourceGroupsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetSourceGroupsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetSourceGroupsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetSourceGroupsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetSourceGroupsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetSourceGroupsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetSourceGroupsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetSourceGroupsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetSourceGroupsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetSourceGroupsLOVExecute(r)
}

/*
GetSourceGroupsLOV Fetch List Of Values for Source Groups

 <p><strong>OperationId:</strong>getSourceGroupsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param includeInactive Value of the parameter 'includeInactive' which is required to fetch SourceGroups LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch SourceGroups LOV
 @return LOVApiGetSourceGroupsLOVRequest
*/
func (a *LOVApiService) GetSourceGroupsLOV(ctx context.Context, includeInactive string, hotelId string) LOVApiGetSourceGroupsLOVRequest {
	return LOVApiGetSourceGroupsLOVRequest{
		ApiService: a,
		ctx: ctx,
		includeInactive: includeInactive,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetSourceGroupsLOVExecute(r LOVApiGetSourceGroupsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetSourceGroupsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/includeInactive/{includeInactive}/sourceGroups"
	localVarPath = strings.Replace(localVarPath, "{"+"includeInactive"+"}", url.PathEscape(parameterValueToString(r.includeInactive, "includeInactive")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.includeInactive) < 1 {
		return localVarReturnValue, nil, reportError("includeInactive must have at least 1 elements")
	}
	if strlen(r.includeInactive) > 2000 {
		return localVarReturnValue, nil, reportError("includeInactive must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetSpacesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetSpacesLOVRequest) Authorization(authorization string) LOVApiGetSpacesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetSpacesLOVRequest) XAppKey(xAppKey string) LOVApiGetSpacesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetSpacesLOVRequest) XHotelid(xHotelid string) LOVApiGetSpacesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetSpacesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetSpacesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetSpacesLOVRequest) ParameterName(parameterName []string) LOVApiGetSpacesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetSpacesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetSpacesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetSpacesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetSpacesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetSpacesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetSpacesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetSpacesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetSpacesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetSpacesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetSpacesLOVExecute(r)
}

/*
GetSpacesLOV Fetch List Of Values for Spaces

 <p><strong>OperationId:</strong>getSpacesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch Spaces LOV
 @return LOVApiGetSpacesLOVRequest
*/
func (a *LOVApiService) GetSpacesLOV(ctx context.Context, hotelId string) LOVApiGetSpacesLOVRequest {
	return LOVApiGetSpacesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetSpacesLOVExecute(r LOVApiGetSpacesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetSpacesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/spaces"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetSpecialRequestsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetSpecialRequestsLOVRequest) Authorization(authorization string) LOVApiGetSpecialRequestsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetSpecialRequestsLOVRequest) XAppKey(xAppKey string) LOVApiGetSpecialRequestsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetSpecialRequestsLOVRequest) XHotelid(xHotelid string) LOVApiGetSpecialRequestsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetSpecialRequestsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetSpecialRequestsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetSpecialRequestsLOVRequest) ParameterName(parameterName []string) LOVApiGetSpecialRequestsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetSpecialRequestsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetSpecialRequestsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetSpecialRequestsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetSpecialRequestsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetSpecialRequestsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetSpecialRequestsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetSpecialRequestsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetSpecialRequestsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetSpecialRequestsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetSpecialRequestsLOVExecute(r)
}

/*
GetSpecialRequestsLOV Fetch List Of Values for Special Requests

 <p><strong>OperationId:</strong>getSpecialRequestsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch SpecialRequests LOV
 @return LOVApiGetSpecialRequestsLOVRequest
*/
func (a *LOVApiService) GetSpecialRequestsLOV(ctx context.Context, hotelId string) LOVApiGetSpecialRequestsLOVRequest {
	return LOVApiGetSpecialRequestsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetSpecialRequestsLOVExecute(r LOVApiGetSpecialRequestsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetSpecialRequestsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/specialRequests"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetSpecialsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetSpecialsLOVRequest) Authorization(authorization string) LOVApiGetSpecialsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetSpecialsLOVRequest) XAppKey(xAppKey string) LOVApiGetSpecialsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetSpecialsLOVRequest) XHotelid(xHotelid string) LOVApiGetSpecialsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetSpecialsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetSpecialsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetSpecialsLOVRequest) ParameterName(parameterName []string) LOVApiGetSpecialsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetSpecialsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetSpecialsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetSpecialsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetSpecialsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetSpecialsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetSpecialsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetSpecialsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetSpecialsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetSpecialsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetSpecialsLOVExecute(r)
}

/*
GetSpecialsLOV Fetch List Of Values for Specials

 <p><strong>OperationId:</strong>getSpecialsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch Specials LOV
 @return LOVApiGetSpecialsLOVRequest
*/
func (a *LOVApiService) GetSpecialsLOV(ctx context.Context, hotelId string) LOVApiGetSpecialsLOVRequest {
	return LOVApiGetSpecialsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetSpecialsLOVExecute(r LOVApiGetSpecialsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetSpecialsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/specials"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetStageProfilesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	criteria string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetStageProfilesLOVRequest) Authorization(authorization string) LOVApiGetStageProfilesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetStageProfilesLOVRequest) XAppKey(xAppKey string) LOVApiGetStageProfilesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetStageProfilesLOVRequest) XHotelid(xHotelid string) LOVApiGetStageProfilesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetStageProfilesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetStageProfilesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetStageProfilesLOVRequest) ParameterName(parameterName []string) LOVApiGetStageProfilesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetStageProfilesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetStageProfilesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetStageProfilesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetStageProfilesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetStageProfilesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetStageProfilesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetStageProfilesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetStageProfilesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetStageProfilesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetStageProfilesLOVExecute(r)
}

/*
GetStageProfilesLOV Fetch List Of Values for Stage Profiles

 <p><strong>OperationId:</strong>getStageProfilesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param criteria Value of the parameter 'criteria' which is required to fetch StageProfiles LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch StageProfiles LOV
 @return LOVApiGetStageProfilesLOVRequest
*/
func (a *LOVApiService) GetStageProfilesLOV(ctx context.Context, criteria string, hotelId string) LOVApiGetStageProfilesLOVRequest {
	return LOVApiGetStageProfilesLOVRequest{
		ApiService: a,
		ctx: ctx,
		criteria: criteria,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetStageProfilesLOVExecute(r LOVApiGetStageProfilesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetStageProfilesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/criteria/{criteria}/stageProfiles"
	localVarPath = strings.Replace(localVarPath, "{"+"criteria"+"}", url.PathEscape(parameterValueToString(r.criteria, "criteria")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.criteria) < 1 {
		return localVarReturnValue, nil, reportError("criteria must have at least 1 elements")
	}
	if strlen(r.criteria) > 2000 {
		return localVarReturnValue, nil, reportError("criteria must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetStagedProfilePreferencesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	resortNameId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetStagedProfilePreferencesLOVRequest) Authorization(authorization string) LOVApiGetStagedProfilePreferencesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetStagedProfilePreferencesLOVRequest) XAppKey(xAppKey string) LOVApiGetStagedProfilePreferencesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetStagedProfilePreferencesLOVRequest) XHotelid(xHotelid string) LOVApiGetStagedProfilePreferencesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetStagedProfilePreferencesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetStagedProfilePreferencesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetStagedProfilePreferencesLOVRequest) ParameterName(parameterName []string) LOVApiGetStagedProfilePreferencesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetStagedProfilePreferencesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetStagedProfilePreferencesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetStagedProfilePreferencesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetStagedProfilePreferencesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetStagedProfilePreferencesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetStagedProfilePreferencesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetStagedProfilePreferencesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetStagedProfilePreferencesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetStagedProfilePreferencesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetStagedProfilePreferencesLOVExecute(r)
}

/*
GetStagedProfilePreferencesLOV Fetch List Of Values for Staged Profile Preferences

 <p><strong>OperationId:</strong>getStagedProfilePreferencesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param resortNameId Value of the parameter 'resortNameId' which is required to fetch StagedProfilePreferences LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch StagedProfilePreferences LOV
 @return LOVApiGetStagedProfilePreferencesLOVRequest
*/
func (a *LOVApiService) GetStagedProfilePreferencesLOV(ctx context.Context, resortNameId string, hotelId string) LOVApiGetStagedProfilePreferencesLOVRequest {
	return LOVApiGetStagedProfilePreferencesLOVRequest{
		ApiService: a,
		ctx: ctx,
		resortNameId: resortNameId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetStagedProfilePreferencesLOVExecute(r LOVApiGetStagedProfilePreferencesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetStagedProfilePreferencesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/resortNameId/{resortNameId}/stagedProfilePreferences"
	localVarPath = strings.Replace(localVarPath, "{"+"resortNameId"+"}", url.PathEscape(parameterValueToString(r.resortNameId, "resortNameId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.resortNameId) < 1 {
		return localVarReturnValue, nil, reportError("resortNameId must have at least 1 elements")
	}
	if strlen(r.resortNameId) > 2000 {
		return localVarReturnValue, nil, reportError("resortNameId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetStatisticsYearsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	year string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetStatisticsYearsLOVRequest) Authorization(authorization string) LOVApiGetStatisticsYearsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetStatisticsYearsLOVRequest) XAppKey(xAppKey string) LOVApiGetStatisticsYearsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetStatisticsYearsLOVRequest) XHotelid(xHotelid string) LOVApiGetStatisticsYearsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetStatisticsYearsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetStatisticsYearsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetStatisticsYearsLOVRequest) ParameterName(parameterName []string) LOVApiGetStatisticsYearsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetStatisticsYearsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetStatisticsYearsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetStatisticsYearsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetStatisticsYearsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetStatisticsYearsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetStatisticsYearsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetStatisticsYearsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetStatisticsYearsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetStatisticsYearsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetStatisticsYearsLOVExecute(r)
}

/*
GetStatisticsYearsLOV Fetch List Of Values for Statistics Years

 <p><strong>OperationId:</strong>getStatisticsYearsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param year Value of the parameter 'year' which is required to fetch StatisticsYears LOV
 @return LOVApiGetStatisticsYearsLOVRequest
*/
func (a *LOVApiService) GetStatisticsYearsLOV(ctx context.Context, year string) LOVApiGetStatisticsYearsLOVRequest {
	return LOVApiGetStatisticsYearsLOVRequest{
		ApiService: a,
		ctx: ctx,
		year: year,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetStatisticsYearsLOVExecute(r LOVApiGetStatisticsYearsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetStatisticsYearsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/year/{year}/statisticsYears"
	localVarPath = strings.Replace(localVarPath, "{"+"year"+"}", url.PathEscape(parameterValueToString(r.year, "year")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.year) < 1 {
		return localVarReturnValue, nil, reportError("year must have at least 1 elements")
	}
	if strlen(r.year) > 2000 {
		return localVarReturnValue, nil, reportError("year must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetStoredValueRedeemTrxLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetStoredValueRedeemTrxLOVRequest) Authorization(authorization string) LOVApiGetStoredValueRedeemTrxLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetStoredValueRedeemTrxLOVRequest) XAppKey(xAppKey string) LOVApiGetStoredValueRedeemTrxLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetStoredValueRedeemTrxLOVRequest) XHotelid(xHotelid string) LOVApiGetStoredValueRedeemTrxLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetStoredValueRedeemTrxLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetStoredValueRedeemTrxLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetStoredValueRedeemTrxLOVRequest) ParameterName(parameterName []string) LOVApiGetStoredValueRedeemTrxLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetStoredValueRedeemTrxLOVRequest) ParameterValue(parameterValue []string) LOVApiGetStoredValueRedeemTrxLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetStoredValueRedeemTrxLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetStoredValueRedeemTrxLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetStoredValueRedeemTrxLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetStoredValueRedeemTrxLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetStoredValueRedeemTrxLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetStoredValueRedeemTrxLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetStoredValueRedeemTrxLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetStoredValueRedeemTrxLOVExecute(r)
}

/*
GetStoredValueRedeemTrxLOV Fetch List Of Values for Stored Value Redeem Trx

 <p><strong>OperationId:</strong>getStoredValueRedeemTrxLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch StoredValueRedeemTrx LOV
 @return LOVApiGetStoredValueRedeemTrxLOVRequest
*/
func (a *LOVApiService) GetStoredValueRedeemTrxLOV(ctx context.Context, hotelId string) LOVApiGetStoredValueRedeemTrxLOVRequest {
	return LOVApiGetStoredValueRedeemTrxLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetStoredValueRedeemTrxLOVExecute(r LOVApiGetStoredValueRedeemTrxLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetStoredValueRedeemTrxLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/storedValueRedeemTrx"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetSubBlockLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	superBlock string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetSubBlockLOVRequest) Authorization(authorization string) LOVApiGetSubBlockLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetSubBlockLOVRequest) XAppKey(xAppKey string) LOVApiGetSubBlockLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetSubBlockLOVRequest) XHotelid(xHotelid string) LOVApiGetSubBlockLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetSubBlockLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetSubBlockLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetSubBlockLOVRequest) ParameterName(parameterName []string) LOVApiGetSubBlockLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetSubBlockLOVRequest) ParameterValue(parameterValue []string) LOVApiGetSubBlockLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetSubBlockLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetSubBlockLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetSubBlockLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetSubBlockLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetSubBlockLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetSubBlockLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetSubBlockLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetSubBlockLOVExecute(r)
}

/*
GetSubBlockLOV Fetch List Of Values for Sub Block

 <p><strong>OperationId:</strong>getSubBlockLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param superBlock Value of the parameter 'superBlock' which is required to fetch SubBlock LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch SubBlock LOV
 @return LOVApiGetSubBlockLOVRequest
*/
func (a *LOVApiService) GetSubBlockLOV(ctx context.Context, superBlock string, hotelId string) LOVApiGetSubBlockLOVRequest {
	return LOVApiGetSubBlockLOVRequest{
		ApiService: a,
		ctx: ctx,
		superBlock: superBlock,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetSubBlockLOVExecute(r LOVApiGetSubBlockLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetSubBlockLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/superBlock/{superBlock}/subBlock"
	localVarPath = strings.Replace(localVarPath, "{"+"superBlock"+"}", url.PathEscape(parameterValueToString(r.superBlock, "superBlock")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.superBlock) < 1 {
		return localVarReturnValue, nil, reportError("superBlock must have at least 1 elements")
	}
	if strlen(r.superBlock) > 2000 {
		return localVarReturnValue, nil, reportError("superBlock must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetSummaryRefreshLogLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetSummaryRefreshLogLOVRequest) Authorization(authorization string) LOVApiGetSummaryRefreshLogLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetSummaryRefreshLogLOVRequest) XAppKey(xAppKey string) LOVApiGetSummaryRefreshLogLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetSummaryRefreshLogLOVRequest) XHotelid(xHotelid string) LOVApiGetSummaryRefreshLogLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetSummaryRefreshLogLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetSummaryRefreshLogLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetSummaryRefreshLogLOVRequest) ParameterName(parameterName []string) LOVApiGetSummaryRefreshLogLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetSummaryRefreshLogLOVRequest) ParameterValue(parameterValue []string) LOVApiGetSummaryRefreshLogLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetSummaryRefreshLogLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetSummaryRefreshLogLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetSummaryRefreshLogLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetSummaryRefreshLogLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetSummaryRefreshLogLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetSummaryRefreshLogLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetSummaryRefreshLogLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetSummaryRefreshLogLOVExecute(r)
}

/*
GetSummaryRefreshLogLOV Fetch List Of Values for Summary Refresh Log

 <p><strong>OperationId:</strong>getSummaryRefreshLogLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch SummaryRefreshLog LOV
 @return LOVApiGetSummaryRefreshLogLOVRequest
*/
func (a *LOVApiService) GetSummaryRefreshLogLOV(ctx context.Context, hotelId string) LOVApiGetSummaryRefreshLogLOVRequest {
	return LOVApiGetSummaryRefreshLogLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetSummaryRefreshLogLOVExecute(r LOVApiGetSummaryRefreshLogLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetSummaryRefreshLogLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/summaryRefreshLog"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetSynchronizeRateCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetSynchronizeRateCodesLOVRequest) Authorization(authorization string) LOVApiGetSynchronizeRateCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetSynchronizeRateCodesLOVRequest) XAppKey(xAppKey string) LOVApiGetSynchronizeRateCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetSynchronizeRateCodesLOVRequest) XHotelid(xHotelid string) LOVApiGetSynchronizeRateCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetSynchronizeRateCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetSynchronizeRateCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetSynchronizeRateCodesLOVRequest) ParameterName(parameterName []string) LOVApiGetSynchronizeRateCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetSynchronizeRateCodesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetSynchronizeRateCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetSynchronizeRateCodesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetSynchronizeRateCodesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetSynchronizeRateCodesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetSynchronizeRateCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetSynchronizeRateCodesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetSynchronizeRateCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetSynchronizeRateCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetSynchronizeRateCodesLOVExecute(r)
}

/*
GetSynchronizeRateCodesLOV Fetch List Of Values for Synchronize Rate Codes

 <p><strong>OperationId:</strong>getSynchronizeRateCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch SynchronizeRateCodes LOV
 @return LOVApiGetSynchronizeRateCodesLOVRequest
*/
func (a *LOVApiService) GetSynchronizeRateCodesLOV(ctx context.Context, hotelId string) LOVApiGetSynchronizeRateCodesLOVRequest {
	return LOVApiGetSynchronizeRateCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetSynchronizeRateCodesLOVExecute(r LOVApiGetSynchronizeRateCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetSynchronizeRateCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/synchronizeRateCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetTaskBreakOutLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	fromDate string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetTaskBreakOutLOVRequest) Authorization(authorization string) LOVApiGetTaskBreakOutLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetTaskBreakOutLOVRequest) XAppKey(xAppKey string) LOVApiGetTaskBreakOutLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetTaskBreakOutLOVRequest) XHotelid(xHotelid string) LOVApiGetTaskBreakOutLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetTaskBreakOutLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetTaskBreakOutLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetTaskBreakOutLOVRequest) ParameterName(parameterName []string) LOVApiGetTaskBreakOutLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetTaskBreakOutLOVRequest) ParameterValue(parameterValue []string) LOVApiGetTaskBreakOutLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetTaskBreakOutLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetTaskBreakOutLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetTaskBreakOutLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetTaskBreakOutLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetTaskBreakOutLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetTaskBreakOutLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetTaskBreakOutLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetTaskBreakOutLOVExecute(r)
}

/*
GetTaskBreakOutLOV Fetch List Of Values for Task Break Out

 <p><strong>OperationId:</strong>getTaskBreakOutLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fromDate Value of the parameter 'fromDate' which is required to fetch TaskBreakOut LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch TaskBreakOut LOV
 @return LOVApiGetTaskBreakOutLOVRequest
*/
func (a *LOVApiService) GetTaskBreakOutLOV(ctx context.Context, fromDate string, hotelId string) LOVApiGetTaskBreakOutLOVRequest {
	return LOVApiGetTaskBreakOutLOVRequest{
		ApiService: a,
		ctx: ctx,
		fromDate: fromDate,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetTaskBreakOutLOVExecute(r LOVApiGetTaskBreakOutLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetTaskBreakOutLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/fromDate/{fromDate}/taskBreakOut"
	localVarPath = strings.Replace(localVarPath, "{"+"fromDate"+"}", url.PathEscape(parameterValueToString(r.fromDate, "fromDate")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.fromDate) < 1 {
		return localVarReturnValue, nil, reportError("fromDate must have at least 1 elements")
	}
	if strlen(r.fromDate) > 2000 {
		return localVarReturnValue, nil, reportError("fromDate must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetTaskSheetDeptLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	levelCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetTaskSheetDeptLOVRequest) Authorization(authorization string) LOVApiGetTaskSheetDeptLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetTaskSheetDeptLOVRequest) XAppKey(xAppKey string) LOVApiGetTaskSheetDeptLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetTaskSheetDeptLOVRequest) XHotelid(xHotelid string) LOVApiGetTaskSheetDeptLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetTaskSheetDeptLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetTaskSheetDeptLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetTaskSheetDeptLOVRequest) ParameterName(parameterName []string) LOVApiGetTaskSheetDeptLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetTaskSheetDeptLOVRequest) ParameterValue(parameterValue []string) LOVApiGetTaskSheetDeptLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetTaskSheetDeptLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetTaskSheetDeptLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetTaskSheetDeptLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetTaskSheetDeptLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetTaskSheetDeptLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetTaskSheetDeptLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetTaskSheetDeptLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetTaskSheetDeptLOVExecute(r)
}

/*
GetTaskSheetDeptLOV Fetch List Of Values for Task Sheet Dept

 <p><strong>OperationId:</strong>getTaskSheetDeptLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param levelCode Value of the parameter 'levelCode' which is required to fetch TaskSheetDept LOV
 @return LOVApiGetTaskSheetDeptLOVRequest
*/
func (a *LOVApiService) GetTaskSheetDeptLOV(ctx context.Context, levelCode string) LOVApiGetTaskSheetDeptLOVRequest {
	return LOVApiGetTaskSheetDeptLOVRequest{
		ApiService: a,
		ctx: ctx,
		levelCode: levelCode,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetTaskSheetDeptLOVExecute(r LOVApiGetTaskSheetDeptLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetTaskSheetDeptLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/levelCode/{levelCode}/taskSheetDept"
	localVarPath = strings.Replace(localVarPath, "{"+"levelCode"+"}", url.PathEscape(parameterValueToString(r.levelCode, "levelCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.levelCode) < 1 {
		return localVarReturnValue, nil, reportError("levelCode must have at least 1 elements")
	}
	if strlen(r.levelCode) > 2000 {
		return localVarReturnValue, nil, reportError("levelCode must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetTaskSheetLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	breakOutId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetTaskSheetLOVRequest) Authorization(authorization string) LOVApiGetTaskSheetLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetTaskSheetLOVRequest) XAppKey(xAppKey string) LOVApiGetTaskSheetLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetTaskSheetLOVRequest) XHotelid(xHotelid string) LOVApiGetTaskSheetLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetTaskSheetLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetTaskSheetLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetTaskSheetLOVRequest) ParameterName(parameterName []string) LOVApiGetTaskSheetLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetTaskSheetLOVRequest) ParameterValue(parameterValue []string) LOVApiGetTaskSheetLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetTaskSheetLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetTaskSheetLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetTaskSheetLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetTaskSheetLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetTaskSheetLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetTaskSheetLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetTaskSheetLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetTaskSheetLOVExecute(r)
}

/*
GetTaskSheetLOV Fetch List Of Values for Task Sheet

 <p><strong>OperationId:</strong>getTaskSheetLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param breakOutId Value of the parameter 'breakOutId' which is required to fetch TaskSheet LOV
 @return LOVApiGetTaskSheetLOVRequest
*/
func (a *LOVApiService) GetTaskSheetLOV(ctx context.Context, breakOutId string) LOVApiGetTaskSheetLOVRequest {
	return LOVApiGetTaskSheetLOVRequest{
		ApiService: a,
		ctx: ctx,
		breakOutId: breakOutId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetTaskSheetLOVExecute(r LOVApiGetTaskSheetLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetTaskSheetLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/breakOutId/{breakOutId}/taskSheet"
	localVarPath = strings.Replace(localVarPath, "{"+"breakOutId"+"}", url.PathEscape(parameterValueToString(r.breakOutId, "breakOutId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.breakOutId) < 1 {
		return localVarReturnValue, nil, reportError("breakOutId must have at least 1 elements")
	}
	if strlen(r.breakOutId) > 2000 {
		return localVarReturnValue, nil, reportError("breakOutId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetTaskSheetRoomsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	taskSheetNo string
	taskCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetTaskSheetRoomsLOVRequest) Authorization(authorization string) LOVApiGetTaskSheetRoomsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetTaskSheetRoomsLOVRequest) XAppKey(xAppKey string) LOVApiGetTaskSheetRoomsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetTaskSheetRoomsLOVRequest) XHotelid(xHotelid string) LOVApiGetTaskSheetRoomsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetTaskSheetRoomsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetTaskSheetRoomsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetTaskSheetRoomsLOVRequest) ParameterName(parameterName []string) LOVApiGetTaskSheetRoomsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetTaskSheetRoomsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetTaskSheetRoomsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetTaskSheetRoomsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetTaskSheetRoomsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetTaskSheetRoomsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetTaskSheetRoomsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetTaskSheetRoomsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetTaskSheetRoomsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetTaskSheetRoomsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetTaskSheetRoomsLOVExecute(r)
}

/*
GetTaskSheetRoomsLOV Fetch List Of Values for Task Sheet Rooms

 <p><strong>OperationId:</strong>getTaskSheetRoomsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taskSheetNo Value of the parameter 'taskSheetNo' which is required to fetch TaskSheetRooms LOV
 @param taskCode Value of the parameter 'taskCode' which is required to fetch TaskSheetRooms LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch TaskSheetRooms LOV
 @return LOVApiGetTaskSheetRoomsLOVRequest
*/
func (a *LOVApiService) GetTaskSheetRoomsLOV(ctx context.Context, taskSheetNo string, taskCode string, hotelId string) LOVApiGetTaskSheetRoomsLOVRequest {
	return LOVApiGetTaskSheetRoomsLOVRequest{
		ApiService: a,
		ctx: ctx,
		taskSheetNo: taskSheetNo,
		taskCode: taskCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetTaskSheetRoomsLOVExecute(r LOVApiGetTaskSheetRoomsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetTaskSheetRoomsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/taskCode/{taskCode}/taskSheetNo/{taskSheetNo}/taskSheetRooms"
	localVarPath = strings.Replace(localVarPath, "{"+"taskSheetNo"+"}", url.PathEscape(parameterValueToString(r.taskSheetNo, "taskSheetNo")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"taskCode"+"}", url.PathEscape(parameterValueToString(r.taskCode, "taskCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.taskSheetNo) < 1 {
		return localVarReturnValue, nil, reportError("taskSheetNo must have at least 1 elements")
	}
	if strlen(r.taskSheetNo) > 2000 {
		return localVarReturnValue, nil, reportError("taskSheetNo must have less than 2000 elements")
	}
	if strlen(r.taskCode) < 1 {
		return localVarReturnValue, nil, reportError("taskCode must have at least 1 elements")
	}
	if strlen(r.taskCode) > 2000 {
		return localVarReturnValue, nil, reportError("taskCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetTaxTransactionCodeLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	taxCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetTaxTransactionCodeLOVRequest) Authorization(authorization string) LOVApiGetTaxTransactionCodeLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetTaxTransactionCodeLOVRequest) XAppKey(xAppKey string) LOVApiGetTaxTransactionCodeLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetTaxTransactionCodeLOVRequest) XHotelid(xHotelid string) LOVApiGetTaxTransactionCodeLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetTaxTransactionCodeLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetTaxTransactionCodeLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetTaxTransactionCodeLOVRequest) ParameterName(parameterName []string) LOVApiGetTaxTransactionCodeLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetTaxTransactionCodeLOVRequest) ParameterValue(parameterValue []string) LOVApiGetTaxTransactionCodeLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetTaxTransactionCodeLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetTaxTransactionCodeLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetTaxTransactionCodeLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetTaxTransactionCodeLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetTaxTransactionCodeLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetTaxTransactionCodeLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetTaxTransactionCodeLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetTaxTransactionCodeLOVExecute(r)
}

/*
GetTaxTransactionCodeLOV Fetch List Of Values for Tax Transaction Code

 <p><strong>OperationId:</strong>getTaxTransactionCodeLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taxCode Value of the parameter 'taxCode' which is required to fetch TaxTransactionCode LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch TaxTransactionCode LOV
 @return LOVApiGetTaxTransactionCodeLOVRequest
*/
func (a *LOVApiService) GetTaxTransactionCodeLOV(ctx context.Context, taxCode string, hotelId string) LOVApiGetTaxTransactionCodeLOVRequest {
	return LOVApiGetTaxTransactionCodeLOVRequest{
		ApiService: a,
		ctx: ctx,
		taxCode: taxCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetTaxTransactionCodeLOVExecute(r LOVApiGetTaxTransactionCodeLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetTaxTransactionCodeLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/taxCode/{taxCode}/taxTransactionCode"
	localVarPath = strings.Replace(localVarPath, "{"+"taxCode"+"}", url.PathEscape(parameterValueToString(r.taxCode, "taxCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.taxCode) < 1 {
		return localVarReturnValue, nil, reportError("taxCode must have at least 1 elements")
	}
	if strlen(r.taxCode) > 2000 {
		return localVarReturnValue, nil, reportError("taxCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetTaxTypesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetTaxTypesLOVRequest) Authorization(authorization string) LOVApiGetTaxTypesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetTaxTypesLOVRequest) XAppKey(xAppKey string) LOVApiGetTaxTypesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetTaxTypesLOVRequest) XHotelid(xHotelid string) LOVApiGetTaxTypesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetTaxTypesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetTaxTypesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetTaxTypesLOVRequest) ParameterName(parameterName []string) LOVApiGetTaxTypesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetTaxTypesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetTaxTypesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetTaxTypesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetTaxTypesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetTaxTypesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetTaxTypesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetTaxTypesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetTaxTypesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetTaxTypesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetTaxTypesLOVExecute(r)
}

/*
GetTaxTypesLOV Fetch List Of Values for Tax Types

 <p><strong>OperationId:</strong>getTaxTypesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch TaxTypes LOV
 @return LOVApiGetTaxTypesLOVRequest
*/
func (a *LOVApiService) GetTaxTypesLOV(ctx context.Context, hotelId string) LOVApiGetTaxTypesLOVRequest {
	return LOVApiGetTaxTypesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetTaxTypesLOVExecute(r LOVApiGetTaxTypesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetTaxTypesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/taxTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetTelephoneCategoryLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetTelephoneCategoryLOVRequest) Authorization(authorization string) LOVApiGetTelephoneCategoryLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetTelephoneCategoryLOVRequest) XAppKey(xAppKey string) LOVApiGetTelephoneCategoryLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetTelephoneCategoryLOVRequest) XHotelid(xHotelid string) LOVApiGetTelephoneCategoryLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetTelephoneCategoryLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetTelephoneCategoryLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetTelephoneCategoryLOVRequest) ParameterName(parameterName []string) LOVApiGetTelephoneCategoryLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetTelephoneCategoryLOVRequest) ParameterValue(parameterValue []string) LOVApiGetTelephoneCategoryLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetTelephoneCategoryLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetTelephoneCategoryLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetTelephoneCategoryLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetTelephoneCategoryLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetTelephoneCategoryLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetTelephoneCategoryLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetTelephoneCategoryLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetTelephoneCategoryLOVExecute(r)
}

/*
GetTelephoneCategoryLOV Fetch List Of Values for Telephone Category

 <p><strong>OperationId:</strong>getTelephoneCategoryLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch TelephoneCategory LOV
 @return LOVApiGetTelephoneCategoryLOVRequest
*/
func (a *LOVApiService) GetTelephoneCategoryLOV(ctx context.Context, hotelId string) LOVApiGetTelephoneCategoryLOVRequest {
	return LOVApiGetTelephoneCategoryLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetTelephoneCategoryLOVExecute(r LOVApiGetTelephoneCategoryLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetTelephoneCategoryLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/telephoneCategory"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetTemplateBookingChannelRoomTypesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	bookingChannelCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetTemplateBookingChannelRoomTypesLOVRequest) Authorization(authorization string) LOVApiGetTemplateBookingChannelRoomTypesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetTemplateBookingChannelRoomTypesLOVRequest) XAppKey(xAppKey string) LOVApiGetTemplateBookingChannelRoomTypesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetTemplateBookingChannelRoomTypesLOVRequest) XHotelid(xHotelid string) LOVApiGetTemplateBookingChannelRoomTypesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetTemplateBookingChannelRoomTypesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetTemplateBookingChannelRoomTypesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetTemplateBookingChannelRoomTypesLOVRequest) ParameterName(parameterName []string) LOVApiGetTemplateBookingChannelRoomTypesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetTemplateBookingChannelRoomTypesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetTemplateBookingChannelRoomTypesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetTemplateBookingChannelRoomTypesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetTemplateBookingChannelRoomTypesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetTemplateBookingChannelRoomTypesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetTemplateBookingChannelRoomTypesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetTemplateBookingChannelRoomTypesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetTemplateBookingChannelRoomTypesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetTemplateBookingChannelRoomTypesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetTemplateBookingChannelRoomTypesLOVExecute(r)
}

/*
GetTemplateBookingChannelRoomTypesLOV Fetch List Of Values for Template Booking Channel Room Types

 <p><strong>OperationId:</strong>getTemplateBookingChannelRoomTypesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bookingChannelCode Value of the parameter 'bookingChannelCode' which is required to fetch TemplateBookingChannelRoomTypes LOV
 @return LOVApiGetTemplateBookingChannelRoomTypesLOVRequest
*/
func (a *LOVApiService) GetTemplateBookingChannelRoomTypesLOV(ctx context.Context, bookingChannelCode string) LOVApiGetTemplateBookingChannelRoomTypesLOVRequest {
	return LOVApiGetTemplateBookingChannelRoomTypesLOVRequest{
		ApiService: a,
		ctx: ctx,
		bookingChannelCode: bookingChannelCode,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetTemplateBookingChannelRoomTypesLOVExecute(r LOVApiGetTemplateBookingChannelRoomTypesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetTemplateBookingChannelRoomTypesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/bookingChannels/{bookingChannelCode}/templateBookingChannelRoomTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"bookingChannelCode"+"}", url.PathEscape(parameterValueToString(r.bookingChannelCode, "bookingChannelCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.bookingChannelCode) < 1 {
		return localVarReturnValue, nil, reportError("bookingChannelCode must have at least 1 elements")
	}
	if strlen(r.bookingChannelCode) > 2000 {
		return localVarReturnValue, nil, reportError("bookingChannelCode must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetTemplateFiscalFolioParametersLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	templateCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetTemplateFiscalFolioParametersLOVRequest) Authorization(authorization string) LOVApiGetTemplateFiscalFolioParametersLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetTemplateFiscalFolioParametersLOVRequest) XAppKey(xAppKey string) LOVApiGetTemplateFiscalFolioParametersLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetTemplateFiscalFolioParametersLOVRequest) XHotelid(xHotelid string) LOVApiGetTemplateFiscalFolioParametersLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetTemplateFiscalFolioParametersLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetTemplateFiscalFolioParametersLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetTemplateFiscalFolioParametersLOVRequest) ParameterName(parameterName []string) LOVApiGetTemplateFiscalFolioParametersLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetTemplateFiscalFolioParametersLOVRequest) ParameterValue(parameterValue []string) LOVApiGetTemplateFiscalFolioParametersLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetTemplateFiscalFolioParametersLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetTemplateFiscalFolioParametersLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetTemplateFiscalFolioParametersLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetTemplateFiscalFolioParametersLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetTemplateFiscalFolioParametersLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetTemplateFiscalFolioParametersLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetTemplateFiscalFolioParametersLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetTemplateFiscalFolioParametersLOVExecute(r)
}

/*
GetTemplateFiscalFolioParametersLOV Fetch List Of Values for Template Fiscal Folio Parameters

 <p><strong>OperationId:</strong>getTemplateFiscalFolioParametersLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param templateCode Value of the parameter 'templateCode' which is required to fetch TemplateFiscalFolioParameters LOV
 @return LOVApiGetTemplateFiscalFolioParametersLOVRequest
*/
func (a *LOVApiService) GetTemplateFiscalFolioParametersLOV(ctx context.Context, templateCode string) LOVApiGetTemplateFiscalFolioParametersLOVRequest {
	return LOVApiGetTemplateFiscalFolioParametersLOVRequest{
		ApiService: a,
		ctx: ctx,
		templateCode: templateCode,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetTemplateFiscalFolioParametersLOVExecute(r LOVApiGetTemplateFiscalFolioParametersLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetTemplateFiscalFolioParametersLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/templateCode/{templateCode}/templateFiscalFolioParameters"
	localVarPath = strings.Replace(localVarPath, "{"+"templateCode"+"}", url.PathEscape(parameterValueToString(r.templateCode, "templateCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.templateCode) < 1 {
		return localVarReturnValue, nil, reportError("templateCode must have at least 1 elements")
	}
	if strlen(r.templateCode) > 2000 {
		return localVarReturnValue, nil, reportError("templateCode must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetTemplateMarketCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	includeInactive string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetTemplateMarketCodesLOVRequest) Authorization(authorization string) LOVApiGetTemplateMarketCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetTemplateMarketCodesLOVRequest) XAppKey(xAppKey string) LOVApiGetTemplateMarketCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetTemplateMarketCodesLOVRequest) XHotelid(xHotelid string) LOVApiGetTemplateMarketCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetTemplateMarketCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetTemplateMarketCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetTemplateMarketCodesLOVRequest) ParameterName(parameterName []string) LOVApiGetTemplateMarketCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetTemplateMarketCodesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetTemplateMarketCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetTemplateMarketCodesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetTemplateMarketCodesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetTemplateMarketCodesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetTemplateMarketCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetTemplateMarketCodesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetTemplateMarketCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetTemplateMarketCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetTemplateMarketCodesLOVExecute(r)
}

/*
GetTemplateMarketCodesLOV Fetch List Of Values for Template Market Codes

 <p><strong>OperationId:</strong>getTemplateMarketCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param includeInactive Value of the parameter 'includeInactive' which is required to fetch TemplateMarketCodes LOV
 @return LOVApiGetTemplateMarketCodesLOVRequest
*/
func (a *LOVApiService) GetTemplateMarketCodesLOV(ctx context.Context, includeInactive string) LOVApiGetTemplateMarketCodesLOVRequest {
	return LOVApiGetTemplateMarketCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		includeInactive: includeInactive,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetTemplateMarketCodesLOVExecute(r LOVApiGetTemplateMarketCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetTemplateMarketCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/includeInactive/{includeInactive}/templateMarketCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"includeInactive"+"}", url.PathEscape(parameterValueToString(r.includeInactive, "includeInactive")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.includeInactive) < 1 {
		return localVarReturnValue, nil, reportError("includeInactive must have at least 1 elements")
	}
	if strlen(r.includeInactive) > 2000 {
		return localVarReturnValue, nil, reportError("includeInactive must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetTemplateMarketGroupsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	includeInactive string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetTemplateMarketGroupsLOVRequest) Authorization(authorization string) LOVApiGetTemplateMarketGroupsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetTemplateMarketGroupsLOVRequest) XAppKey(xAppKey string) LOVApiGetTemplateMarketGroupsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetTemplateMarketGroupsLOVRequest) XHotelid(xHotelid string) LOVApiGetTemplateMarketGroupsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetTemplateMarketGroupsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetTemplateMarketGroupsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetTemplateMarketGroupsLOVRequest) ParameterName(parameterName []string) LOVApiGetTemplateMarketGroupsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetTemplateMarketGroupsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetTemplateMarketGroupsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetTemplateMarketGroupsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetTemplateMarketGroupsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetTemplateMarketGroupsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetTemplateMarketGroupsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetTemplateMarketGroupsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetTemplateMarketGroupsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetTemplateMarketGroupsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetTemplateMarketGroupsLOVExecute(r)
}

/*
GetTemplateMarketGroupsLOV Fetch List Of Values for Template Market Groups

 <p><strong>OperationId:</strong>getTemplateMarketGroupsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param includeInactive Value of the parameter 'includeInactive' which is required to fetch TemplateMarketGroups LOV
 @return LOVApiGetTemplateMarketGroupsLOVRequest
*/
func (a *LOVApiService) GetTemplateMarketGroupsLOV(ctx context.Context, includeInactive string) LOVApiGetTemplateMarketGroupsLOVRequest {
	return LOVApiGetTemplateMarketGroupsLOVRequest{
		ApiService: a,
		ctx: ctx,
		includeInactive: includeInactive,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetTemplateMarketGroupsLOVExecute(r LOVApiGetTemplateMarketGroupsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetTemplateMarketGroupsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/includeInactive/{includeInactive}/templateMarketGroups"
	localVarPath = strings.Replace(localVarPath, "{"+"includeInactive"+"}", url.PathEscape(parameterValueToString(r.includeInactive, "includeInactive")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.includeInactive) < 1 {
		return localVarReturnValue, nil, reportError("includeInactive must have at least 1 elements")
	}
	if strlen(r.includeInactive) > 2000 {
		return localVarReturnValue, nil, reportError("includeInactive must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetTemplatePolicyCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	policyType string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetTemplatePolicyCodesLOVRequest) Authorization(authorization string) LOVApiGetTemplatePolicyCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetTemplatePolicyCodesLOVRequest) XAppKey(xAppKey string) LOVApiGetTemplatePolicyCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetTemplatePolicyCodesLOVRequest) XHotelid(xHotelid string) LOVApiGetTemplatePolicyCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetTemplatePolicyCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetTemplatePolicyCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetTemplatePolicyCodesLOVRequest) ParameterName(parameterName []string) LOVApiGetTemplatePolicyCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetTemplatePolicyCodesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetTemplatePolicyCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetTemplatePolicyCodesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetTemplatePolicyCodesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetTemplatePolicyCodesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetTemplatePolicyCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetTemplatePolicyCodesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetTemplatePolicyCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetTemplatePolicyCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetTemplatePolicyCodesLOVExecute(r)
}

/*
GetTemplatePolicyCodesLOV Fetch List Of Values for Template Policy Codes

 <p><strong>OperationId:</strong>getTemplatePolicyCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param policyType Value of the parameter 'policyType' which is required to fetch TemplatePolicyCodes LOV
 @return LOVApiGetTemplatePolicyCodesLOVRequest
*/
func (a *LOVApiService) GetTemplatePolicyCodesLOV(ctx context.Context, policyType string) LOVApiGetTemplatePolicyCodesLOVRequest {
	return LOVApiGetTemplatePolicyCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		policyType: policyType,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetTemplatePolicyCodesLOVExecute(r LOVApiGetTemplatePolicyCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetTemplatePolicyCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/policyType/{policyType}/templatePolicyCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"policyType"+"}", url.PathEscape(parameterValueToString(r.policyType, "policyType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.policyType) < 1 {
		return localVarReturnValue, nil, reportError("policyType must have at least 1 elements")
	}
	if strlen(r.policyType) > 2000 {
		return localVarReturnValue, nil, reportError("policyType must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetTemplatePreferencesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	includeGlobals string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetTemplatePreferencesLOVRequest) Authorization(authorization string) LOVApiGetTemplatePreferencesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetTemplatePreferencesLOVRequest) XAppKey(xAppKey string) LOVApiGetTemplatePreferencesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetTemplatePreferencesLOVRequest) XHotelid(xHotelid string) LOVApiGetTemplatePreferencesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetTemplatePreferencesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetTemplatePreferencesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetTemplatePreferencesLOVRequest) ParameterName(parameterName []string) LOVApiGetTemplatePreferencesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetTemplatePreferencesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetTemplatePreferencesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetTemplatePreferencesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetTemplatePreferencesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetTemplatePreferencesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetTemplatePreferencesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetTemplatePreferencesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetTemplatePreferencesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetTemplatePreferencesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetTemplatePreferencesLOVExecute(r)
}

/*
GetTemplatePreferencesLOV Fetch List Of Values for Template Preferences

 <p><strong>OperationId:</strong>getTemplatePreferencesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param includeGlobals Value of the parameter 'includeGlobals' which is required to fetch TemplatePreferences LOV
 @return LOVApiGetTemplatePreferencesLOVRequest
*/
func (a *LOVApiService) GetTemplatePreferencesLOV(ctx context.Context, includeGlobals string) LOVApiGetTemplatePreferencesLOVRequest {
	return LOVApiGetTemplatePreferencesLOVRequest{
		ApiService: a,
		ctx: ctx,
		includeGlobals: includeGlobals,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetTemplatePreferencesLOVExecute(r LOVApiGetTemplatePreferencesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetTemplatePreferencesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/includeGlobals/{includeGlobals}/templatePreferences"
	localVarPath = strings.Replace(localVarPath, "{"+"includeGlobals"+"}", url.PathEscape(parameterValueToString(r.includeGlobals, "includeGlobals")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.includeGlobals) < 1 {
		return localVarReturnValue, nil, reportError("includeGlobals must have at least 1 elements")
	}
	if strlen(r.includeGlobals) > 2000 {
		return localVarReturnValue, nil, reportError("includeGlobals must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetTemplateRoomClassesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	includeInactive string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetTemplateRoomClassesLOVRequest) Authorization(authorization string) LOVApiGetTemplateRoomClassesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetTemplateRoomClassesLOVRequest) XAppKey(xAppKey string) LOVApiGetTemplateRoomClassesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetTemplateRoomClassesLOVRequest) XHotelid(xHotelid string) LOVApiGetTemplateRoomClassesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetTemplateRoomClassesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetTemplateRoomClassesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetTemplateRoomClassesLOVRequest) ParameterName(parameterName []string) LOVApiGetTemplateRoomClassesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetTemplateRoomClassesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetTemplateRoomClassesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetTemplateRoomClassesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetTemplateRoomClassesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetTemplateRoomClassesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetTemplateRoomClassesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetTemplateRoomClassesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetTemplateRoomClassesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetTemplateRoomClassesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetTemplateRoomClassesLOVExecute(r)
}

/*
GetTemplateRoomClassesLOV Fetch List Of Values for Template Room Classes

 <p><strong>OperationId:</strong>getTemplateRoomClassesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param includeInactive Value of the parameter 'includeInactive' which is required to fetch TemplateRoomClasses LOV
 @return LOVApiGetTemplateRoomClassesLOVRequest
*/
func (a *LOVApiService) GetTemplateRoomClassesLOV(ctx context.Context, includeInactive string) LOVApiGetTemplateRoomClassesLOVRequest {
	return LOVApiGetTemplateRoomClassesLOVRequest{
		ApiService: a,
		ctx: ctx,
		includeInactive: includeInactive,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetTemplateRoomClassesLOVExecute(r LOVApiGetTemplateRoomClassesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetTemplateRoomClassesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/includeInactive/{includeInactive}/templateRoomClasses"
	localVarPath = strings.Replace(localVarPath, "{"+"includeInactive"+"}", url.PathEscape(parameterValueToString(r.includeInactive, "includeInactive")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.includeInactive) < 1 {
		return localVarReturnValue, nil, reportError("includeInactive must have at least 1 elements")
	}
	if strlen(r.includeInactive) > 2000 {
		return localVarReturnValue, nil, reportError("includeInactive must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetTemplateSourceCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	includeInactive string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetTemplateSourceCodesLOVRequest) Authorization(authorization string) LOVApiGetTemplateSourceCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetTemplateSourceCodesLOVRequest) XAppKey(xAppKey string) LOVApiGetTemplateSourceCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetTemplateSourceCodesLOVRequest) XHotelid(xHotelid string) LOVApiGetTemplateSourceCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetTemplateSourceCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetTemplateSourceCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetTemplateSourceCodesLOVRequest) ParameterName(parameterName []string) LOVApiGetTemplateSourceCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetTemplateSourceCodesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetTemplateSourceCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetTemplateSourceCodesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetTemplateSourceCodesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetTemplateSourceCodesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetTemplateSourceCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetTemplateSourceCodesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetTemplateSourceCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetTemplateSourceCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetTemplateSourceCodesLOVExecute(r)
}

/*
GetTemplateSourceCodesLOV Fetch List Of Values for Template Source Codes

 <p><strong>OperationId:</strong>getTemplateSourceCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param includeInactive Value of the parameter 'includeInactive' which is required to fetch TemplateSourceCodes LOV
 @return LOVApiGetTemplateSourceCodesLOVRequest
*/
func (a *LOVApiService) GetTemplateSourceCodesLOV(ctx context.Context, includeInactive string) LOVApiGetTemplateSourceCodesLOVRequest {
	return LOVApiGetTemplateSourceCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		includeInactive: includeInactive,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetTemplateSourceCodesLOVExecute(r LOVApiGetTemplateSourceCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetTemplateSourceCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/includeInactive/{includeInactive}/templateSourceCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"includeInactive"+"}", url.PathEscape(parameterValueToString(r.includeInactive, "includeInactive")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.includeInactive) < 1 {
		return localVarReturnValue, nil, reportError("includeInactive must have at least 1 elements")
	}
	if strlen(r.includeInactive) > 2000 {
		return localVarReturnValue, nil, reportError("includeInactive must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetTemplateSourceGroupsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	includeInactive string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetTemplateSourceGroupsLOVRequest) Authorization(authorization string) LOVApiGetTemplateSourceGroupsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetTemplateSourceGroupsLOVRequest) XAppKey(xAppKey string) LOVApiGetTemplateSourceGroupsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetTemplateSourceGroupsLOVRequest) XHotelid(xHotelid string) LOVApiGetTemplateSourceGroupsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetTemplateSourceGroupsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetTemplateSourceGroupsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetTemplateSourceGroupsLOVRequest) ParameterName(parameterName []string) LOVApiGetTemplateSourceGroupsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetTemplateSourceGroupsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetTemplateSourceGroupsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetTemplateSourceGroupsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetTemplateSourceGroupsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetTemplateSourceGroupsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetTemplateSourceGroupsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetTemplateSourceGroupsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetTemplateSourceGroupsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetTemplateSourceGroupsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetTemplateSourceGroupsLOVExecute(r)
}

/*
GetTemplateSourceGroupsLOV Fetch List Of Values for Template Source Groups

 <p><strong>OperationId:</strong>getTemplateSourceGroupsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param includeInactive Value of the parameter 'includeInactive' which is required to fetch TemplateSourceGroups LOV
 @return LOVApiGetTemplateSourceGroupsLOVRequest
*/
func (a *LOVApiService) GetTemplateSourceGroupsLOV(ctx context.Context, includeInactive string) LOVApiGetTemplateSourceGroupsLOVRequest {
	return LOVApiGetTemplateSourceGroupsLOVRequest{
		ApiService: a,
		ctx: ctx,
		includeInactive: includeInactive,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetTemplateSourceGroupsLOVExecute(r LOVApiGetTemplateSourceGroupsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetTemplateSourceGroupsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/includeInactive/{includeInactive}/templateSourceGroups"
	localVarPath = strings.Replace(localVarPath, "{"+"includeInactive"+"}", url.PathEscape(parameterValueToString(r.includeInactive, "includeInactive")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.includeInactive) < 1 {
		return localVarReturnValue, nil, reportError("includeInactive must have at least 1 elements")
	}
	if strlen(r.includeInactive) > 2000 {
		return localVarReturnValue, nil, reportError("includeInactive must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetTemplateTransactionSubgroupsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	fetchOnlyUniqueValues string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetTemplateTransactionSubgroupsLOVRequest) Authorization(authorization string) LOVApiGetTemplateTransactionSubgroupsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetTemplateTransactionSubgroupsLOVRequest) XAppKey(xAppKey string) LOVApiGetTemplateTransactionSubgroupsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetTemplateTransactionSubgroupsLOVRequest) XHotelid(xHotelid string) LOVApiGetTemplateTransactionSubgroupsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetTemplateTransactionSubgroupsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetTemplateTransactionSubgroupsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetTemplateTransactionSubgroupsLOVRequest) ParameterName(parameterName []string) LOVApiGetTemplateTransactionSubgroupsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetTemplateTransactionSubgroupsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetTemplateTransactionSubgroupsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetTemplateTransactionSubgroupsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetTemplateTransactionSubgroupsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetTemplateTransactionSubgroupsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetTemplateTransactionSubgroupsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetTemplateTransactionSubgroupsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetTemplateTransactionSubgroupsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetTemplateTransactionSubgroupsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetTemplateTransactionSubgroupsLOVExecute(r)
}

/*
GetTemplateTransactionSubgroupsLOV Fetch List Of Values for Template Transaction Subgroups

 <p><strong>OperationId:</strong>getTemplateTransactionSubgroupsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fetchOnlyUniqueValues Value of the parameter 'fetchOnlyUniqueValues' which is required to fetch TemplateTransactionSubgroups LOV
 @return LOVApiGetTemplateTransactionSubgroupsLOVRequest
*/
func (a *LOVApiService) GetTemplateTransactionSubgroupsLOV(ctx context.Context, fetchOnlyUniqueValues string) LOVApiGetTemplateTransactionSubgroupsLOVRequest {
	return LOVApiGetTemplateTransactionSubgroupsLOVRequest{
		ApiService: a,
		ctx: ctx,
		fetchOnlyUniqueValues: fetchOnlyUniqueValues,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetTemplateTransactionSubgroupsLOVExecute(r LOVApiGetTemplateTransactionSubgroupsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetTemplateTransactionSubgroupsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/fetchOnlyUniqueValues/{fetchOnlyUniqueValues}/templateTransactionSubgroups"
	localVarPath = strings.Replace(localVarPath, "{"+"fetchOnlyUniqueValues"+"}", url.PathEscape(parameterValueToString(r.fetchOnlyUniqueValues, "fetchOnlyUniqueValues")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.fetchOnlyUniqueValues) < 1 {
		return localVarReturnValue, nil, reportError("fetchOnlyUniqueValues must have at least 1 elements")
	}
	if strlen(r.fetchOnlyUniqueValues) > 2000 {
		return localVarReturnValue, nil, reportError("fetchOnlyUniqueValues must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetTestUpsellRulesRateCodeLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	roomCategory string
	arrivalDate string
	nights string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetTestUpsellRulesRateCodeLOVRequest) Authorization(authorization string) LOVApiGetTestUpsellRulesRateCodeLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetTestUpsellRulesRateCodeLOVRequest) XAppKey(xAppKey string) LOVApiGetTestUpsellRulesRateCodeLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetTestUpsellRulesRateCodeLOVRequest) XHotelid(xHotelid string) LOVApiGetTestUpsellRulesRateCodeLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetTestUpsellRulesRateCodeLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetTestUpsellRulesRateCodeLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetTestUpsellRulesRateCodeLOVRequest) ParameterName(parameterName []string) LOVApiGetTestUpsellRulesRateCodeLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetTestUpsellRulesRateCodeLOVRequest) ParameterValue(parameterValue []string) LOVApiGetTestUpsellRulesRateCodeLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetTestUpsellRulesRateCodeLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetTestUpsellRulesRateCodeLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetTestUpsellRulesRateCodeLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetTestUpsellRulesRateCodeLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetTestUpsellRulesRateCodeLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetTestUpsellRulesRateCodeLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetTestUpsellRulesRateCodeLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetTestUpsellRulesRateCodeLOVExecute(r)
}

/*
GetTestUpsellRulesRateCodeLOV Fetch List Of Values for Test Upsell Rules Rate Code

 <p><strong>OperationId:</strong>getTestUpsellRulesRateCodeLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param roomCategory Value of the parameter 'roomCategory' which is required to fetch TestUpsellRulesRateCode LOV
 @param arrivalDate Value of the parameter 'arrivalDate' which is required to fetch TestUpsellRulesRateCode LOV
 @param nights Value of the parameter 'nights' which is required to fetch TestUpsellRulesRateCode LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch TestUpsellRulesRateCode LOV
 @return LOVApiGetTestUpsellRulesRateCodeLOVRequest
*/
func (a *LOVApiService) GetTestUpsellRulesRateCodeLOV(ctx context.Context, roomCategory string, arrivalDate string, nights string, hotelId string) LOVApiGetTestUpsellRulesRateCodeLOVRequest {
	return LOVApiGetTestUpsellRulesRateCodeLOVRequest{
		ApiService: a,
		ctx: ctx,
		roomCategory: roomCategory,
		arrivalDate: arrivalDate,
		nights: nights,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetTestUpsellRulesRateCodeLOVExecute(r LOVApiGetTestUpsellRulesRateCodeLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetTestUpsellRulesRateCodeLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/nights/{nights}/arrivalDate/{arrivalDate}/roomCategory/{roomCategory}/testUpsellRulesRateCode"
	localVarPath = strings.Replace(localVarPath, "{"+"roomCategory"+"}", url.PathEscape(parameterValueToString(r.roomCategory, "roomCategory")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"arrivalDate"+"}", url.PathEscape(parameterValueToString(r.arrivalDate, "arrivalDate")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"nights"+"}", url.PathEscape(parameterValueToString(r.nights, "nights")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.roomCategory) < 1 {
		return localVarReturnValue, nil, reportError("roomCategory must have at least 1 elements")
	}
	if strlen(r.roomCategory) > 2000 {
		return localVarReturnValue, nil, reportError("roomCategory must have less than 2000 elements")
	}
	if strlen(r.arrivalDate) < 1 {
		return localVarReturnValue, nil, reportError("arrivalDate must have at least 1 elements")
	}
	if strlen(r.arrivalDate) > 2000 {
		return localVarReturnValue, nil, reportError("arrivalDate must have less than 2000 elements")
	}
	if strlen(r.nights) < 1 {
		return localVarReturnValue, nil, reportError("nights must have at least 1 elements")
	}
	if strlen(r.nights) > 2000 {
		return localVarReturnValue, nil, reportError("nights must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetToPostalCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	country string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetToPostalCodesLOVRequest) Authorization(authorization string) LOVApiGetToPostalCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetToPostalCodesLOVRequest) XAppKey(xAppKey string) LOVApiGetToPostalCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetToPostalCodesLOVRequest) XHotelid(xHotelid string) LOVApiGetToPostalCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetToPostalCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetToPostalCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetToPostalCodesLOVRequest) ParameterName(parameterName []string) LOVApiGetToPostalCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetToPostalCodesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetToPostalCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetToPostalCodesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetToPostalCodesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetToPostalCodesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetToPostalCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetToPostalCodesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetToPostalCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetToPostalCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetToPostalCodesLOVExecute(r)
}

/*
GetToPostalCodesLOV Fetch List Of Values for To Postal Codes

 <p><strong>OperationId:</strong>getToPostalCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param country Value of the parameter 'country' which is required to fetch ToPostalCodes LOV
 @return LOVApiGetToPostalCodesLOVRequest
*/
func (a *LOVApiService) GetToPostalCodesLOV(ctx context.Context, country string) LOVApiGetToPostalCodesLOVRequest {
	return LOVApiGetToPostalCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		country: country,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetToPostalCodesLOVExecute(r LOVApiGetToPostalCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetToPostalCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/country/{country}/toPostalCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"country"+"}", url.PathEscape(parameterValueToString(r.country, "country")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.country) < 1 {
		return localVarReturnValue, nil, reportError("country must have at least 1 elements")
	}
	if strlen(r.country) > 2000 {
		return localVarReturnValue, nil, reportError("country must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetTraceDateCalcLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	view string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetTraceDateCalcLOVRequest) Authorization(authorization string) LOVApiGetTraceDateCalcLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetTraceDateCalcLOVRequest) XAppKey(xAppKey string) LOVApiGetTraceDateCalcLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetTraceDateCalcLOVRequest) XHotelid(xHotelid string) LOVApiGetTraceDateCalcLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetTraceDateCalcLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetTraceDateCalcLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetTraceDateCalcLOVRequest) ParameterName(parameterName []string) LOVApiGetTraceDateCalcLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetTraceDateCalcLOVRequest) ParameterValue(parameterValue []string) LOVApiGetTraceDateCalcLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetTraceDateCalcLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetTraceDateCalcLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetTraceDateCalcLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetTraceDateCalcLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetTraceDateCalcLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetTraceDateCalcLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetTraceDateCalcLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetTraceDateCalcLOVExecute(r)
}

/*
GetTraceDateCalcLOV Fetch List Of Values for Trace Date Calc

 <p><strong>OperationId:</strong>getTraceDateCalcLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param view Value of the parameter 'view' which is required to fetch TraceDateCalc LOV
 @return LOVApiGetTraceDateCalcLOVRequest
*/
func (a *LOVApiService) GetTraceDateCalcLOV(ctx context.Context, view string) LOVApiGetTraceDateCalcLOVRequest {
	return LOVApiGetTraceDateCalcLOVRequest{
		ApiService: a,
		ctx: ctx,
		view: view,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetTraceDateCalcLOVExecute(r LOVApiGetTraceDateCalcLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetTraceDateCalcLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/view/{view}/traceDateCalc"
	localVarPath = strings.Replace(localVarPath, "{"+"view"+"}", url.PathEscape(parameterValueToString(r.view, "view")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.view) < 1 {
		return localVarReturnValue, nil, reportError("view must have at least 1 elements")
	}
	if strlen(r.view) > 2000 {
		return localVarReturnValue, nil, reportError("view must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetTraceFieldLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	view string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetTraceFieldLOVRequest) Authorization(authorization string) LOVApiGetTraceFieldLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetTraceFieldLOVRequest) XAppKey(xAppKey string) LOVApiGetTraceFieldLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetTraceFieldLOVRequest) XHotelid(xHotelid string) LOVApiGetTraceFieldLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetTraceFieldLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetTraceFieldLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetTraceFieldLOVRequest) ParameterName(parameterName []string) LOVApiGetTraceFieldLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetTraceFieldLOVRequest) ParameterValue(parameterValue []string) LOVApiGetTraceFieldLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetTraceFieldLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetTraceFieldLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetTraceFieldLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetTraceFieldLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetTraceFieldLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetTraceFieldLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetTraceFieldLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetTraceFieldLOVExecute(r)
}

/*
GetTraceFieldLOV Fetch List Of Values for Trace Field

 <p><strong>OperationId:</strong>getTraceFieldLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param view Value of the parameter 'view' which is required to fetch TraceField LOV
 @return LOVApiGetTraceFieldLOVRequest
*/
func (a *LOVApiService) GetTraceFieldLOV(ctx context.Context, view string) LOVApiGetTraceFieldLOVRequest {
	return LOVApiGetTraceFieldLOVRequest{
		ApiService: a,
		ctx: ctx,
		view: view,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetTraceFieldLOVExecute(r LOVApiGetTraceFieldLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetTraceFieldLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/view/{view}/traceField"
	localVarPath = strings.Replace(localVarPath, "{"+"view"+"}", url.PathEscape(parameterValueToString(r.view, "view")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.view) < 1 {
		return localVarReturnValue, nil, reportError("view must have at least 1 elements")
	}
	if strlen(r.view) > 2000 {
		return localVarReturnValue, nil, reportError("view must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetTransactionAdjustmentReasonCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetTransactionAdjustmentReasonCodesLOVRequest) Authorization(authorization string) LOVApiGetTransactionAdjustmentReasonCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetTransactionAdjustmentReasonCodesLOVRequest) XAppKey(xAppKey string) LOVApiGetTransactionAdjustmentReasonCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetTransactionAdjustmentReasonCodesLOVRequest) XHotelid(xHotelid string) LOVApiGetTransactionAdjustmentReasonCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetTransactionAdjustmentReasonCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetTransactionAdjustmentReasonCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetTransactionAdjustmentReasonCodesLOVRequest) ParameterName(parameterName []string) LOVApiGetTransactionAdjustmentReasonCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetTransactionAdjustmentReasonCodesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetTransactionAdjustmentReasonCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetTransactionAdjustmentReasonCodesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetTransactionAdjustmentReasonCodesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetTransactionAdjustmentReasonCodesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetTransactionAdjustmentReasonCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetTransactionAdjustmentReasonCodesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetTransactionAdjustmentReasonCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetTransactionAdjustmentReasonCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetTransactionAdjustmentReasonCodesLOVExecute(r)
}

/*
GetTransactionAdjustmentReasonCodesLOV Fetch List Of Values for Transaction Adjustment Reason Codes

 <p><strong>OperationId:</strong>getTransactionAdjustmentReasonCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch TransactionAdjustmentReasonCodes LOV
 @return LOVApiGetTransactionAdjustmentReasonCodesLOVRequest
*/
func (a *LOVApiService) GetTransactionAdjustmentReasonCodesLOV(ctx context.Context, hotelId string) LOVApiGetTransactionAdjustmentReasonCodesLOVRequest {
	return LOVApiGetTransactionAdjustmentReasonCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetTransactionAdjustmentReasonCodesLOVExecute(r LOVApiGetTransactionAdjustmentReasonCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetTransactionAdjustmentReasonCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/transactionAdjustmentReasonCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetTransactionCodesConsumptionLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetTransactionCodesConsumptionLOVRequest) Authorization(authorization string) LOVApiGetTransactionCodesConsumptionLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetTransactionCodesConsumptionLOVRequest) XAppKey(xAppKey string) LOVApiGetTransactionCodesConsumptionLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetTransactionCodesConsumptionLOVRequest) XHotelid(xHotelid string) LOVApiGetTransactionCodesConsumptionLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetTransactionCodesConsumptionLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetTransactionCodesConsumptionLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetTransactionCodesConsumptionLOVRequest) ParameterName(parameterName []string) LOVApiGetTransactionCodesConsumptionLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetTransactionCodesConsumptionLOVRequest) ParameterValue(parameterValue []string) LOVApiGetTransactionCodesConsumptionLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetTransactionCodesConsumptionLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetTransactionCodesConsumptionLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetTransactionCodesConsumptionLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetTransactionCodesConsumptionLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetTransactionCodesConsumptionLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetTransactionCodesConsumptionLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetTransactionCodesConsumptionLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetTransactionCodesConsumptionLOVExecute(r)
}

/*
GetTransactionCodesConsumptionLOV Fetch List Of Values for Transaction Codes Consumption

 <p><strong>OperationId:</strong>getTransactionCodesConsumptionLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch TransactionCodesConsumption LOV
 @return LOVApiGetTransactionCodesConsumptionLOVRequest
*/
func (a *LOVApiService) GetTransactionCodesConsumptionLOV(ctx context.Context, hotelId string) LOVApiGetTransactionCodesConsumptionLOVRequest {
	return LOVApiGetTransactionCodesConsumptionLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetTransactionCodesConsumptionLOVExecute(r LOVApiGetTransactionCodesConsumptionLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetTransactionCodesConsumptionLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/transactionCodesConsumption"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetTransactionCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetTransactionCodesLOVRequest) Authorization(authorization string) LOVApiGetTransactionCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetTransactionCodesLOVRequest) XAppKey(xAppKey string) LOVApiGetTransactionCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetTransactionCodesLOVRequest) XHotelid(xHotelid string) LOVApiGetTransactionCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetTransactionCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetTransactionCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetTransactionCodesLOVRequest) ParameterName(parameterName []string) LOVApiGetTransactionCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetTransactionCodesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetTransactionCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetTransactionCodesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetTransactionCodesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetTransactionCodesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetTransactionCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetTransactionCodesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetTransactionCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetTransactionCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetTransactionCodesLOVExecute(r)
}

/*
GetTransactionCodesLOV Fetch List Of Values for Transaction Codes

 <p><strong>OperationId:</strong>getTransactionCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch TransactionCodes LOV
 @return LOVApiGetTransactionCodesLOVRequest
*/
func (a *LOVApiService) GetTransactionCodesLOV(ctx context.Context, hotelId string) LOVApiGetTransactionCodesLOVRequest {
	return LOVApiGetTransactionCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetTransactionCodesLOVExecute(r LOVApiGetTransactionCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetTransactionCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/transactionCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetTransactionCodesPaymentLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetTransactionCodesPaymentLOVRequest) Authorization(authorization string) LOVApiGetTransactionCodesPaymentLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetTransactionCodesPaymentLOVRequest) XAppKey(xAppKey string) LOVApiGetTransactionCodesPaymentLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetTransactionCodesPaymentLOVRequest) XHotelid(xHotelid string) LOVApiGetTransactionCodesPaymentLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetTransactionCodesPaymentLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetTransactionCodesPaymentLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetTransactionCodesPaymentLOVRequest) ParameterName(parameterName []string) LOVApiGetTransactionCodesPaymentLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetTransactionCodesPaymentLOVRequest) ParameterValue(parameterValue []string) LOVApiGetTransactionCodesPaymentLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetTransactionCodesPaymentLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetTransactionCodesPaymentLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetTransactionCodesPaymentLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetTransactionCodesPaymentLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetTransactionCodesPaymentLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetTransactionCodesPaymentLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetTransactionCodesPaymentLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetTransactionCodesPaymentLOVExecute(r)
}

/*
GetTransactionCodesPaymentLOV Fetch List Of Values for Transaction Codes Payment

 <p><strong>OperationId:</strong>getTransactionCodesPaymentLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch TransactionCodesPayment LOV
 @return LOVApiGetTransactionCodesPaymentLOVRequest
*/
func (a *LOVApiService) GetTransactionCodesPaymentLOV(ctx context.Context, hotelId string) LOVApiGetTransactionCodesPaymentLOVRequest {
	return LOVApiGetTransactionCodesPaymentLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetTransactionCodesPaymentLOVExecute(r LOVApiGetTransactionCodesPaymentLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetTransactionCodesPaymentLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/transactionCodesPayment"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetTransactionDeleteReasonCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetTransactionDeleteReasonCodesLOVRequest) Authorization(authorization string) LOVApiGetTransactionDeleteReasonCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetTransactionDeleteReasonCodesLOVRequest) XAppKey(xAppKey string) LOVApiGetTransactionDeleteReasonCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetTransactionDeleteReasonCodesLOVRequest) XHotelid(xHotelid string) LOVApiGetTransactionDeleteReasonCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetTransactionDeleteReasonCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetTransactionDeleteReasonCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetTransactionDeleteReasonCodesLOVRequest) ParameterName(parameterName []string) LOVApiGetTransactionDeleteReasonCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetTransactionDeleteReasonCodesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetTransactionDeleteReasonCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetTransactionDeleteReasonCodesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetTransactionDeleteReasonCodesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetTransactionDeleteReasonCodesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetTransactionDeleteReasonCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetTransactionDeleteReasonCodesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetTransactionDeleteReasonCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetTransactionDeleteReasonCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetTransactionDeleteReasonCodesLOVExecute(r)
}

/*
GetTransactionDeleteReasonCodesLOV Fetch List Of Values for Transaction Delete Reason Codes

 <p><strong>OperationId:</strong>getTransactionDeleteReasonCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch TransactionDeleteReasonCodes LOV
 @return LOVApiGetTransactionDeleteReasonCodesLOVRequest
*/
func (a *LOVApiService) GetTransactionDeleteReasonCodesLOV(ctx context.Context, hotelId string) LOVApiGetTransactionDeleteReasonCodesLOVRequest {
	return LOVApiGetTransactionDeleteReasonCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetTransactionDeleteReasonCodesLOVExecute(r LOVApiGetTransactionDeleteReasonCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetTransactionDeleteReasonCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/transactionDeleteReasonCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetTransactionDiversionRuleRoomsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetTransactionDiversionRuleRoomsLOVRequest) Authorization(authorization string) LOVApiGetTransactionDiversionRuleRoomsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetTransactionDiversionRuleRoomsLOVRequest) XAppKey(xAppKey string) LOVApiGetTransactionDiversionRuleRoomsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetTransactionDiversionRuleRoomsLOVRequest) XHotelid(xHotelid string) LOVApiGetTransactionDiversionRuleRoomsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetTransactionDiversionRuleRoomsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetTransactionDiversionRuleRoomsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetTransactionDiversionRuleRoomsLOVRequest) ParameterName(parameterName []string) LOVApiGetTransactionDiversionRuleRoomsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetTransactionDiversionRuleRoomsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetTransactionDiversionRuleRoomsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetTransactionDiversionRuleRoomsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetTransactionDiversionRuleRoomsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetTransactionDiversionRuleRoomsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetTransactionDiversionRuleRoomsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetTransactionDiversionRuleRoomsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetTransactionDiversionRuleRoomsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetTransactionDiversionRuleRoomsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetTransactionDiversionRuleRoomsLOVExecute(r)
}

/*
GetTransactionDiversionRuleRoomsLOV Fetch List Of Values for Transaction Diversion Rule Rooms

 <p><strong>OperationId:</strong>getTransactionDiversionRuleRoomsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch TransactionDiversionRuleRooms LOV
 @return LOVApiGetTransactionDiversionRuleRoomsLOVRequest
*/
func (a *LOVApiService) GetTransactionDiversionRuleRoomsLOV(ctx context.Context, hotelId string) LOVApiGetTransactionDiversionRuleRoomsLOVRequest {
	return LOVApiGetTransactionDiversionRuleRoomsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetTransactionDiversionRuleRoomsLOVExecute(r LOVApiGetTransactionDiversionRuleRoomsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetTransactionDiversionRuleRoomsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/transactionDiversionRuleRooms"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetTransactionGroupsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetTransactionGroupsLOVRequest) Authorization(authorization string) LOVApiGetTransactionGroupsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetTransactionGroupsLOVRequest) XAppKey(xAppKey string) LOVApiGetTransactionGroupsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetTransactionGroupsLOVRequest) XHotelid(xHotelid string) LOVApiGetTransactionGroupsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetTransactionGroupsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetTransactionGroupsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetTransactionGroupsLOVRequest) ParameterName(parameterName []string) LOVApiGetTransactionGroupsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetTransactionGroupsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetTransactionGroupsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetTransactionGroupsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetTransactionGroupsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetTransactionGroupsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetTransactionGroupsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetTransactionGroupsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetTransactionGroupsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetTransactionGroupsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetTransactionGroupsLOVExecute(r)
}

/*
GetTransactionGroupsLOV Fetch List Of Values for Transaction Groups

 <p><strong>OperationId:</strong>getTransactionGroupsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch TransactionGroups LOV
 @return LOVApiGetTransactionGroupsLOVRequest
*/
func (a *LOVApiService) GetTransactionGroupsLOV(ctx context.Context, hotelId string) LOVApiGetTransactionGroupsLOVRequest {
	return LOVApiGetTransactionGroupsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetTransactionGroupsLOVExecute(r LOVApiGetTransactionGroupsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetTransactionGroupsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/transactionGroups"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetTransactionSubgroupsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetTransactionSubgroupsLOVRequest) Authorization(authorization string) LOVApiGetTransactionSubgroupsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetTransactionSubgroupsLOVRequest) XAppKey(xAppKey string) LOVApiGetTransactionSubgroupsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetTransactionSubgroupsLOVRequest) XHotelid(xHotelid string) LOVApiGetTransactionSubgroupsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetTransactionSubgroupsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetTransactionSubgroupsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetTransactionSubgroupsLOVRequest) ParameterName(parameterName []string) LOVApiGetTransactionSubgroupsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetTransactionSubgroupsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetTransactionSubgroupsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetTransactionSubgroupsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetTransactionSubgroupsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetTransactionSubgroupsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetTransactionSubgroupsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetTransactionSubgroupsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetTransactionSubgroupsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetTransactionSubgroupsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetTransactionSubgroupsLOVExecute(r)
}

/*
GetTransactionSubgroupsLOV Fetch List Of Values for Transaction Subgroups

 <p><strong>OperationId:</strong>getTransactionSubgroupsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch TransactionSubgroups LOV
 @return LOVApiGetTransactionSubgroupsLOVRequest
*/
func (a *LOVApiService) GetTransactionSubgroupsLOV(ctx context.Context, hotelId string) LOVApiGetTransactionSubgroupsLOVRequest {
	return LOVApiGetTransactionSubgroupsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetTransactionSubgroupsLOVExecute(r LOVApiGetTransactionSubgroupsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetTransactionSubgroupsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/transactionSubgroups"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetTransportTypesHotelLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetTransportTypesHotelLOVRequest) Authorization(authorization string) LOVApiGetTransportTypesHotelLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetTransportTypesHotelLOVRequest) XAppKey(xAppKey string) LOVApiGetTransportTypesHotelLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetTransportTypesHotelLOVRequest) XHotelid(xHotelid string) LOVApiGetTransportTypesHotelLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetTransportTypesHotelLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetTransportTypesHotelLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetTransportTypesHotelLOVRequest) ParameterName(parameterName []string) LOVApiGetTransportTypesHotelLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetTransportTypesHotelLOVRequest) ParameterValue(parameterValue []string) LOVApiGetTransportTypesHotelLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetTransportTypesHotelLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetTransportTypesHotelLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetTransportTypesHotelLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetTransportTypesHotelLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetTransportTypesHotelLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetTransportTypesHotelLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetTransportTypesHotelLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetTransportTypesHotelLOVExecute(r)
}

/*
GetTransportTypesHotelLOV Fetch List Of Values for Transport Types Hotel

 <p><strong>OperationId:</strong>getTransportTypesHotelLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch TransportTypesHotel LOV
 @return LOVApiGetTransportTypesHotelLOVRequest
*/
func (a *LOVApiService) GetTransportTypesHotelLOV(ctx context.Context, hotelId string) LOVApiGetTransportTypesHotelLOVRequest {
	return LOVApiGetTransportTypesHotelLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetTransportTypesHotelLOVExecute(r LOVApiGetTransportTypesHotelLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetTransportTypesHotelLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/transportTypesHotel"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetTransportTypesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetTransportTypesLOVRequest) Authorization(authorization string) LOVApiGetTransportTypesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetTransportTypesLOVRequest) XAppKey(xAppKey string) LOVApiGetTransportTypesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetTransportTypesLOVRequest) XHotelid(xHotelid string) LOVApiGetTransportTypesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetTransportTypesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetTransportTypesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetTransportTypesLOVRequest) ParameterName(parameterName []string) LOVApiGetTransportTypesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetTransportTypesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetTransportTypesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetTransportTypesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetTransportTypesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetTransportTypesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetTransportTypesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetTransportTypesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetTransportTypesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetTransportTypesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetTransportTypesLOVExecute(r)
}

/*
GetTransportTypesLOV Fetch List Of Values for Transport Types

 <p><strong>OperationId:</strong>getTransportTypesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch TransportTypes LOV
 @return LOVApiGetTransportTypesLOVRequest
*/
func (a *LOVApiService) GetTransportTypesLOV(ctx context.Context, hotelId string) LOVApiGetTransportTypesLOVRequest {
	return LOVApiGetTransportTypesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetTransportTypesLOVExecute(r LOVApiGetTransportTypesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetTransportTypesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/transportTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetTravelAgentSourceLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetTravelAgentSourceLOVRequest) Authorization(authorization string) LOVApiGetTravelAgentSourceLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetTravelAgentSourceLOVRequest) XAppKey(xAppKey string) LOVApiGetTravelAgentSourceLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetTravelAgentSourceLOVRequest) XHotelid(xHotelid string) LOVApiGetTravelAgentSourceLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetTravelAgentSourceLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetTravelAgentSourceLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetTravelAgentSourceLOVRequest) ParameterName(parameterName []string) LOVApiGetTravelAgentSourceLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetTravelAgentSourceLOVRequest) ParameterValue(parameterValue []string) LOVApiGetTravelAgentSourceLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetTravelAgentSourceLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetTravelAgentSourceLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetTravelAgentSourceLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetTravelAgentSourceLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetTravelAgentSourceLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetTravelAgentSourceLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetTravelAgentSourceLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetTravelAgentSourceLOVExecute(r)
}

/*
GetTravelAgentSourceLOV Fetch List Of Values for Travel Agent Source

 <p><strong>OperationId:</strong>getTravelAgentSourceLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch TravelAgentSource LOV
 @return LOVApiGetTravelAgentSourceLOVRequest
*/
func (a *LOVApiService) GetTravelAgentSourceLOV(ctx context.Context, hotelId string) LOVApiGetTravelAgentSourceLOVRequest {
	return LOVApiGetTravelAgentSourceLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetTravelAgentSourceLOVExecute(r LOVApiGetTravelAgentSourceLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetTravelAgentSourceLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/travelAgentSource"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetTravelAgentSourceResvLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetTravelAgentSourceResvLOVRequest) Authorization(authorization string) LOVApiGetTravelAgentSourceResvLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetTravelAgentSourceResvLOVRequest) XAppKey(xAppKey string) LOVApiGetTravelAgentSourceResvLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetTravelAgentSourceResvLOVRequest) XHotelid(xHotelid string) LOVApiGetTravelAgentSourceResvLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetTravelAgentSourceResvLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetTravelAgentSourceResvLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetTravelAgentSourceResvLOVRequest) ParameterName(parameterName []string) LOVApiGetTravelAgentSourceResvLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetTravelAgentSourceResvLOVRequest) ParameterValue(parameterValue []string) LOVApiGetTravelAgentSourceResvLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetTravelAgentSourceResvLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetTravelAgentSourceResvLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetTravelAgentSourceResvLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetTravelAgentSourceResvLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetTravelAgentSourceResvLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetTravelAgentSourceResvLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetTravelAgentSourceResvLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetTravelAgentSourceResvLOVExecute(r)
}

/*
GetTravelAgentSourceResvLOV Fetch List Of Values for Travel Agent Source Resv

 <p><strong>OperationId:</strong>getTravelAgentSourceResvLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch TravelAgentSourceResv LOV
 @return LOVApiGetTravelAgentSourceResvLOVRequest
*/
func (a *LOVApiService) GetTravelAgentSourceResvLOV(ctx context.Context, hotelId string) LOVApiGetTravelAgentSourceResvLOVRequest {
	return LOVApiGetTravelAgentSourceResvLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetTravelAgentSourceResvLOVExecute(r LOVApiGetTravelAgentSourceResvLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetTravelAgentSourceResvLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/travelAgentSourceResv"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetTrxCodeArrangementLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	type_ string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetTrxCodeArrangementLOVRequest) Authorization(authorization string) LOVApiGetTrxCodeArrangementLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetTrxCodeArrangementLOVRequest) XAppKey(xAppKey string) LOVApiGetTrxCodeArrangementLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetTrxCodeArrangementLOVRequest) XHotelid(xHotelid string) LOVApiGetTrxCodeArrangementLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetTrxCodeArrangementLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetTrxCodeArrangementLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetTrxCodeArrangementLOVRequest) ParameterName(parameterName []string) LOVApiGetTrxCodeArrangementLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetTrxCodeArrangementLOVRequest) ParameterValue(parameterValue []string) LOVApiGetTrxCodeArrangementLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetTrxCodeArrangementLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetTrxCodeArrangementLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetTrxCodeArrangementLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetTrxCodeArrangementLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetTrxCodeArrangementLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetTrxCodeArrangementLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetTrxCodeArrangementLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetTrxCodeArrangementLOVExecute(r)
}

/*
GetTrxCodeArrangementLOV Fetch List Of Values for Trx Code Arrangement

 <p><strong>OperationId:</strong>getTrxCodeArrangementLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param type_ Value of the parameter 'type' which is required to fetch TrxCodeArrangement LOV
 @return LOVApiGetTrxCodeArrangementLOVRequest
*/
func (a *LOVApiService) GetTrxCodeArrangementLOV(ctx context.Context, type_ string) LOVApiGetTrxCodeArrangementLOVRequest {
	return LOVApiGetTrxCodeArrangementLOVRequest{
		ApiService: a,
		ctx: ctx,
		type_: type_,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetTrxCodeArrangementLOVExecute(r LOVApiGetTrxCodeArrangementLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetTrxCodeArrangementLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/type/{type}/trxCodeArrangement"
	localVarPath = strings.Replace(localVarPath, "{"+"type"+"}", url.PathEscape(parameterValueToString(r.type_, "type_")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.type_) < 1 {
		return localVarReturnValue, nil, reportError("type_ must have at least 1 elements")
	}
	if strlen(r.type_) > 2000 {
		return localVarReturnValue, nil, reportError("type_ must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetTurnawayCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetTurnawayCodesLOVRequest) Authorization(authorization string) LOVApiGetTurnawayCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetTurnawayCodesLOVRequest) XAppKey(xAppKey string) LOVApiGetTurnawayCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetTurnawayCodesLOVRequest) XHotelid(xHotelid string) LOVApiGetTurnawayCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetTurnawayCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetTurnawayCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetTurnawayCodesLOVRequest) ParameterName(parameterName []string) LOVApiGetTurnawayCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetTurnawayCodesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetTurnawayCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetTurnawayCodesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetTurnawayCodesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetTurnawayCodesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetTurnawayCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetTurnawayCodesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetTurnawayCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetTurnawayCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetTurnawayCodesLOVExecute(r)
}

/*
GetTurnawayCodesLOV Fetch List Of Values for Turnaway Codes

 <p><strong>OperationId:</strong>getTurnawayCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch TurnawayCodes LOV
 @return LOVApiGetTurnawayCodesLOVRequest
*/
func (a *LOVApiService) GetTurnawayCodesLOV(ctx context.Context, hotelId string) LOVApiGetTurnawayCodesLOVRequest {
	return LOVApiGetTurnawayCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetTurnawayCodesLOVExecute(r LOVApiGetTurnawayCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetTurnawayCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/turnawayCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetUDFMappingsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	moduleName string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetUDFMappingsLOVRequest) Authorization(authorization string) LOVApiGetUDFMappingsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetUDFMappingsLOVRequest) XAppKey(xAppKey string) LOVApiGetUDFMappingsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetUDFMappingsLOVRequest) XHotelid(xHotelid string) LOVApiGetUDFMappingsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetUDFMappingsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetUDFMappingsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetUDFMappingsLOVRequest) ParameterName(parameterName []string) LOVApiGetUDFMappingsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetUDFMappingsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetUDFMappingsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetUDFMappingsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetUDFMappingsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetUDFMappingsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetUDFMappingsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetUDFMappingsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetUDFMappingsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetUDFMappingsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetUDFMappingsLOVExecute(r)
}

/*
GetUDFMappingsLOV Fetch List Of Values for UDFMappings

 <p><strong>OperationId:</strong>getUDFMappingsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param moduleName Value of the parameter 'moduleName' which is required to fetch UDFMappings LOV
 @return LOVApiGetUDFMappingsLOVRequest
*/
func (a *LOVApiService) GetUDFMappingsLOV(ctx context.Context, moduleName string) LOVApiGetUDFMappingsLOVRequest {
	return LOVApiGetUDFMappingsLOVRequest{
		ApiService: a,
		ctx: ctx,
		moduleName: moduleName,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetUDFMappingsLOVExecute(r LOVApiGetUDFMappingsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetUDFMappingsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/moduleName/{moduleName}/udfMappings"
	localVarPath = strings.Replace(localVarPath, "{"+"moduleName"+"}", url.PathEscape(parameterValueToString(r.moduleName, "moduleName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.moduleName) < 1 {
		return localVarReturnValue, nil, reportError("moduleName must have at least 1 elements")
	}
	if strlen(r.moduleName) > 2000 {
		return localVarReturnValue, nil, reportError("moduleName must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetUdfAttributesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	udfCategory string
	udfType string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetUdfAttributesLOVRequest) Authorization(authorization string) LOVApiGetUdfAttributesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetUdfAttributesLOVRequest) XAppKey(xAppKey string) LOVApiGetUdfAttributesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetUdfAttributesLOVRequest) XHotelid(xHotelid string) LOVApiGetUdfAttributesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetUdfAttributesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetUdfAttributesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetUdfAttributesLOVRequest) ParameterName(parameterName []string) LOVApiGetUdfAttributesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetUdfAttributesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetUdfAttributesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetUdfAttributesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetUdfAttributesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetUdfAttributesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetUdfAttributesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetUdfAttributesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetUdfAttributesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetUdfAttributesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetUdfAttributesLOVExecute(r)
}

/*
GetUdfAttributesLOV Fetch List Of Values for Udf Attributes

 <p><strong>OperationId:</strong>getUdfAttributesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param udfCategory Value of the parameter 'udfCategory' which is required to fetch UdfAttributes LOV
 @param udfType Value of the parameter 'udfType' which is required to fetch UdfAttributes LOV
 @return LOVApiGetUdfAttributesLOVRequest
*/
func (a *LOVApiService) GetUdfAttributesLOV(ctx context.Context, udfCategory string, udfType string) LOVApiGetUdfAttributesLOVRequest {
	return LOVApiGetUdfAttributesLOVRequest{
		ApiService: a,
		ctx: ctx,
		udfCategory: udfCategory,
		udfType: udfType,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetUdfAttributesLOVExecute(r LOVApiGetUdfAttributesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetUdfAttributesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/udfType/{udfType}/udfCategory/{udfCategory}/udfAttributes"
	localVarPath = strings.Replace(localVarPath, "{"+"udfCategory"+"}", url.PathEscape(parameterValueToString(r.udfCategory, "udfCategory")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"udfType"+"}", url.PathEscape(parameterValueToString(r.udfType, "udfType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.udfCategory) < 1 {
		return localVarReturnValue, nil, reportError("udfCategory must have at least 1 elements")
	}
	if strlen(r.udfCategory) > 2000 {
		return localVarReturnValue, nil, reportError("udfCategory must have less than 2000 elements")
	}
	if strlen(r.udfType) < 1 {
		return localVarReturnValue, nil, reportError("udfType must have at least 1 elements")
	}
	if strlen(r.udfType) > 2000 {
		return localVarReturnValue, nil, reportError("udfType must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetUpsellDefaultTrxCodeLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetUpsellDefaultTrxCodeLOVRequest) Authorization(authorization string) LOVApiGetUpsellDefaultTrxCodeLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetUpsellDefaultTrxCodeLOVRequest) XAppKey(xAppKey string) LOVApiGetUpsellDefaultTrxCodeLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetUpsellDefaultTrxCodeLOVRequest) XHotelid(xHotelid string) LOVApiGetUpsellDefaultTrxCodeLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetUpsellDefaultTrxCodeLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetUpsellDefaultTrxCodeLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetUpsellDefaultTrxCodeLOVRequest) ParameterName(parameterName []string) LOVApiGetUpsellDefaultTrxCodeLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetUpsellDefaultTrxCodeLOVRequest) ParameterValue(parameterValue []string) LOVApiGetUpsellDefaultTrxCodeLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetUpsellDefaultTrxCodeLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetUpsellDefaultTrxCodeLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetUpsellDefaultTrxCodeLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetUpsellDefaultTrxCodeLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetUpsellDefaultTrxCodeLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetUpsellDefaultTrxCodeLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetUpsellDefaultTrxCodeLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetUpsellDefaultTrxCodeLOVExecute(r)
}

/*
GetUpsellDefaultTrxCodeLOV Fetch List Of Values for Upsell Default Trx Code

 <p><strong>OperationId:</strong>getUpsellDefaultTrxCodeLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch UpsellDefaultTrxCode LOV
 @return LOVApiGetUpsellDefaultTrxCodeLOVRequest
*/
func (a *LOVApiService) GetUpsellDefaultTrxCodeLOV(ctx context.Context, hotelId string) LOVApiGetUpsellDefaultTrxCodeLOVRequest {
	return LOVApiGetUpsellDefaultTrxCodeLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetUpsellDefaultTrxCodeLOVExecute(r LOVApiGetUpsellDefaultTrxCodeLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetUpsellDefaultTrxCodeLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/upsellDefaultTrxCode"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetUpsellFromRoomClassEditLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetUpsellFromRoomClassEditLOVRequest) Authorization(authorization string) LOVApiGetUpsellFromRoomClassEditLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetUpsellFromRoomClassEditLOVRequest) XAppKey(xAppKey string) LOVApiGetUpsellFromRoomClassEditLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetUpsellFromRoomClassEditLOVRequest) XHotelid(xHotelid string) LOVApiGetUpsellFromRoomClassEditLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetUpsellFromRoomClassEditLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetUpsellFromRoomClassEditLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetUpsellFromRoomClassEditLOVRequest) ParameterName(parameterName []string) LOVApiGetUpsellFromRoomClassEditLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetUpsellFromRoomClassEditLOVRequest) ParameterValue(parameterValue []string) LOVApiGetUpsellFromRoomClassEditLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetUpsellFromRoomClassEditLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetUpsellFromRoomClassEditLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetUpsellFromRoomClassEditLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetUpsellFromRoomClassEditLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetUpsellFromRoomClassEditLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetUpsellFromRoomClassEditLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetUpsellFromRoomClassEditLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetUpsellFromRoomClassEditLOVExecute(r)
}

/*
GetUpsellFromRoomClassEditLOV Fetch List Of Values for Upsell From Room Class Edit

 <p><strong>OperationId:</strong>getUpsellFromRoomClassEditLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch UpsellFromRoomClassEdit LOV
 @return LOVApiGetUpsellFromRoomClassEditLOVRequest
*/
func (a *LOVApiService) GetUpsellFromRoomClassEditLOV(ctx context.Context, hotelId string) LOVApiGetUpsellFromRoomClassEditLOVRequest {
	return LOVApiGetUpsellFromRoomClassEditLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetUpsellFromRoomClassEditLOVExecute(r LOVApiGetUpsellFromRoomClassEditLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetUpsellFromRoomClassEditLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/upsellFromRoomClassEdit"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetUpsellFromRoomTypeEditLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetUpsellFromRoomTypeEditLOVRequest) Authorization(authorization string) LOVApiGetUpsellFromRoomTypeEditLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetUpsellFromRoomTypeEditLOVRequest) XAppKey(xAppKey string) LOVApiGetUpsellFromRoomTypeEditLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetUpsellFromRoomTypeEditLOVRequest) XHotelid(xHotelid string) LOVApiGetUpsellFromRoomTypeEditLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetUpsellFromRoomTypeEditLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetUpsellFromRoomTypeEditLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetUpsellFromRoomTypeEditLOVRequest) ParameterName(parameterName []string) LOVApiGetUpsellFromRoomTypeEditLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetUpsellFromRoomTypeEditLOVRequest) ParameterValue(parameterValue []string) LOVApiGetUpsellFromRoomTypeEditLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetUpsellFromRoomTypeEditLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetUpsellFromRoomTypeEditLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetUpsellFromRoomTypeEditLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetUpsellFromRoomTypeEditLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetUpsellFromRoomTypeEditLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetUpsellFromRoomTypeEditLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetUpsellFromRoomTypeEditLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetUpsellFromRoomTypeEditLOVExecute(r)
}

/*
GetUpsellFromRoomTypeEditLOV Fetch List Of Values for Upsell From Room Type Edit

 <p><strong>OperationId:</strong>getUpsellFromRoomTypeEditLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch UpsellFromRoomTypeEdit LOV
 @return LOVApiGetUpsellFromRoomTypeEditLOVRequest
*/
func (a *LOVApiService) GetUpsellFromRoomTypeEditLOV(ctx context.Context, hotelId string) LOVApiGetUpsellFromRoomTypeEditLOVRequest {
	return LOVApiGetUpsellFromRoomTypeEditLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetUpsellFromRoomTypeEditLOVExecute(r LOVApiGetUpsellFromRoomTypeEditLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetUpsellFromRoomTypeEditLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/upsellFromRoomTypeEdit"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetUpsellHierarchyLevelsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetUpsellHierarchyLevelsLOVRequest) Authorization(authorization string) LOVApiGetUpsellHierarchyLevelsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetUpsellHierarchyLevelsLOVRequest) XAppKey(xAppKey string) LOVApiGetUpsellHierarchyLevelsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetUpsellHierarchyLevelsLOVRequest) XHotelid(xHotelid string) LOVApiGetUpsellHierarchyLevelsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetUpsellHierarchyLevelsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetUpsellHierarchyLevelsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetUpsellHierarchyLevelsLOVRequest) ParameterName(parameterName []string) LOVApiGetUpsellHierarchyLevelsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetUpsellHierarchyLevelsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetUpsellHierarchyLevelsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetUpsellHierarchyLevelsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetUpsellHierarchyLevelsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetUpsellHierarchyLevelsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetUpsellHierarchyLevelsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetUpsellHierarchyLevelsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetUpsellHierarchyLevelsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetUpsellHierarchyLevelsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetUpsellHierarchyLevelsLOVExecute(r)
}

/*
GetUpsellHierarchyLevelsLOV Fetch List Of Values for Upsell Hierarchy Levels

 <p><strong>OperationId:</strong>getUpsellHierarchyLevelsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch UpsellHierarchyLevels LOV
 @return LOVApiGetUpsellHierarchyLevelsLOVRequest
*/
func (a *LOVApiService) GetUpsellHierarchyLevelsLOV(ctx context.Context, hotelId string) LOVApiGetUpsellHierarchyLevelsLOVRequest {
	return LOVApiGetUpsellHierarchyLevelsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetUpsellHierarchyLevelsLOVExecute(r LOVApiGetUpsellHierarchyLevelsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetUpsellHierarchyLevelsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/upsellHierarchyLevels"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetUpsellMembershipLevelsOnlyLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	membershipType string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetUpsellMembershipLevelsOnlyLOVRequest) Authorization(authorization string) LOVApiGetUpsellMembershipLevelsOnlyLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetUpsellMembershipLevelsOnlyLOVRequest) XAppKey(xAppKey string) LOVApiGetUpsellMembershipLevelsOnlyLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetUpsellMembershipLevelsOnlyLOVRequest) XHotelid(xHotelid string) LOVApiGetUpsellMembershipLevelsOnlyLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetUpsellMembershipLevelsOnlyLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetUpsellMembershipLevelsOnlyLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetUpsellMembershipLevelsOnlyLOVRequest) ParameterName(parameterName []string) LOVApiGetUpsellMembershipLevelsOnlyLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetUpsellMembershipLevelsOnlyLOVRequest) ParameterValue(parameterValue []string) LOVApiGetUpsellMembershipLevelsOnlyLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetUpsellMembershipLevelsOnlyLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetUpsellMembershipLevelsOnlyLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetUpsellMembershipLevelsOnlyLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetUpsellMembershipLevelsOnlyLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetUpsellMembershipLevelsOnlyLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetUpsellMembershipLevelsOnlyLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetUpsellMembershipLevelsOnlyLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetUpsellMembershipLevelsOnlyLOVExecute(r)
}

/*
GetUpsellMembershipLevelsOnlyLOV Fetch List Of Values for Upsell Membership Levels Only

 <p><strong>OperationId:</strong>getUpsellMembershipLevelsOnlyLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param membershipType Value of the parameter 'membershipType' which is required to fetch UpsellMembershipLevelsOnly LOV
 @return LOVApiGetUpsellMembershipLevelsOnlyLOVRequest
*/
func (a *LOVApiService) GetUpsellMembershipLevelsOnlyLOV(ctx context.Context, membershipType string) LOVApiGetUpsellMembershipLevelsOnlyLOVRequest {
	return LOVApiGetUpsellMembershipLevelsOnlyLOVRequest{
		ApiService: a,
		ctx: ctx,
		membershipType: membershipType,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetUpsellMembershipLevelsOnlyLOVExecute(r LOVApiGetUpsellMembershipLevelsOnlyLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetUpsellMembershipLevelsOnlyLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/membershipType/{membershipType}/upsellMembershipLevelsOnly"
	localVarPath = strings.Replace(localVarPath, "{"+"membershipType"+"}", url.PathEscape(parameterValueToString(r.membershipType, "membershipType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.membershipType) < 1 {
		return localVarReturnValue, nil, reportError("membershipType must have at least 1 elements")
	}
	if strlen(r.membershipType) > 2000 {
		return localVarReturnValue, nil, reportError("membershipType must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetUpsellOccupancyLevelsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	includeBlank string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetUpsellOccupancyLevelsLOVRequest) Authorization(authorization string) LOVApiGetUpsellOccupancyLevelsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetUpsellOccupancyLevelsLOVRequest) XAppKey(xAppKey string) LOVApiGetUpsellOccupancyLevelsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetUpsellOccupancyLevelsLOVRequest) XHotelid(xHotelid string) LOVApiGetUpsellOccupancyLevelsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetUpsellOccupancyLevelsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetUpsellOccupancyLevelsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetUpsellOccupancyLevelsLOVRequest) ParameterName(parameterName []string) LOVApiGetUpsellOccupancyLevelsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetUpsellOccupancyLevelsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetUpsellOccupancyLevelsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetUpsellOccupancyLevelsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetUpsellOccupancyLevelsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetUpsellOccupancyLevelsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetUpsellOccupancyLevelsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetUpsellOccupancyLevelsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetUpsellOccupancyLevelsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetUpsellOccupancyLevelsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetUpsellOccupancyLevelsLOVExecute(r)
}

/*
GetUpsellOccupancyLevelsLOV Fetch List Of Values for Upsell Occupancy Levels

 <p><strong>OperationId:</strong>getUpsellOccupancyLevelsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param includeBlank Value of the parameter 'includeBlank' which is required to fetch UpsellOccupancyLevels LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch UpsellOccupancyLevels LOV
 @return LOVApiGetUpsellOccupancyLevelsLOVRequest
*/
func (a *LOVApiService) GetUpsellOccupancyLevelsLOV(ctx context.Context, includeBlank string, hotelId string) LOVApiGetUpsellOccupancyLevelsLOVRequest {
	return LOVApiGetUpsellOccupancyLevelsLOVRequest{
		ApiService: a,
		ctx: ctx,
		includeBlank: includeBlank,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetUpsellOccupancyLevelsLOVExecute(r LOVApiGetUpsellOccupancyLevelsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetUpsellOccupancyLevelsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/includeBlank/{includeBlank}/upsellOccupancyLevels"
	localVarPath = strings.Replace(localVarPath, "{"+"includeBlank"+"}", url.PathEscape(parameterValueToString(r.includeBlank, "includeBlank")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.includeBlank) < 1 {
		return localVarReturnValue, nil, reportError("includeBlank must have at least 1 elements")
	}
	if strlen(r.includeBlank) > 2000 {
		return localVarReturnValue, nil, reportError("includeBlank must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetUpsellRateCategoriesEditLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetUpsellRateCategoriesEditLOVRequest) Authorization(authorization string) LOVApiGetUpsellRateCategoriesEditLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetUpsellRateCategoriesEditLOVRequest) XAppKey(xAppKey string) LOVApiGetUpsellRateCategoriesEditLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetUpsellRateCategoriesEditLOVRequest) XHotelid(xHotelid string) LOVApiGetUpsellRateCategoriesEditLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetUpsellRateCategoriesEditLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetUpsellRateCategoriesEditLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetUpsellRateCategoriesEditLOVRequest) ParameterName(parameterName []string) LOVApiGetUpsellRateCategoriesEditLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetUpsellRateCategoriesEditLOVRequest) ParameterValue(parameterValue []string) LOVApiGetUpsellRateCategoriesEditLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetUpsellRateCategoriesEditLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetUpsellRateCategoriesEditLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetUpsellRateCategoriesEditLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetUpsellRateCategoriesEditLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetUpsellRateCategoriesEditLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetUpsellRateCategoriesEditLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetUpsellRateCategoriesEditLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetUpsellRateCategoriesEditLOVExecute(r)
}

/*
GetUpsellRateCategoriesEditLOV Fetch List Of Values for Upsell Rate Categories Edit

 <p><strong>OperationId:</strong>getUpsellRateCategoriesEditLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch UpsellRateCategoriesEdit LOV
 @return LOVApiGetUpsellRateCategoriesEditLOVRequest
*/
func (a *LOVApiService) GetUpsellRateCategoriesEditLOV(ctx context.Context, hotelId string) LOVApiGetUpsellRateCategoriesEditLOVRequest {
	return LOVApiGetUpsellRateCategoriesEditLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetUpsellRateCategoriesEditLOVExecute(r LOVApiGetUpsellRateCategoriesEditLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetUpsellRateCategoriesEditLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/upsellRateCategoriesEdit"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetUpsellRateCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetUpsellRateCodesLOVRequest) Authorization(authorization string) LOVApiGetUpsellRateCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetUpsellRateCodesLOVRequest) XAppKey(xAppKey string) LOVApiGetUpsellRateCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetUpsellRateCodesLOVRequest) XHotelid(xHotelid string) LOVApiGetUpsellRateCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetUpsellRateCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetUpsellRateCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetUpsellRateCodesLOVRequest) ParameterName(parameterName []string) LOVApiGetUpsellRateCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetUpsellRateCodesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetUpsellRateCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetUpsellRateCodesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetUpsellRateCodesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetUpsellRateCodesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetUpsellRateCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetUpsellRateCodesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetUpsellRateCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetUpsellRateCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetUpsellRateCodesLOVExecute(r)
}

/*
GetUpsellRateCodesLOV Fetch List Of Values for Upsell Rate Codes

 <p><strong>OperationId:</strong>getUpsellRateCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch UpsellRateCodes LOV
 @return LOVApiGetUpsellRateCodesLOVRequest
*/
func (a *LOVApiService) GetUpsellRateCodesLOV(ctx context.Context, hotelId string) LOVApiGetUpsellRateCodesLOVRequest {
	return LOVApiGetUpsellRateCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetUpsellRateCodesLOVExecute(r LOVApiGetUpsellRateCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetUpsellRateCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/upsellRateCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetUpsellRoomClassViewLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetUpsellRoomClassViewLOVRequest) Authorization(authorization string) LOVApiGetUpsellRoomClassViewLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetUpsellRoomClassViewLOVRequest) XAppKey(xAppKey string) LOVApiGetUpsellRoomClassViewLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetUpsellRoomClassViewLOVRequest) XHotelid(xHotelid string) LOVApiGetUpsellRoomClassViewLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetUpsellRoomClassViewLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetUpsellRoomClassViewLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetUpsellRoomClassViewLOVRequest) ParameterName(parameterName []string) LOVApiGetUpsellRoomClassViewLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetUpsellRoomClassViewLOVRequest) ParameterValue(parameterValue []string) LOVApiGetUpsellRoomClassViewLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetUpsellRoomClassViewLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetUpsellRoomClassViewLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetUpsellRoomClassViewLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetUpsellRoomClassViewLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetUpsellRoomClassViewLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetUpsellRoomClassViewLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetUpsellRoomClassViewLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetUpsellRoomClassViewLOVExecute(r)
}

/*
GetUpsellRoomClassViewLOV Fetch List Of Values for Upsell Room Class View

 <p><strong>OperationId:</strong>getUpsellRoomClassViewLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch UpsellRoomClassView LOV
 @return LOVApiGetUpsellRoomClassViewLOVRequest
*/
func (a *LOVApiService) GetUpsellRoomClassViewLOV(ctx context.Context, hotelId string) LOVApiGetUpsellRoomClassViewLOVRequest {
	return LOVApiGetUpsellRoomClassViewLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetUpsellRoomClassViewLOVExecute(r LOVApiGetUpsellRoomClassViewLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetUpsellRoomClassViewLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/upsellRoomClassView"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetUpsellRoomTypeViewLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetUpsellRoomTypeViewLOVRequest) Authorization(authorization string) LOVApiGetUpsellRoomTypeViewLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetUpsellRoomTypeViewLOVRequest) XAppKey(xAppKey string) LOVApiGetUpsellRoomTypeViewLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetUpsellRoomTypeViewLOVRequest) XHotelid(xHotelid string) LOVApiGetUpsellRoomTypeViewLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetUpsellRoomTypeViewLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetUpsellRoomTypeViewLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetUpsellRoomTypeViewLOVRequest) ParameterName(parameterName []string) LOVApiGetUpsellRoomTypeViewLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetUpsellRoomTypeViewLOVRequest) ParameterValue(parameterValue []string) LOVApiGetUpsellRoomTypeViewLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetUpsellRoomTypeViewLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetUpsellRoomTypeViewLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetUpsellRoomTypeViewLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetUpsellRoomTypeViewLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetUpsellRoomTypeViewLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetUpsellRoomTypeViewLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetUpsellRoomTypeViewLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetUpsellRoomTypeViewLOVExecute(r)
}

/*
GetUpsellRoomTypeViewLOV Fetch List Of Values for Upsell Room Type View

 <p><strong>OperationId:</strong>getUpsellRoomTypeViewLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch UpsellRoomTypeView LOV
 @return LOVApiGetUpsellRoomTypeViewLOVRequest
*/
func (a *LOVApiService) GetUpsellRoomTypeViewLOV(ctx context.Context, hotelId string) LOVApiGetUpsellRoomTypeViewLOVRequest {
	return LOVApiGetUpsellRoomTypeViewLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetUpsellRoomTypeViewLOVExecute(r LOVApiGetUpsellRoomTypeViewLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetUpsellRoomTypeViewLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/upsellRoomTypeView"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetUpsellRuleLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetUpsellRuleLOVRequest) Authorization(authorization string) LOVApiGetUpsellRuleLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetUpsellRuleLOVRequest) XAppKey(xAppKey string) LOVApiGetUpsellRuleLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetUpsellRuleLOVRequest) XHotelid(xHotelid string) LOVApiGetUpsellRuleLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetUpsellRuleLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetUpsellRuleLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetUpsellRuleLOVRequest) ParameterName(parameterName []string) LOVApiGetUpsellRuleLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetUpsellRuleLOVRequest) ParameterValue(parameterValue []string) LOVApiGetUpsellRuleLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetUpsellRuleLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetUpsellRuleLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetUpsellRuleLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetUpsellRuleLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetUpsellRuleLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetUpsellRuleLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetUpsellRuleLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetUpsellRuleLOVExecute(r)
}

/*
GetUpsellRuleLOV Fetch List Of Values for Upsell Rule

 <p><strong>OperationId:</strong>getUpsellRuleLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch UpsellRule LOV
 @return LOVApiGetUpsellRuleLOVRequest
*/
func (a *LOVApiService) GetUpsellRuleLOV(ctx context.Context, hotelId string) LOVApiGetUpsellRuleLOVRequest {
	return LOVApiGetUpsellRuleLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetUpsellRuleLOVExecute(r LOVApiGetUpsellRuleLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetUpsellRuleLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/upsellRule"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetUpsellToRoomClassEditLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	fromRoomClass string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetUpsellToRoomClassEditLOVRequest) Authorization(authorization string) LOVApiGetUpsellToRoomClassEditLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetUpsellToRoomClassEditLOVRequest) XAppKey(xAppKey string) LOVApiGetUpsellToRoomClassEditLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetUpsellToRoomClassEditLOVRequest) XHotelid(xHotelid string) LOVApiGetUpsellToRoomClassEditLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetUpsellToRoomClassEditLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetUpsellToRoomClassEditLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetUpsellToRoomClassEditLOVRequest) ParameterName(parameterName []string) LOVApiGetUpsellToRoomClassEditLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetUpsellToRoomClassEditLOVRequest) ParameterValue(parameterValue []string) LOVApiGetUpsellToRoomClassEditLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetUpsellToRoomClassEditLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetUpsellToRoomClassEditLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetUpsellToRoomClassEditLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetUpsellToRoomClassEditLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetUpsellToRoomClassEditLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetUpsellToRoomClassEditLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetUpsellToRoomClassEditLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetUpsellToRoomClassEditLOVExecute(r)
}

/*
GetUpsellToRoomClassEditLOV Fetch List Of Values for Upsell To Room Class Edit

 <p><strong>OperationId:</strong>getUpsellToRoomClassEditLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fromRoomClass Value of the parameter 'fromRoomClass' which is required to fetch UpsellToRoomClassEdit LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch UpsellToRoomClassEdit LOV
 @return LOVApiGetUpsellToRoomClassEditLOVRequest
*/
func (a *LOVApiService) GetUpsellToRoomClassEditLOV(ctx context.Context, fromRoomClass string, hotelId string) LOVApiGetUpsellToRoomClassEditLOVRequest {
	return LOVApiGetUpsellToRoomClassEditLOVRequest{
		ApiService: a,
		ctx: ctx,
		fromRoomClass: fromRoomClass,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetUpsellToRoomClassEditLOVExecute(r LOVApiGetUpsellToRoomClassEditLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetUpsellToRoomClassEditLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/fromRoomClass/{fromRoomClass}/upsellToRoomClassEdit"
	localVarPath = strings.Replace(localVarPath, "{"+"fromRoomClass"+"}", url.PathEscape(parameterValueToString(r.fromRoomClass, "fromRoomClass")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.fromRoomClass) < 1 {
		return localVarReturnValue, nil, reportError("fromRoomClass must have at least 1 elements")
	}
	if strlen(r.fromRoomClass) > 2000 {
		return localVarReturnValue, nil, reportError("fromRoomClass must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetUpsellToRoomTypeEditLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	fromRoomTypeLabel string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetUpsellToRoomTypeEditLOVRequest) Authorization(authorization string) LOVApiGetUpsellToRoomTypeEditLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetUpsellToRoomTypeEditLOVRequest) XAppKey(xAppKey string) LOVApiGetUpsellToRoomTypeEditLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetUpsellToRoomTypeEditLOVRequest) XHotelid(xHotelid string) LOVApiGetUpsellToRoomTypeEditLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetUpsellToRoomTypeEditLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetUpsellToRoomTypeEditLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetUpsellToRoomTypeEditLOVRequest) ParameterName(parameterName []string) LOVApiGetUpsellToRoomTypeEditLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetUpsellToRoomTypeEditLOVRequest) ParameterValue(parameterValue []string) LOVApiGetUpsellToRoomTypeEditLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetUpsellToRoomTypeEditLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetUpsellToRoomTypeEditLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetUpsellToRoomTypeEditLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetUpsellToRoomTypeEditLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetUpsellToRoomTypeEditLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetUpsellToRoomTypeEditLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetUpsellToRoomTypeEditLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetUpsellToRoomTypeEditLOVExecute(r)
}

/*
GetUpsellToRoomTypeEditLOV Fetch List Of Values for Upsell To Room Type Edit

 <p><strong>OperationId:</strong>getUpsellToRoomTypeEditLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fromRoomTypeLabel Value of the parameter 'fromRoomTypeLabel' which is required to fetch UpsellToRoomTypeEdit LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch UpsellToRoomTypeEdit LOV
 @return LOVApiGetUpsellToRoomTypeEditLOVRequest
*/
func (a *LOVApiService) GetUpsellToRoomTypeEditLOV(ctx context.Context, fromRoomTypeLabel string, hotelId string) LOVApiGetUpsellToRoomTypeEditLOVRequest {
	return LOVApiGetUpsellToRoomTypeEditLOVRequest{
		ApiService: a,
		ctx: ctx,
		fromRoomTypeLabel: fromRoomTypeLabel,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetUpsellToRoomTypeEditLOVExecute(r LOVApiGetUpsellToRoomTypeEditLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetUpsellToRoomTypeEditLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/fromRoomTypeLabel/{fromRoomTypeLabel}/upsellToRoomTypeEdit"
	localVarPath = strings.Replace(localVarPath, "{"+"fromRoomTypeLabel"+"}", url.PathEscape(parameterValueToString(r.fromRoomTypeLabel, "fromRoomTypeLabel")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.fromRoomTypeLabel) < 1 {
		return localVarReturnValue, nil, reportError("fromRoomTypeLabel must have at least 1 elements")
	}
	if strlen(r.fromRoomTypeLabel) > 2000 {
		return localVarReturnValue, nil, reportError("fromRoomTypeLabel must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetUpsellTrxCodesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetUpsellTrxCodesLOVRequest) Authorization(authorization string) LOVApiGetUpsellTrxCodesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetUpsellTrxCodesLOVRequest) XAppKey(xAppKey string) LOVApiGetUpsellTrxCodesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetUpsellTrxCodesLOVRequest) XHotelid(xHotelid string) LOVApiGetUpsellTrxCodesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetUpsellTrxCodesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetUpsellTrxCodesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetUpsellTrxCodesLOVRequest) ParameterName(parameterName []string) LOVApiGetUpsellTrxCodesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetUpsellTrxCodesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetUpsellTrxCodesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetUpsellTrxCodesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetUpsellTrxCodesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetUpsellTrxCodesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetUpsellTrxCodesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetUpsellTrxCodesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetUpsellTrxCodesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetUpsellTrxCodesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetUpsellTrxCodesLOVExecute(r)
}

/*
GetUpsellTrxCodesLOV Fetch List Of Values for Upsell Trx Codes

 <p><strong>OperationId:</strong>getUpsellTrxCodesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch UpsellTrxCodes LOV
 @return LOVApiGetUpsellTrxCodesLOVRequest
*/
func (a *LOVApiService) GetUpsellTrxCodesLOV(ctx context.Context, hotelId string) LOVApiGetUpsellTrxCodesLOVRequest {
	return LOVApiGetUpsellTrxCodesLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetUpsellTrxCodesLOVExecute(r LOVApiGetUpsellTrxCodesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetUpsellTrxCodesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/upsellTrxCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetUserDbFunctionArgsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	category string
	functionName string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetUserDbFunctionArgsLOVRequest) Authorization(authorization string) LOVApiGetUserDbFunctionArgsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetUserDbFunctionArgsLOVRequest) XAppKey(xAppKey string) LOVApiGetUserDbFunctionArgsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetUserDbFunctionArgsLOVRequest) XHotelid(xHotelid string) LOVApiGetUserDbFunctionArgsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetUserDbFunctionArgsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetUserDbFunctionArgsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetUserDbFunctionArgsLOVRequest) ParameterName(parameterName []string) LOVApiGetUserDbFunctionArgsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetUserDbFunctionArgsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetUserDbFunctionArgsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetUserDbFunctionArgsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetUserDbFunctionArgsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetUserDbFunctionArgsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetUserDbFunctionArgsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetUserDbFunctionArgsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetUserDbFunctionArgsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetUserDbFunctionArgsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetUserDbFunctionArgsLOVExecute(r)
}

/*
GetUserDbFunctionArgsLOV Fetch List Of Values for User Db Function Args

 <p><strong>OperationId:</strong>getUserDbFunctionArgsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param category Value of the parameter 'category' which is required to fetch UserDbFunctionArgs LOV
 @param functionName Value of the parameter 'functionName' which is required to fetch UserDbFunctionArgs LOV
 @return LOVApiGetUserDbFunctionArgsLOVRequest
*/
func (a *LOVApiService) GetUserDbFunctionArgsLOV(ctx context.Context, category string, functionName string) LOVApiGetUserDbFunctionArgsLOVRequest {
	return LOVApiGetUserDbFunctionArgsLOVRequest{
		ApiService: a,
		ctx: ctx,
		category: category,
		functionName: functionName,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetUserDbFunctionArgsLOVExecute(r LOVApiGetUserDbFunctionArgsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetUserDbFunctionArgsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/functionName/{functionName}/category/{category}/userDbFunctionArgs"
	localVarPath = strings.Replace(localVarPath, "{"+"category"+"}", url.PathEscape(parameterValueToString(r.category, "category")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"functionName"+"}", url.PathEscape(parameterValueToString(r.functionName, "functionName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.category) < 1 {
		return localVarReturnValue, nil, reportError("category must have at least 1 elements")
	}
	if strlen(r.category) > 2000 {
		return localVarReturnValue, nil, reportError("category must have less than 2000 elements")
	}
	if strlen(r.functionName) < 1 {
		return localVarReturnValue, nil, reportError("functionName must have at least 1 elements")
	}
	if strlen(r.functionName) > 2000 {
		return localVarReturnValue, nil, reportError("functionName must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetUserDbFunctionsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	category string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetUserDbFunctionsLOVRequest) Authorization(authorization string) LOVApiGetUserDbFunctionsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetUserDbFunctionsLOVRequest) XAppKey(xAppKey string) LOVApiGetUserDbFunctionsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetUserDbFunctionsLOVRequest) XHotelid(xHotelid string) LOVApiGetUserDbFunctionsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetUserDbFunctionsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetUserDbFunctionsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetUserDbFunctionsLOVRequest) ParameterName(parameterName []string) LOVApiGetUserDbFunctionsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetUserDbFunctionsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetUserDbFunctionsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetUserDbFunctionsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetUserDbFunctionsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetUserDbFunctionsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetUserDbFunctionsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetUserDbFunctionsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetUserDbFunctionsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetUserDbFunctionsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetUserDbFunctionsLOVExecute(r)
}

/*
GetUserDbFunctionsLOV Fetch List Of Values for User Db Functions

 <p><strong>OperationId:</strong>getUserDbFunctionsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param category Value of the parameter 'category' which is required to fetch UserDbFunctions LOV
 @return LOVApiGetUserDbFunctionsLOVRequest
*/
func (a *LOVApiService) GetUserDbFunctionsLOV(ctx context.Context, category string) LOVApiGetUserDbFunctionsLOVRequest {
	return LOVApiGetUserDbFunctionsLOVRequest{
		ApiService: a,
		ctx: ctx,
		category: category,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetUserDbFunctionsLOVExecute(r LOVApiGetUserDbFunctionsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetUserDbFunctionsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/category/{category}/userDbFunctions"
	localVarPath = strings.Replace(localVarPath, "{"+"category"+"}", url.PathEscape(parameterValueToString(r.category, "category")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.category) < 1 {
		return localVarReturnValue, nil, reportError("category must have at least 1 elements")
	}
	if strlen(r.category) > 2000 {
		return localVarReturnValue, nil, reportError("category must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetUserLogActivityGroupsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetUserLogActivityGroupsLOVRequest) Authorization(authorization string) LOVApiGetUserLogActivityGroupsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetUserLogActivityGroupsLOVRequest) XAppKey(xAppKey string) LOVApiGetUserLogActivityGroupsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetUserLogActivityGroupsLOVRequest) XHotelid(xHotelid string) LOVApiGetUserLogActivityGroupsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetUserLogActivityGroupsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetUserLogActivityGroupsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetUserLogActivityGroupsLOVRequest) ParameterName(parameterName []string) LOVApiGetUserLogActivityGroupsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetUserLogActivityGroupsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetUserLogActivityGroupsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetUserLogActivityGroupsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetUserLogActivityGroupsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetUserLogActivityGroupsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetUserLogActivityGroupsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetUserLogActivityGroupsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetUserLogActivityGroupsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetUserLogActivityGroupsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetUserLogActivityGroupsLOVExecute(r)
}

/*
GetUserLogActivityGroupsLOV Fetch List Of Values for User Log Activity Groups

 <p><strong>OperationId:</strong>getUserLogActivityGroupsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch UserLogActivityGroups LOV
 @return LOVApiGetUserLogActivityGroupsLOVRequest
*/
func (a *LOVApiService) GetUserLogActivityGroupsLOV(ctx context.Context, hotelId string) LOVApiGetUserLogActivityGroupsLOVRequest {
	return LOVApiGetUserLogActivityGroupsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetUserLogActivityGroupsLOVExecute(r LOVApiGetUserLogActivityGroupsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetUserLogActivityGroupsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/userLogActivityGroups"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetUserLogActivityTypesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	activityGroup string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetUserLogActivityTypesLOVRequest) Authorization(authorization string) LOVApiGetUserLogActivityTypesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetUserLogActivityTypesLOVRequest) XAppKey(xAppKey string) LOVApiGetUserLogActivityTypesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetUserLogActivityTypesLOVRequest) XHotelid(xHotelid string) LOVApiGetUserLogActivityTypesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetUserLogActivityTypesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetUserLogActivityTypesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetUserLogActivityTypesLOVRequest) ParameterName(parameterName []string) LOVApiGetUserLogActivityTypesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetUserLogActivityTypesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetUserLogActivityTypesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetUserLogActivityTypesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetUserLogActivityTypesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetUserLogActivityTypesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetUserLogActivityTypesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetUserLogActivityTypesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetUserLogActivityTypesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetUserLogActivityTypesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetUserLogActivityTypesLOVExecute(r)
}

/*
GetUserLogActivityTypesLOV Fetch List Of Values for User Log Activity Types

 <p><strong>OperationId:</strong>getUserLogActivityTypesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param activityGroup Value of the parameter 'activityGroup' which is required to fetch UserLogActivityTypes LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch UserLogActivityTypes LOV
 @return LOVApiGetUserLogActivityTypesLOVRequest
*/
func (a *LOVApiService) GetUserLogActivityTypesLOV(ctx context.Context, activityGroup string, hotelId string) LOVApiGetUserLogActivityTypesLOVRequest {
	return LOVApiGetUserLogActivityTypesLOVRequest{
		ApiService: a,
		ctx: ctx,
		activityGroup: activityGroup,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetUserLogActivityTypesLOVExecute(r LOVApiGetUserLogActivityTypesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetUserLogActivityTypesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/activityGroup/{activityGroup}/userLogActivityTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"activityGroup"+"}", url.PathEscape(parameterValueToString(r.activityGroup, "activityGroup")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.activityGroup) < 1 {
		return localVarReturnValue, nil, reportError("activityGroup must have at least 1 elements")
	}
	if strlen(r.activityGroup) > 2000 {
		return localVarReturnValue, nil, reportError("activityGroup must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetUserRolesLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	roleWithDepartment string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetUserRolesLOVRequest) Authorization(authorization string) LOVApiGetUserRolesLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetUserRolesLOVRequest) XAppKey(xAppKey string) LOVApiGetUserRolesLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetUserRolesLOVRequest) XHotelid(xHotelid string) LOVApiGetUserRolesLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetUserRolesLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetUserRolesLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetUserRolesLOVRequest) ParameterName(parameterName []string) LOVApiGetUserRolesLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetUserRolesLOVRequest) ParameterValue(parameterValue []string) LOVApiGetUserRolesLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetUserRolesLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetUserRolesLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetUserRolesLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetUserRolesLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetUserRolesLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetUserRolesLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetUserRolesLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetUserRolesLOVExecute(r)
}

/*
GetUserRolesLOV Fetch List Of Values for User Roles

 <p><strong>OperationId:</strong>getUserRolesLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param roleWithDepartment Value of the parameter 'roleWithDepartment' which is required to fetch UserRoles LOV
 @param hotelId Value of the parameter 'hotelId' which is required to fetch UserRoles LOV
 @return LOVApiGetUserRolesLOVRequest
*/
func (a *LOVApiService) GetUserRolesLOV(ctx context.Context, roleWithDepartment string, hotelId string) LOVApiGetUserRolesLOVRequest {
	return LOVApiGetUserRolesLOVRequest{
		ApiService: a,
		ctx: ctx,
		roleWithDepartment: roleWithDepartment,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetUserRolesLOVExecute(r LOVApiGetUserRolesLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetUserRolesLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/roleWithDepartment/{roleWithDepartment}/userRoles"
	localVarPath = strings.Replace(localVarPath, "{"+"roleWithDepartment"+"}", url.PathEscape(parameterValueToString(r.roleWithDepartment, "roleWithDepartment")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.roleWithDepartment) < 1 {
		return localVarReturnValue, nil, reportError("roleWithDepartment must have at least 1 elements")
	}
	if strlen(r.roleWithDepartment) > 2000 {
		return localVarReturnValue, nil, reportError("roleWithDepartment must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetYearSetupLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetYearSetupLOVRequest) Authorization(authorization string) LOVApiGetYearSetupLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetYearSetupLOVRequest) XAppKey(xAppKey string) LOVApiGetYearSetupLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetYearSetupLOVRequest) XHotelid(xHotelid string) LOVApiGetYearSetupLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetYearSetupLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetYearSetupLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetYearSetupLOVRequest) ParameterName(parameterName []string) LOVApiGetYearSetupLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetYearSetupLOVRequest) ParameterValue(parameterValue []string) LOVApiGetYearSetupLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetYearSetupLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetYearSetupLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetYearSetupLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetYearSetupLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetYearSetupLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetYearSetupLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetYearSetupLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetYearSetupLOVExecute(r)
}

/*
GetYearSetupLOV Fetch List Of Values for Year Setup

 <p><strong>OperationId:</strong>getYearSetupLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch YearSetup LOV
 @return LOVApiGetYearSetupLOVRequest
*/
func (a *LOVApiService) GetYearSetupLOV(ctx context.Context, hotelId string) LOVApiGetYearSetupLOVRequest {
	return LOVApiGetYearSetupLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetYearSetupLOVExecute(r LOVApiGetYearSetupLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetYearSetupLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/yearSetup"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiGetYieldMarketsLOVRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactiveFlag *bool
	parameterName *[]string
	parameterValue *[]string
	excludeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiGetYieldMarketsLOVRequest) Authorization(authorization string) LOVApiGetYieldMarketsLOVRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiGetYieldMarketsLOVRequest) XAppKey(xAppKey string) LOVApiGetYieldMarketsLOVRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiGetYieldMarketsLOVRequest) XHotelid(xHotelid string) LOVApiGetYieldMarketsLOVRequest {
	r.xHotelid = &xHotelid
	return r
}

// Only useful for LOVs that support toggle of inactive records inclusion. When set to true, inactive records will be included.
func (r LOVApiGetYieldMarketsLOVRequest) IncludeInactiveFlag(includeInactiveFlag bool) LOVApiGetYieldMarketsLOVRequest {
	r.includeInactiveFlag = &includeInactiveFlag
	return r
}

// Name of the parameter.
func (r LOVApiGetYieldMarketsLOVRequest) ParameterName(parameterName []string) LOVApiGetYieldMarketsLOVRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r LOVApiGetYieldMarketsLOVRequest) ParameterValue(parameterValue []string) LOVApiGetYieldMarketsLOVRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r LOVApiGetYieldMarketsLOVRequest) ExcludeCodes(excludeCodes []string) LOVApiGetYieldMarketsLOVRequest {
	r.excludeCodes = &excludeCodes
	return r
}

// External system code.
func (r LOVApiGetYieldMarketsLOVRequest) XExternalsystem(xExternalsystem string) LOVApiGetYieldMarketsLOVRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiGetYieldMarketsLOVRequest) AcceptLanguage(acceptLanguage string) LOVApiGetYieldMarketsLOVRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiGetYieldMarketsLOVRequest) Execute() (*ListOfValues, *http.Response, error) {
	return r.ApiService.GetYieldMarketsLOVExecute(r)
}

/*
GetYieldMarketsLOV Fetch List Of Values for Yield Markets

 <p><strong>OperationId:</strong>getYieldMarketsLOV</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Value of the parameter 'hotelId' which is required to fetch YieldMarkets LOV
 @return LOVApiGetYieldMarketsLOVRequest
*/
func (a *LOVApiService) GetYieldMarketsLOV(ctx context.Context, hotelId string) LOVApiGetYieldMarketsLOVRequest {
	return LOVApiGetYieldMarketsLOVRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ListOfValues
func (a *LOVApiService) GetYieldMarketsLOVExecute(r LOVApiGetYieldMarketsLOVRequest) (*ListOfValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.GetYieldMarketsLOV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/hotels/{hotelId}/yieldMarkets"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactiveFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveFlag", r.includeInactiveFlag, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.excludeCodes != nil {
		t := *r.excludeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiPingLOVServiceRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiPingLOVServiceRequest) Authorization(authorization string) LOVApiPingLOVServiceRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiPingLOVServiceRequest) XAppKey(xAppKey string) LOVApiPingLOVServiceRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiPingLOVServiceRequest) XHotelid(xHotelid string) LOVApiPingLOVServiceRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r LOVApiPingLOVServiceRequest) XExternalsystem(xExternalsystem string) LOVApiPingLOVServiceRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiPingLOVServiceRequest) AcceptLanguage(acceptLanguage string) LOVApiPingLOVServiceRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiPingLOVServiceRequest) Execute() (*OperaVersion, *http.Response, error) {
	return r.ApiService.PingLOVServiceExecute(r)
}

/*
PingLOVService Retrieve List of Values Service Version

 <p><strong>OperationId:</strong>pingLOVService</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LOVApiPingLOVServiceRequest
*/
func (a *LOVApiService) PingLOVService(ctx context.Context) LOVApiPingLOVServiceRequest {
	return LOVApiPingLOVServiceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return OperaVersion
func (a *LOVApiService) PingLOVServiceExecute(r LOVApiPingLOVServiceRequest) (*OperaVersion, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OperaVersion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.PingLOVService")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/services/listOfValues/status"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LOVApiValidateListOfValuesRequest struct {
	ctx context.Context
	ApiService *LOVApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	validateListOfValues *ValidateListOfValuesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r LOVApiValidateListOfValuesRequest) Authorization(authorization string) LOVApiValidateListOfValuesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r LOVApiValidateListOfValuesRequest) XAppKey(xAppKey string) LOVApiValidateListOfValuesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r LOVApiValidateListOfValuesRequest) XHotelid(xHotelid string) LOVApiValidateListOfValuesRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r LOVApiValidateListOfValuesRequest) ValidateListOfValues(validateListOfValues ValidateListOfValuesRequest) LOVApiValidateListOfValuesRequest {
	r.validateListOfValues = &validateListOfValues
	return r
}

// External system code.
func (r LOVApiValidateListOfValuesRequest) XExternalsystem(xExternalsystem string) LOVApiValidateListOfValuesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r LOVApiValidateListOfValuesRequest) AcceptLanguage(acceptLanguage string) LOVApiValidateListOfValuesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r LOVApiValidateListOfValuesRequest) Execute() (*ValidateListOfValuesDetails, *http.Response, error) {
	return r.ApiService.ValidateListOfValuesExecute(r)
}

/*
ValidateListOfValues Validate List Of Values

 <p><strong>OperationId:</strong>validateListOfValues</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LOVApiValidateListOfValuesRequest
*/
func (a *LOVApiService) ValidateListOfValues(ctx context.Context) LOVApiValidateListOfValuesRequest {
	return LOVApiValidateListOfValuesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ValidateListOfValuesDetails
func (a *LOVApiService) ValidateListOfValuesExecute(r LOVApiValidateListOfValuesRequest) (*ValidateListOfValuesDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ValidateListOfValuesDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LOVApiService.ValidateListOfValues")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listOfValues/validate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.validateListOfValues
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
