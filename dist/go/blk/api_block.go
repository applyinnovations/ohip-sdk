/*
OPERA Cloud Block API

APIs to cater for Business Block functionality in OPERA Cloud. <br /><br /> A block is a group of rooms held for guests who are attending an event, meeting, or function. You can create blocks for family reunions, business conferences, weddings, and so on. You can also set aside rooms for the event (block).<br /><br /> Compatible with OPERA Cloud release 22.3.<br /><br /><p> This document and all content within is available under the Universal Permissive License v 1.0 (https://oss.oracle.com/licenses/upl). Copyright (c) 2020, 2023 Oracle and/or its affiliates.</p>

API version: 22.3
Contact: hospitality_apis_ww_grp@oracle.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package blk

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// BlockApiService BlockApi service
type BlockApiService service

type BlockApiGetBlockRequest struct {
	ctx context.Context
	ApiService *BlockApiService
	blockId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	markAsRecentlyAccessed *bool
	fetchInstructions *[]string
	fetchAllocatedRoomTypes *bool
	startDate *string
	numberOfDays *float32
	roomAllocationCriteria *[]string
	roomTypes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockApiGetBlockRequest) Authorization(authorization string) BlockApiGetBlockRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r BlockApiGetBlockRequest) XAppKey(xAppKey string) BlockApiGetBlockRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockApiGetBlockRequest) XHotelid(xHotelid string) BlockApiGetBlockRequest {
	r.xHotelid = &xHotelid
	return r
}

// Mark this block as recently accessed.
func (r BlockApiGetBlockRequest) MarkAsRecentlyAccessed(markAsRecentlyAccessed bool) BlockApiGetBlockRequest {
	r.markAsRecentlyAccessed = &markAsRecentlyAccessed
	return r
}

// Type for block instructions that can be used in requests for partial operations.
func (r BlockApiGetBlockRequest) FetchInstructions(fetchInstructions []string) BlockApiGetBlockRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// Indicates whether to fetch only those room types that have rooms allocated. If this flag is true then only those room types with rooms allocated for the block are fetched. Only applicable to fetch instruction RateGrid.
func (r BlockApiGetBlockRequest) FetchAllocatedRoomTypes(fetchAllocatedRoomTypes bool) BlockApiGetBlockRequest {
	r.fetchAllocatedRoomTypes = &fetchAllocatedRoomTypes
	return r
}

// Start Date for the rate grid data. Only applicable to fetch instruction RateGrid.
func (r BlockApiGetBlockRequest) StartDate(startDate string) BlockApiGetBlockRequest {
	r.startDate = &startDate
	return r
}

// Number of days to fetch for the rate grid data. Only applicable to fetch instruction RateGrid.
func (r BlockApiGetBlockRequest) NumberOfDays(numberOfDays float32) BlockApiGetBlockRequest {
	r.numberOfDays = &numberOfDays
	return r
}

// Simple type for block allocation used in room rate grid.
func (r BlockApiGetBlockRequest) RoomAllocationCriteria(roomAllocationCriteria []string) BlockApiGetBlockRequest {
	r.roomAllocationCriteria = &roomAllocationCriteria
	return r
}

// The Room Types that need to be fetched for the rate room grid data. If these values are not provided, all room types for the block will be fetched.
func (r BlockApiGetBlockRequest) RoomTypes(roomTypes []string) BlockApiGetBlockRequest {
	r.roomTypes = &roomTypes
	return r
}

// External system code.
func (r BlockApiGetBlockRequest) XExternalsystem(xExternalsystem string) BlockApiGetBlockRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockApiGetBlockRequest) AcceptLanguage(acceptLanguage string) BlockApiGetBlockRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockApiGetBlockRequest) Execute() (*Block, *http.Response, error) {
	return r.ApiService.GetBlockExecute(r)
}

/*
GetBlock Get a Block By ID

Use this API to retrieve a specific block.  You will need to know the blockID in the request; if you don't know it, please go ahead and use getBlocks API first.  The response will include detailed information about the block. <p><strong>OperationId:</strong>getBlock</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockId Unique OPERA Block ID which is used to find a Block from OPERA. This ID is a primary identification of a Block in OPERA.
 @param hotelId Hotel Id
 @return BlockApiGetBlockRequest
*/
func (a *BlockApiService) GetBlock(ctx context.Context, blockId string, hotelId string) BlockApiGetBlockRequest {
	return BlockApiGetBlockRequest{
		ApiService: a,
		ctx: ctx,
		blockId: blockId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Block
func (a *BlockApiService) GetBlockExecute(r BlockApiGetBlockRequest) (*Block, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Block
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockApiService.GetBlock")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/blocks/{blockId}"
	localVarPath = strings.Replace(localVarPath, "{"+"blockId"+"}", url.PathEscape(parameterValueToString(r.blockId, "blockId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.blockId) < 1 {
		return localVarReturnValue, nil, reportError("blockId must have at least 1 elements")
	}
	if strlen(r.blockId) > 2000 {
		return localVarReturnValue, nil, reportError("blockId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.markAsRecentlyAccessed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "markAsRecentlyAccessed", r.markAsRecentlyAccessed, "")
	}
	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
	}
	if r.fetchAllocatedRoomTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetchAllocatedRoomTypes", r.fetchAllocatedRoomTypes, "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.numberOfDays != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "numberOfDays", r.numberOfDays, "")
	}
	if r.roomAllocationCriteria != nil {
		t := *r.roomAllocationCriteria
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomAllocationCriteria", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomAllocationCriteria", t, "multi")
		}
	}
	if r.roomTypes != nil {
		t := *r.roomTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomTypes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomTypes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockApiGetBlockAvailabilityRequest struct {
	ctx context.Context
	ApiService *BlockApiService
	blockId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	overrideRateCode *bool
	arrivalDate *string
	nights *int32
	adults *int32
	children *int32
	rooms *int32
	ratePlanCode *string
	existingReservationId *string
	existingReservationIdType *string
	roomType *[]string
	fetchAllocatedRoomType *[]string
	roomTypeCount *int32
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockApiGetBlockAvailabilityRequest) Authorization(authorization string) BlockApiGetBlockAvailabilityRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r BlockApiGetBlockAvailabilityRequest) XAppKey(xAppKey string) BlockApiGetBlockAvailabilityRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockApiGetBlockAvailabilityRequest) XHotelid(xHotelid string) BlockApiGetBlockAvailabilityRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r BlockApiGetBlockAvailabilityRequest) OverrideRateCode(overrideRateCode bool) BlockApiGetBlockAvailabilityRequest {
	r.overrideRateCode = &overrideRateCode
	return r
}

// Arrival date.
func (r BlockApiGetBlockAvailabilityRequest) ArrivalDate(arrivalDate string) BlockApiGetBlockAvailabilityRequest {
	r.arrivalDate = &arrivalDate
	return r
}

// Number of nights of stay.
func (r BlockApiGetBlockAvailabilityRequest) Nights(nights int32) BlockApiGetBlockAvailabilityRequest {
	r.nights = &nights
	return r
}

// Documentation goes here
func (r BlockApiGetBlockAvailabilityRequest) Adults(adults int32) BlockApiGetBlockAvailabilityRequest {
	r.adults = &adults
	return r
}

// Documentation goes here
func (r BlockApiGetBlockAvailabilityRequest) Children(children int32) BlockApiGetBlockAvailabilityRequest {
	r.children = &children
	return r
}

// Documentation goes here
func (r BlockApiGetBlockAvailabilityRequest) Rooms(rooms int32) BlockApiGetBlockAvailabilityRequest {
	r.rooms = &rooms
	return r
}

// Documentation goes here
func (r BlockApiGetBlockAvailabilityRequest) RatePlanCode(ratePlanCode string) BlockApiGetBlockAvailabilityRequest {
	r.ratePlanCode = &ratePlanCode
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r BlockApiGetBlockAvailabilityRequest) ExistingReservationId(existingReservationId string) BlockApiGetBlockAvailabilityRequest {
	r.existingReservationId = &existingReservationId
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r BlockApiGetBlockAvailabilityRequest) ExistingReservationIdType(existingReservationIdType string) BlockApiGetBlockAvailabilityRequest {
	r.existingReservationIdType = &existingReservationIdType
	return r
}

// Room type.
func (r BlockApiGetBlockAvailabilityRequest) RoomType(roomType []string) BlockApiGetBlockAvailabilityRequest {
	r.roomType = &roomType
	return r
}

// Instruction to determine room types to fetch.
func (r BlockApiGetBlockAvailabilityRequest) FetchAllocatedRoomType(fetchAllocatedRoomType []string) BlockApiGetBlockAvailabilityRequest {
	r.fetchAllocatedRoomType = &fetchAllocatedRoomType
	return r
}

// Criteria to fetch number of room type(s).
func (r BlockApiGetBlockAvailabilityRequest) RoomTypeCount(roomTypeCount int32) BlockApiGetBlockAvailabilityRequest {
	r.roomTypeCount = &roomTypeCount
	return r
}

// External system code.
func (r BlockApiGetBlockAvailabilityRequest) XExternalsystem(xExternalsystem string) BlockApiGetBlockAvailabilityRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockApiGetBlockAvailabilityRequest) AcceptLanguage(acceptLanguage string) BlockApiGetBlockAvailabilityRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockApiGetBlockAvailabilityRequest) Execute() (*BlockAvailability, *http.Response, error) {
	return r.ApiService.GetBlockAvailabilityExecute(r)
}

/*
GetBlockAvailability Get Block AvailaBility

Use this API to search for availability on an OPERA block.  You will need to know the block ID.  Once you know what rooms and rates are available you can proceed to post a block reservation. <p><strong>OperationId:</strong>getBlockAvailability</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockId Block Id
 @param hotelId Hotel Id
 @return BlockApiGetBlockAvailabilityRequest
*/
func (a *BlockApiService) GetBlockAvailability(ctx context.Context, blockId string, hotelId string) BlockApiGetBlockAvailabilityRequest {
	return BlockApiGetBlockAvailabilityRequest{
		ApiService: a,
		ctx: ctx,
		blockId: blockId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return BlockAvailability
func (a *BlockApiService) GetBlockAvailabilityExecute(r BlockApiGetBlockAvailabilityRequest) (*BlockAvailability, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BlockAvailability
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockApiService.GetBlockAvailability")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/blocks/{blockId}/availability"
	localVarPath = strings.Replace(localVarPath, "{"+"blockId"+"}", url.PathEscape(parameterValueToString(r.blockId, "blockId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.blockId) < 1 {
		return localVarReturnValue, nil, reportError("blockId must have at least 1 elements")
	}
	if strlen(r.blockId) > 2000 {
		return localVarReturnValue, nil, reportError("blockId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.overrideRateCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "overrideRateCode", r.overrideRateCode, "")
	}
	if r.arrivalDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "arrivalDate", r.arrivalDate, "")
	}
	if r.nights != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nights", r.nights, "")
	}
	if r.adults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adults", r.adults, "")
	}
	if r.children != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "children", r.children, "")
	}
	if r.rooms != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rooms", r.rooms, "")
	}
	if r.ratePlanCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanCode", r.ratePlanCode, "")
	}
	if r.existingReservationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "existingReservationId", r.existingReservationId, "")
	}
	if r.existingReservationIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "existingReservationIdType", r.existingReservationIdType, "")
	}
	if r.roomType != nil {
		t := *r.roomType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomType", t, "multi")
		}
	}
	if r.fetchAllocatedRoomType != nil {
		t := *r.fetchAllocatedRoomType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchAllocatedRoomType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchAllocatedRoomType", t, "multi")
		}
	}
	if r.roomTypeCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomTypeCount", r.roomTypeCount, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockApiGetBlockDailyStatisticsRequest struct {
	ctx context.Context
	ApiService *BlockApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	genericRoomType *bool
	limit *int32
	offset *int32
	hotelId *string
	end *string
	start *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockApiGetBlockDailyStatisticsRequest) Authorization(authorization string) BlockApiGetBlockDailyStatisticsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r BlockApiGetBlockDailyStatisticsRequest) XAppKey(xAppKey string) BlockApiGetBlockDailyStatisticsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockApiGetBlockDailyStatisticsRequest) XHotelid(xHotelid string) BlockApiGetBlockDailyStatisticsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates if the Allocation objects refer to Generic Room Types (Room Pools).
func (r BlockApiGetBlockDailyStatisticsRequest) GenericRoomType(genericRoomType bool) BlockApiGetBlockDailyStatisticsRequest {
	r.genericRoomType = &genericRoomType
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r BlockApiGetBlockDailyStatisticsRequest) Limit(limit int32) BlockApiGetBlockDailyStatisticsRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r BlockApiGetBlockDailyStatisticsRequest) Offset(offset int32) BlockApiGetBlockDailyStatisticsRequest {
	r.offset = &offset
	return r
}

// Pertain Hotel Code for search criteria.
func (r BlockApiGetBlockDailyStatisticsRequest) HotelId(hotelId string) BlockApiGetBlockDailyStatisticsRequest {
	r.hotelId = &hotelId
	return r
}

// The ending value of the date range.
func (r BlockApiGetBlockDailyStatisticsRequest) End(end string) BlockApiGetBlockDailyStatisticsRequest {
	r.end = &end
	return r
}

// The starting value of the date range.
func (r BlockApiGetBlockDailyStatisticsRequest) Start(start string) BlockApiGetBlockDailyStatisticsRequest {
	r.start = &start
	return r
}

// External system code.
func (r BlockApiGetBlockDailyStatisticsRequest) XExternalsystem(xExternalsystem string) BlockApiGetBlockDailyStatisticsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockApiGetBlockDailyStatisticsRequest) AcceptLanguage(acceptLanguage string) BlockApiGetBlockDailyStatisticsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockApiGetBlockDailyStatisticsRequest) Execute() (*BlockDailyStatistics, *http.Response, error) {
	return r.ApiService.GetBlockDailyStatisticsExecute(r)
}

/*
GetBlockDailyStatistics Get Block Daily Statistics

Use this API to retrieve block daily statistics for the given date range and hotel ID. It returns allocated, picked up, and available number of room nights per block, per day, per room type.<p><strong>OperationId:</strong>getBlockDailyStatistics</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return BlockApiGetBlockDailyStatisticsRequest
*/
func (a *BlockApiService) GetBlockDailyStatistics(ctx context.Context) BlockApiGetBlockDailyStatisticsRequest {
	return BlockApiGetBlockDailyStatisticsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BlockDailyStatistics
func (a *BlockApiService) GetBlockDailyStatisticsExecute(r BlockApiGetBlockDailyStatisticsRequest) (*BlockDailyStatistics, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BlockDailyStatistics
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockApiService.GetBlockDailyStatistics")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blocks/dailyStatistics"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.genericRoomType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "genericRoomType", r.genericRoomType, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
	}
	if r.end != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end", r.end, "")
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockApiGetBlockPMReservationsRequest struct {
	ctx context.Context
	ApiService *BlockApiService
	blockId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	postingmaster *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockApiGetBlockPMReservationsRequest) Authorization(authorization string) BlockApiGetBlockPMReservationsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r BlockApiGetBlockPMReservationsRequest) XAppKey(xAppKey string) BlockApiGetBlockPMReservationsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockApiGetBlockPMReservationsRequest) XHotelid(xHotelid string) BlockApiGetBlockPMReservationsRequest {
	r.xHotelid = &xHotelid
	return r
}

// If true, a PM reservation will be created for the block if no PM reservations exist.
func (r BlockApiGetBlockPMReservationsRequest) Postingmaster(postingmaster bool) BlockApiGetBlockPMReservationsRequest {
	r.postingmaster = &postingmaster
	return r
}

// External system code.
func (r BlockApiGetBlockPMReservationsRequest) XExternalsystem(xExternalsystem string) BlockApiGetBlockPMReservationsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockApiGetBlockPMReservationsRequest) AcceptLanguage(acceptLanguage string) BlockApiGetBlockPMReservationsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockApiGetBlockPMReservationsRequest) Execute() (*BlockPMReservations, *http.Response, error) {
	return r.ApiService.GetBlockPMReservationsExecute(r)
}

/*
GetBlockPMReservations Get Posting Master Reservations for a Block

Use this API to retrieve PM (Posting Master) reservations for a block. <p><strong>OperationId:</strong>getBlockPMReservations</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockId Block Id
 @param hotelId Hotel Id
 @return BlockApiGetBlockPMReservationsRequest
*/
func (a *BlockApiService) GetBlockPMReservations(ctx context.Context, blockId string, hotelId string) BlockApiGetBlockPMReservationsRequest {
	return BlockApiGetBlockPMReservationsRequest{
		ApiService: a,
		ctx: ctx,
		blockId: blockId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return BlockPMReservations
func (a *BlockApiService) GetBlockPMReservationsExecute(r BlockApiGetBlockPMReservationsRequest) (*BlockPMReservations, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BlockPMReservations
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockApiService.GetBlockPMReservations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/blocks/{blockId}/postingMaster/reservations"
	localVarPath = strings.Replace(localVarPath, "{"+"blockId"+"}", url.PathEscape(parameterValueToString(r.blockId, "blockId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.blockId) < 1 {
		return localVarReturnValue, nil, reportError("blockId must have at least 1 elements")
	}
	if strlen(r.blockId) > 2000 {
		return localVarReturnValue, nil, reportError("blockId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.postingmaster != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "postingmaster", r.postingmaster, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockApiGetBlockRevenueChangesRequest struct {
	ctx context.Context
	ApiService *BlockApiService
	blockId string
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	hotelId *string
	status *[]string
	changeEndDate *string
	changeStartDate *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockApiGetBlockRevenueChangesRequest) Authorization(authorization string) BlockApiGetBlockRevenueChangesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r BlockApiGetBlockRevenueChangesRequest) XAppKey(xAppKey string) BlockApiGetBlockRevenueChangesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockApiGetBlockRevenueChangesRequest) XHotelid(xHotelid string) BlockApiGetBlockRevenueChangesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r BlockApiGetBlockRevenueChangesRequest) Limit(limit int32) BlockApiGetBlockRevenueChangesRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r BlockApiGetBlockRevenueChangesRequest) Offset(offset int32) BlockApiGetBlockRevenueChangesRequest {
	r.offset = &offset
	return r
}

// Hotel code for this block.
func (r BlockApiGetBlockRevenueChangesRequest) HotelId(hotelId string) BlockApiGetBlockRevenueChangesRequest {
	r.hotelId = &hotelId
	return r
}

// Status of this block.
func (r BlockApiGetBlockRevenueChangesRequest) Status(status []string) BlockApiGetBlockRevenueChangesRequest {
	r.status = &status
	return r
}

// The ending value of the date range.
func (r BlockApiGetBlockRevenueChangesRequest) ChangeEndDate(changeEndDate string) BlockApiGetBlockRevenueChangesRequest {
	r.changeEndDate = &changeEndDate
	return r
}

// The starting value of the date range.
func (r BlockApiGetBlockRevenueChangesRequest) ChangeStartDate(changeStartDate string) BlockApiGetBlockRevenueChangesRequest {
	r.changeStartDate = &changeStartDate
	return r
}

// External system code.
func (r BlockApiGetBlockRevenueChangesRequest) XExternalsystem(xExternalsystem string) BlockApiGetBlockRevenueChangesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockApiGetBlockRevenueChangesRequest) AcceptLanguage(acceptLanguage string) BlockApiGetBlockRevenueChangesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockApiGetBlockRevenueChangesRequest) Execute() (*BlockRevenueChanges, *http.Response, error) {
	return r.ApiService.GetBlockRevenueChangesExecute(r)
}

/*
GetBlockRevenueChanges Fetch Block Revenue Changes

This API will fetch revenue changes for a specific block recorded in the revenue change log for a specified date range. Please note that the revenue changes are delta changes only and single records do not represent a total summary of the block revenue per date. <p><strong>OperationId:</strong>getBlockRevenueChanges</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockId Block Id
 @return BlockApiGetBlockRevenueChangesRequest
*/
func (a *BlockApiService) GetBlockRevenueChanges(ctx context.Context, blockId string) BlockApiGetBlockRevenueChangesRequest {
	return BlockApiGetBlockRevenueChangesRequest{
		ApiService: a,
		ctx: ctx,
		blockId: blockId,
	}
}

// Execute executes the request
//  @return BlockRevenueChanges
func (a *BlockApiService) GetBlockRevenueChangesExecute(r BlockApiGetBlockRevenueChangesRequest) (*BlockRevenueChanges, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BlockRevenueChanges
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockApiService.GetBlockRevenueChanges")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blocks/{blockId}/revenueActivityLog"
	localVarPath = strings.Replace(localVarPath, "{"+"blockId"+"}", url.PathEscape(parameterValueToString(r.blockId, "blockId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.blockId) < 1 {
		return localVarReturnValue, nil, reportError("blockId must have at least 1 elements")
	}
	if strlen(r.blockId) > 2000 {
		return localVarReturnValue, nil, reportError("blockId must have less than 2000 elements")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
	}
	if r.status != nil {
		t := *r.status
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status", t, "multi")
		}
	}
	if r.changeEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "changeEndDate", r.changeEndDate, "")
	}
	if r.changeStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "changeStartDate", r.changeStartDate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockApiGetBlockStatisticsRequest struct {
	ctx context.Context
	ApiService *BlockApiService
	blockId string
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelId *string
	startDate *string
	numberOfDays *int32
	statisticsInstructions *[]string
	roomTypeHotelId *[]string
	invBlockCode *[]string
	promotionCode *[]string
	roomCategory *[]string
	roomClass *[]string
	roomQualifierCode *[]string
	roomQualifierMatchIndicator *[]string
	roomType *[]string
	roomViewCode *[]string
	roomFeatureCode *[]string
	defaultOccupancy *int32
	maximumOccupancy *int32
	noOfPhysicalRooms *int32
	bookingChannelCode *[]string
	bookingChannelMappingCode *[]string
	bookingChannelMappingName *[]string
	bedTypeCode *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockApiGetBlockStatisticsRequest) Authorization(authorization string) BlockApiGetBlockStatisticsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r BlockApiGetBlockStatisticsRequest) XAppKey(xAppKey string) BlockApiGetBlockStatisticsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockApiGetBlockStatisticsRequest) XHotelid(xHotelid string) BlockApiGetBlockStatisticsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Hotel Code of the business block.
func (r BlockApiGetBlockStatisticsRequest) HotelId(hotelId string) BlockApiGetBlockStatisticsRequest {
	r.hotelId = &hotelId
	return r
}

// Start date for the statistics data.
func (r BlockApiGetBlockStatisticsRequest) StartDate(startDate string) BlockApiGetBlockStatisticsRequest {
	r.startDate = &startDate
	return r
}

// Number of days to fetch for statistics data.
func (r BlockApiGetBlockStatisticsRequest) NumberOfDays(numberOfDays int32) BlockApiGetBlockStatisticsRequest {
	r.numberOfDays = &numberOfDays
	return r
}

// Type of statistic for which its statistics information by date and room type will be populated.
func (r BlockApiGetBlockStatisticsRequest) StatisticsInstructions(statisticsInstructions []string) BlockApiGetBlockStatisticsRequest {
	r.statisticsInstructions = &statisticsInstructions
	return r
}

func (r BlockApiGetBlockStatisticsRequest) RoomTypeHotelId(roomTypeHotelId []string) BlockApiGetBlockStatisticsRequest {
	r.roomTypeHotelId = &roomTypeHotelId
	return r
}

// Block code.
func (r BlockApiGetBlockStatisticsRequest) InvBlockCode(invBlockCode []string) BlockApiGetBlockStatisticsRequest {
	r.invBlockCode = &invBlockCode
	return r
}

// Represents the promotional code.
func (r BlockApiGetBlockStatisticsRequest) PromotionCode(promotionCode []string) BlockApiGetBlockStatisticsRequest {
	r.promotionCode = &promotionCode
	return r
}

func (r BlockApiGetBlockStatisticsRequest) RoomCategory(roomCategory []string) BlockApiGetBlockStatisticsRequest {
	r.roomCategory = &roomCategory
	return r
}

func (r BlockApiGetBlockStatisticsRequest) RoomClass(roomClass []string) BlockApiGetBlockStatisticsRequest {
	r.roomClass = &roomClass
	return r
}

// Represents the room qualifier code like Deluxe,Economy,Suite etc.
func (r BlockApiGetBlockStatisticsRequest) RoomQualifierCode(roomQualifierCode []string) BlockApiGetBlockStatisticsRequest {
	r.roomQualifierCode = &roomQualifierCode
	return r
}

// Represents the match indicator of room qualifier code returned in the response with the requested room qualifier code.
func (r BlockApiGetBlockStatisticsRequest) RoomQualifierMatchIndicator(roomQualifierMatchIndicator []string) BlockApiGetBlockStatisticsRequest {
	r.roomQualifierMatchIndicator = &roomQualifierMatchIndicator
	return r
}

func (r BlockApiGetBlockStatisticsRequest) RoomType(roomType []string) BlockApiGetBlockStatisticsRequest {
	r.roomType = &roomType
	return r
}

// Represents the room view code like City view, River view, Ocean view etc.
func (r BlockApiGetBlockStatisticsRequest) RoomViewCode(roomViewCode []string) BlockApiGetBlockStatisticsRequest {
	r.roomViewCode = &roomViewCode
	return r
}

// A code representing a room feature.
func (r BlockApiGetBlockStatisticsRequest) RoomFeatureCode(roomFeatureCode []string) BlockApiGetBlockStatisticsRequest {
	r.roomFeatureCode = &roomFeatureCode
	return r
}

// Default occupancy of property room type.
func (r BlockApiGetBlockStatisticsRequest) DefaultOccupancy(defaultOccupancy int32) BlockApiGetBlockStatisticsRequest {
	r.defaultOccupancy = &defaultOccupancy
	return r
}

// Max occupancy of property room type.
func (r BlockApiGetBlockStatisticsRequest) MaximumOccupancy(maximumOccupancy int32) BlockApiGetBlockStatisticsRequest {
	r.maximumOccupancy = &maximumOccupancy
	return r
}

// Number of physical rooms of property room type.
func (r BlockApiGetBlockStatisticsRequest) NoOfPhysicalRooms(noOfPhysicalRooms int32) BlockApiGetBlockStatisticsRequest {
	r.noOfPhysicalRooms = &noOfPhysicalRooms
	return r
}

func (r BlockApiGetBlockStatisticsRequest) BookingChannelCode(bookingChannelCode []string) BlockApiGetBlockStatisticsRequest {
	r.bookingChannelCode = &bookingChannelCode
	return r
}

func (r BlockApiGetBlockStatisticsRequest) BookingChannelMappingCode(bookingChannelMappingCode []string) BlockApiGetBlockStatisticsRequest {
	r.bookingChannelMappingCode = &bookingChannelMappingCode
	return r
}

func (r BlockApiGetBlockStatisticsRequest) BookingChannelMappingName(bookingChannelMappingName []string) BlockApiGetBlockStatisticsRequest {
	r.bookingChannelMappingName = &bookingChannelMappingName
	return r
}

// Bed type code associated with room.
func (r BlockApiGetBlockStatisticsRequest) BedTypeCode(bedTypeCode []string) BlockApiGetBlockStatisticsRequest {
	r.bedTypeCode = &bedTypeCode
	return r
}

// External system code.
func (r BlockApiGetBlockStatisticsRequest) XExternalsystem(xExternalsystem string) BlockApiGetBlockStatisticsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockApiGetBlockStatisticsRequest) AcceptLanguage(acceptLanguage string) BlockApiGetBlockStatisticsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockApiGetBlockStatisticsRequest) Execute() (*BlockStatistics, *http.Response, error) {
	return r.ApiService.GetBlockStatisticsExecute(r)
}

/*
GetBlockStatistics Get Block Statistics

Use this API to API retrieve detailed block statistics <p><strong>OperationId:</strong>getBlockStatistics</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockId Block Id
 @return BlockApiGetBlockStatisticsRequest
*/
func (a *BlockApiService) GetBlockStatistics(ctx context.Context, blockId string) BlockApiGetBlockStatisticsRequest {
	return BlockApiGetBlockStatisticsRequest{
		ApiService: a,
		ctx: ctx,
		blockId: blockId,
	}
}

// Execute executes the request
//  @return BlockStatistics
func (a *BlockApiService) GetBlockStatisticsExecute(r BlockApiGetBlockStatisticsRequest) (*BlockStatistics, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BlockStatistics
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockApiService.GetBlockStatistics")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blocks/{blockId}/statistics"
	localVarPath = strings.Replace(localVarPath, "{"+"blockId"+"}", url.PathEscape(parameterValueToString(r.blockId, "blockId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.blockId) < 1 {
		return localVarReturnValue, nil, reportError("blockId must have at least 1 elements")
	}
	if strlen(r.blockId) > 2000 {
		return localVarReturnValue, nil, reportError("blockId must have less than 2000 elements")
	}

	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.numberOfDays != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "numberOfDays", r.numberOfDays, "")
	}
	if r.statisticsInstructions != nil {
		t := *r.statisticsInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "statisticsInstructions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "statisticsInstructions", t, "multi")
		}
	}
	if r.roomTypeHotelId != nil {
		t := *r.roomTypeHotelId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomTypeHotelId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomTypeHotelId", t, "multi")
		}
	}
	if r.invBlockCode != nil {
		t := *r.invBlockCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "invBlockCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "invBlockCode", t, "multi")
		}
	}
	if r.promotionCode != nil {
		t := *r.promotionCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "promotionCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "promotionCode", t, "multi")
		}
	}
	if r.roomCategory != nil {
		t := *r.roomCategory
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomCategory", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomCategory", t, "multi")
		}
	}
	if r.roomClass != nil {
		t := *r.roomClass
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomClass", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomClass", t, "multi")
		}
	}
	if r.roomQualifierCode != nil {
		t := *r.roomQualifierCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomQualifierCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomQualifierCode", t, "multi")
		}
	}
	if r.roomQualifierMatchIndicator != nil {
		t := *r.roomQualifierMatchIndicator
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomQualifierMatchIndicator", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomQualifierMatchIndicator", t, "multi")
		}
	}
	if r.roomType != nil {
		t := *r.roomType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomType", t, "multi")
		}
	}
	if r.roomViewCode != nil {
		t := *r.roomViewCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomViewCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomViewCode", t, "multi")
		}
	}
	if r.roomFeatureCode != nil {
		t := *r.roomFeatureCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomFeatureCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomFeatureCode", t, "multi")
		}
	}
	if r.defaultOccupancy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "defaultOccupancy", r.defaultOccupancy, "")
	}
	if r.maximumOccupancy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maximumOccupancy", r.maximumOccupancy, "")
	}
	if r.noOfPhysicalRooms != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "noOfPhysicalRooms", r.noOfPhysicalRooms, "")
	}
	if r.bookingChannelCode != nil {
		t := *r.bookingChannelCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "bookingChannelCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "bookingChannelCode", t, "multi")
		}
	}
	if r.bookingChannelMappingCode != nil {
		t := *r.bookingChannelMappingCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "bookingChannelMappingCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "bookingChannelMappingCode", t, "multi")
		}
	}
	if r.bookingChannelMappingName != nil {
		t := *r.bookingChannelMappingName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "bookingChannelMappingName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "bookingChannelMappingName", t, "multi")
		}
	}
	if r.bedTypeCode != nil {
		t := *r.bedTypeCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "bedTypeCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "bedTypeCode", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockApiGetBlocksRequest struct {
	ctx context.Context
	ApiService *BlockApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelId *string
	markAsRecentlyAccessed *bool
	limit *int32
	offset *int32
	multipleHotelsSearchHotelIds *[]string
	superSearch *string
	blockIdList *[]string
	blockIdType *[]string
	externalReferenceIds *[]string
	externalSystemCodes *[]string
	blockCode *string
	blockName *string
	blockOwner *[]string
	blockStatus *[]string
	cateringStatus *[]string
	createdByUser *string
	blockStartEndDate *string
	blockStartStartDate *string
	blockEndEndDate *string
	blockEndStartDate *string
	reservationArrival *string
	reservationDeparture *string
	includeShoulderDates *bool
	stayDate *string
	blockCreatedOnEndDate *string
	blockCreatedOnStartDate *string
	decisionEndDate *string
	decisionStartDate *string
	cutOffEndDate *string
	cutOffStartDate *string
	category *[]string
	name *[]string
	attachedProfileId *string
	attachedProfileIdType *string
	leads *bool
	tourSeries *bool
	onlyPickupBlocks *bool
	onlyOpportunities *bool
	ratePlanCode *[]string
	tourCode *string
	attributeName *[]string
	orderType *[]string
	fetchInstructions *[]string
	fetchAllocatedRoomTypes *bool
	additionalCriteriaStartDate *string
	numberOfDays *float32
	adults *int32
	children *int32
	childAge *[]int32
	bucket1Count *int32
	bucket2Count *int32
	bucket3Count *int32
	bucket4Count *int32
	bucket5Count *int32
	existingReservationId *string
	existingReservationIdType *string
	roomAllocationCriteria *[]string
	roomType *[]string
	additionalCriteriaRatePlanCode *string
	currencyCode *string
	customCharUDFsAltname *[]string
	customCharUDFsName *[]string
	customCharUDFsValue *[]string
	customNumericUDFsAltname *[]string
	customNumericUDFsName *[]string
	customNumericUDFsValue *[]float32
	customDateUDFsAltname *[]string
	customDateUDFsName *[]string
	customDateUDFsValue *[]string
	accessRestriction *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockApiGetBlocksRequest) Authorization(authorization string) BlockApiGetBlocksRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r BlockApiGetBlocksRequest) XAppKey(xAppKey string) BlockApiGetBlocksRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockApiGetBlocksRequest) XHotelid(xHotelid string) BlockApiGetBlocksRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r BlockApiGetBlocksRequest) HotelId(hotelId string) BlockApiGetBlocksRequest {
	r.hotelId = &hotelId
	return r
}

// Mark this block as recently accessed.
func (r BlockApiGetBlocksRequest) MarkAsRecentlyAccessed(markAsRecentlyAccessed bool) BlockApiGetBlocksRequest {
	r.markAsRecentlyAccessed = &markAsRecentlyAccessed
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r BlockApiGetBlocksRequest) Limit(limit int32) BlockApiGetBlocksRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r BlockApiGetBlocksRequest) Offset(offset int32) BlockApiGetBlocksRequest {
	r.offset = &offset
	return r
}

// Hotel code.
func (r BlockApiGetBlocksRequest) MultipleHotelsSearchHotelIds(multipleHotelsSearchHotelIds []string) BlockApiGetBlocksRequest {
	r.multipleHotelsSearchHotelIds = &multipleHotelsSearchHotelIds
	return r
}

// Free form text field for searching block fields
func (r BlockApiGetBlocksRequest) SuperSearch(superSearch string) BlockApiGetBlocksRequest {
	r.superSearch = &superSearch
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r BlockApiGetBlocksRequest) BlockIdList(blockIdList []string) BlockApiGetBlocksRequest {
	r.blockIdList = &blockIdList
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r BlockApiGetBlocksRequest) BlockIdType(blockIdType []string) BlockApiGetBlocksRequest {
	r.blockIdType = &blockIdType
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r BlockApiGetBlocksRequest) ExternalReferenceIds(externalReferenceIds []string) BlockApiGetBlocksRequest {
	r.externalReferenceIds = &externalReferenceIds
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r BlockApiGetBlocksRequest) ExternalSystemCodes(externalSystemCodes []string) BlockApiGetBlocksRequest {
	r.externalSystemCodes = &externalSystemCodes
	return r
}

// Block code
func (r BlockApiGetBlocksRequest) BlockCode(blockCode string) BlockApiGetBlocksRequest {
	r.blockCode = &blockCode
	return r
}

// Block Name
func (r BlockApiGetBlocksRequest) BlockName(blockName string) BlockApiGetBlocksRequest {
	r.blockName = &blockName
	return r
}

// Block Owner.
func (r BlockApiGetBlocksRequest) BlockOwner(blockOwner []string) BlockApiGetBlocksRequest {
	r.blockOwner = &blockOwner
	return r
}

// Block Status.
func (r BlockApiGetBlocksRequest) BlockStatus(blockStatus []string) BlockApiGetBlocksRequest {
	r.blockStatus = &blockStatus
	return r
}

// Catering Status.
func (r BlockApiGetBlocksRequest) CateringStatus(cateringStatus []string) BlockApiGetBlocksRequest {
	r.cateringStatus = &cateringStatus
	return r
}

// user who created the Block(s).
func (r BlockApiGetBlocksRequest) CreatedByUser(createdByUser string) BlockApiGetBlocksRequest {
	r.createdByUser = &createdByUser
	return r
}

// The ending value of the date range.
func (r BlockApiGetBlocksRequest) BlockStartEndDate(blockStartEndDate string) BlockApiGetBlocksRequest {
	r.blockStartEndDate = &blockStartEndDate
	return r
}

// The starting value of the date range.
func (r BlockApiGetBlocksRequest) BlockStartStartDate(blockStartStartDate string) BlockApiGetBlocksRequest {
	r.blockStartStartDate = &blockStartStartDate
	return r
}

// The ending value of the date range.
func (r BlockApiGetBlocksRequest) BlockEndEndDate(blockEndEndDate string) BlockApiGetBlocksRequest {
	r.blockEndEndDate = &blockEndEndDate
	return r
}

// The starting value of the date range.
func (r BlockApiGetBlocksRequest) BlockEndStartDate(blockEndStartDate string) BlockApiGetBlocksRequest {
	r.blockEndStartDate = &blockEndStartDate
	return r
}

// Date when guests plan to arrive(first night stay date).
func (r BlockApiGetBlocksRequest) ReservationArrival(reservationArrival string) BlockApiGetBlocksRequest {
	r.reservationArrival = &reservationArrival
	return r
}

// Date when guests plan to leave(last stay day date).
func (r BlockApiGetBlocksRequest) ReservationDeparture(reservationDeparture string) BlockApiGetBlocksRequest {
	r.reservationDeparture = &reservationDeparture
	return r
}

// Whether to include shoulder dates when considering stay date.
func (r BlockApiGetBlocksRequest) IncludeShoulderDates(includeShoulderDates bool) BlockApiGetBlocksRequest {
	r.includeShoulderDates = &includeShoulderDates
	return r
}

func (r BlockApiGetBlocksRequest) StayDate(stayDate string) BlockApiGetBlocksRequest {
	r.stayDate = &stayDate
	return r
}

// The ending value of the date range.
func (r BlockApiGetBlocksRequest) BlockCreatedOnEndDate(blockCreatedOnEndDate string) BlockApiGetBlocksRequest {
	r.blockCreatedOnEndDate = &blockCreatedOnEndDate
	return r
}

// The starting value of the date range.
func (r BlockApiGetBlocksRequest) BlockCreatedOnStartDate(blockCreatedOnStartDate string) BlockApiGetBlocksRequest {
	r.blockCreatedOnStartDate = &blockCreatedOnStartDate
	return r
}

// The ending value of the date range.
func (r BlockApiGetBlocksRequest) DecisionEndDate(decisionEndDate string) BlockApiGetBlocksRequest {
	r.decisionEndDate = &decisionEndDate
	return r
}

// The starting value of the date range.
func (r BlockApiGetBlocksRequest) DecisionStartDate(decisionStartDate string) BlockApiGetBlocksRequest {
	r.decisionStartDate = &decisionStartDate
	return r
}

// The ending value of the date range.
func (r BlockApiGetBlocksRequest) CutOffEndDate(cutOffEndDate string) BlockApiGetBlocksRequest {
	r.cutOffEndDate = &cutOffEndDate
	return r
}

// The starting value of the date range.
func (r BlockApiGetBlocksRequest) CutOffStartDate(cutOffStartDate string) BlockApiGetBlocksRequest {
	r.cutOffStartDate = &cutOffStartDate
	return r
}

// Simple type for block instructions to be used in requests for fetching blocks. Valid status values are Group, Source, TravelAgent, Contact, Company.
func (r BlockApiGetBlocksRequest) Category(category []string) BlockApiGetBlocksRequest {
	r.category = &category
	return r
}

// Attached profile name
func (r BlockApiGetBlocksRequest) Name(name []string) BlockApiGetBlocksRequest {
	r.name = &name
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r BlockApiGetBlocksRequest) AttachedProfileId(attachedProfileId string) BlockApiGetBlocksRequest {
	r.attachedProfileId = &attachedProfileId
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r BlockApiGetBlocksRequest) AttachedProfileIdType(attachedProfileIdType string) BlockApiGetBlocksRequest {
	r.attachedProfileIdType = &attachedProfileIdType
	return r
}

// Show Leads in the search result.
func (r BlockApiGetBlocksRequest) Leads(leads bool) BlockApiGetBlocksRequest {
	r.leads = &leads
	return r
}

// Show tour series in the search result.
func (r BlockApiGetBlocksRequest) TourSeries(tourSeries bool) BlockApiGetBlocksRequest {
	r.tourSeries = &tourSeries
	return r
}

// Fetch only blocks which are open for pickup, if true. If the value is false, fetch all block statuses.
func (r BlockApiGetBlocksRequest) OnlyPickupBlocks(onlyPickupBlocks bool) BlockApiGetBlocksRequest {
	r.onlyPickupBlocks = &onlyPickupBlocks
	return r
}

// Indicates that only Opportunity blocks will be fetched.
func (r BlockApiGetBlocksRequest) OnlyOpportunities(onlyOpportunities bool) BlockApiGetBlocksRequest {
	r.onlyOpportunities = &onlyOpportunities
	return r
}

// Rate Plan Code.
func (r BlockApiGetBlocksRequest) RatePlanCode(ratePlanCode []string) BlockApiGetBlocksRequest {
	r.ratePlanCode = &ratePlanCode
	return r
}

// Tour code for the block.
func (r BlockApiGetBlocksRequest) TourCode(tourCode string) BlockApiGetBlocksRequest {
	r.tourCode = &tourCode
	return r
}

func (r BlockApiGetBlocksRequest) AttributeName(attributeName []string) BlockApiGetBlocksRequest {
	r.attributeName = &attributeName
	return r
}

func (r BlockApiGetBlocksRequest) OrderType(orderType []string) BlockApiGetBlocksRequest {
	r.orderType = &orderType
	return r
}

// Type for block instructions that can be used in requests for partial operations.
func (r BlockApiGetBlocksRequest) FetchInstructions(fetchInstructions []string) BlockApiGetBlocksRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// Indicates whether to fetch only those room types that have rooms allocated. If this flag is true then only those room types with rooms allocated for the block are fetched. Only applicable to fetch instruction RateGrid.
func (r BlockApiGetBlocksRequest) FetchAllocatedRoomTypes(fetchAllocatedRoomTypes bool) BlockApiGetBlocksRequest {
	r.fetchAllocatedRoomTypes = &fetchAllocatedRoomTypes
	return r
}

// Start Date for the rate grid data. Only applicable to fetch instruction RateGrid.
func (r BlockApiGetBlocksRequest) AdditionalCriteriaStartDate(additionalCriteriaStartDate string) BlockApiGetBlocksRequest {
	r.additionalCriteriaStartDate = &additionalCriteriaStartDate
	return r
}

// Number of days to fetch for the rate grid data. Only applicable to fetch instruction RateGrid.
func (r BlockApiGetBlocksRequest) NumberOfDays(numberOfDays float32) BlockApiGetBlocksRequest {
	r.numberOfDays = &numberOfDays
	return r
}

// Defines the number of Adults.
func (r BlockApiGetBlocksRequest) Adults(adults int32) BlockApiGetBlocksRequest {
	r.adults = &adults
	return r
}

// Defines the number of Children.
func (r BlockApiGetBlocksRequest) Children(children int32) BlockApiGetBlocksRequest {
	r.children = &children
	return r
}

// Age of a child in years.
func (r BlockApiGetBlocksRequest) ChildAge(childAge []int32) BlockApiGetBlocksRequest {
	r.childAge = &childAge
	return r
}

// Number of children classified under the first Age Qualifying Group(Child Bucket#1).
func (r BlockApiGetBlocksRequest) Bucket1Count(bucket1Count int32) BlockApiGetBlocksRequest {
	r.bucket1Count = &bucket1Count
	return r
}

// Number of children classified under the second Age Qualifying Group(Child Bucket#2).
func (r BlockApiGetBlocksRequest) Bucket2Count(bucket2Count int32) BlockApiGetBlocksRequest {
	r.bucket2Count = &bucket2Count
	return r
}

// Number of children classified under the third Age Qualifying Group(Child Bucket#3).
func (r BlockApiGetBlocksRequest) Bucket3Count(bucket3Count int32) BlockApiGetBlocksRequest {
	r.bucket3Count = &bucket3Count
	return r
}

// Number of children classified under the fourth Age Qualifying Group(Child Bucket#4).
func (r BlockApiGetBlocksRequest) Bucket4Count(bucket4Count int32) BlockApiGetBlocksRequest {
	r.bucket4Count = &bucket4Count
	return r
}

// Number of children classified under the fifth Age Qualifying Group(Child Bucket#5).
func (r BlockApiGetBlocksRequest) Bucket5Count(bucket5Count int32) BlockApiGetBlocksRequest {
	r.bucket5Count = &bucket5Count
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r BlockApiGetBlocksRequest) ExistingReservationId(existingReservationId string) BlockApiGetBlocksRequest {
	r.existingReservationId = &existingReservationId
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r BlockApiGetBlocksRequest) ExistingReservationIdType(existingReservationIdType string) BlockApiGetBlocksRequest {
	r.existingReservationIdType = &existingReservationIdType
	return r
}

// Simple type for block allocation used in room rate grid.
func (r BlockApiGetBlocksRequest) RoomAllocationCriteria(roomAllocationCriteria []string) BlockApiGetBlocksRequest {
	r.roomAllocationCriteria = &roomAllocationCriteria
	return r
}

// The Room Types that need to be fetched for the rate room grid data. If these values are not provided, all room types for the block will be fetched.
func (r BlockApiGetBlocksRequest) RoomType(roomType []string) BlockApiGetBlocksRequest {
	r.roomType = &roomType
	return r
}

// Rate Plan to use for fetching rates.
func (r BlockApiGetBlocksRequest) AdditionalCriteriaRatePlanCode(additionalCriteriaRatePlanCode string) BlockApiGetBlocksRequest {
	r.additionalCriteriaRatePlanCode = &additionalCriteriaRatePlanCode
	return r
}

// Curency in which the grid rates should be fetched.
func (r BlockApiGetBlocksRequest) CurrencyCode(currencyCode string) BlockApiGetBlocksRequest {
	r.currencyCode = &currencyCode
	return r
}

// Label of user defined field used by vendors or customers.
func (r BlockApiGetBlocksRequest) CustomCharUDFsAltname(customCharUDFsAltname []string) BlockApiGetBlocksRequest {
	r.customCharUDFsAltname = &customCharUDFsAltname
	return r
}

// Used to hold user defined field of Character Type. It is highly recommended to use UDFC01, UDFC02,...UDFC40 (Total 40) as Character/String UDF names(commonly used on Reservation, Profile etc.). Name is not restricted using enumeration, to provide flexibility of different name usage if required.
func (r BlockApiGetBlocksRequest) CustomCharUDFsName(customCharUDFsName []string) BlockApiGetBlocksRequest {
	r.customCharUDFsName = &customCharUDFsName
	return r
}

// Value of user defined field.
func (r BlockApiGetBlocksRequest) CustomCharUDFsValue(customCharUDFsValue []string) BlockApiGetBlocksRequest {
	r.customCharUDFsValue = &customCharUDFsValue
	return r
}

// Label of user defined field used by vendors or customers.
func (r BlockApiGetBlocksRequest) CustomNumericUDFsAltname(customNumericUDFsAltname []string) BlockApiGetBlocksRequest {
	r.customNumericUDFsAltname = &customNumericUDFsAltname
	return r
}

// Name of user defined field.
func (r BlockApiGetBlocksRequest) CustomNumericUDFsName(customNumericUDFsName []string) BlockApiGetBlocksRequest {
	r.customNumericUDFsName = &customNumericUDFsName
	return r
}

// Value of user defined field.
func (r BlockApiGetBlocksRequest) CustomNumericUDFsValue(customNumericUDFsValue []float32) BlockApiGetBlocksRequest {
	r.customNumericUDFsValue = &customNumericUDFsValue
	return r
}

// Label of user defined field used by vendors or customers.
func (r BlockApiGetBlocksRequest) CustomDateUDFsAltname(customDateUDFsAltname []string) BlockApiGetBlocksRequest {
	r.customDateUDFsAltname = &customDateUDFsAltname
	return r
}

// Used to hold user defined field of Date Type. It is highly recommended to use UDFD01, UDFD02,...UDFN20 (Total 20) as Date UDF names(commonly used on Reservation, Profile etc.). Name is not restricted using enumeration, to provide flexibility of different name usage if required.
func (r BlockApiGetBlocksRequest) CustomDateUDFsName(customDateUDFsName []string) BlockApiGetBlocksRequest {
	r.customDateUDFsName = &customDateUDFsName
	return r
}

// Value of user defined field.
func (r BlockApiGetBlocksRequest) CustomDateUDFsValue(customDateUDFsValue []string) BlockApiGetBlocksRequest {
	r.customDateUDFsValue = &customDateUDFsValue
	return r
}

// Simple type for block access exclusion/restriction types.
func (r BlockApiGetBlocksRequest) AccessRestriction(accessRestriction []string) BlockApiGetBlocksRequest {
	r.accessRestriction = &accessRestriction
	return r
}

// External system code.
func (r BlockApiGetBlocksRequest) XExternalsystem(xExternalsystem string) BlockApiGetBlocksRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockApiGetBlocksRequest) AcceptLanguage(acceptLanguage string) BlockApiGetBlocksRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockApiGetBlocksRequest) Execute() (*BlockSummaries, *http.Response, error) {
	return r.ApiService.GetBlocksExecute(r)
}

/*
GetBlocks Get Blocks

Use this API to retrieve blocks.  You can use the query parameters to narrow down your results. <p><strong>OperationId:</strong>getBlocks</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return BlockApiGetBlocksRequest
*/
func (a *BlockApiService) GetBlocks(ctx context.Context) BlockApiGetBlocksRequest {
	return BlockApiGetBlocksRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BlockSummaries
func (a *BlockApiService) GetBlocksExecute(r BlockApiGetBlocksRequest) (*BlockSummaries, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BlockSummaries
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockApiService.GetBlocks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blocks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
	}
	if r.markAsRecentlyAccessed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "markAsRecentlyAccessed", r.markAsRecentlyAccessed, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.multipleHotelsSearchHotelIds != nil {
		t := *r.multipleHotelsSearchHotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "multipleHotelsSearchHotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "multipleHotelsSearchHotelIds", t, "multi")
		}
	}
	if r.superSearch != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "superSearch", r.superSearch, "")
	}
	if r.blockIdList != nil {
		t := *r.blockIdList
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "blockIdList", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "blockIdList", t, "multi")
		}
	}
	if r.blockIdType != nil {
		t := *r.blockIdType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "blockIdType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "blockIdType", t, "multi")
		}
	}
	if r.externalReferenceIds != nil {
		t := *r.externalReferenceIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "externalReferenceIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "externalReferenceIds", t, "multi")
		}
	}
	if r.externalSystemCodes != nil {
		t := *r.externalSystemCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "externalSystemCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "externalSystemCodes", t, "multi")
		}
	}
	if r.blockCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blockCode", r.blockCode, "")
	}
	if r.blockName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blockName", r.blockName, "")
	}
	if r.blockOwner != nil {
		t := *r.blockOwner
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "blockOwner", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "blockOwner", t, "multi")
		}
	}
	if r.blockStatus != nil {
		t := *r.blockStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "blockStatus", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "blockStatus", t, "multi")
		}
	}
	if r.cateringStatus != nil {
		t := *r.cateringStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "cateringStatus", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "cateringStatus", t, "multi")
		}
	}
	if r.createdByUser != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createdByUser", r.createdByUser, "")
	}
	if r.blockStartEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blockStartEndDate", r.blockStartEndDate, "")
	}
	if r.blockStartStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blockStartStartDate", r.blockStartStartDate, "")
	}
	if r.blockEndEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blockEndEndDate", r.blockEndEndDate, "")
	}
	if r.blockEndStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blockEndStartDate", r.blockEndStartDate, "")
	}
	if r.reservationArrival != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationArrival", r.reservationArrival, "")
	}
	if r.reservationDeparture != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationDeparture", r.reservationDeparture, "")
	}
	if r.includeShoulderDates != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeShoulderDates", r.includeShoulderDates, "")
	}
	if r.stayDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stayDate", r.stayDate, "")
	}
	if r.blockCreatedOnEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blockCreatedOnEndDate", r.blockCreatedOnEndDate, "")
	}
	if r.blockCreatedOnStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blockCreatedOnStartDate", r.blockCreatedOnStartDate, "")
	}
	if r.decisionEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "decisionEndDate", r.decisionEndDate, "")
	}
	if r.decisionStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "decisionStartDate", r.decisionStartDate, "")
	}
	if r.cutOffEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cutOffEndDate", r.cutOffEndDate, "")
	}
	if r.cutOffStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cutOffStartDate", r.cutOffStartDate, "")
	}
	if r.category != nil {
		t := *r.category
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "category", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "category", t, "multi")
		}
	}
	if r.name != nil {
		t := *r.name
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name", t, "multi")
		}
	}
	if r.attachedProfileId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attachedProfileId", r.attachedProfileId, "")
	}
	if r.attachedProfileIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attachedProfileIdType", r.attachedProfileIdType, "")
	}
	if r.leads != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "leads", r.leads, "")
	}
	if r.tourSeries != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tourSeries", r.tourSeries, "")
	}
	if r.onlyPickupBlocks != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "onlyPickupBlocks", r.onlyPickupBlocks, "")
	}
	if r.onlyOpportunities != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "onlyOpportunities", r.onlyOpportunities, "")
	}
	if r.ratePlanCode != nil {
		t := *r.ratePlanCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanCode", t, "multi")
		}
	}
	if r.tourCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tourCode", r.tourCode, "")
	}
	if r.attributeName != nil {
		t := *r.attributeName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "attributeName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "attributeName", t, "multi")
		}
	}
	if r.orderType != nil {
		t := *r.orderType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "orderType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "orderType", t, "multi")
		}
	}
	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
	}
	if r.fetchAllocatedRoomTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetchAllocatedRoomTypes", r.fetchAllocatedRoomTypes, "")
	}
	if r.additionalCriteriaStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "additionalCriteriaStartDate", r.additionalCriteriaStartDate, "")
	}
	if r.numberOfDays != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "numberOfDays", r.numberOfDays, "")
	}
	if r.adults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adults", r.adults, "")
	}
	if r.children != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "children", r.children, "")
	}
	if r.childAge != nil {
		t := *r.childAge
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "childAge", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "childAge", t, "multi")
		}
	}
	if r.bucket1Count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bucket1Count", r.bucket1Count, "")
	}
	if r.bucket2Count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bucket2Count", r.bucket2Count, "")
	}
	if r.bucket3Count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bucket3Count", r.bucket3Count, "")
	}
	if r.bucket4Count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bucket4Count", r.bucket4Count, "")
	}
	if r.bucket5Count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bucket5Count", r.bucket5Count, "")
	}
	if r.existingReservationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "existingReservationId", r.existingReservationId, "")
	}
	if r.existingReservationIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "existingReservationIdType", r.existingReservationIdType, "")
	}
	if r.roomAllocationCriteria != nil {
		t := *r.roomAllocationCriteria
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomAllocationCriteria", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomAllocationCriteria", t, "multi")
		}
	}
	if r.roomType != nil {
		t := *r.roomType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomType", t, "multi")
		}
	}
	if r.additionalCriteriaRatePlanCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "additionalCriteriaRatePlanCode", r.additionalCriteriaRatePlanCode, "")
	}
	if r.currencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currencyCode", r.currencyCode, "")
	}
	if r.customCharUDFsAltname != nil {
		t := *r.customCharUDFsAltname
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "customCharUDFsAltname", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "customCharUDFsAltname", t, "multi")
		}
	}
	if r.customCharUDFsName != nil {
		t := *r.customCharUDFsName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "customCharUDFsName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "customCharUDFsName", t, "multi")
		}
	}
	if r.customCharUDFsValue != nil {
		t := *r.customCharUDFsValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "customCharUDFsValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "customCharUDFsValue", t, "multi")
		}
	}
	if r.customNumericUDFsAltname != nil {
		t := *r.customNumericUDFsAltname
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "customNumericUDFsAltname", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "customNumericUDFsAltname", t, "multi")
		}
	}
	if r.customNumericUDFsName != nil {
		t := *r.customNumericUDFsName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "customNumericUDFsName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "customNumericUDFsName", t, "multi")
		}
	}
	if r.customNumericUDFsValue != nil {
		t := *r.customNumericUDFsValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "customNumericUDFsValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "customNumericUDFsValue", t, "multi")
		}
	}
	if r.customDateUDFsAltname != nil {
		t := *r.customDateUDFsAltname
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "customDateUDFsAltname", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "customDateUDFsAltname", t, "multi")
		}
	}
	if r.customDateUDFsName != nil {
		t := *r.customDateUDFsName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "customDateUDFsName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "customDateUDFsName", t, "multi")
		}
	}
	if r.customDateUDFsValue != nil {
		t := *r.customDateUDFsValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "customDateUDFsValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "customDateUDFsValue", t, "multi")
		}
	}
	if r.accessRestriction != nil {
		t := *r.accessRestriction
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "accessRestriction", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "accessRestriction", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockApiPostBlockRequest struct {
	ctx context.Context
	ApiService *BlockApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	block *PostBlockRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockApiPostBlockRequest) Authorization(authorization string) BlockApiPostBlockRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r BlockApiPostBlockRequest) XAppKey(xAppKey string) BlockApiPostBlockRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockApiPostBlockRequest) XHotelid(xHotelid string) BlockApiPostBlockRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creation of blocks. This object contains block details with unique identifiers for each block. The standard optional Opera Context element is also included.
func (r BlockApiPostBlockRequest) Block(block PostBlockRequest) BlockApiPostBlockRequest {
	r.block = &block
	return r
}

// External system code.
func (r BlockApiPostBlockRequest) XExternalsystem(xExternalsystem string) BlockApiPostBlockRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockApiPostBlockRequest) AcceptLanguage(acceptLanguage string) BlockApiPostBlockRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockApiPostBlockRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostBlockExecute(r)
}

/*
PostBlock Create a Block

Use this API to create a new group block in OPERA Cloud. You must first use the ListOfValues APIs to find block attributes, such as Block Status, Room Types, and so on. Knowing this list of values helps ensure a successful postBlock. <p><strong>OperationId:</strong>postBlock</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Hotel Id
 @return BlockApiPostBlockRequest
*/
func (a *BlockApiService) PostBlock(ctx context.Context, hotelId string) BlockApiPostBlockRequest {
	return BlockApiPostBlockRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *BlockApiService) PostBlockExecute(r BlockApiPostBlockRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockApiService.PostBlock")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/block"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.block
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockApiPutBlockRequest struct {
	ctx context.Context
	ApiService *BlockApiService
	blockId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	blockToBeChanged *PutBlockRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockApiPutBlockRequest) Authorization(authorization string) BlockApiPutBlockRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r BlockApiPutBlockRequest) XAppKey(xAppKey string) BlockApiPutBlockRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockApiPutBlockRequest) XHotelid(xHotelid string) BlockApiPutBlockRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for change/modification of block details. This object contains modified block details with unique identifiers for each block. The standard optional Opera Context element is also included.
func (r BlockApiPutBlockRequest) BlockToBeChanged(blockToBeChanged PutBlockRequest) BlockApiPutBlockRequest {
	r.blockToBeChanged = &blockToBeChanged
	return r
}

// External system code.
func (r BlockApiPutBlockRequest) XExternalsystem(xExternalsystem string) BlockApiPutBlockRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockApiPutBlockRequest) AcceptLanguage(acceptLanguage string) BlockApiPutBlockRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockApiPutBlockRequest) Execute() (*BlockChanged, *http.Response, error) {
	return r.ApiService.PutBlockExecute(r)
}

/*
PutBlock Change a Block

Use this API to update an existing group block in OPERA Cloud. This API allows update of block header information, such as description, market segment, source code, rate code, and other details, but does not include updates for room grid or events, which have their own update API calls. <p><strong>OperationId:</strong>putBlock</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockId Block Id
 @param hotelId Hotel Id
 @return BlockApiPutBlockRequest
*/
func (a *BlockApiService) PutBlock(ctx context.Context, blockId string, hotelId string) BlockApiPutBlockRequest {
	return BlockApiPutBlockRequest{
		ApiService: a,
		ctx: ctx,
		blockId: blockId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return BlockChanged
func (a *BlockApiService) PutBlockExecute(r BlockApiPutBlockRequest) (*BlockChanged, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BlockChanged
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockApiService.PutBlock")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/blocks/{blockId}"
	localVarPath = strings.Replace(localVarPath, "{"+"blockId"+"}", url.PathEscape(parameterValueToString(r.blockId, "blockId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.blockId) < 1 {
		return localVarReturnValue, nil, reportError("blockId must have at least 1 elements")
	}
	if strlen(r.blockId) > 2000 {
		return localVarReturnValue, nil, reportError("blockId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.blockToBeChanged
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockApiPutBlockAllocationRequest struct {
	ctx context.Context
	ApiService *BlockApiService
	blockId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	allocation *PutBlockAllocationRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockApiPutBlockAllocationRequest) Authorization(authorization string) BlockApiPutBlockAllocationRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r BlockApiPutBlockAllocationRequest) XAppKey(xAppKey string) BlockApiPutBlockAllocationRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockApiPutBlockAllocationRequest) XHotelid(xHotelid string) BlockApiPutBlockAllocationRequest {
	r.xHotelid = &xHotelid
	return r
}

// A Request message that sets the room allocations as a collection of room types and dates.
func (r BlockApiPutBlockAllocationRequest) Allocation(allocation PutBlockAllocationRequest) BlockApiPutBlockAllocationRequest {
	r.allocation = &allocation
	return r
}

// External system code.
func (r BlockApiPutBlockAllocationRequest) XExternalsystem(xExternalsystem string) BlockApiPutBlockAllocationRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockApiPutBlockAllocationRequest) AcceptLanguage(acceptLanguage string) BlockApiPutBlockAllocationRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockApiPutBlockAllocationRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutBlockAllocationExecute(r)
}

/*
PutBlockAllocation Set Block Allocation  

Use this API to add block room type allocations and rates to a specified Block. <p><strong>OperationId:</strong>putBlockAllocation</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockId Block Id
 @param hotelId Hotel Id
 @return BlockApiPutBlockAllocationRequest
*/
func (a *BlockApiService) PutBlockAllocation(ctx context.Context, blockId string, hotelId string) BlockApiPutBlockAllocationRequest {
	return BlockApiPutBlockAllocationRequest{
		ApiService: a,
		ctx: ctx,
		blockId: blockId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *BlockApiService) PutBlockAllocationExecute(r BlockApiPutBlockAllocationRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockApiService.PutBlockAllocation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/blocks/{blockId}/allocation"
	localVarPath = strings.Replace(localVarPath, "{"+"blockId"+"}", url.PathEscape(parameterValueToString(r.blockId, "blockId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.blockId) < 1 {
		return localVarReturnValue, nil, reportError("blockId must have at least 1 elements")
	}
	if strlen(r.blockId) > 2000 {
		return localVarReturnValue, nil, reportError("blockId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.allocation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
