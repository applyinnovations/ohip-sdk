/*
OPERA Cloud Block API

APIs to cater for Business Block functionality in OPERA Cloud. <br /><br /> A block is a group of rooms held for guests who are attending an event, meeting, or function. You can create blocks for family reunions, business conferences, weddings, and so on. You can also set aside rooms for the event (block).<br /><br /> Compatible with OPERA Cloud release 23.2.<br /><br /><p> This document and all content within is available under the Universal Permissive License v 1.0 (https://oss.oracle.com/licenses/upl). Copyright (c) 2020, 2023 Oracle and/or its affiliates.</p>

API version: 23.2
Contact: hospitality_apis_ww_grp@oracle.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package blk

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// BlockApiService BlockApi service
type BlockApiService service

type BlockApiChangeRateOverrideRequest struct {
	ctx context.Context
	ApiService *BlockApiService
	blockId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	rateOverride *ChangeRateOverrideRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockApiChangeRateOverrideRequest) Authorization(authorization string) BlockApiChangeRateOverrideRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r BlockApiChangeRateOverrideRequest) XAppKey(xAppKey string) BlockApiChangeRateOverrideRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockApiChangeRateOverrideRequest) XHotelid(xHotelid string) BlockApiChangeRateOverrideRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object of change block rate override operation.
func (r BlockApiChangeRateOverrideRequest) RateOverride(rateOverride ChangeRateOverrideRequest) BlockApiChangeRateOverrideRequest {
	r.rateOverride = &rateOverride
	return r
}

// External system code.
func (r BlockApiChangeRateOverrideRequest) XExternalsystem(xExternalsystem string) BlockApiChangeRateOverrideRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockApiChangeRateOverrideRequest) AcceptLanguage(acceptLanguage string) BlockApiChangeRateOverrideRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockApiChangeRateOverrideRequest) Execute() (*RateOverrideStatus, *http.Response, error) {
	return r.ApiService.ChangeRateOverrideExecute(r)
}

/*
ChangeRateOverride Change rate override

Use this API to change rate override. <p><strong>OperationId:</strong>changeRateOverride</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockId Block Id
 @param hotelId Hotel Id
 @return BlockApiChangeRateOverrideRequest
*/
func (a *BlockApiService) ChangeRateOverride(ctx context.Context, blockId string, hotelId string) BlockApiChangeRateOverrideRequest {
	return BlockApiChangeRateOverrideRequest{
		ApiService: a,
		ctx: ctx,
		blockId: blockId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return RateOverrideStatus
func (a *BlockApiService) ChangeRateOverrideExecute(r BlockApiChangeRateOverrideRequest) (*RateOverrideStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RateOverrideStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockApiService.ChangeRateOverride")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/blocks/{blockId}/rate/override"
	localVarPath = strings.Replace(localVarPath, "{"+"blockId"+"}", url.PathEscape(parameterValueToString(r.blockId, "blockId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.blockId) < 1 {
		return localVarReturnValue, nil, reportError("blockId must have at least 1 elements")
	}
	if strlen(r.blockId) > 2000 {
		return localVarReturnValue, nil, reportError("blockId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.rateOverride
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockApiDeleteAlternateDatesRequest struct {
	ctx context.Context
	ApiService *BlockApiService
	blockId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockApiDeleteAlternateDatesRequest) Authorization(authorization string) BlockApiDeleteAlternateDatesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r BlockApiDeleteAlternateDatesRequest) XAppKey(xAppKey string) BlockApiDeleteAlternateDatesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockApiDeleteAlternateDatesRequest) XHotelid(xHotelid string) BlockApiDeleteAlternateDatesRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r BlockApiDeleteAlternateDatesRequest) XExternalsystem(xExternalsystem string) BlockApiDeleteAlternateDatesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockApiDeleteAlternateDatesRequest) AcceptLanguage(acceptLanguage string) BlockApiDeleteAlternateDatesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockApiDeleteAlternateDatesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteAlternateDatesExecute(r)
}

/*
DeleteAlternateDates Delete alternate dates for a Block

Use this API to delete alternate dates for a block. <p><strong>OperationId:</strong>deleteAlternateDates</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockId Block Id
 @return BlockApiDeleteAlternateDatesRequest
*/
func (a *BlockApiService) DeleteAlternateDates(ctx context.Context, blockId string) BlockApiDeleteAlternateDatesRequest {
	return BlockApiDeleteAlternateDatesRequest{
		ApiService: a,
		ctx: ctx,
		blockId: blockId,
	}
}

// Execute executes the request
//  @return Status
func (a *BlockApiService) DeleteAlternateDatesExecute(r BlockApiDeleteAlternateDatesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockApiService.DeleteAlternateDates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blocks/{blockId}/alternateDates"
	localVarPath = strings.Replace(localVarPath, "{"+"blockId"+"}", url.PathEscape(parameterValueToString(r.blockId, "blockId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.blockId) < 1 {
		return localVarReturnValue, nil, reportError("blockId must have at least 1 elements")
	}
	if strlen(r.blockId) > 2000 {
		return localVarReturnValue, nil, reportError("blockId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockApiDeleteBlockRequest struct {
	ctx context.Context
	ApiService *BlockApiService
	blockId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockApiDeleteBlockRequest) Authorization(authorization string) BlockApiDeleteBlockRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r BlockApiDeleteBlockRequest) XAppKey(xAppKey string) BlockApiDeleteBlockRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockApiDeleteBlockRequest) XHotelid(xHotelid string) BlockApiDeleteBlockRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r BlockApiDeleteBlockRequest) XExternalsystem(xExternalsystem string) BlockApiDeleteBlockRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockApiDeleteBlockRequest) AcceptLanguage(acceptLanguage string) BlockApiDeleteBlockRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockApiDeleteBlockRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteBlockExecute(r)
}

/*
DeleteBlock Delete a Block

Use this API to delete block, if any reservations attached to the block, you will be unable to delete.  <p><strong>OperationId:</strong>deleteBlock</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockId Block Id
 @param hotelId Hotel Id
 @return BlockApiDeleteBlockRequest
*/
func (a *BlockApiService) DeleteBlock(ctx context.Context, blockId string, hotelId string) BlockApiDeleteBlockRequest {
	return BlockApiDeleteBlockRequest{
		ApiService: a,
		ctx: ctx,
		blockId: blockId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *BlockApiService) DeleteBlockExecute(r BlockApiDeleteBlockRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockApiService.DeleteBlock")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/blocks/{blockId}"
	localVarPath = strings.Replace(localVarPath, "{"+"blockId"+"}", url.PathEscape(parameterValueToString(r.blockId, "blockId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.blockId) < 1 {
		return localVarReturnValue, nil, reportError("blockId must have at least 1 elements")
	}
	if strlen(r.blockId) > 2000 {
		return localVarReturnValue, nil, reportError("blockId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockApiDeleteBlockAccessExclusionRequest struct {
	ctx context.Context
	ApiService *BlockApiService
	blockId string
	authorization *string
	xAppKey *string
	xHotelid *string
	allowCancelReservation *bool
	allowCreateReservation *bool
	allowModifyReservation *bool
	excludeFromAvailability *bool
	inactive *bool
	sourceType *string
	sourceValue *string
	hotelId *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockApiDeleteBlockAccessExclusionRequest) Authorization(authorization string) BlockApiDeleteBlockAccessExclusionRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r BlockApiDeleteBlockAccessExclusionRequest) XAppKey(xAppKey string) BlockApiDeleteBlockAccessExclusionRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockApiDeleteBlockAccessExclusionRequest) XHotelid(xHotelid string) BlockApiDeleteBlockAccessExclusionRequest {
	r.xHotelid = &xHotelid
	return r
}

// Allow to cancel a reservation under this access exclusion.
func (r BlockApiDeleteBlockAccessExclusionRequest) AllowCancelReservation(allowCancelReservation bool) BlockApiDeleteBlockAccessExclusionRequest {
	r.allowCancelReservation = &allowCancelReservation
	return r
}

// Allow to create a reservation under this access exclusion.
func (r BlockApiDeleteBlockAccessExclusionRequest) AllowCreateReservation(allowCreateReservation bool) BlockApiDeleteBlockAccessExclusionRequest {
	r.allowCreateReservation = &allowCreateReservation
	return r
}

// Allow to modify a reservation under this access exclusion.
func (r BlockApiDeleteBlockAccessExclusionRequest) AllowModifyReservation(allowModifyReservation bool) BlockApiDeleteBlockAccessExclusionRequest {
	r.allowModifyReservation = &allowModifyReservation
	return r
}

// Exclude a specific rate from availability
func (r BlockApiDeleteBlockAccessExclusionRequest) ExcludeFromAvailability(excludeFromAvailability bool) BlockApiDeleteBlockAccessExclusionRequest {
	r.excludeFromAvailability = &excludeFromAvailability
	return r
}

// The rate access exclusion is inactive
func (r BlockApiDeleteBlockAccessExclusionRequest) Inactive(inactive bool) BlockApiDeleteBlockAccessExclusionRequest {
	r.inactive = &inactive
	return r
}

// The type of source (CRO or Hotel code) for which the rate access exclusion is set.
func (r BlockApiDeleteBlockAccessExclusionRequest) SourceType(sourceType string) BlockApiDeleteBlockAccessExclusionRequest {
	r.sourceType = &sourceType
	return r
}

// CRO or Hotel code value.
func (r BlockApiDeleteBlockAccessExclusionRequest) SourceValue(sourceValue string) BlockApiDeleteBlockAccessExclusionRequest {
	r.sourceValue = &sourceValue
	return r
}

// Used for codes in the OPERA Code tables. Possible values of this pattern are 1, 101, 101.EQP, or 101.EQP.X.
func (r BlockApiDeleteBlockAccessExclusionRequest) HotelId(hotelId string) BlockApiDeleteBlockAccessExclusionRequest {
	r.hotelId = &hotelId
	return r
}

// External system code.
func (r BlockApiDeleteBlockAccessExclusionRequest) XExternalsystem(xExternalsystem string) BlockApiDeleteBlockAccessExclusionRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockApiDeleteBlockAccessExclusionRequest) AcceptLanguage(acceptLanguage string) BlockApiDeleteBlockAccessExclusionRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockApiDeleteBlockAccessExclusionRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteBlockAccessExclusionExecute(r)
}

/*
DeleteBlockAccessExclusion Delete Block access exclusion

Use this API to delete block access exclusion <p><strong>OperationId:</strong>deleteBlockAccessExclusion</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockId Block Id
 @return BlockApiDeleteBlockAccessExclusionRequest
*/
func (a *BlockApiService) DeleteBlockAccessExclusion(ctx context.Context, blockId string) BlockApiDeleteBlockAccessExclusionRequest {
	return BlockApiDeleteBlockAccessExclusionRequest{
		ApiService: a,
		ctx: ctx,
		blockId: blockId,
	}
}

// Execute executes the request
//  @return Status
func (a *BlockApiService) DeleteBlockAccessExclusionExecute(r BlockApiDeleteBlockAccessExclusionRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockApiService.DeleteBlockAccessExclusion")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blocks/{blockId}/blockAccessExclusion"
	localVarPath = strings.Replace(localVarPath, "{"+"blockId"+"}", url.PathEscape(parameterValueToString(r.blockId, "blockId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.blockId) < 1 {
		return localVarReturnValue, nil, reportError("blockId must have at least 1 elements")
	}
	if strlen(r.blockId) > 2000 {
		return localVarReturnValue, nil, reportError("blockId must have less than 2000 elements")
	}

	if r.allowCancelReservation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allowCancelReservation", r.allowCancelReservation, "")
	}
	if r.allowCreateReservation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allowCreateReservation", r.allowCreateReservation, "")
	}
	if r.allowModifyReservation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allowModifyReservation", r.allowModifyReservation, "")
	}
	if r.excludeFromAvailability != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excludeFromAvailability", r.excludeFromAvailability, "")
	}
	if r.inactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inactive", r.inactive, "")
	}
	if r.sourceType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sourceType", r.sourceType, "")
	}
	if r.sourceValue != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sourceValue", r.sourceValue, "")
	}
	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockApiDeleteBlockAttachmentRequest struct {
	ctx context.Context
	ApiService *BlockApiService
	attachId string
	blockId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockApiDeleteBlockAttachmentRequest) Authorization(authorization string) BlockApiDeleteBlockAttachmentRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r BlockApiDeleteBlockAttachmentRequest) XAppKey(xAppKey string) BlockApiDeleteBlockAttachmentRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockApiDeleteBlockAttachmentRequest) XHotelid(xHotelid string) BlockApiDeleteBlockAttachmentRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r BlockApiDeleteBlockAttachmentRequest) XExternalsystem(xExternalsystem string) BlockApiDeleteBlockAttachmentRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockApiDeleteBlockAttachmentRequest) AcceptLanguage(acceptLanguage string) BlockApiDeleteBlockAttachmentRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockApiDeleteBlockAttachmentRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteBlockAttachmentExecute(r)
}

/*
DeleteBlockAttachment Delete Block Attachment

Use this API remove block attachments. <p><strong>OperationId:</strong>deleteBlockAttachment</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param attachId Attachment Id
 @param blockId Block Id
 @return BlockApiDeleteBlockAttachmentRequest
*/
func (a *BlockApiService) DeleteBlockAttachment(ctx context.Context, attachId string, blockId string) BlockApiDeleteBlockAttachmentRequest {
	return BlockApiDeleteBlockAttachmentRequest{
		ApiService: a,
		ctx: ctx,
		attachId: attachId,
		blockId: blockId,
	}
}

// Execute executes the request
//  @return Status
func (a *BlockApiService) DeleteBlockAttachmentExecute(r BlockApiDeleteBlockAttachmentRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockApiService.DeleteBlockAttachment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blocks/{blockId}/attachments/{attachId}"
	localVarPath = strings.Replace(localVarPath, "{"+"attachId"+"}", url.PathEscape(parameterValueToString(r.attachId, "attachId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"blockId"+"}", url.PathEscape(parameterValueToString(r.blockId, "blockId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.attachId) < 1 {
		return localVarReturnValue, nil, reportError("attachId must have at least 1 elements")
	}
	if strlen(r.attachId) > 2000 {
		return localVarReturnValue, nil, reportError("attachId must have less than 2000 elements")
	}
	if strlen(r.blockId) < 1 {
		return localVarReturnValue, nil, reportError("blockId must have at least 1 elements")
	}
	if strlen(r.blockId) > 2000 {
		return localVarReturnValue, nil, reportError("blockId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockApiDeleteBlockOwnersRequest struct {
	ctx context.Context
	ApiService *BlockApiService
	blockId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockApiDeleteBlockOwnersRequest) Authorization(authorization string) BlockApiDeleteBlockOwnersRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r BlockApiDeleteBlockOwnersRequest) XAppKey(xAppKey string) BlockApiDeleteBlockOwnersRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockApiDeleteBlockOwnersRequest) XHotelid(xHotelid string) BlockApiDeleteBlockOwnersRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r BlockApiDeleteBlockOwnersRequest) XExternalsystem(xExternalsystem string) BlockApiDeleteBlockOwnersRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockApiDeleteBlockOwnersRequest) AcceptLanguage(acceptLanguage string) BlockApiDeleteBlockOwnersRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockApiDeleteBlockOwnersRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteBlockOwnersExecute(r)
}

/*
DeleteBlockOwners Delete a Block owner

Use this API to delete a block owner. <p><strong>OperationId:</strong>deleteBlockOwners</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockId Block Id
 @return BlockApiDeleteBlockOwnersRequest
*/
func (a *BlockApiService) DeleteBlockOwners(ctx context.Context, blockId string) BlockApiDeleteBlockOwnersRequest {
	return BlockApiDeleteBlockOwnersRequest{
		ApiService: a,
		ctx: ctx,
		blockId: blockId,
	}
}

// Execute executes the request
//  @return Status
func (a *BlockApiService) DeleteBlockOwnersExecute(r BlockApiDeleteBlockOwnersRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockApiService.DeleteBlockOwners")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blocks/{blockId}/owners"
	localVarPath = strings.Replace(localVarPath, "{"+"blockId"+"}", url.PathEscape(parameterValueToString(r.blockId, "blockId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.blockId) < 1 {
		return localVarReturnValue, nil, reportError("blockId must have at least 1 elements")
	}
	if strlen(r.blockId) > 2000 {
		return localVarReturnValue, nil, reportError("blockId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockApiDeleteBlockRestrictionRequest struct {
	ctx context.Context
	ApiService *BlockApiService
	blockId string
	hotelId *string
	startDate *string
	endDate *string
	code *string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Hotel to which the block belongs to.
func (r BlockApiDeleteBlockRestrictionRequest) HotelId(hotelId string) BlockApiDeleteBlockRestrictionRequest {
	r.hotelId = &hotelId
	return r
}

func (r BlockApiDeleteBlockRestrictionRequest) StartDate(startDate string) BlockApiDeleteBlockRestrictionRequest {
	r.startDate = &startDate
	return r
}

func (r BlockApiDeleteBlockRestrictionRequest) EndDate(endDate string) BlockApiDeleteBlockRestrictionRequest {
	r.endDate = &endDate
	return r
}

func (r BlockApiDeleteBlockRestrictionRequest) Code(code string) BlockApiDeleteBlockRestrictionRequest {
	r.code = &code
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockApiDeleteBlockRestrictionRequest) Authorization(authorization string) BlockApiDeleteBlockRestrictionRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r BlockApiDeleteBlockRestrictionRequest) XAppKey(xAppKey string) BlockApiDeleteBlockRestrictionRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockApiDeleteBlockRestrictionRequest) XHotelid(xHotelid string) BlockApiDeleteBlockRestrictionRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r BlockApiDeleteBlockRestrictionRequest) XExternalsystem(xExternalsystem string) BlockApiDeleteBlockRestrictionRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockApiDeleteBlockRestrictionRequest) AcceptLanguage(acceptLanguage string) BlockApiDeleteBlockRestrictionRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockApiDeleteBlockRestrictionRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteBlockRestrictionExecute(r)
}

/*
DeleteBlockRestriction Delete Block Restriction

Use this API to delete block restrictions. <p><strong>OperationId:</strong>deleteBlockRestriction</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockId Block Id
 @return BlockApiDeleteBlockRestrictionRequest
*/
func (a *BlockApiService) DeleteBlockRestriction(ctx context.Context, blockId string) BlockApiDeleteBlockRestrictionRequest {
	return BlockApiDeleteBlockRestrictionRequest{
		ApiService: a,
		ctx: ctx,
		blockId: blockId,
	}
}

// Execute executes the request
//  @return Status
func (a *BlockApiService) DeleteBlockRestrictionExecute(r BlockApiDeleteBlockRestrictionRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockApiService.DeleteBlockRestriction")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blocks/{blockId}/restrictions"
	localVarPath = strings.Replace(localVarPath, "{"+"blockId"+"}", url.PathEscape(parameterValueToString(r.blockId, "blockId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.blockId) < 1 {
		return localVarReturnValue, nil, reportError("blockId must have at least 1 elements")
	}
	if strlen(r.blockId) > 2000 {
		return localVarReturnValue, nil, reportError("blockId must have less than 2000 elements")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "code", r.code, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockApiDeleteBlockWashSchedulesRequest struct {
	ctx context.Context
	ApiService *BlockApiService
	blockId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockApiDeleteBlockWashSchedulesRequest) Authorization(authorization string) BlockApiDeleteBlockWashSchedulesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r BlockApiDeleteBlockWashSchedulesRequest) XAppKey(xAppKey string) BlockApiDeleteBlockWashSchedulesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockApiDeleteBlockWashSchedulesRequest) XHotelid(xHotelid string) BlockApiDeleteBlockWashSchedulesRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r BlockApiDeleteBlockWashSchedulesRequest) XExternalsystem(xExternalsystem string) BlockApiDeleteBlockWashSchedulesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockApiDeleteBlockWashSchedulesRequest) AcceptLanguage(acceptLanguage string) BlockApiDeleteBlockWashSchedulesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockApiDeleteBlockWashSchedulesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteBlockWashSchedulesExecute(r)
}

/*
DeleteBlockWashSchedules Remove Block Wash Schedules

Use this API to remove block wash schedules based on the HotelCode, Block ID and Wash Date. <p><strong>OperationId:</strong>deleteBlockWashSchedules</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockId Block Id
 @return BlockApiDeleteBlockWashSchedulesRequest
*/
func (a *BlockApiService) DeleteBlockWashSchedules(ctx context.Context, blockId string) BlockApiDeleteBlockWashSchedulesRequest {
	return BlockApiDeleteBlockWashSchedulesRequest{
		ApiService: a,
		ctx: ctx,
		blockId: blockId,
	}
}

// Execute executes the request
//  @return Status
func (a *BlockApiService) DeleteBlockWashSchedulesExecute(r BlockApiDeleteBlockWashSchedulesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockApiService.DeleteBlockWashSchedules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blocks/{blockId}/washSchedules"
	localVarPath = strings.Replace(localVarPath, "{"+"blockId"+"}", url.PathEscape(parameterValueToString(r.blockId, "blockId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.blockId) < 1 {
		return localVarReturnValue, nil, reportError("blockId must have at least 1 elements")
	}
	if strlen(r.blockId) > 2000 {
		return localVarReturnValue, nil, reportError("blockId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockApiGetBlockRequest struct {
	ctx context.Context
	ApiService *BlockApiService
	blockId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	markAsRecentlyAccessed *bool
	fetchInstructions *[]string
	fetchAllocatedRoomTypes *bool
	startDate *string
	numberOfDays *float32
	roomAllocationCriteria *[]string
	roomTypes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockApiGetBlockRequest) Authorization(authorization string) BlockApiGetBlockRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r BlockApiGetBlockRequest) XAppKey(xAppKey string) BlockApiGetBlockRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockApiGetBlockRequest) XHotelid(xHotelid string) BlockApiGetBlockRequest {
	r.xHotelid = &xHotelid
	return r
}

// Mark this block as recently accessed.
func (r BlockApiGetBlockRequest) MarkAsRecentlyAccessed(markAsRecentlyAccessed bool) BlockApiGetBlockRequest {
	r.markAsRecentlyAccessed = &markAsRecentlyAccessed
	return r
}

// Type for block instructions that can be used in requests for partial operations.
func (r BlockApiGetBlockRequest) FetchInstructions(fetchInstructions []string) BlockApiGetBlockRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// Indicates whether to fetch only those room types that have rooms allocated. If this flag is true then only those room types with rooms allocated for the block are fetched. Only applicable to fetch instruction RateGrid.
func (r BlockApiGetBlockRequest) FetchAllocatedRoomTypes(fetchAllocatedRoomTypes bool) BlockApiGetBlockRequest {
	r.fetchAllocatedRoomTypes = &fetchAllocatedRoomTypes
	return r
}

// Start Date for the rate grid data. Only applicable to fetch instruction RateGrid.
func (r BlockApiGetBlockRequest) StartDate(startDate string) BlockApiGetBlockRequest {
	r.startDate = &startDate
	return r
}

// Number of days to fetch for the rate grid data. Only applicable to fetch instruction RateGrid.
func (r BlockApiGetBlockRequest) NumberOfDays(numberOfDays float32) BlockApiGetBlockRequest {
	r.numberOfDays = &numberOfDays
	return r
}

// Simple type for block allocation used in room rate grid.
func (r BlockApiGetBlockRequest) RoomAllocationCriteria(roomAllocationCriteria []string) BlockApiGetBlockRequest {
	r.roomAllocationCriteria = &roomAllocationCriteria
	return r
}

// The Room Types that need to be fetched for the rate room grid data. If these values are not provided, all room types for the block will be fetched.
func (r BlockApiGetBlockRequest) RoomTypes(roomTypes []string) BlockApiGetBlockRequest {
	r.roomTypes = &roomTypes
	return r
}

// External system code.
func (r BlockApiGetBlockRequest) XExternalsystem(xExternalsystem string) BlockApiGetBlockRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockApiGetBlockRequest) AcceptLanguage(acceptLanguage string) BlockApiGetBlockRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockApiGetBlockRequest) Execute() (*Block, *http.Response, error) {
	return r.ApiService.GetBlockExecute(r)
}

/*
GetBlock Get a Block By ID

Use this API to retrieve a specific block.  You will need to know the blockID in the request; if you don't know it, please go ahead and use getBlocks API first.  The response will include detailed information about the block. <p><strong>OperationId:</strong>getBlock</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockId Unique OPERA Block ID which is used to find a Block from OPERA. This ID is a primary identification of a Block in OPERA.
 @param hotelId Hotel Id
 @return BlockApiGetBlockRequest
*/
func (a *BlockApiService) GetBlock(ctx context.Context, blockId string, hotelId string) BlockApiGetBlockRequest {
	return BlockApiGetBlockRequest{
		ApiService: a,
		ctx: ctx,
		blockId: blockId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Block
func (a *BlockApiService) GetBlockExecute(r BlockApiGetBlockRequest) (*Block, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Block
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockApiService.GetBlock")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/blocks/{blockId}"
	localVarPath = strings.Replace(localVarPath, "{"+"blockId"+"}", url.PathEscape(parameterValueToString(r.blockId, "blockId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.blockId) < 1 {
		return localVarReturnValue, nil, reportError("blockId must have at least 1 elements")
	}
	if strlen(r.blockId) > 2000 {
		return localVarReturnValue, nil, reportError("blockId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.markAsRecentlyAccessed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "markAsRecentlyAccessed", r.markAsRecentlyAccessed, "")
	}
	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
	}
	if r.fetchAllocatedRoomTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetchAllocatedRoomTypes", r.fetchAllocatedRoomTypes, "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.numberOfDays != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "numberOfDays", r.numberOfDays, "")
	}
	if r.roomAllocationCriteria != nil {
		t := *r.roomAllocationCriteria
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomAllocationCriteria", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomAllocationCriteria", t, "multi")
		}
	}
	if r.roomTypes != nil {
		t := *r.roomTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomTypes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomTypes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockApiGetBlockAccessExclusionRequest struct {
	ctx context.Context
	ApiService *BlockApiService
	blockId string
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelId *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockApiGetBlockAccessExclusionRequest) Authorization(authorization string) BlockApiGetBlockAccessExclusionRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r BlockApiGetBlockAccessExclusionRequest) XAppKey(xAppKey string) BlockApiGetBlockAccessExclusionRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockApiGetBlockAccessExclusionRequest) XHotelid(xHotelid string) BlockApiGetBlockAccessExclusionRequest {
	r.xHotelid = &xHotelid
	return r
}

// Used for codes in the OPERA Code tables. Possible values of this pattern are 1, 101, 101.EQP, or 101.EQP.X.
func (r BlockApiGetBlockAccessExclusionRequest) HotelId(hotelId string) BlockApiGetBlockAccessExclusionRequest {
	r.hotelId = &hotelId
	return r
}

// External system code.
func (r BlockApiGetBlockAccessExclusionRequest) XExternalsystem(xExternalsystem string) BlockApiGetBlockAccessExclusionRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockApiGetBlockAccessExclusionRequest) AcceptLanguage(acceptLanguage string) BlockApiGetBlockAccessExclusionRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockApiGetBlockAccessExclusionRequest) Execute() (*BlockAccessExclusionInfo, *http.Response, error) {
	return r.ApiService.GetBlockAccessExclusionExecute(r)
}

/*
GetBlockAccessExclusion Get Block exclusion information

This API retrieves block exclusion information. <p><strong>OperationId:</strong>getBlockAccessExclusion</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockId Block Id
 @return BlockApiGetBlockAccessExclusionRequest
*/
func (a *BlockApiService) GetBlockAccessExclusion(ctx context.Context, blockId string) BlockApiGetBlockAccessExclusionRequest {
	return BlockApiGetBlockAccessExclusionRequest{
		ApiService: a,
		ctx: ctx,
		blockId: blockId,
	}
}

// Execute executes the request
//  @return BlockAccessExclusionInfo
func (a *BlockApiService) GetBlockAccessExclusionExecute(r BlockApiGetBlockAccessExclusionRequest) (*BlockAccessExclusionInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BlockAccessExclusionInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockApiService.GetBlockAccessExclusion")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blocks/{blockId}/blockAccessExclusion"
	localVarPath = strings.Replace(localVarPath, "{"+"blockId"+"}", url.PathEscape(parameterValueToString(r.blockId, "blockId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.blockId) < 1 {
		return localVarReturnValue, nil, reportError("blockId must have at least 1 elements")
	}
	if strlen(r.blockId) > 2000 {
		return localVarReturnValue, nil, reportError("blockId must have less than 2000 elements")
	}

	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockApiGetBlockActivityLogRequest struct {
	ctx context.Context
	ApiService *BlockApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	hotelId *string
	module *string
	moduleParamsParameterName *[]string
	moduleParamsParameterValue *[]string
	activityGroup *string
	activityType *string
	activityParamsFromDate *string
	activityParamsToDate *string
	activityParamsSearchText *string
	userByIDsUserId *[]int32
	userForIDsUserId *[]int32
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockApiGetBlockActivityLogRequest) Authorization(authorization string) BlockApiGetBlockActivityLogRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r BlockApiGetBlockActivityLogRequest) XAppKey(xAppKey string) BlockApiGetBlockActivityLogRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockApiGetBlockActivityLogRequest) XHotelid(xHotelid string) BlockApiGetBlockActivityLogRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r BlockApiGetBlockActivityLogRequest) Limit(limit int32) BlockApiGetBlockActivityLogRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r BlockApiGetBlockActivityLogRequest) Offset(offset int32) BlockApiGetBlockActivityLogRequest {
	r.offset = &offset
	return r
}

// Hotel code.
func (r BlockApiGetBlockActivityLogRequest) HotelId(hotelId string) BlockApiGetBlockActivityLogRequest {
	r.hotelId = &hotelId
	return r
}

// Activity module.
func (r BlockApiGetBlockActivityLogRequest) Module(module string) BlockApiGetBlockActivityLogRequest {
	r.module = &module
	return r
}

// Name of the parameter.
func (r BlockApiGetBlockActivityLogRequest) ModuleParamsParameterName(moduleParamsParameterName []string) BlockApiGetBlockActivityLogRequest {
	r.moduleParamsParameterName = &moduleParamsParameterName
	return r
}

// Value of the parameter.
func (r BlockApiGetBlockActivityLogRequest) ModuleParamsParameterValue(moduleParamsParameterValue []string) BlockApiGetBlockActivityLogRequest {
	r.moduleParamsParameterValue = &moduleParamsParameterValue
	return r
}

func (r BlockApiGetBlockActivityLogRequest) ActivityGroup(activityGroup string) BlockApiGetBlockActivityLogRequest {
	r.activityGroup = &activityGroup
	return r
}

func (r BlockApiGetBlockActivityLogRequest) ActivityType(activityType string) BlockApiGetBlockActivityLogRequest {
	r.activityType = &activityType
	return r
}

// Search from date for the user activity log.
func (r BlockApiGetBlockActivityLogRequest) ActivityParamsFromDate(activityParamsFromDate string) BlockApiGetBlockActivityLogRequest {
	r.activityParamsFromDate = &activityParamsFromDate
	return r
}

// Search to date for the user activity log.
func (r BlockApiGetBlockActivityLogRequest) ActivityParamsToDate(activityParamsToDate string) BlockApiGetBlockActivityLogRequest {
	r.activityParamsToDate = &activityParamsToDate
	return r
}

// Search text for the user activity log.
func (r BlockApiGetBlockActivityLogRequest) ActivityParamsSearchText(activityParamsSearchText string) BlockApiGetBlockActivityLogRequest {
	r.activityParamsSearchText = &activityParamsSearchText
	return r
}

func (r BlockApiGetBlockActivityLogRequest) UserByIDsUserId(userByIDsUserId []int32) BlockApiGetBlockActivityLogRequest {
	r.userByIDsUserId = &userByIDsUserId
	return r
}

func (r BlockApiGetBlockActivityLogRequest) UserForIDsUserId(userForIDsUserId []int32) BlockApiGetBlockActivityLogRequest {
	r.userForIDsUserId = &userForIDsUserId
	return r
}

// External system code.
func (r BlockApiGetBlockActivityLogRequest) XExternalsystem(xExternalsystem string) BlockApiGetBlockActivityLogRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockApiGetBlockActivityLogRequest) AcceptLanguage(acceptLanguage string) BlockApiGetBlockActivityLogRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockApiGetBlockActivityLogRequest) Execute() (*BlockActivityLog, *http.Response, error) {
	return r.ApiService.GetBlockActivityLogExecute(r)
}

/*
GetBlockActivityLog Get the Block activity log

Use this API to facilitate retrieving the block activity log. <p><strong>OperationId:</strong>getBlockActivityLog</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return BlockApiGetBlockActivityLogRequest
*/
func (a *BlockApiService) GetBlockActivityLog(ctx context.Context) BlockApiGetBlockActivityLogRequest {
	return BlockApiGetBlockActivityLogRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BlockActivityLog
func (a *BlockApiService) GetBlockActivityLogExecute(r BlockApiGetBlockActivityLogRequest) (*BlockActivityLog, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BlockActivityLog
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockApiService.GetBlockActivityLog")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blockActivityLog"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
	}
	if r.module != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "module", r.module, "")
	}
	if r.moduleParamsParameterName != nil {
		t := *r.moduleParamsParameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "moduleParamsParameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "moduleParamsParameterName", t, "multi")
		}
	}
	if r.moduleParamsParameterValue != nil {
		t := *r.moduleParamsParameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "moduleParamsParameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "moduleParamsParameterValue", t, "multi")
		}
	}
	if r.activityGroup != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "activityGroup", r.activityGroup, "")
	}
	if r.activityType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "activityType", r.activityType, "")
	}
	if r.activityParamsFromDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "activityParamsFromDate", r.activityParamsFromDate, "")
	}
	if r.activityParamsToDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "activityParamsToDate", r.activityParamsToDate, "")
	}
	if r.activityParamsSearchText != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "activityParamsSearchText", r.activityParamsSearchText, "")
	}
	if r.userByIDsUserId != nil {
		t := *r.userByIDsUserId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "userByIDsUserId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "userByIDsUserId", t, "multi")
		}
	}
	if r.userForIDsUserId != nil {
		t := *r.userForIDsUserId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "userForIDsUserId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "userForIDsUserId", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockApiGetBlockAttachmentsRequest struct {
	ctx context.Context
	ApiService *BlockApiService
	blockId string
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelId *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockApiGetBlockAttachmentsRequest) Authorization(authorization string) BlockApiGetBlockAttachmentsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r BlockApiGetBlockAttachmentsRequest) XAppKey(xAppKey string) BlockApiGetBlockAttachmentsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockApiGetBlockAttachmentsRequest) XHotelid(xHotelid string) BlockApiGetBlockAttachmentsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Hotel Code.
func (r BlockApiGetBlockAttachmentsRequest) HotelId(hotelId string) BlockApiGetBlockAttachmentsRequest {
	r.hotelId = &hotelId
	return r
}

// External system code.
func (r BlockApiGetBlockAttachmentsRequest) XExternalsystem(xExternalsystem string) BlockApiGetBlockAttachmentsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockApiGetBlockAttachmentsRequest) AcceptLanguage(acceptLanguage string) BlockApiGetBlockAttachmentsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockApiGetBlockAttachmentsRequest) Execute() (*BlockAttachments, *http.Response, error) {
	return r.ApiService.GetBlockAttachmentsExecute(r)
}

/*
GetBlockAttachments Get Block Attachments

Use this API to retrieve block attachments. <p><strong>OperationId:</strong>getBlockAttachments</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockId Block Id
 @return BlockApiGetBlockAttachmentsRequest
*/
func (a *BlockApiService) GetBlockAttachments(ctx context.Context, blockId string) BlockApiGetBlockAttachmentsRequest {
	return BlockApiGetBlockAttachmentsRequest{
		ApiService: a,
		ctx: ctx,
		blockId: blockId,
	}
}

// Execute executes the request
//  @return BlockAttachments
func (a *BlockApiService) GetBlockAttachmentsExecute(r BlockApiGetBlockAttachmentsRequest) (*BlockAttachments, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BlockAttachments
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockApiService.GetBlockAttachments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blocks/{blockId}/attachments"
	localVarPath = strings.Replace(localVarPath, "{"+"blockId"+"}", url.PathEscape(parameterValueToString(r.blockId, "blockId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.blockId) < 1 {
		return localVarReturnValue, nil, reportError("blockId must have at least 1 elements")
	}
	if strlen(r.blockId) > 2000 {
		return localVarReturnValue, nil, reportError("blockId must have less than 2000 elements")
	}

	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockApiGetBlockAvailabilityRequest struct {
	ctx context.Context
	ApiService *BlockApiService
	blockId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	overrideRateCode *bool
	arrivalDate *string
	nights *int32
	adults *int32
	children *int32
	rooms *int32
	ratePlanCode *string
	existingReservationId *string
	existingReservationIdType *string
	roomType *[]string
	fetchAllocatedRoomType *[]string
	roomTypeCount *int32
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockApiGetBlockAvailabilityRequest) Authorization(authorization string) BlockApiGetBlockAvailabilityRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r BlockApiGetBlockAvailabilityRequest) XAppKey(xAppKey string) BlockApiGetBlockAvailabilityRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockApiGetBlockAvailabilityRequest) XHotelid(xHotelid string) BlockApiGetBlockAvailabilityRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r BlockApiGetBlockAvailabilityRequest) OverrideRateCode(overrideRateCode bool) BlockApiGetBlockAvailabilityRequest {
	r.overrideRateCode = &overrideRateCode
	return r
}

// Arrival date.
func (r BlockApiGetBlockAvailabilityRequest) ArrivalDate(arrivalDate string) BlockApiGetBlockAvailabilityRequest {
	r.arrivalDate = &arrivalDate
	return r
}

// Number of nights of stay.
func (r BlockApiGetBlockAvailabilityRequest) Nights(nights int32) BlockApiGetBlockAvailabilityRequest {
	r.nights = &nights
	return r
}

// Documentation goes here
func (r BlockApiGetBlockAvailabilityRequest) Adults(adults int32) BlockApiGetBlockAvailabilityRequest {
	r.adults = &adults
	return r
}

// Documentation goes here
func (r BlockApiGetBlockAvailabilityRequest) Children(children int32) BlockApiGetBlockAvailabilityRequest {
	r.children = &children
	return r
}

// Documentation goes here
func (r BlockApiGetBlockAvailabilityRequest) Rooms(rooms int32) BlockApiGetBlockAvailabilityRequest {
	r.rooms = &rooms
	return r
}

// Documentation goes here
func (r BlockApiGetBlockAvailabilityRequest) RatePlanCode(ratePlanCode string) BlockApiGetBlockAvailabilityRequest {
	r.ratePlanCode = &ratePlanCode
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r BlockApiGetBlockAvailabilityRequest) ExistingReservationId(existingReservationId string) BlockApiGetBlockAvailabilityRequest {
	r.existingReservationId = &existingReservationId
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r BlockApiGetBlockAvailabilityRequest) ExistingReservationIdType(existingReservationIdType string) BlockApiGetBlockAvailabilityRequest {
	r.existingReservationIdType = &existingReservationIdType
	return r
}

// Room type.
func (r BlockApiGetBlockAvailabilityRequest) RoomType(roomType []string) BlockApiGetBlockAvailabilityRequest {
	r.roomType = &roomType
	return r
}

// Instruction to determine room types to fetch.
func (r BlockApiGetBlockAvailabilityRequest) FetchAllocatedRoomType(fetchAllocatedRoomType []string) BlockApiGetBlockAvailabilityRequest {
	r.fetchAllocatedRoomType = &fetchAllocatedRoomType
	return r
}

// Criteria to fetch number of room type(s).
func (r BlockApiGetBlockAvailabilityRequest) RoomTypeCount(roomTypeCount int32) BlockApiGetBlockAvailabilityRequest {
	r.roomTypeCount = &roomTypeCount
	return r
}

// External system code.
func (r BlockApiGetBlockAvailabilityRequest) XExternalsystem(xExternalsystem string) BlockApiGetBlockAvailabilityRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockApiGetBlockAvailabilityRequest) AcceptLanguage(acceptLanguage string) BlockApiGetBlockAvailabilityRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockApiGetBlockAvailabilityRequest) Execute() (*BlockAvailability, *http.Response, error) {
	return r.ApiService.GetBlockAvailabilityExecute(r)
}

/*
GetBlockAvailability Get Block AvailaBility

Use this API to search for availability on an OPERA block.  You will need to know the block ID.  Once you know what rooms and rates are available you can proceed to post a block reservation. <p><strong>OperationId:</strong>getBlockAvailability</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockId Block Id
 @param hotelId Hotel Id
 @return BlockApiGetBlockAvailabilityRequest
*/
func (a *BlockApiService) GetBlockAvailability(ctx context.Context, blockId string, hotelId string) BlockApiGetBlockAvailabilityRequest {
	return BlockApiGetBlockAvailabilityRequest{
		ApiService: a,
		ctx: ctx,
		blockId: blockId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return BlockAvailability
func (a *BlockApiService) GetBlockAvailabilityExecute(r BlockApiGetBlockAvailabilityRequest) (*BlockAvailability, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BlockAvailability
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockApiService.GetBlockAvailability")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/blocks/{blockId}/availability"
	localVarPath = strings.Replace(localVarPath, "{"+"blockId"+"}", url.PathEscape(parameterValueToString(r.blockId, "blockId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.blockId) < 1 {
		return localVarReturnValue, nil, reportError("blockId must have at least 1 elements")
	}
	if strlen(r.blockId) > 2000 {
		return localVarReturnValue, nil, reportError("blockId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.overrideRateCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "overrideRateCode", r.overrideRateCode, "")
	}
	if r.arrivalDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "arrivalDate", r.arrivalDate, "")
	}
	if r.nights != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nights", r.nights, "")
	}
	if r.adults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adults", r.adults, "")
	}
	if r.children != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "children", r.children, "")
	}
	if r.rooms != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rooms", r.rooms, "")
	}
	if r.ratePlanCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanCode", r.ratePlanCode, "")
	}
	if r.existingReservationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "existingReservationId", r.existingReservationId, "")
	}
	if r.existingReservationIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "existingReservationIdType", r.existingReservationIdType, "")
	}
	if r.roomType != nil {
		t := *r.roomType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomType", t, "multi")
		}
	}
	if r.fetchAllocatedRoomType != nil {
		t := *r.fetchAllocatedRoomType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchAllocatedRoomType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchAllocatedRoomType", t, "multi")
		}
	}
	if r.roomTypeCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomTypeCount", r.roomTypeCount, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockApiGetBlockByExtIdRequest struct {
	ctx context.Context
	ApiService *BlockApiService
	blockExternalId string
	externalSystemCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	markAsRecentlyAccessed *bool
	fetchInstructions *[]string
	fetchAllocatedRoomTypes *bool
	startDate *string
	numberOfDays *float32
	roomAllocationCriteria *[]string
	roomTypes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockApiGetBlockByExtIdRequest) Authorization(authorization string) BlockApiGetBlockByExtIdRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r BlockApiGetBlockByExtIdRequest) XAppKey(xAppKey string) BlockApiGetBlockByExtIdRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockApiGetBlockByExtIdRequest) XHotelid(xHotelid string) BlockApiGetBlockByExtIdRequest {
	r.xHotelid = &xHotelid
	return r
}

// Mark this block as recently accessed.
func (r BlockApiGetBlockByExtIdRequest) MarkAsRecentlyAccessed(markAsRecentlyAccessed bool) BlockApiGetBlockByExtIdRequest {
	r.markAsRecentlyAccessed = &markAsRecentlyAccessed
	return r
}

// Type for block instructions that can be used in requests for partial operations.
func (r BlockApiGetBlockByExtIdRequest) FetchInstructions(fetchInstructions []string) BlockApiGetBlockByExtIdRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// Indicates whether to fetch only those room types that have rooms allocated. If this flag is true then only those room types with rooms allocated for the block are fetched. Only applicable to fetch instruction RateGrid.
func (r BlockApiGetBlockByExtIdRequest) FetchAllocatedRoomTypes(fetchAllocatedRoomTypes bool) BlockApiGetBlockByExtIdRequest {
	r.fetchAllocatedRoomTypes = &fetchAllocatedRoomTypes
	return r
}

// Start Date for the rate grid data. Only applicable to fetch instruction RateGrid.
func (r BlockApiGetBlockByExtIdRequest) StartDate(startDate string) BlockApiGetBlockByExtIdRequest {
	r.startDate = &startDate
	return r
}

// Number of days to fetch for the rate grid data. Only applicable to fetch instruction RateGrid.
func (r BlockApiGetBlockByExtIdRequest) NumberOfDays(numberOfDays float32) BlockApiGetBlockByExtIdRequest {
	r.numberOfDays = &numberOfDays
	return r
}

// Simple type for block allocation used in room rate grid.
func (r BlockApiGetBlockByExtIdRequest) RoomAllocationCriteria(roomAllocationCriteria []string) BlockApiGetBlockByExtIdRequest {
	r.roomAllocationCriteria = &roomAllocationCriteria
	return r
}

// The Room Types that need to be fetched for the rate room grid data. If these values are not provided, all room types for the block will be fetched.
func (r BlockApiGetBlockByExtIdRequest) RoomTypes(roomTypes []string) BlockApiGetBlockByExtIdRequest {
	r.roomTypes = &roomTypes
	return r
}

// External system code.
func (r BlockApiGetBlockByExtIdRequest) XExternalsystem(xExternalsystem string) BlockApiGetBlockByExtIdRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockApiGetBlockByExtIdRequest) AcceptLanguage(acceptLanguage string) BlockApiGetBlockByExtIdRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockApiGetBlockByExtIdRequest) Execute() (*Block, *http.Response, error) {
	return r.ApiService.GetBlockByExtIdExecute(r)
}

/*
GetBlockByExtId Get a Block By ID

Use this API to retrieve a specific block.  You will need to know the blockID in the request; if you don't know it, please go ahead and use getBlocks API first.  The response will include detailed information about the block. <p><strong>OperationId:</strong>getBlockByExtId</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockExternalId External Block ID.
 @param externalSystemCode Code to identify the external system from which the request is coming. This is the ExternalSystem ID used to exchange information between OPERA and the external system.
 @param hotelId Hotel Id
 @return BlockApiGetBlockByExtIdRequest
*/
func (a *BlockApiService) GetBlockByExtId(ctx context.Context, blockExternalId string, externalSystemCode string, hotelId string) BlockApiGetBlockByExtIdRequest {
	return BlockApiGetBlockByExtIdRequest{
		ApiService: a,
		ctx: ctx,
		blockExternalId: blockExternalId,
		externalSystemCode: externalSystemCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Block
func (a *BlockApiService) GetBlockByExtIdExecute(r BlockApiGetBlockByExtIdRequest) (*Block, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Block
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockApiService.GetBlockByExtId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/externalSystems/{externalSystemCode}/blocks/{blockExternalId}"
	localVarPath = strings.Replace(localVarPath, "{"+"blockExternalId"+"}", url.PathEscape(parameterValueToString(r.blockExternalId, "blockExternalId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"externalSystemCode"+"}", url.PathEscape(parameterValueToString(r.externalSystemCode, "externalSystemCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.blockExternalId) < 1 {
		return localVarReturnValue, nil, reportError("blockExternalId must have at least 1 elements")
	}
	if strlen(r.blockExternalId) > 2000 {
		return localVarReturnValue, nil, reportError("blockExternalId must have less than 2000 elements")
	}
	if strlen(r.externalSystemCode) < 1 {
		return localVarReturnValue, nil, reportError("externalSystemCode must have at least 1 elements")
	}
	if strlen(r.externalSystemCode) > 2000 {
		return localVarReturnValue, nil, reportError("externalSystemCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.markAsRecentlyAccessed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "markAsRecentlyAccessed", r.markAsRecentlyAccessed, "")
	}
	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
	}
	if r.fetchAllocatedRoomTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetchAllocatedRoomTypes", r.fetchAllocatedRoomTypes, "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.numberOfDays != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "numberOfDays", r.numberOfDays, "")
	}
	if r.roomAllocationCriteria != nil {
		t := *r.roomAllocationCriteria
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomAllocationCriteria", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomAllocationCriteria", t, "multi")
		}
	}
	if r.roomTypes != nil {
		t := *r.roomTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomTypes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomTypes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockApiGetBlockDailyStatisticsRequest struct {
	ctx context.Context
	ApiService *BlockApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	genericRoomType *bool
	limit *int32
	offset *int32
	hotelId *string
	end *string
	start *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockApiGetBlockDailyStatisticsRequest) Authorization(authorization string) BlockApiGetBlockDailyStatisticsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r BlockApiGetBlockDailyStatisticsRequest) XAppKey(xAppKey string) BlockApiGetBlockDailyStatisticsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockApiGetBlockDailyStatisticsRequest) XHotelid(xHotelid string) BlockApiGetBlockDailyStatisticsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates if the Allocation objects refer to Generic Room Types (Room Pools).
func (r BlockApiGetBlockDailyStatisticsRequest) GenericRoomType(genericRoomType bool) BlockApiGetBlockDailyStatisticsRequest {
	r.genericRoomType = &genericRoomType
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r BlockApiGetBlockDailyStatisticsRequest) Limit(limit int32) BlockApiGetBlockDailyStatisticsRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r BlockApiGetBlockDailyStatisticsRequest) Offset(offset int32) BlockApiGetBlockDailyStatisticsRequest {
	r.offset = &offset
	return r
}

// Pertain Hotel Code for search criteria.
func (r BlockApiGetBlockDailyStatisticsRequest) HotelId(hotelId string) BlockApiGetBlockDailyStatisticsRequest {
	r.hotelId = &hotelId
	return r
}

// The ending value of the date range.
func (r BlockApiGetBlockDailyStatisticsRequest) End(end string) BlockApiGetBlockDailyStatisticsRequest {
	r.end = &end
	return r
}

// The starting value of the date range.
func (r BlockApiGetBlockDailyStatisticsRequest) Start(start string) BlockApiGetBlockDailyStatisticsRequest {
	r.start = &start
	return r
}

// External system code.
func (r BlockApiGetBlockDailyStatisticsRequest) XExternalsystem(xExternalsystem string) BlockApiGetBlockDailyStatisticsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockApiGetBlockDailyStatisticsRequest) AcceptLanguage(acceptLanguage string) BlockApiGetBlockDailyStatisticsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockApiGetBlockDailyStatisticsRequest) Execute() (*BlockDailyStatistics, *http.Response, error) {
	return r.ApiService.GetBlockDailyStatisticsExecute(r)
}

/*
GetBlockDailyStatistics Get Block Daily Statistics

Use this API to retrieve block daily statistics for the given date range and hotel ID. It returns allocated, picked up, and available number of room nights per block, per day, per room type.<p><strong>OperationId:</strong>getBlockDailyStatistics</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return BlockApiGetBlockDailyStatisticsRequest
*/
func (a *BlockApiService) GetBlockDailyStatistics(ctx context.Context) BlockApiGetBlockDailyStatisticsRequest {
	return BlockApiGetBlockDailyStatisticsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BlockDailyStatistics
func (a *BlockApiService) GetBlockDailyStatisticsExecute(r BlockApiGetBlockDailyStatisticsRequest) (*BlockDailyStatistics, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BlockDailyStatistics
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockApiService.GetBlockDailyStatistics")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blocks/dailyStatistics"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.genericRoomType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "genericRoomType", r.genericRoomType, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
	}
	if r.end != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end", r.end, "")
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockApiGetBlockOwnersRequest struct {
	ctx context.Context
	ApiService *BlockApiService
	blockId string
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelId *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockApiGetBlockOwnersRequest) Authorization(authorization string) BlockApiGetBlockOwnersRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r BlockApiGetBlockOwnersRequest) XAppKey(xAppKey string) BlockApiGetBlockOwnersRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockApiGetBlockOwnersRequest) XHotelid(xHotelid string) BlockApiGetBlockOwnersRequest {
	r.xHotelid = &xHotelid
	return r
}

// Hotel code of the business block.
func (r BlockApiGetBlockOwnersRequest) HotelId(hotelId string) BlockApiGetBlockOwnersRequest {
	r.hotelId = &hotelId
	return r
}

// External system code.
func (r BlockApiGetBlockOwnersRequest) XExternalsystem(xExternalsystem string) BlockApiGetBlockOwnersRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockApiGetBlockOwnersRequest) AcceptLanguage(acceptLanguage string) BlockApiGetBlockOwnersRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockApiGetBlockOwnersRequest) Execute() (*BlockOwners, *http.Response, error) {
	return r.ApiService.GetBlockOwnersExecute(r)
}

/*
GetBlockOwners Get Block owners

Use this API to retrieve block owners. <p><strong>OperationId:</strong>getBlockOwners</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockId Block Id
 @return BlockApiGetBlockOwnersRequest
*/
func (a *BlockApiService) GetBlockOwners(ctx context.Context, blockId string) BlockApiGetBlockOwnersRequest {
	return BlockApiGetBlockOwnersRequest{
		ApiService: a,
		ctx: ctx,
		blockId: blockId,
	}
}

// Execute executes the request
//  @return BlockOwners
func (a *BlockApiService) GetBlockOwnersExecute(r BlockApiGetBlockOwnersRequest) (*BlockOwners, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BlockOwners
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockApiService.GetBlockOwners")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blocks/{blockId}/owners"
	localVarPath = strings.Replace(localVarPath, "{"+"blockId"+"}", url.PathEscape(parameterValueToString(r.blockId, "blockId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.blockId) < 1 {
		return localVarReturnValue, nil, reportError("blockId must have at least 1 elements")
	}
	if strlen(r.blockId) > 2000 {
		return localVarReturnValue, nil, reportError("blockId must have less than 2000 elements")
	}

	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockApiGetBlockPMReservationsRequest struct {
	ctx context.Context
	ApiService *BlockApiService
	blockId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	postingmaster *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockApiGetBlockPMReservationsRequest) Authorization(authorization string) BlockApiGetBlockPMReservationsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r BlockApiGetBlockPMReservationsRequest) XAppKey(xAppKey string) BlockApiGetBlockPMReservationsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockApiGetBlockPMReservationsRequest) XHotelid(xHotelid string) BlockApiGetBlockPMReservationsRequest {
	r.xHotelid = &xHotelid
	return r
}

// If true, a PM reservation will be created for the block if no PM reservations exist.
func (r BlockApiGetBlockPMReservationsRequest) Postingmaster(postingmaster bool) BlockApiGetBlockPMReservationsRequest {
	r.postingmaster = &postingmaster
	return r
}

// External system code.
func (r BlockApiGetBlockPMReservationsRequest) XExternalsystem(xExternalsystem string) BlockApiGetBlockPMReservationsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockApiGetBlockPMReservationsRequest) AcceptLanguage(acceptLanguage string) BlockApiGetBlockPMReservationsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockApiGetBlockPMReservationsRequest) Execute() (*BlockPMReservations, *http.Response, error) {
	return r.ApiService.GetBlockPMReservationsExecute(r)
}

/*
GetBlockPMReservations Get Posting Master Reservations for a Block

Use this API to retrieve PM (Posting Master) reservations for a block. <p><strong>OperationId:</strong>getBlockPMReservations</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockId Block Id
 @param hotelId Hotel Id
 @return BlockApiGetBlockPMReservationsRequest
*/
func (a *BlockApiService) GetBlockPMReservations(ctx context.Context, blockId string, hotelId string) BlockApiGetBlockPMReservationsRequest {
	return BlockApiGetBlockPMReservationsRequest{
		ApiService: a,
		ctx: ctx,
		blockId: blockId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return BlockPMReservations
func (a *BlockApiService) GetBlockPMReservationsExecute(r BlockApiGetBlockPMReservationsRequest) (*BlockPMReservations, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BlockPMReservations
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockApiService.GetBlockPMReservations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/blocks/{blockId}/postingMaster/reservations"
	localVarPath = strings.Replace(localVarPath, "{"+"blockId"+"}", url.PathEscape(parameterValueToString(r.blockId, "blockId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.blockId) < 1 {
		return localVarReturnValue, nil, reportError("blockId must have at least 1 elements")
	}
	if strlen(r.blockId) > 2000 {
		return localVarReturnValue, nil, reportError("blockId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.postingmaster != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "postingmaster", r.postingmaster, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockApiGetBlockPMReservationsByExtIdRequest struct {
	ctx context.Context
	ApiService *BlockApiService
	blockExternalId string
	externalSystemCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	postingmaster *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockApiGetBlockPMReservationsByExtIdRequest) Authorization(authorization string) BlockApiGetBlockPMReservationsByExtIdRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r BlockApiGetBlockPMReservationsByExtIdRequest) XAppKey(xAppKey string) BlockApiGetBlockPMReservationsByExtIdRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockApiGetBlockPMReservationsByExtIdRequest) XHotelid(xHotelid string) BlockApiGetBlockPMReservationsByExtIdRequest {
	r.xHotelid = &xHotelid
	return r
}

// If true, a PM reservation will be created for the block if no PM reservations exist.
func (r BlockApiGetBlockPMReservationsByExtIdRequest) Postingmaster(postingmaster bool) BlockApiGetBlockPMReservationsByExtIdRequest {
	r.postingmaster = &postingmaster
	return r
}

// External system code.
func (r BlockApiGetBlockPMReservationsByExtIdRequest) XExternalsystem(xExternalsystem string) BlockApiGetBlockPMReservationsByExtIdRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockApiGetBlockPMReservationsByExtIdRequest) AcceptLanguage(acceptLanguage string) BlockApiGetBlockPMReservationsByExtIdRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockApiGetBlockPMReservationsByExtIdRequest) Execute() (*BlockPMReservations, *http.Response, error) {
	return r.ApiService.GetBlockPMReservationsByExtIdExecute(r)
}

/*
GetBlockPMReservationsByExtId Get Posting Master Reservations for a Block

Use this API to retrieve PM (Posting Master) reservations for a block. <p><strong>OperationId:</strong>getBlockPMReservationsByExtId</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockExternalId External Block Id
 @param externalSystemCode Code to identify the external system from which the request is coming. This is the ExternalSystem ID used to exchange information between OPERA and the external system.
 @param hotelId Hotel Id
 @return BlockApiGetBlockPMReservationsByExtIdRequest
*/
func (a *BlockApiService) GetBlockPMReservationsByExtId(ctx context.Context, blockExternalId string, externalSystemCode string, hotelId string) BlockApiGetBlockPMReservationsByExtIdRequest {
	return BlockApiGetBlockPMReservationsByExtIdRequest{
		ApiService: a,
		ctx: ctx,
		blockExternalId: blockExternalId,
		externalSystemCode: externalSystemCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return BlockPMReservations
func (a *BlockApiService) GetBlockPMReservationsByExtIdExecute(r BlockApiGetBlockPMReservationsByExtIdRequest) (*BlockPMReservations, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BlockPMReservations
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockApiService.GetBlockPMReservationsByExtId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/externalSystems/{externalSystemCode}/blocks/{blockExternalId}/postingMaster/reservations"
	localVarPath = strings.Replace(localVarPath, "{"+"blockExternalId"+"}", url.PathEscape(parameterValueToString(r.blockExternalId, "blockExternalId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"externalSystemCode"+"}", url.PathEscape(parameterValueToString(r.externalSystemCode, "externalSystemCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.blockExternalId) < 1 {
		return localVarReturnValue, nil, reportError("blockExternalId must have at least 1 elements")
	}
	if strlen(r.blockExternalId) > 2000 {
		return localVarReturnValue, nil, reportError("blockExternalId must have less than 2000 elements")
	}
	if strlen(r.externalSystemCode) < 1 {
		return localVarReturnValue, nil, reportError("externalSystemCode must have at least 1 elements")
	}
	if strlen(r.externalSystemCode) > 2000 {
		return localVarReturnValue, nil, reportError("externalSystemCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.postingmaster != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "postingmaster", r.postingmaster, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockApiGetBlockRangeInfoRequest struct {
	ctx context.Context
	ApiService *BlockApiService
	blockId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	genericRoomType *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockApiGetBlockRangeInfoRequest) Authorization(authorization string) BlockApiGetBlockRangeInfoRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r BlockApiGetBlockRangeInfoRequest) XAppKey(xAppKey string) BlockApiGetBlockRangeInfoRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockApiGetBlockRangeInfoRequest) XHotelid(xHotelid string) BlockApiGetBlockRangeInfoRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates if the Allocation objects refer to Generic Room Types (Room Pools).
func (r BlockApiGetBlockRangeInfoRequest) GenericRoomType(genericRoomType bool) BlockApiGetBlockRangeInfoRequest {
	r.genericRoomType = &genericRoomType
	return r
}

// External system code.
func (r BlockApiGetBlockRangeInfoRequest) XExternalsystem(xExternalsystem string) BlockApiGetBlockRangeInfoRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockApiGetBlockRangeInfoRequest) AcceptLanguage(acceptLanguage string) BlockApiGetBlockRangeInfoRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockApiGetBlockRangeInfoRequest) Execute() (*BlockRangeInfo, *http.Response, error) {
	return r.ApiService.GetBlockRangeInfoExecute(r)
}

/*
GetBlockRangeInfo Get Block Range Information

Request for updating block allocation for a range of dates. <p><strong>OperationId:</strong>getBlockRangeInfo</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockId Block Id
 @param hotelId Hotel Id
 @return BlockApiGetBlockRangeInfoRequest
*/
func (a *BlockApiService) GetBlockRangeInfo(ctx context.Context, blockId string, hotelId string) BlockApiGetBlockRangeInfoRequest {
	return BlockApiGetBlockRangeInfoRequest{
		ApiService: a,
		ctx: ctx,
		blockId: blockId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return BlockRangeInfo
func (a *BlockApiService) GetBlockRangeInfoExecute(r BlockApiGetBlockRangeInfoRequest) (*BlockRangeInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BlockRangeInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockApiService.GetBlockRangeInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/blocks/{blockId}/allocationRange"
	localVarPath = strings.Replace(localVarPath, "{"+"blockId"+"}", url.PathEscape(parameterValueToString(r.blockId, "blockId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.blockId) < 1 {
		return localVarReturnValue, nil, reportError("blockId must have at least 1 elements")
	}
	if strlen(r.blockId) > 2000 {
		return localVarReturnValue, nil, reportError("blockId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.genericRoomType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "genericRoomType", r.genericRoomType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockApiGetBlockReservationsRequest struct {
	ctx context.Context
	ApiService *BlockApiService
	blockId string
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelId *string
	fetchInstructions *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockApiGetBlockReservationsRequest) Authorization(authorization string) BlockApiGetBlockReservationsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r BlockApiGetBlockReservationsRequest) XAppKey(xAppKey string) BlockApiGetBlockReservationsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockApiGetBlockReservationsRequest) XHotelid(xHotelid string) BlockApiGetBlockReservationsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Hotel Code to which the block belongs to.
func (r BlockApiGetBlockReservationsRequest) HotelId(hotelId string) BlockApiGetBlockReservationsRequest {
	r.hotelId = &hotelId
	return r
}

// Instruction to fetch whether the room was assigned/upgraded by AI. This will also include Reservation instruction.
func (r BlockApiGetBlockReservationsRequest) FetchInstructions(fetchInstructions []string) BlockApiGetBlockReservationsRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// External system code.
func (r BlockApiGetBlockReservationsRequest) XExternalsystem(xExternalsystem string) BlockApiGetBlockReservationsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockApiGetBlockReservationsRequest) AcceptLanguage(acceptLanguage string) BlockApiGetBlockReservationsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockApiGetBlockReservationsRequest) Execute() (*BlockReservations, *http.Response, error) {
	return r.ApiService.GetBlockReservationsExecute(r)
}

/*
GetBlockReservations Retrieves all reservations created for the Block

Use this API to  retrieve all reservations created for the given block ID. <p><strong>OperationId:</strong>getBlockReservations</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockId Block Id
 @return BlockApiGetBlockReservationsRequest
*/
func (a *BlockApiService) GetBlockReservations(ctx context.Context, blockId string) BlockApiGetBlockReservationsRequest {
	return BlockApiGetBlockReservationsRequest{
		ApiService: a,
		ctx: ctx,
		blockId: blockId,
	}
}

// Execute executes the request
//  @return BlockReservations
func (a *BlockApiService) GetBlockReservationsExecute(r BlockApiGetBlockReservationsRequest) (*BlockReservations, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BlockReservations
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockApiService.GetBlockReservations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blocks/{blockId}/reservations"
	localVarPath = strings.Replace(localVarPath, "{"+"blockId"+"}", url.PathEscape(parameterValueToString(r.blockId, "blockId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.blockId) < 1 {
		return localVarReturnValue, nil, reportError("blockId must have at least 1 elements")
	}
	if strlen(r.blockId) > 2000 {
		return localVarReturnValue, nil, reportError("blockId must have less than 2000 elements")
	}

	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
	}
	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockApiGetBlockRestrictionsRequest struct {
	ctx context.Context
	ApiService *BlockApiService
	blockId string
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelId *string
	startDate *string
	endDate *string
	duration *string
	roomType *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockApiGetBlockRestrictionsRequest) Authorization(authorization string) BlockApiGetBlockRestrictionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r BlockApiGetBlockRestrictionsRequest) XAppKey(xAppKey string) BlockApiGetBlockRestrictionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockApiGetBlockRestrictionsRequest) XHotelid(xHotelid string) BlockApiGetBlockRestrictionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Hotel Code to which the block belongs to.
func (r BlockApiGetBlockRestrictionsRequest) HotelId(hotelId string) BlockApiGetBlockRestrictionsRequest {
	r.hotelId = &hotelId
	return r
}

func (r BlockApiGetBlockRestrictionsRequest) StartDate(startDate string) BlockApiGetBlockRestrictionsRequest {
	r.startDate = &startDate
	return r
}

func (r BlockApiGetBlockRestrictionsRequest) EndDate(endDate string) BlockApiGetBlockRestrictionsRequest {
	r.endDate = &endDate
	return r
}

func (r BlockApiGetBlockRestrictionsRequest) Duration(duration string) BlockApiGetBlockRestrictionsRequest {
	r.duration = &duration
	return r
}

// Room Type for the restriction.
func (r BlockApiGetBlockRestrictionsRequest) RoomType(roomType []string) BlockApiGetBlockRestrictionsRequest {
	r.roomType = &roomType
	return r
}

// External system code.
func (r BlockApiGetBlockRestrictionsRequest) XExternalsystem(xExternalsystem string) BlockApiGetBlockRestrictionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockApiGetBlockRestrictionsRequest) AcceptLanguage(acceptLanguage string) BlockApiGetBlockRestrictionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockApiGetBlockRestrictionsRequest) Execute() (*BlockRestrictions, *http.Response, error) {
	return r.ApiService.GetBlockRestrictionsExecute(r)
}

/*
GetBlockRestrictions Get Block restrictions 

This API retrieves block restrictions. <p><strong>OperationId:</strong>getBlockRestrictions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockId Block Id
 @return BlockApiGetBlockRestrictionsRequest
*/
func (a *BlockApiService) GetBlockRestrictions(ctx context.Context, blockId string) BlockApiGetBlockRestrictionsRequest {
	return BlockApiGetBlockRestrictionsRequest{
		ApiService: a,
		ctx: ctx,
		blockId: blockId,
	}
}

// Execute executes the request
//  @return BlockRestrictions
func (a *BlockApiService) GetBlockRestrictionsExecute(r BlockApiGetBlockRestrictionsRequest) (*BlockRestrictions, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BlockRestrictions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockApiService.GetBlockRestrictions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blocks/{blockId}/restrictions"
	localVarPath = strings.Replace(localVarPath, "{"+"blockId"+"}", url.PathEscape(parameterValueToString(r.blockId, "blockId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.blockId) < 1 {
		return localVarReturnValue, nil, reportError("blockId must have at least 1 elements")
	}
	if strlen(r.blockId) > 2000 {
		return localVarReturnValue, nil, reportError("blockId must have less than 2000 elements")
	}

	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration", r.duration, "")
	}
	if r.roomType != nil {
		t := *r.roomType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomType", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockApiGetBlockRevenueChangesRequest struct {
	ctx context.Context
	ApiService *BlockApiService
	blockId string
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	hotelId *string
	status *[]string
	changeEndDate *string
	changeStartDate *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockApiGetBlockRevenueChangesRequest) Authorization(authorization string) BlockApiGetBlockRevenueChangesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r BlockApiGetBlockRevenueChangesRequest) XAppKey(xAppKey string) BlockApiGetBlockRevenueChangesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockApiGetBlockRevenueChangesRequest) XHotelid(xHotelid string) BlockApiGetBlockRevenueChangesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r BlockApiGetBlockRevenueChangesRequest) Limit(limit int32) BlockApiGetBlockRevenueChangesRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r BlockApiGetBlockRevenueChangesRequest) Offset(offset int32) BlockApiGetBlockRevenueChangesRequest {
	r.offset = &offset
	return r
}

// Hotel code for this block.
func (r BlockApiGetBlockRevenueChangesRequest) HotelId(hotelId string) BlockApiGetBlockRevenueChangesRequest {
	r.hotelId = &hotelId
	return r
}

// Status of this block.
func (r BlockApiGetBlockRevenueChangesRequest) Status(status []string) BlockApiGetBlockRevenueChangesRequest {
	r.status = &status
	return r
}

// The ending value of the date range.
func (r BlockApiGetBlockRevenueChangesRequest) ChangeEndDate(changeEndDate string) BlockApiGetBlockRevenueChangesRequest {
	r.changeEndDate = &changeEndDate
	return r
}

// The starting value of the date range.
func (r BlockApiGetBlockRevenueChangesRequest) ChangeStartDate(changeStartDate string) BlockApiGetBlockRevenueChangesRequest {
	r.changeStartDate = &changeStartDate
	return r
}

// External system code.
func (r BlockApiGetBlockRevenueChangesRequest) XExternalsystem(xExternalsystem string) BlockApiGetBlockRevenueChangesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockApiGetBlockRevenueChangesRequest) AcceptLanguage(acceptLanguage string) BlockApiGetBlockRevenueChangesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockApiGetBlockRevenueChangesRequest) Execute() (*BlockRevenueChanges, *http.Response, error) {
	return r.ApiService.GetBlockRevenueChangesExecute(r)
}

/*
GetBlockRevenueChanges Fetch Block Revenue Changes

This API will fetch revenue changes for a specific block recorded in the revenue change log for a specified date range. Please note that the revenue changes are delta changes only and single records do not represent a total summary of the block revenue per date. <p><strong>OperationId:</strong>getBlockRevenueChanges</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockId Block Id
 @return BlockApiGetBlockRevenueChangesRequest
*/
func (a *BlockApiService) GetBlockRevenueChanges(ctx context.Context, blockId string) BlockApiGetBlockRevenueChangesRequest {
	return BlockApiGetBlockRevenueChangesRequest{
		ApiService: a,
		ctx: ctx,
		blockId: blockId,
	}
}

// Execute executes the request
//  @return BlockRevenueChanges
func (a *BlockApiService) GetBlockRevenueChangesExecute(r BlockApiGetBlockRevenueChangesRequest) (*BlockRevenueChanges, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BlockRevenueChanges
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockApiService.GetBlockRevenueChanges")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blocks/{blockId}/revenueActivityLog"
	localVarPath = strings.Replace(localVarPath, "{"+"blockId"+"}", url.PathEscape(parameterValueToString(r.blockId, "blockId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.blockId) < 1 {
		return localVarReturnValue, nil, reportError("blockId must have at least 1 elements")
	}
	if strlen(r.blockId) > 2000 {
		return localVarReturnValue, nil, reportError("blockId must have less than 2000 elements")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
	}
	if r.status != nil {
		t := *r.status
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status", t, "multi")
		}
	}
	if r.changeEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "changeEndDate", r.changeEndDate, "")
	}
	if r.changeStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "changeStartDate", r.changeStartDate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockApiGetBlockRoomTypesRequest struct {
	ctx context.Context
	ApiService *BlockApiService
	blockId string
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelId *string
	fetchAllocatedRoomTypes *bool
	startDate *string
	endDate *string
	fetchGenericRoomTypes *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockApiGetBlockRoomTypesRequest) Authorization(authorization string) BlockApiGetBlockRoomTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r BlockApiGetBlockRoomTypesRequest) XAppKey(xAppKey string) BlockApiGetBlockRoomTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockApiGetBlockRoomTypesRequest) XHotelid(xHotelid string) BlockApiGetBlockRoomTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Used for codes in the OPERA Code tables. Possible values of this pattern are 1, 101, 101.EQP, or 101.EQP.X.
func (r BlockApiGetBlockRoomTypesRequest) HotelId(hotelId string) BlockApiGetBlockRoomTypesRequest {
	r.hotelId = &hotelId
	return r
}

// Indicates whether to fetch only allocated room types for the block.
func (r BlockApiGetBlockRoomTypesRequest) FetchAllocatedRoomTypes(fetchAllocatedRoomTypes bool) BlockApiGetBlockRoomTypesRequest {
	r.fetchAllocatedRoomTypes = &fetchAllocatedRoomTypes
	return r
}

// The start date of the range to be used to fetch allocated room types.
func (r BlockApiGetBlockRoomTypesRequest) StartDate(startDate string) BlockApiGetBlockRoomTypesRequest {
	r.startDate = &startDate
	return r
}

// The end date of the range to be used to fetch allocated room types.
func (r BlockApiGetBlockRoomTypesRequest) EndDate(endDate string) BlockApiGetBlockRoomTypesRequest {
	r.endDate = &endDate
	return r
}

// Indicates to fetch Generic Room Types (Room Pools).
func (r BlockApiGetBlockRoomTypesRequest) FetchGenericRoomTypes(fetchGenericRoomTypes bool) BlockApiGetBlockRoomTypesRequest {
	r.fetchGenericRoomTypes = &fetchGenericRoomTypes
	return r
}

// External system code.
func (r BlockApiGetBlockRoomTypesRequest) XExternalsystem(xExternalsystem string) BlockApiGetBlockRoomTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockApiGetBlockRoomTypesRequest) AcceptLanguage(acceptLanguage string) BlockApiGetBlockRoomTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockApiGetBlockRoomTypesRequest) Execute() (*BlockRoomTypes, *http.Response, error) {
	return r.ApiService.GetBlockRoomTypesExecute(r)
}

/*
GetBlockRoomTypes Get Bock Room Types

Use this API to retrieve room types for a block based on search criteria <p><strong>OperationId:</strong>getBlockRoomTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockId Block Id
 @return BlockApiGetBlockRoomTypesRequest
*/
func (a *BlockApiService) GetBlockRoomTypes(ctx context.Context, blockId string) BlockApiGetBlockRoomTypesRequest {
	return BlockApiGetBlockRoomTypesRequest{
		ApiService: a,
		ctx: ctx,
		blockId: blockId,
	}
}

// Execute executes the request
//  @return BlockRoomTypes
func (a *BlockApiService) GetBlockRoomTypesExecute(r BlockApiGetBlockRoomTypesRequest) (*BlockRoomTypes, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BlockRoomTypes
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockApiService.GetBlockRoomTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blocks/{blockId}/roomTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"blockId"+"}", url.PathEscape(parameterValueToString(r.blockId, "blockId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.blockId) < 1 {
		return localVarReturnValue, nil, reportError("blockId must have at least 1 elements")
	}
	if strlen(r.blockId) > 2000 {
		return localVarReturnValue, nil, reportError("blockId must have less than 2000 elements")
	}

	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
	}
	if r.fetchAllocatedRoomTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetchAllocatedRoomTypes", r.fetchAllocatedRoomTypes, "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.fetchGenericRoomTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetchGenericRoomTypes", r.fetchGenericRoomTypes, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockApiGetBlockRoomsStatusRequest struct {
	ctx context.Context
	ApiService *BlockApiService
	blockId string
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelId *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockApiGetBlockRoomsStatusRequest) Authorization(authorization string) BlockApiGetBlockRoomsStatusRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r BlockApiGetBlockRoomsStatusRequest) XAppKey(xAppKey string) BlockApiGetBlockRoomsStatusRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockApiGetBlockRoomsStatusRequest) XHotelid(xHotelid string) BlockApiGetBlockRoomsStatusRequest {
	r.xHotelid = &xHotelid
	return r
}

// Used for codes in the OPERA Code tables. Possible values of this pattern are 1, 101, 101.EQP, or 101.EQP.X.
func (r BlockApiGetBlockRoomsStatusRequest) HotelId(hotelId string) BlockApiGetBlockRoomsStatusRequest {
	r.hotelId = &hotelId
	return r
}

// External system code.
func (r BlockApiGetBlockRoomsStatusRequest) XExternalsystem(xExternalsystem string) BlockApiGetBlockRoomsStatusRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockApiGetBlockRoomsStatusRequest) AcceptLanguage(acceptLanguage string) BlockApiGetBlockRoomsStatusRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockApiGetBlockRoomsStatusRequest) Execute() (*BlockRoomsStatus, *http.Response, error) {
	return r.ApiService.GetBlockRoomsStatusExecute(r)
}

/*
GetBlockRoomsStatus Get room status for a Block

This API facilitates retrieving room status for the block. <p><strong>OperationId:</strong>getBlockRoomsStatus</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockId Block Id
 @return BlockApiGetBlockRoomsStatusRequest
*/
func (a *BlockApiService) GetBlockRoomsStatus(ctx context.Context, blockId string) BlockApiGetBlockRoomsStatusRequest {
	return BlockApiGetBlockRoomsStatusRequest{
		ApiService: a,
		ctx: ctx,
		blockId: blockId,
	}
}

// Execute executes the request
//  @return BlockRoomsStatus
func (a *BlockApiService) GetBlockRoomsStatusExecute(r BlockApiGetBlockRoomsStatusRequest) (*BlockRoomsStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BlockRoomsStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockApiService.GetBlockRoomsStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blocks/{blockId}/roomsStatus"
	localVarPath = strings.Replace(localVarPath, "{"+"blockId"+"}", url.PathEscape(parameterValueToString(r.blockId, "blockId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.blockId) < 1 {
		return localVarReturnValue, nil, reportError("blockId must have at least 1 elements")
	}
	if strlen(r.blockId) > 2000 {
		return localVarReturnValue, nil, reportError("blockId must have less than 2000 elements")
	}

	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockApiGetBlockStatisticsRequest struct {
	ctx context.Context
	ApiService *BlockApiService
	blockId string
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelId *string
	startDate *string
	numberOfDays *int32
	statisticsInstructions *[]string
	roomTypeHotelId *[]string
	invBlockCode *[]string
	promotionCode *[]string
	roomCategory *[]string
	roomClass *[]string
	roomQualifierCode *[]string
	roomQualifierMatchIndicator *[]string
	roomType *[]string
	roomViewCode *[]string
	roomFeatureCode *[]string
	defaultOccupancy *int32
	maximumOccupancy *int32
	noOfPhysicalRooms *int32
	bookingChannelCode *[]string
	bookingChannelMappingCode *[]string
	bookingChannelMappingName *[]string
	bedTypeCode *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockApiGetBlockStatisticsRequest) Authorization(authorization string) BlockApiGetBlockStatisticsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r BlockApiGetBlockStatisticsRequest) XAppKey(xAppKey string) BlockApiGetBlockStatisticsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockApiGetBlockStatisticsRequest) XHotelid(xHotelid string) BlockApiGetBlockStatisticsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Hotel Code of the business block.
func (r BlockApiGetBlockStatisticsRequest) HotelId(hotelId string) BlockApiGetBlockStatisticsRequest {
	r.hotelId = &hotelId
	return r
}

// Start date for the statistics data.
func (r BlockApiGetBlockStatisticsRequest) StartDate(startDate string) BlockApiGetBlockStatisticsRequest {
	r.startDate = &startDate
	return r
}

// Number of days to fetch for statistics data.
func (r BlockApiGetBlockStatisticsRequest) NumberOfDays(numberOfDays int32) BlockApiGetBlockStatisticsRequest {
	r.numberOfDays = &numberOfDays
	return r
}

// Type of statistic for which its statistics information by date and room type will be populated.
func (r BlockApiGetBlockStatisticsRequest) StatisticsInstructions(statisticsInstructions []string) BlockApiGetBlockStatisticsRequest {
	r.statisticsInstructions = &statisticsInstructions
	return r
}

func (r BlockApiGetBlockStatisticsRequest) RoomTypeHotelId(roomTypeHotelId []string) BlockApiGetBlockStatisticsRequest {
	r.roomTypeHotelId = &roomTypeHotelId
	return r
}

// Block code.
func (r BlockApiGetBlockStatisticsRequest) InvBlockCode(invBlockCode []string) BlockApiGetBlockStatisticsRequest {
	r.invBlockCode = &invBlockCode
	return r
}

// Represents the promotional code.
func (r BlockApiGetBlockStatisticsRequest) PromotionCode(promotionCode []string) BlockApiGetBlockStatisticsRequest {
	r.promotionCode = &promotionCode
	return r
}

func (r BlockApiGetBlockStatisticsRequest) RoomCategory(roomCategory []string) BlockApiGetBlockStatisticsRequest {
	r.roomCategory = &roomCategory
	return r
}

func (r BlockApiGetBlockStatisticsRequest) RoomClass(roomClass []string) BlockApiGetBlockStatisticsRequest {
	r.roomClass = &roomClass
	return r
}

// Represents the room qualifier code like Deluxe,Economy,Suite etc.
func (r BlockApiGetBlockStatisticsRequest) RoomQualifierCode(roomQualifierCode []string) BlockApiGetBlockStatisticsRequest {
	r.roomQualifierCode = &roomQualifierCode
	return r
}

// Represents the match indicator of room qualifier code returned in the response with the requested room qualifier code.
func (r BlockApiGetBlockStatisticsRequest) RoomQualifierMatchIndicator(roomQualifierMatchIndicator []string) BlockApiGetBlockStatisticsRequest {
	r.roomQualifierMatchIndicator = &roomQualifierMatchIndicator
	return r
}

func (r BlockApiGetBlockStatisticsRequest) RoomType(roomType []string) BlockApiGetBlockStatisticsRequest {
	r.roomType = &roomType
	return r
}

// Represents the room view code like City view, River view, Ocean view etc.
func (r BlockApiGetBlockStatisticsRequest) RoomViewCode(roomViewCode []string) BlockApiGetBlockStatisticsRequest {
	r.roomViewCode = &roomViewCode
	return r
}

// A code representing a room feature.
func (r BlockApiGetBlockStatisticsRequest) RoomFeatureCode(roomFeatureCode []string) BlockApiGetBlockStatisticsRequest {
	r.roomFeatureCode = &roomFeatureCode
	return r
}

// Default occupancy of property room type.
func (r BlockApiGetBlockStatisticsRequest) DefaultOccupancy(defaultOccupancy int32) BlockApiGetBlockStatisticsRequest {
	r.defaultOccupancy = &defaultOccupancy
	return r
}

// Max occupancy of property room type.
func (r BlockApiGetBlockStatisticsRequest) MaximumOccupancy(maximumOccupancy int32) BlockApiGetBlockStatisticsRequest {
	r.maximumOccupancy = &maximumOccupancy
	return r
}

// Number of physical rooms of property room type.
func (r BlockApiGetBlockStatisticsRequest) NoOfPhysicalRooms(noOfPhysicalRooms int32) BlockApiGetBlockStatisticsRequest {
	r.noOfPhysicalRooms = &noOfPhysicalRooms
	return r
}

func (r BlockApiGetBlockStatisticsRequest) BookingChannelCode(bookingChannelCode []string) BlockApiGetBlockStatisticsRequest {
	r.bookingChannelCode = &bookingChannelCode
	return r
}

func (r BlockApiGetBlockStatisticsRequest) BookingChannelMappingCode(bookingChannelMappingCode []string) BlockApiGetBlockStatisticsRequest {
	r.bookingChannelMappingCode = &bookingChannelMappingCode
	return r
}

func (r BlockApiGetBlockStatisticsRequest) BookingChannelMappingName(bookingChannelMappingName []string) BlockApiGetBlockStatisticsRequest {
	r.bookingChannelMappingName = &bookingChannelMappingName
	return r
}

// Bed type code associated with room.
func (r BlockApiGetBlockStatisticsRequest) BedTypeCode(bedTypeCode []string) BlockApiGetBlockStatisticsRequest {
	r.bedTypeCode = &bedTypeCode
	return r
}

// External system code.
func (r BlockApiGetBlockStatisticsRequest) XExternalsystem(xExternalsystem string) BlockApiGetBlockStatisticsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockApiGetBlockStatisticsRequest) AcceptLanguage(acceptLanguage string) BlockApiGetBlockStatisticsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockApiGetBlockStatisticsRequest) Execute() (*BlockStatistics, *http.Response, error) {
	return r.ApiService.GetBlockStatisticsExecute(r)
}

/*
GetBlockStatistics Get Block Statistics

Use this API to API retrieve detailed block statistics <p><strong>OperationId:</strong>getBlockStatistics</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockId Block Id
 @return BlockApiGetBlockStatisticsRequest
*/
func (a *BlockApiService) GetBlockStatistics(ctx context.Context, blockId string) BlockApiGetBlockStatisticsRequest {
	return BlockApiGetBlockStatisticsRequest{
		ApiService: a,
		ctx: ctx,
		blockId: blockId,
	}
}

// Execute executes the request
//  @return BlockStatistics
func (a *BlockApiService) GetBlockStatisticsExecute(r BlockApiGetBlockStatisticsRequest) (*BlockStatistics, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BlockStatistics
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockApiService.GetBlockStatistics")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blocks/{blockId}/statistics"
	localVarPath = strings.Replace(localVarPath, "{"+"blockId"+"}", url.PathEscape(parameterValueToString(r.blockId, "blockId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.blockId) < 1 {
		return localVarReturnValue, nil, reportError("blockId must have at least 1 elements")
	}
	if strlen(r.blockId) > 2000 {
		return localVarReturnValue, nil, reportError("blockId must have less than 2000 elements")
	}

	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.numberOfDays != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "numberOfDays", r.numberOfDays, "")
	}
	if r.statisticsInstructions != nil {
		t := *r.statisticsInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "statisticsInstructions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "statisticsInstructions", t, "multi")
		}
	}
	if r.roomTypeHotelId != nil {
		t := *r.roomTypeHotelId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomTypeHotelId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomTypeHotelId", t, "multi")
		}
	}
	if r.invBlockCode != nil {
		t := *r.invBlockCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "invBlockCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "invBlockCode", t, "multi")
		}
	}
	if r.promotionCode != nil {
		t := *r.promotionCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "promotionCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "promotionCode", t, "multi")
		}
	}
	if r.roomCategory != nil {
		t := *r.roomCategory
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomCategory", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomCategory", t, "multi")
		}
	}
	if r.roomClass != nil {
		t := *r.roomClass
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomClass", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomClass", t, "multi")
		}
	}
	if r.roomQualifierCode != nil {
		t := *r.roomQualifierCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomQualifierCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomQualifierCode", t, "multi")
		}
	}
	if r.roomQualifierMatchIndicator != nil {
		t := *r.roomQualifierMatchIndicator
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomQualifierMatchIndicator", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomQualifierMatchIndicator", t, "multi")
		}
	}
	if r.roomType != nil {
		t := *r.roomType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomType", t, "multi")
		}
	}
	if r.roomViewCode != nil {
		t := *r.roomViewCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomViewCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomViewCode", t, "multi")
		}
	}
	if r.roomFeatureCode != nil {
		t := *r.roomFeatureCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomFeatureCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomFeatureCode", t, "multi")
		}
	}
	if r.defaultOccupancy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "defaultOccupancy", r.defaultOccupancy, "")
	}
	if r.maximumOccupancy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maximumOccupancy", r.maximumOccupancy, "")
	}
	if r.noOfPhysicalRooms != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "noOfPhysicalRooms", r.noOfPhysicalRooms, "")
	}
	if r.bookingChannelCode != nil {
		t := *r.bookingChannelCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "bookingChannelCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "bookingChannelCode", t, "multi")
		}
	}
	if r.bookingChannelMappingCode != nil {
		t := *r.bookingChannelMappingCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "bookingChannelMappingCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "bookingChannelMappingCode", t, "multi")
		}
	}
	if r.bookingChannelMappingName != nil {
		t := *r.bookingChannelMappingName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "bookingChannelMappingName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "bookingChannelMappingName", t, "multi")
		}
	}
	if r.bedTypeCode != nil {
		t := *r.bedTypeCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "bedTypeCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "bedTypeCode", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockApiGetBlockStatusChangesRequest struct {
	ctx context.Context
	ApiService *BlockApiService
	blockId string
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	hotelId *string
	changeEndDate *string
	changeStartDate *string
	currentStatus *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockApiGetBlockStatusChangesRequest) Authorization(authorization string) BlockApiGetBlockStatusChangesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r BlockApiGetBlockStatusChangesRequest) XAppKey(xAppKey string) BlockApiGetBlockStatusChangesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockApiGetBlockStatusChangesRequest) XHotelid(xHotelid string) BlockApiGetBlockStatusChangesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r BlockApiGetBlockStatusChangesRequest) Limit(limit int32) BlockApiGetBlockStatusChangesRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r BlockApiGetBlockStatusChangesRequest) Offset(offset int32) BlockApiGetBlockStatusChangesRequest {
	r.offset = &offset
	return r
}

// Hotel Code for this block .
func (r BlockApiGetBlockStatusChangesRequest) HotelId(hotelId string) BlockApiGetBlockStatusChangesRequest {
	r.hotelId = &hotelId
	return r
}

// The ending value of the date range.
func (r BlockApiGetBlockStatusChangesRequest) ChangeEndDate(changeEndDate string) BlockApiGetBlockStatusChangesRequest {
	r.changeEndDate = &changeEndDate
	return r
}

// The starting value of the date range.
func (r BlockApiGetBlockStatusChangesRequest) ChangeStartDate(changeStartDate string) BlockApiGetBlockStatusChangesRequest {
	r.changeStartDate = &changeStartDate
	return r
}

// Current Status of the block .
func (r BlockApiGetBlockStatusChangesRequest) CurrentStatus(currentStatus []string) BlockApiGetBlockStatusChangesRequest {
	r.currentStatus = &currentStatus
	return r
}

// External system code.
func (r BlockApiGetBlockStatusChangesRequest) XExternalsystem(xExternalsystem string) BlockApiGetBlockStatusChangesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockApiGetBlockStatusChangesRequest) AcceptLanguage(acceptLanguage string) BlockApiGetBlockStatusChangesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockApiGetBlockStatusChangesRequest) Execute() (*BlockStatusChanges, *http.Response, error) {
	return r.ApiService.GetBlockStatusChangesExecute(r)
}

/*
GetBlockStatusChanges Get Block Status Activity Log

Use this API to retrieve block status change log based on the HotelCode and Block ID. <p><strong>OperationId:</strong>getBlockStatusChanges</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockId Block Id
 @return BlockApiGetBlockStatusChangesRequest
*/
func (a *BlockApiService) GetBlockStatusChanges(ctx context.Context, blockId string) BlockApiGetBlockStatusChangesRequest {
	return BlockApiGetBlockStatusChangesRequest{
		ApiService: a,
		ctx: ctx,
		blockId: blockId,
	}
}

// Execute executes the request
//  @return BlockStatusChanges
func (a *BlockApiService) GetBlockStatusChangesExecute(r BlockApiGetBlockStatusChangesRequest) (*BlockStatusChanges, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BlockStatusChanges
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockApiService.GetBlockStatusChanges")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blocks/{blockId}/statusActivityLog"
	localVarPath = strings.Replace(localVarPath, "{"+"blockId"+"}", url.PathEscape(parameterValueToString(r.blockId, "blockId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.blockId) < 1 {
		return localVarReturnValue, nil, reportError("blockId must have at least 1 elements")
	}
	if strlen(r.blockId) > 2000 {
		return localVarReturnValue, nil, reportError("blockId must have less than 2000 elements")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
	}
	if r.changeEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "changeEndDate", r.changeEndDate, "")
	}
	if r.changeStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "changeStartDate", r.changeStartDate, "")
	}
	if r.currentStatus != nil {
		t := *r.currentStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "currentStatus", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "currentStatus", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockApiGetBlockWashInfoRequest struct {
	ctx context.Context
	ApiService *BlockApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelId *string
	blockId *string
	blockIdType *string
	genericRoomType *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockApiGetBlockWashInfoRequest) Authorization(authorization string) BlockApiGetBlockWashInfoRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r BlockApiGetBlockWashInfoRequest) XAppKey(xAppKey string) BlockApiGetBlockWashInfoRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockApiGetBlockWashInfoRequest) XHotelid(xHotelid string) BlockApiGetBlockWashInfoRequest {
	r.xHotelid = &xHotelid
	return r
}

// Used for codes in the OPERA Code tables. Possible values of this pattern are 1, 101, 101.EQP, or 101.EQP.X.
func (r BlockApiGetBlockWashInfoRequest) HotelId(hotelId string) BlockApiGetBlockWashInfoRequest {
	r.hotelId = &hotelId
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r BlockApiGetBlockWashInfoRequest) BlockId(blockId string) BlockApiGetBlockWashInfoRequest {
	r.blockId = &blockId
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r BlockApiGetBlockWashInfoRequest) BlockIdType(blockIdType string) BlockApiGetBlockWashInfoRequest {
	r.blockIdType = &blockIdType
	return r
}

// Indicates if the Allocation objects refer to Generic Room Types (Room Pools).
func (r BlockApiGetBlockWashInfoRequest) GenericRoomType(genericRoomType bool) BlockApiGetBlockWashInfoRequest {
	r.genericRoomType = &genericRoomType
	return r
}

// External system code.
func (r BlockApiGetBlockWashInfoRequest) XExternalsystem(xExternalsystem string) BlockApiGetBlockWashInfoRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockApiGetBlockWashInfoRequest) AcceptLanguage(acceptLanguage string) BlockApiGetBlockWashInfoRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockApiGetBlockWashInfoRequest) Execute() (*BlockWashInfo, *http.Response, error) {
	return r.ApiService.GetBlockWashInfoExecute(r)
}

/*
GetBlockWashInfo Get Block Wash Information

This API retrieves block information needed to perform block wash operation. <p><strong>OperationId:</strong>getBlockWashInfo</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return BlockApiGetBlockWashInfoRequest
*/
func (a *BlockApiService) GetBlockWashInfo(ctx context.Context) BlockApiGetBlockWashInfoRequest {
	return BlockApiGetBlockWashInfoRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BlockWashInfo
func (a *BlockApiService) GetBlockWashInfoExecute(r BlockApiGetBlockWashInfoRequest) (*BlockWashInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BlockWashInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockApiService.GetBlockWashInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blockWash"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
	}
	if r.blockId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blockId", r.blockId, "")
	}
	if r.blockIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blockIdType", r.blockIdType, "")
	}
	if r.genericRoomType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "genericRoomType", r.genericRoomType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockApiGetBlockWashSchedulesRequest struct {
	ctx context.Context
	ApiService *BlockApiService
	blockId string
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelId *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockApiGetBlockWashSchedulesRequest) Authorization(authorization string) BlockApiGetBlockWashSchedulesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r BlockApiGetBlockWashSchedulesRequest) XAppKey(xAppKey string) BlockApiGetBlockWashSchedulesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockApiGetBlockWashSchedulesRequest) XHotelid(xHotelid string) BlockApiGetBlockWashSchedulesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Used for codes in the OPERA Code tables. Possible values of this pattern are 1, 101, 101.EQP, or 101.EQP.X.
func (r BlockApiGetBlockWashSchedulesRequest) HotelId(hotelId string) BlockApiGetBlockWashSchedulesRequest {
	r.hotelId = &hotelId
	return r
}

// External system code.
func (r BlockApiGetBlockWashSchedulesRequest) XExternalsystem(xExternalsystem string) BlockApiGetBlockWashSchedulesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockApiGetBlockWashSchedulesRequest) AcceptLanguage(acceptLanguage string) BlockApiGetBlockWashSchedulesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockApiGetBlockWashSchedulesRequest) Execute() (*BlockWashSchedules, *http.Response, error) {
	return r.ApiService.GetBlockWashSchedulesExecute(r)
}

/*
GetBlockWashSchedules Get Block Wash Schedule

Use this API to retrieve the information regarding block wash schedule based on the parameter HotelCode and Block ID. <p><strong>OperationId:</strong>getBlockWashSchedules</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockId Block Id
 @return BlockApiGetBlockWashSchedulesRequest
*/
func (a *BlockApiService) GetBlockWashSchedules(ctx context.Context, blockId string) BlockApiGetBlockWashSchedulesRequest {
	return BlockApiGetBlockWashSchedulesRequest{
		ApiService: a,
		ctx: ctx,
		blockId: blockId,
	}
}

// Execute executes the request
//  @return BlockWashSchedules
func (a *BlockApiService) GetBlockWashSchedulesExecute(r BlockApiGetBlockWashSchedulesRequest) (*BlockWashSchedules, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BlockWashSchedules
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockApiService.GetBlockWashSchedules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blocks/{blockId}/washSchedules"
	localVarPath = strings.Replace(localVarPath, "{"+"blockId"+"}", url.PathEscape(parameterValueToString(r.blockId, "blockId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.blockId) < 1 {
		return localVarReturnValue, nil, reportError("blockId must have at least 1 elements")
	}
	if strlen(r.blockId) > 2000 {
		return localVarReturnValue, nil, reportError("blockId must have less than 2000 elements")
	}

	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockApiGetBlocksRequest struct {
	ctx context.Context
	ApiService *BlockApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelId *string
	markAsRecentlyAccessed *bool
	limit *int32
	offset *int32
	multipleHotelsSearchHotelIds *[]string
	superSearch *string
	blockIdList *[]string
	blockIdType *[]string
	externalReferenceIds *[]string
	externalSystemCodes *[]string
	blockCode *string
	blockName *string
	blockOwner *[]string
	blockStatus *[]string
	cateringStatus *[]string
	createdByUser *string
	blockStartEndDate *string
	blockStartStartDate *string
	blockEndEndDate *string
	blockEndStartDate *string
	reservationArrival *string
	reservationDeparture *string
	includeShoulderDates *bool
	stayDate *string
	blockCreatedOnEndDate *string
	blockCreatedOnStartDate *string
	decisionEndDate *string
	decisionStartDate *string
	cutOffEndDate *string
	cutOffStartDate *string
	category *[]string
	name *[]string
	attachedProfileId *string
	attachedProfileIdType *string
	leads *bool
	tourSeries *bool
	onlyPickupBlocks *bool
	onlyOpportunities *bool
	ratePlanCode *[]string
	tourCode *string
	attributeName *[]string
	orderType *[]string
	fetchInstructions *[]string
	fetchAllocatedRoomTypes *bool
	additionalCriteriaStartDate *string
	numberOfDays *float32
	adults *int32
	children *int32
	childAge *[]int32
	bucket1Count *int32
	bucket2Count *int32
	bucket3Count *int32
	bucket4Count *int32
	bucket5Count *int32
	existingReservationId *string
	existingReservationIdType *string
	roomAllocationCriteria *[]string
	roomType *[]string
	additionalCriteriaRatePlanCode *string
	currencyCode *string
	customCharUDFsAltname *[]string
	customCharUDFsName *[]string
	customCharUDFsValue *[]string
	customNumericUDFsAltname *[]string
	customNumericUDFsName *[]string
	customNumericUDFsValue *[]float32
	customDateUDFsAltname *[]string
	customDateUDFsName *[]string
	customDateUDFsValue *[]string
	accessRestriction *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockApiGetBlocksRequest) Authorization(authorization string) BlockApiGetBlocksRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r BlockApiGetBlocksRequest) XAppKey(xAppKey string) BlockApiGetBlocksRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockApiGetBlocksRequest) XHotelid(xHotelid string) BlockApiGetBlocksRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r BlockApiGetBlocksRequest) HotelId(hotelId string) BlockApiGetBlocksRequest {
	r.hotelId = &hotelId
	return r
}

// Mark this block as recently accessed.
func (r BlockApiGetBlocksRequest) MarkAsRecentlyAccessed(markAsRecentlyAccessed bool) BlockApiGetBlocksRequest {
	r.markAsRecentlyAccessed = &markAsRecentlyAccessed
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r BlockApiGetBlocksRequest) Limit(limit int32) BlockApiGetBlocksRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r BlockApiGetBlocksRequest) Offset(offset int32) BlockApiGetBlocksRequest {
	r.offset = &offset
	return r
}

// Hotel code.
func (r BlockApiGetBlocksRequest) MultipleHotelsSearchHotelIds(multipleHotelsSearchHotelIds []string) BlockApiGetBlocksRequest {
	r.multipleHotelsSearchHotelIds = &multipleHotelsSearchHotelIds
	return r
}

// Free form text field for searching block fields
func (r BlockApiGetBlocksRequest) SuperSearch(superSearch string) BlockApiGetBlocksRequest {
	r.superSearch = &superSearch
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r BlockApiGetBlocksRequest) BlockIdList(blockIdList []string) BlockApiGetBlocksRequest {
	r.blockIdList = &blockIdList
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r BlockApiGetBlocksRequest) BlockIdType(blockIdType []string) BlockApiGetBlocksRequest {
	r.blockIdType = &blockIdType
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r BlockApiGetBlocksRequest) ExternalReferenceIds(externalReferenceIds []string) BlockApiGetBlocksRequest {
	r.externalReferenceIds = &externalReferenceIds
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r BlockApiGetBlocksRequest) ExternalSystemCodes(externalSystemCodes []string) BlockApiGetBlocksRequest {
	r.externalSystemCodes = &externalSystemCodes
	return r
}

// Block code
func (r BlockApiGetBlocksRequest) BlockCode(blockCode string) BlockApiGetBlocksRequest {
	r.blockCode = &blockCode
	return r
}

// Block Name
func (r BlockApiGetBlocksRequest) BlockName(blockName string) BlockApiGetBlocksRequest {
	r.blockName = &blockName
	return r
}

// Block Owner.
func (r BlockApiGetBlocksRequest) BlockOwner(blockOwner []string) BlockApiGetBlocksRequest {
	r.blockOwner = &blockOwner
	return r
}

// Block Status.
func (r BlockApiGetBlocksRequest) BlockStatus(blockStatus []string) BlockApiGetBlocksRequest {
	r.blockStatus = &blockStatus
	return r
}

// Catering Status.
func (r BlockApiGetBlocksRequest) CateringStatus(cateringStatus []string) BlockApiGetBlocksRequest {
	r.cateringStatus = &cateringStatus
	return r
}

// user who created the Block(s).
func (r BlockApiGetBlocksRequest) CreatedByUser(createdByUser string) BlockApiGetBlocksRequest {
	r.createdByUser = &createdByUser
	return r
}

// The ending value of the date range.
func (r BlockApiGetBlocksRequest) BlockStartEndDate(blockStartEndDate string) BlockApiGetBlocksRequest {
	r.blockStartEndDate = &blockStartEndDate
	return r
}

// The starting value of the date range.
func (r BlockApiGetBlocksRequest) BlockStartStartDate(blockStartStartDate string) BlockApiGetBlocksRequest {
	r.blockStartStartDate = &blockStartStartDate
	return r
}

// The ending value of the date range.
func (r BlockApiGetBlocksRequest) BlockEndEndDate(blockEndEndDate string) BlockApiGetBlocksRequest {
	r.blockEndEndDate = &blockEndEndDate
	return r
}

// The starting value of the date range.
func (r BlockApiGetBlocksRequest) BlockEndStartDate(blockEndStartDate string) BlockApiGetBlocksRequest {
	r.blockEndStartDate = &blockEndStartDate
	return r
}

// Date when guests plan to arrive(first night stay date).
func (r BlockApiGetBlocksRequest) ReservationArrival(reservationArrival string) BlockApiGetBlocksRequest {
	r.reservationArrival = &reservationArrival
	return r
}

// Date when guests plan to leave(last stay day date).
func (r BlockApiGetBlocksRequest) ReservationDeparture(reservationDeparture string) BlockApiGetBlocksRequest {
	r.reservationDeparture = &reservationDeparture
	return r
}

// Whether to include shoulder dates when considering stay date.
func (r BlockApiGetBlocksRequest) IncludeShoulderDates(includeShoulderDates bool) BlockApiGetBlocksRequest {
	r.includeShoulderDates = &includeShoulderDates
	return r
}

func (r BlockApiGetBlocksRequest) StayDate(stayDate string) BlockApiGetBlocksRequest {
	r.stayDate = &stayDate
	return r
}

// The ending value of the date range.
func (r BlockApiGetBlocksRequest) BlockCreatedOnEndDate(blockCreatedOnEndDate string) BlockApiGetBlocksRequest {
	r.blockCreatedOnEndDate = &blockCreatedOnEndDate
	return r
}

// The starting value of the date range.
func (r BlockApiGetBlocksRequest) BlockCreatedOnStartDate(blockCreatedOnStartDate string) BlockApiGetBlocksRequest {
	r.blockCreatedOnStartDate = &blockCreatedOnStartDate
	return r
}

// The ending value of the date range.
func (r BlockApiGetBlocksRequest) DecisionEndDate(decisionEndDate string) BlockApiGetBlocksRequest {
	r.decisionEndDate = &decisionEndDate
	return r
}

// The starting value of the date range.
func (r BlockApiGetBlocksRequest) DecisionStartDate(decisionStartDate string) BlockApiGetBlocksRequest {
	r.decisionStartDate = &decisionStartDate
	return r
}

// The ending value of the date range.
func (r BlockApiGetBlocksRequest) CutOffEndDate(cutOffEndDate string) BlockApiGetBlocksRequest {
	r.cutOffEndDate = &cutOffEndDate
	return r
}

// The starting value of the date range.
func (r BlockApiGetBlocksRequest) CutOffStartDate(cutOffStartDate string) BlockApiGetBlocksRequest {
	r.cutOffStartDate = &cutOffStartDate
	return r
}

// Simple type for block instructions to be used in requests for fetching blocks. Valid status values are Group, Source, TravelAgent, Contact, Company.
func (r BlockApiGetBlocksRequest) Category(category []string) BlockApiGetBlocksRequest {
	r.category = &category
	return r
}

// Attached profile name
func (r BlockApiGetBlocksRequest) Name(name []string) BlockApiGetBlocksRequest {
	r.name = &name
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r BlockApiGetBlocksRequest) AttachedProfileId(attachedProfileId string) BlockApiGetBlocksRequest {
	r.attachedProfileId = &attachedProfileId
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r BlockApiGetBlocksRequest) AttachedProfileIdType(attachedProfileIdType string) BlockApiGetBlocksRequest {
	r.attachedProfileIdType = &attachedProfileIdType
	return r
}

// Show Leads in the search result.
func (r BlockApiGetBlocksRequest) Leads(leads bool) BlockApiGetBlocksRequest {
	r.leads = &leads
	return r
}

// Show tour series in the search result.
func (r BlockApiGetBlocksRequest) TourSeries(tourSeries bool) BlockApiGetBlocksRequest {
	r.tourSeries = &tourSeries
	return r
}

// Fetch only blocks which are open for pickup, if true. If the value is false, fetch all block statuses.
func (r BlockApiGetBlocksRequest) OnlyPickupBlocks(onlyPickupBlocks bool) BlockApiGetBlocksRequest {
	r.onlyPickupBlocks = &onlyPickupBlocks
	return r
}

// Indicates that only Opportunity blocks will be fetched.
func (r BlockApiGetBlocksRequest) OnlyOpportunities(onlyOpportunities bool) BlockApiGetBlocksRequest {
	r.onlyOpportunities = &onlyOpportunities
	return r
}

// Rate Plan Code.
func (r BlockApiGetBlocksRequest) RatePlanCode(ratePlanCode []string) BlockApiGetBlocksRequest {
	r.ratePlanCode = &ratePlanCode
	return r
}

// Tour code for the block.
func (r BlockApiGetBlocksRequest) TourCode(tourCode string) BlockApiGetBlocksRequest {
	r.tourCode = &tourCode
	return r
}

func (r BlockApiGetBlocksRequest) AttributeName(attributeName []string) BlockApiGetBlocksRequest {
	r.attributeName = &attributeName
	return r
}

func (r BlockApiGetBlocksRequest) OrderType(orderType []string) BlockApiGetBlocksRequest {
	r.orderType = &orderType
	return r
}

// Type for block instructions that can be used in requests for partial operations.
func (r BlockApiGetBlocksRequest) FetchInstructions(fetchInstructions []string) BlockApiGetBlocksRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// Indicates whether to fetch only those room types that have rooms allocated. If this flag is true then only those room types with rooms allocated for the block are fetched. Only applicable to fetch instruction RateGrid.
func (r BlockApiGetBlocksRequest) FetchAllocatedRoomTypes(fetchAllocatedRoomTypes bool) BlockApiGetBlocksRequest {
	r.fetchAllocatedRoomTypes = &fetchAllocatedRoomTypes
	return r
}

// Start Date for the rate grid data. Only applicable to fetch instruction RateGrid.
func (r BlockApiGetBlocksRequest) AdditionalCriteriaStartDate(additionalCriteriaStartDate string) BlockApiGetBlocksRequest {
	r.additionalCriteriaStartDate = &additionalCriteriaStartDate
	return r
}

// Number of days to fetch for the rate grid data. Only applicable to fetch instruction RateGrid.
func (r BlockApiGetBlocksRequest) NumberOfDays(numberOfDays float32) BlockApiGetBlocksRequest {
	r.numberOfDays = &numberOfDays
	return r
}

// Defines the number of Adults.
func (r BlockApiGetBlocksRequest) Adults(adults int32) BlockApiGetBlocksRequest {
	r.adults = &adults
	return r
}

// Defines the number of Children.
func (r BlockApiGetBlocksRequest) Children(children int32) BlockApiGetBlocksRequest {
	r.children = &children
	return r
}

// Age of a child in years.
func (r BlockApiGetBlocksRequest) ChildAge(childAge []int32) BlockApiGetBlocksRequest {
	r.childAge = &childAge
	return r
}

// Number of children classified under the first Age Qualifying Group(Child Bucket#1).
func (r BlockApiGetBlocksRequest) Bucket1Count(bucket1Count int32) BlockApiGetBlocksRequest {
	r.bucket1Count = &bucket1Count
	return r
}

// Number of children classified under the second Age Qualifying Group(Child Bucket#2).
func (r BlockApiGetBlocksRequest) Bucket2Count(bucket2Count int32) BlockApiGetBlocksRequest {
	r.bucket2Count = &bucket2Count
	return r
}

// Number of children classified under the third Age Qualifying Group(Child Bucket#3).
func (r BlockApiGetBlocksRequest) Bucket3Count(bucket3Count int32) BlockApiGetBlocksRequest {
	r.bucket3Count = &bucket3Count
	return r
}

// Number of children classified under the fourth Age Qualifying Group(Child Bucket#4).
func (r BlockApiGetBlocksRequest) Bucket4Count(bucket4Count int32) BlockApiGetBlocksRequest {
	r.bucket4Count = &bucket4Count
	return r
}

// Number of children classified under the fifth Age Qualifying Group(Child Bucket#5).
func (r BlockApiGetBlocksRequest) Bucket5Count(bucket5Count int32) BlockApiGetBlocksRequest {
	r.bucket5Count = &bucket5Count
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r BlockApiGetBlocksRequest) ExistingReservationId(existingReservationId string) BlockApiGetBlocksRequest {
	r.existingReservationId = &existingReservationId
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r BlockApiGetBlocksRequest) ExistingReservationIdType(existingReservationIdType string) BlockApiGetBlocksRequest {
	r.existingReservationIdType = &existingReservationIdType
	return r
}

// Simple type for block allocation used in room rate grid.
func (r BlockApiGetBlocksRequest) RoomAllocationCriteria(roomAllocationCriteria []string) BlockApiGetBlocksRequest {
	r.roomAllocationCriteria = &roomAllocationCriteria
	return r
}

// The Room Types that need to be fetched for the rate room grid data. If these values are not provided, all room types for the block will be fetched.
func (r BlockApiGetBlocksRequest) RoomType(roomType []string) BlockApiGetBlocksRequest {
	r.roomType = &roomType
	return r
}

// Rate Plan to use for fetching rates.
func (r BlockApiGetBlocksRequest) AdditionalCriteriaRatePlanCode(additionalCriteriaRatePlanCode string) BlockApiGetBlocksRequest {
	r.additionalCriteriaRatePlanCode = &additionalCriteriaRatePlanCode
	return r
}

// Curency in which the grid rates should be fetched.
func (r BlockApiGetBlocksRequest) CurrencyCode(currencyCode string) BlockApiGetBlocksRequest {
	r.currencyCode = &currencyCode
	return r
}

// Label of user defined field used by vendors or customers.
func (r BlockApiGetBlocksRequest) CustomCharUDFsAltname(customCharUDFsAltname []string) BlockApiGetBlocksRequest {
	r.customCharUDFsAltname = &customCharUDFsAltname
	return r
}

// Used to hold user defined field of Character Type. It is highly recommended to use UDFC01, UDFC02,...UDFC40 (Total 40) as Character/String UDF names(commonly used on Reservation, Profile etc.). Name is not restricted using enumeration, to provide flexibility of different name usage if required.
func (r BlockApiGetBlocksRequest) CustomCharUDFsName(customCharUDFsName []string) BlockApiGetBlocksRequest {
	r.customCharUDFsName = &customCharUDFsName
	return r
}

// Value of user defined field.
func (r BlockApiGetBlocksRequest) CustomCharUDFsValue(customCharUDFsValue []string) BlockApiGetBlocksRequest {
	r.customCharUDFsValue = &customCharUDFsValue
	return r
}

// Label of user defined field used by vendors or customers.
func (r BlockApiGetBlocksRequest) CustomNumericUDFsAltname(customNumericUDFsAltname []string) BlockApiGetBlocksRequest {
	r.customNumericUDFsAltname = &customNumericUDFsAltname
	return r
}

// Name of user defined field.
func (r BlockApiGetBlocksRequest) CustomNumericUDFsName(customNumericUDFsName []string) BlockApiGetBlocksRequest {
	r.customNumericUDFsName = &customNumericUDFsName
	return r
}

// Value of user defined field.
func (r BlockApiGetBlocksRequest) CustomNumericUDFsValue(customNumericUDFsValue []float32) BlockApiGetBlocksRequest {
	r.customNumericUDFsValue = &customNumericUDFsValue
	return r
}

// Label of user defined field used by vendors or customers.
func (r BlockApiGetBlocksRequest) CustomDateUDFsAltname(customDateUDFsAltname []string) BlockApiGetBlocksRequest {
	r.customDateUDFsAltname = &customDateUDFsAltname
	return r
}

// Used to hold user defined field of Date Type. It is highly recommended to use UDFD01, UDFD02,...UDFN20 (Total 20) as Date UDF names(commonly used on Reservation, Profile etc.). Name is not restricted using enumeration, to provide flexibility of different name usage if required.
func (r BlockApiGetBlocksRequest) CustomDateUDFsName(customDateUDFsName []string) BlockApiGetBlocksRequest {
	r.customDateUDFsName = &customDateUDFsName
	return r
}

// Value of user defined field.
func (r BlockApiGetBlocksRequest) CustomDateUDFsValue(customDateUDFsValue []string) BlockApiGetBlocksRequest {
	r.customDateUDFsValue = &customDateUDFsValue
	return r
}

// Simple type for block access exclusion/restriction types.
func (r BlockApiGetBlocksRequest) AccessRestriction(accessRestriction []string) BlockApiGetBlocksRequest {
	r.accessRestriction = &accessRestriction
	return r
}

// External system code.
func (r BlockApiGetBlocksRequest) XExternalsystem(xExternalsystem string) BlockApiGetBlocksRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockApiGetBlocksRequest) AcceptLanguage(acceptLanguage string) BlockApiGetBlocksRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockApiGetBlocksRequest) Execute() (*BlockSummaries, *http.Response, error) {
	return r.ApiService.GetBlocksExecute(r)
}

/*
GetBlocks Get Blocks

Use this API to retrieve a list of blocks for requested query parameters. A wide range of query parameters is available to support various persona requirements, so it is recommended to include, at least, the hotel block date range, stay date range, and/or number of days as query parameters. You can use more query parameters to narrow your results. This API is not designed to support sync between two systems or initial upload of data. If x-hubid is used as a header, it returns matching data from multiple hotels within the same chain. <p><strong>OperationId:</strong>getBlocks</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return BlockApiGetBlocksRequest
*/
func (a *BlockApiService) GetBlocks(ctx context.Context) BlockApiGetBlocksRequest {
	return BlockApiGetBlocksRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BlockSummaries
func (a *BlockApiService) GetBlocksExecute(r BlockApiGetBlocksRequest) (*BlockSummaries, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BlockSummaries
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockApiService.GetBlocks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blocks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
	}
	if r.markAsRecentlyAccessed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "markAsRecentlyAccessed", r.markAsRecentlyAccessed, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.multipleHotelsSearchHotelIds != nil {
		t := *r.multipleHotelsSearchHotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "multipleHotelsSearchHotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "multipleHotelsSearchHotelIds", t, "multi")
		}
	}
	if r.superSearch != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "superSearch", r.superSearch, "")
	}
	if r.blockIdList != nil {
		t := *r.blockIdList
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "blockIdList", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "blockIdList", t, "multi")
		}
	}
	if r.blockIdType != nil {
		t := *r.blockIdType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "blockIdType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "blockIdType", t, "multi")
		}
	}
	if r.externalReferenceIds != nil {
		t := *r.externalReferenceIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "externalReferenceIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "externalReferenceIds", t, "multi")
		}
	}
	if r.externalSystemCodes != nil {
		t := *r.externalSystemCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "externalSystemCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "externalSystemCodes", t, "multi")
		}
	}
	if r.blockCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blockCode", r.blockCode, "")
	}
	if r.blockName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blockName", r.blockName, "")
	}
	if r.blockOwner != nil {
		t := *r.blockOwner
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "blockOwner", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "blockOwner", t, "multi")
		}
	}
	if r.blockStatus != nil {
		t := *r.blockStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "blockStatus", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "blockStatus", t, "multi")
		}
	}
	if r.cateringStatus != nil {
		t := *r.cateringStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "cateringStatus", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "cateringStatus", t, "multi")
		}
	}
	if r.createdByUser != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createdByUser", r.createdByUser, "")
	}
	if r.blockStartEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blockStartEndDate", r.blockStartEndDate, "")
	}
	if r.blockStartStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blockStartStartDate", r.blockStartStartDate, "")
	}
	if r.blockEndEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blockEndEndDate", r.blockEndEndDate, "")
	}
	if r.blockEndStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blockEndStartDate", r.blockEndStartDate, "")
	}
	if r.reservationArrival != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationArrival", r.reservationArrival, "")
	}
	if r.reservationDeparture != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationDeparture", r.reservationDeparture, "")
	}
	if r.includeShoulderDates != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeShoulderDates", r.includeShoulderDates, "")
	}
	if r.stayDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stayDate", r.stayDate, "")
	}
	if r.blockCreatedOnEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blockCreatedOnEndDate", r.blockCreatedOnEndDate, "")
	}
	if r.blockCreatedOnStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blockCreatedOnStartDate", r.blockCreatedOnStartDate, "")
	}
	if r.decisionEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "decisionEndDate", r.decisionEndDate, "")
	}
	if r.decisionStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "decisionStartDate", r.decisionStartDate, "")
	}
	if r.cutOffEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cutOffEndDate", r.cutOffEndDate, "")
	}
	if r.cutOffStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cutOffStartDate", r.cutOffStartDate, "")
	}
	if r.category != nil {
		t := *r.category
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "category", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "category", t, "multi")
		}
	}
	if r.name != nil {
		t := *r.name
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name", t, "multi")
		}
	}
	if r.attachedProfileId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attachedProfileId", r.attachedProfileId, "")
	}
	if r.attachedProfileIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attachedProfileIdType", r.attachedProfileIdType, "")
	}
	if r.leads != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "leads", r.leads, "")
	}
	if r.tourSeries != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tourSeries", r.tourSeries, "")
	}
	if r.onlyPickupBlocks != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "onlyPickupBlocks", r.onlyPickupBlocks, "")
	}
	if r.onlyOpportunities != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "onlyOpportunities", r.onlyOpportunities, "")
	}
	if r.ratePlanCode != nil {
		t := *r.ratePlanCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanCode", t, "multi")
		}
	}
	if r.tourCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tourCode", r.tourCode, "")
	}
	if r.attributeName != nil {
		t := *r.attributeName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "attributeName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "attributeName", t, "multi")
		}
	}
	if r.orderType != nil {
		t := *r.orderType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "orderType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "orderType", t, "multi")
		}
	}
	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
	}
	if r.fetchAllocatedRoomTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetchAllocatedRoomTypes", r.fetchAllocatedRoomTypes, "")
	}
	if r.additionalCriteriaStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "additionalCriteriaStartDate", r.additionalCriteriaStartDate, "")
	}
	if r.numberOfDays != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "numberOfDays", r.numberOfDays, "")
	}
	if r.adults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adults", r.adults, "")
	}
	if r.children != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "children", r.children, "")
	}
	if r.childAge != nil {
		t := *r.childAge
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "childAge", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "childAge", t, "multi")
		}
	}
	if r.bucket1Count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bucket1Count", r.bucket1Count, "")
	}
	if r.bucket2Count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bucket2Count", r.bucket2Count, "")
	}
	if r.bucket3Count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bucket3Count", r.bucket3Count, "")
	}
	if r.bucket4Count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bucket4Count", r.bucket4Count, "")
	}
	if r.bucket5Count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bucket5Count", r.bucket5Count, "")
	}
	if r.existingReservationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "existingReservationId", r.existingReservationId, "")
	}
	if r.existingReservationIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "existingReservationIdType", r.existingReservationIdType, "")
	}
	if r.roomAllocationCriteria != nil {
		t := *r.roomAllocationCriteria
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomAllocationCriteria", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomAllocationCriteria", t, "multi")
		}
	}
	if r.roomType != nil {
		t := *r.roomType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomType", t, "multi")
		}
	}
	if r.additionalCriteriaRatePlanCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "additionalCriteriaRatePlanCode", r.additionalCriteriaRatePlanCode, "")
	}
	if r.currencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currencyCode", r.currencyCode, "")
	}
	if r.customCharUDFsAltname != nil {
		t := *r.customCharUDFsAltname
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "customCharUDFsAltname", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "customCharUDFsAltname", t, "multi")
		}
	}
	if r.customCharUDFsName != nil {
		t := *r.customCharUDFsName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "customCharUDFsName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "customCharUDFsName", t, "multi")
		}
	}
	if r.customCharUDFsValue != nil {
		t := *r.customCharUDFsValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "customCharUDFsValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "customCharUDFsValue", t, "multi")
		}
	}
	if r.customNumericUDFsAltname != nil {
		t := *r.customNumericUDFsAltname
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "customNumericUDFsAltname", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "customNumericUDFsAltname", t, "multi")
		}
	}
	if r.customNumericUDFsName != nil {
		t := *r.customNumericUDFsName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "customNumericUDFsName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "customNumericUDFsName", t, "multi")
		}
	}
	if r.customNumericUDFsValue != nil {
		t := *r.customNumericUDFsValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "customNumericUDFsValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "customNumericUDFsValue", t, "multi")
		}
	}
	if r.customDateUDFsAltname != nil {
		t := *r.customDateUDFsAltname
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "customDateUDFsAltname", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "customDateUDFsAltname", t, "multi")
		}
	}
	if r.customDateUDFsName != nil {
		t := *r.customDateUDFsName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "customDateUDFsName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "customDateUDFsName", t, "multi")
		}
	}
	if r.customDateUDFsValue != nil {
		t := *r.customDateUDFsValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "customDateUDFsValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "customDateUDFsValue", t, "multi")
		}
	}
	if r.accessRestriction != nil {
		t := *r.accessRestriction
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "accessRestriction", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "accessRestriction", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockApiGetDefaultBlockCodeRequest struct {
	ctx context.Context
	ApiService *BlockApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelId *string
	blockName *string
	startDate *string
	blockCodeTemplate *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockApiGetDefaultBlockCodeRequest) Authorization(authorization string) BlockApiGetDefaultBlockCodeRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r BlockApiGetDefaultBlockCodeRequest) XAppKey(xAppKey string) BlockApiGetDefaultBlockCodeRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockApiGetDefaultBlockCodeRequest) XHotelid(xHotelid string) BlockApiGetDefaultBlockCodeRequest {
	r.xHotelid = &xHotelid
	return r
}

// Used for codes in the OPERA Code tables. Possible values of this pattern are 1, 101, 101.EQP, or 101.EQP.X.
func (r BlockApiGetDefaultBlockCodeRequest) HotelId(hotelId string) BlockApiGetDefaultBlockCodeRequest {
	r.hotelId = &hotelId
	return r
}

// Used for Character Strings, length 0 to 2000.
func (r BlockApiGetDefaultBlockCodeRequest) BlockName(blockName string) BlockApiGetDefaultBlockCodeRequest {
	r.blockName = &blockName
	return r
}

// Start Date of the business block.
func (r BlockApiGetDefaultBlockCodeRequest) StartDate(startDate string) BlockApiGetDefaultBlockCodeRequest {
	r.startDate = &startDate
	return r
}

// Used for Character Strings, length 0 to 2000.
func (r BlockApiGetDefaultBlockCodeRequest) BlockCodeTemplate(blockCodeTemplate string) BlockApiGetDefaultBlockCodeRequest {
	r.blockCodeTemplate = &blockCodeTemplate
	return r
}

// External system code.
func (r BlockApiGetDefaultBlockCodeRequest) XExternalsystem(xExternalsystem string) BlockApiGetDefaultBlockCodeRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockApiGetDefaultBlockCodeRequest) AcceptLanguage(acceptLanguage string) BlockApiGetDefaultBlockCodeRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockApiGetDefaultBlockCodeRequest) Execute() (*DefaultBlockCodeDetails, *http.Response, error) {
	return r.ApiService.GetDefaultBlockCodeExecute(r)
}

/*
GetDefaultBlockCode Get default Block Code

Use this API to retrieve a default block code based on template. <p><strong>OperationId:</strong>getDefaultBlockCode</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return BlockApiGetDefaultBlockCodeRequest
*/
func (a *BlockApiService) GetDefaultBlockCode(ctx context.Context) BlockApiGetDefaultBlockCodeRequest {
	return BlockApiGetDefaultBlockCodeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DefaultBlockCodeDetails
func (a *BlockApiService) GetDefaultBlockCodeExecute(r BlockApiGetDefaultBlockCodeRequest) (*DefaultBlockCodeDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DefaultBlockCodeDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockApiService.GetDefaultBlockCode")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/defaultBlockCode"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
	}
	if r.blockName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blockName", r.blockName, "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.blockCodeTemplate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blockCodeTemplate", r.blockCodeTemplate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockApiGetInventoryToBorrowRequest struct {
	ctx context.Context
	ApiService *BlockApiService
	hotelId *string
	blockId *string
	startDate *string
	requiredRooms *[]int32
	authorization *string
	xAppKey *string
	xHotelid *string
	blockIdContext *string
	blockIdType *string
	existingReservationId *string
	existingReservationIdType *string
	roomType *string
	endDate *string
	duration *string
	numberOfRooms *int32
	borrowDate *[]string
	overrideRateCode *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Used for codes in the OPERA Code tables. Possible values of this pattern are 1, 101, 101.EQP, or 101.EQP.X.
func (r BlockApiGetInventoryToBorrowRequest) HotelId(hotelId string) BlockApiGetInventoryToBorrowRequest {
	r.hotelId = &hotelId
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r BlockApiGetInventoryToBorrowRequest) BlockId(blockId string) BlockApiGetInventoryToBorrowRequest {
	r.blockId = &blockId
	return r
}

func (r BlockApiGetInventoryToBorrowRequest) StartDate(startDate string) BlockApiGetInventoryToBorrowRequest {
	r.startDate = &startDate
	return r
}

// The number of rooms that need to be borrowed.
func (r BlockApiGetInventoryToBorrowRequest) RequiredRooms(requiredRooms []int32) BlockApiGetInventoryToBorrowRequest {
	r.requiredRooms = &requiredRooms
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockApiGetInventoryToBorrowRequest) Authorization(authorization string) BlockApiGetInventoryToBorrowRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r BlockApiGetInventoryToBorrowRequest) XAppKey(xAppKey string) BlockApiGetInventoryToBorrowRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockApiGetInventoryToBorrowRequest) XHotelid(xHotelid string) BlockApiGetInventoryToBorrowRequest {
	r.xHotelid = &xHotelid
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r BlockApiGetInventoryToBorrowRequest) BlockIdContext(blockIdContext string) BlockApiGetInventoryToBorrowRequest {
	r.blockIdContext = &blockIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r BlockApiGetInventoryToBorrowRequest) BlockIdType(blockIdType string) BlockApiGetInventoryToBorrowRequest {
	r.blockIdType = &blockIdType
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r BlockApiGetInventoryToBorrowRequest) ExistingReservationId(existingReservationId string) BlockApiGetInventoryToBorrowRequest {
	r.existingReservationId = &existingReservationId
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r BlockApiGetInventoryToBorrowRequest) ExistingReservationIdType(existingReservationIdType string) BlockApiGetInventoryToBorrowRequest {
	r.existingReservationIdType = &existingReservationIdType
	return r
}

// Used for codes in the OPERA Code tables. Possible values of this pattern are 1, 101, 101.EQP, or 101.EQP.X.
func (r BlockApiGetInventoryToBorrowRequest) RoomType(roomType string) BlockApiGetInventoryToBorrowRequest {
	r.roomType = &roomType
	return r
}

func (r BlockApiGetInventoryToBorrowRequest) EndDate(endDate string) BlockApiGetInventoryToBorrowRequest {
	r.endDate = &endDate
	return r
}

func (r BlockApiGetInventoryToBorrowRequest) Duration(duration string) BlockApiGetInventoryToBorrowRequest {
	r.duration = &duration
	return r
}

// The number of rooms associated with the reservation.
func (r BlockApiGetInventoryToBorrowRequest) NumberOfRooms(numberOfRooms int32) BlockApiGetInventoryToBorrowRequest {
	r.numberOfRooms = &numberOfRooms
	return r
}

// The date on which rooms need to be borrowed for the block.
func (r BlockApiGetInventoryToBorrowRequest) BorrowDate(borrowDate []string) BlockApiGetInventoryToBorrowRequest {
	r.borrowDate = &borrowDate
	return r
}

// Flag to override the inclusion of block rate code as a criteria when deciding what room types can be allowed to borrow.
func (r BlockApiGetInventoryToBorrowRequest) OverrideRateCode(overrideRateCode bool) BlockApiGetInventoryToBorrowRequest {
	r.overrideRateCode = &overrideRateCode
	return r
}

// External system code.
func (r BlockApiGetInventoryToBorrowRequest) XExternalsystem(xExternalsystem string) BlockApiGetInventoryToBorrowRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockApiGetInventoryToBorrowRequest) AcceptLanguage(acceptLanguage string) BlockApiGetInventoryToBorrowRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockApiGetInventoryToBorrowRequest) Execute() (*InventoryToBorrowInfo, *http.Response, error) {
	return r.ApiService.GetInventoryToBorrowExecute(r)
}

/*
GetInventoryToBorrow Get inventory to Borrow

Use this API to retrieve borrowable inventory for the requested dates when encountering an insufficient number of rooms in a block for a specific room type, or for overall inventory. This operations would usually be used when attempting to pick up a reservation against a block, and the block inventory does not have enough rooms left to support the reservation pick up. <p><strong>OperationId:</strong>getInventoryToBorrow</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return BlockApiGetInventoryToBorrowRequest
*/
func (a *BlockApiService) GetInventoryToBorrow(ctx context.Context) BlockApiGetInventoryToBorrowRequest {
	return BlockApiGetInventoryToBorrowRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InventoryToBorrowInfo
func (a *BlockApiService) GetInventoryToBorrowExecute(r BlockApiGetInventoryToBorrowRequest) (*InventoryToBorrowInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InventoryToBorrowInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockApiService.GetInventoryToBorrow")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/inventoryToBorrow"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "blockId", r.blockId, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	{
		t := *r.requiredRooms
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "requiredRooms", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "requiredRooms", t, "multi")
		}
	}
	if r.blockIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blockIdContext", r.blockIdContext, "")
	}
	if r.blockIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blockIdType", r.blockIdType, "")
	}
	if r.existingReservationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "existingReservationId", r.existingReservationId, "")
	}
	if r.existingReservationIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "existingReservationIdType", r.existingReservationIdType, "")
	}
	if r.roomType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomType", r.roomType, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration", r.duration, "")
	}
	if r.numberOfRooms != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "numberOfRooms", r.numberOfRooms, "")
	}
	if r.borrowDate != nil {
		t := *r.borrowDate
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "borrowDate", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "borrowDate", t, "multi")
		}
	}
	if r.overrideRateCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "overrideRateCode", r.overrideRateCode, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockApiGetNextBlockStatusRequest struct {
	ctx context.Context
	ApiService *BlockApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelId *string
	currentStatus *string
	includeCateringStatus *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockApiGetNextBlockStatusRequest) Authorization(authorization string) BlockApiGetNextBlockStatusRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r BlockApiGetNextBlockStatusRequest) XAppKey(xAppKey string) BlockApiGetNextBlockStatusRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockApiGetNextBlockStatusRequest) XHotelid(xHotelid string) BlockApiGetNextBlockStatusRequest {
	r.xHotelid = &xHotelid
	return r
}

// Used for codes in the OPERA Code tables. Possible values of this pattern are 1, 101, 101.EQP, or 101.EQP.X.
func (r BlockApiGetNextBlockStatusRequest) HotelId(hotelId string) BlockApiGetNextBlockStatusRequest {
	r.hotelId = &hotelId
	return r
}

// Used for codes in the OPERA Code tables. Possible values of this pattern are 1, 101, 101.EQP, or 101.EQP.X.
func (r BlockApiGetNextBlockStatusRequest) CurrentStatus(currentStatus string) BlockApiGetNextBlockStatusRequest {
	r.currentStatus = &currentStatus
	return r
}

// Flag to include catering next status.
func (r BlockApiGetNextBlockStatusRequest) IncludeCateringStatus(includeCateringStatus bool) BlockApiGetNextBlockStatusRequest {
	r.includeCateringStatus = &includeCateringStatus
	return r
}

// External system code.
func (r BlockApiGetNextBlockStatusRequest) XExternalsystem(xExternalsystem string) BlockApiGetNextBlockStatusRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockApiGetNextBlockStatusRequest) AcceptLanguage(acceptLanguage string) BlockApiGetNextBlockStatusRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockApiGetNextBlockStatusRequest) Execute() (*NextBlockStatus, *http.Response, error) {
	return r.ApiService.GetNextBlockStatusExecute(r)
}

/*
GetNextBlockStatus Get Next Block Status

Use this API to retrieve next set of statuses and their next statuses for the current status passed in the request. <p><strong>OperationId:</strong>getNextBlockStatus</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return BlockApiGetNextBlockStatusRequest
*/
func (a *BlockApiService) GetNextBlockStatus(ctx context.Context) BlockApiGetNextBlockStatusRequest {
	return BlockApiGetNextBlockStatusRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return NextBlockStatus
func (a *BlockApiService) GetNextBlockStatusExecute(r BlockApiGetNextBlockStatusRequest) (*NextBlockStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NextBlockStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockApiService.GetNextBlockStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blocks/status"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
	}
	if r.currentStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currentStatus", r.currentStatus, "")
	}
	if r.includeCateringStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeCateringStatus", r.includeCateringStatus, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockApiGetRecentlyAccessedBlocksRequest struct {
	ctx context.Context
	ApiService *BlockApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockApiGetRecentlyAccessedBlocksRequest) Authorization(authorization string) BlockApiGetRecentlyAccessedBlocksRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r BlockApiGetRecentlyAccessedBlocksRequest) XAppKey(xAppKey string) BlockApiGetRecentlyAccessedBlocksRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockApiGetRecentlyAccessedBlocksRequest) XHotelid(xHotelid string) BlockApiGetRecentlyAccessedBlocksRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r BlockApiGetRecentlyAccessedBlocksRequest) XExternalsystem(xExternalsystem string) BlockApiGetRecentlyAccessedBlocksRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockApiGetRecentlyAccessedBlocksRequest) AcceptLanguage(acceptLanguage string) BlockApiGetRecentlyAccessedBlocksRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockApiGetRecentlyAccessedBlocksRequest) Execute() (*RecentlyAccessedBlocks, *http.Response, error) {
	return r.ApiService.GetRecentlyAccessedBlocksExecute(r)
}

/*
GetRecentlyAccessedBlocks Get recently accessed Blocks

This API retrieves recently accessed blocks. <p><strong>OperationId:</strong>getRecentlyAccessedBlocks</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return BlockApiGetRecentlyAccessedBlocksRequest
*/
func (a *BlockApiService) GetRecentlyAccessedBlocks(ctx context.Context) BlockApiGetRecentlyAccessedBlocksRequest {
	return BlockApiGetRecentlyAccessedBlocksRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RecentlyAccessedBlocks
func (a *BlockApiService) GetRecentlyAccessedBlocksExecute(r BlockApiGetRecentlyAccessedBlocksRequest) (*RecentlyAccessedBlocks, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RecentlyAccessedBlocks
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockApiService.GetRecentlyAccessedBlocks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/recentlyAccessedBlocks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockApiGetSalesAllowancesRequest struct {
	ctx context.Context
	ApiService *BlockApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	ceilingId *[]float32
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockApiGetSalesAllowancesRequest) Authorization(authorization string) BlockApiGetSalesAllowancesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r BlockApiGetSalesAllowancesRequest) XAppKey(xAppKey string) BlockApiGetSalesAllowancesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockApiGetSalesAllowancesRequest) XHotelid(xHotelid string) BlockApiGetSalesAllowancesRequest {
	r.xHotelid = &xHotelid
	return r
}

// ID of sales allowance.
func (r BlockApiGetSalesAllowancesRequest) CeilingId(ceilingId []float32) BlockApiGetSalesAllowancesRequest {
	r.ceilingId = &ceilingId
	return r
}

// External system code.
func (r BlockApiGetSalesAllowancesRequest) XExternalsystem(xExternalsystem string) BlockApiGetSalesAllowancesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockApiGetSalesAllowancesRequest) AcceptLanguage(acceptLanguage string) BlockApiGetSalesAllowancesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockApiGetSalesAllowancesRequest) Execute() (*SalesAllowances, *http.Response, error) {
	return r.ApiService.GetSalesAllowancesExecute(r)
}

/*
GetSalesAllowances Get Sales allowances

Use this API to retrieve the Sales Allowance of max amount of rooms that can be sold. <p><strong>OperationId:</strong>getSalesAllowances</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return BlockApiGetSalesAllowancesRequest
*/
func (a *BlockApiService) GetSalesAllowances(ctx context.Context) BlockApiGetSalesAllowancesRequest {
	return BlockApiGetSalesAllowancesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SalesAllowances
func (a *BlockApiService) GetSalesAllowancesExecute(r BlockApiGetSalesAllowancesRequest) (*SalesAllowances, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SalesAllowances
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockApiService.GetSalesAllowances")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/salesAllowances"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ceilingId != nil {
		t := *r.ceilingId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ceilingId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ceilingId", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockApiGetTracesByDateRangeRequest struct {
	ctx context.Context
	ApiService *BlockApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelIds *[]string
	beginDate *string
	endDate *string
	department *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockApiGetTracesByDateRangeRequest) Authorization(authorization string) BlockApiGetTracesByDateRangeRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r BlockApiGetTracesByDateRangeRequest) XAppKey(xAppKey string) BlockApiGetTracesByDateRangeRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockApiGetTracesByDateRangeRequest) XHotelid(xHotelid string) BlockApiGetTracesByDateRangeRequest {
	r.xHotelid = &xHotelid
	return r
}

// Hotel code.
func (r BlockApiGetTracesByDateRangeRequest) HotelIds(hotelIds []string) BlockApiGetTracesByDateRangeRequest {
	r.hotelIds = &hotelIds
	return r
}

// Begin date for fetching traces criteria.
func (r BlockApiGetTracesByDateRangeRequest) BeginDate(beginDate string) BlockApiGetTracesByDateRangeRequest {
	r.beginDate = &beginDate
	return r
}

// End date for fetching traces criteria.
func (r BlockApiGetTracesByDateRangeRequest) EndDate(endDate string) BlockApiGetTracesByDateRangeRequest {
	r.endDate = &endDate
	return r
}

// Department for which traces are to be fetched.
func (r BlockApiGetTracesByDateRangeRequest) Department(department []string) BlockApiGetTracesByDateRangeRequest {
	r.department = &department
	return r
}

// External system code.
func (r BlockApiGetTracesByDateRangeRequest) XExternalsystem(xExternalsystem string) BlockApiGetTracesByDateRangeRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockApiGetTracesByDateRangeRequest) AcceptLanguage(acceptLanguage string) BlockApiGetTracesByDateRangeRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockApiGetTracesByDateRangeRequest) Execute() (*TracesByDateRange, *http.Response, error) {
	return r.ApiService.GetTracesByDateRangeExecute(r)
}

/*
GetTracesByDateRange Get Traces By Date Range

You can use this API to get traces for Reservations and Blocks. <p><strong>OperationId:</strong>getTracesByDateRange</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId
 @return BlockApiGetTracesByDateRangeRequest
*/
func (a *BlockApiService) GetTracesByDateRange(ctx context.Context, hotelId string) BlockApiGetTracesByDateRangeRequest {
	return BlockApiGetTracesByDateRangeRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return TracesByDateRange
func (a *BlockApiService) GetTracesByDateRangeExecute(r BlockApiGetTracesByDateRangeRequest) (*TracesByDateRange, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TracesByDateRange
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockApiService.GetTracesByDateRange")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/tracesByDateRange"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.hotelIds != nil {
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.beginDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "beginDate", r.beginDate, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.department != nil {
		t := *r.department
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "department", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "department", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockApiPostAlternateDatesRequest struct {
	ctx context.Context
	ApiService *BlockApiService
	blockId string
	authorization *string
	xAppKey *string
	xHotelid *string
	blockAlternateDates *PutAlternateDatesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockApiPostAlternateDatesRequest) Authorization(authorization string) BlockApiPostAlternateDatesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r BlockApiPostAlternateDatesRequest) XAppKey(xAppKey string) BlockApiPostAlternateDatesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockApiPostAlternateDatesRequest) XHotelid(xHotelid string) BlockApiPostAlternateDatesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to create block alternate dates.
func (r BlockApiPostAlternateDatesRequest) BlockAlternateDates(blockAlternateDates PutAlternateDatesRequest) BlockApiPostAlternateDatesRequest {
	r.blockAlternateDates = &blockAlternateDates
	return r
}

// External system code.
func (r BlockApiPostAlternateDatesRequest) XExternalsystem(xExternalsystem string) BlockApiPostAlternateDatesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockApiPostAlternateDatesRequest) AcceptLanguage(acceptLanguage string) BlockApiPostAlternateDatesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockApiPostAlternateDatesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostAlternateDatesExecute(r)
}

/*
PostAlternateDates Create alternate dates for a Block

Use this API to create alternate dates for a block. <p><strong>OperationId:</strong>postAlternateDates</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockId Block Id
 @return BlockApiPostAlternateDatesRequest
*/
func (a *BlockApiService) PostAlternateDates(ctx context.Context, blockId string) BlockApiPostAlternateDatesRequest {
	return BlockApiPostAlternateDatesRequest{
		ApiService: a,
		ctx: ctx,
		blockId: blockId,
	}
}

// Execute executes the request
//  @return Status
func (a *BlockApiService) PostAlternateDatesExecute(r BlockApiPostAlternateDatesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockApiService.PostAlternateDates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blocks/{blockId}/alternateDates"
	localVarPath = strings.Replace(localVarPath, "{"+"blockId"+"}", url.PathEscape(parameterValueToString(r.blockId, "blockId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.blockId) < 1 {
		return localVarReturnValue, nil, reportError("blockId must have at least 1 elements")
	}
	if strlen(r.blockId) > 2000 {
		return localVarReturnValue, nil, reportError("blockId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.blockAlternateDates
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockApiPostBlockRequest struct {
	ctx context.Context
	ApiService *BlockApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	block *PostBlockRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockApiPostBlockRequest) Authorization(authorization string) BlockApiPostBlockRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r BlockApiPostBlockRequest) XAppKey(xAppKey string) BlockApiPostBlockRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockApiPostBlockRequest) XHotelid(xHotelid string) BlockApiPostBlockRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creation of blocks. This object contains block details with unique identifiers for each block. The standard optional Opera Context element is also included.
func (r BlockApiPostBlockRequest) Block(block PostBlockRequest) BlockApiPostBlockRequest {
	r.block = &block
	return r
}

// External system code.
func (r BlockApiPostBlockRequest) XExternalsystem(xExternalsystem string) BlockApiPostBlockRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockApiPostBlockRequest) AcceptLanguage(acceptLanguage string) BlockApiPostBlockRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockApiPostBlockRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostBlockExecute(r)
}

/*
PostBlock Create a Block

Use this API to create a new group block in OPERA Cloud. You must first use the ListOfValues APIs to find block attributes, such as Block Status, Room Types, and so on. Knowing this list of values helps ensure a successful postBlock. <p><strong>OperationId:</strong>postBlock</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Hotel Id
 @return BlockApiPostBlockRequest
*/
func (a *BlockApiService) PostBlock(ctx context.Context, hotelId string) BlockApiPostBlockRequest {
	return BlockApiPostBlockRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *BlockApiService) PostBlockExecute(r BlockApiPostBlockRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockApiService.PostBlock")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/block"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.block
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockApiPostBlockOwnersRequest struct {
	ctx context.Context
	ApiService *BlockApiService
	blockId string
	authorization *string
	xAppKey *string
	xHotelid *string
	blockOwnersToAssign *PostBlockOwnersRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockApiPostBlockOwnersRequest) Authorization(authorization string) BlockApiPostBlockOwnersRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r BlockApiPostBlockOwnersRequest) XAppKey(xAppKey string) BlockApiPostBlockOwnersRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockApiPostBlockOwnersRequest) XHotelid(xHotelid string) BlockApiPostBlockOwnersRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to assign block owners.
func (r BlockApiPostBlockOwnersRequest) BlockOwnersToAssign(blockOwnersToAssign PostBlockOwnersRequest) BlockApiPostBlockOwnersRequest {
	r.blockOwnersToAssign = &blockOwnersToAssign
	return r
}

// External system code.
func (r BlockApiPostBlockOwnersRequest) XExternalsystem(xExternalsystem string) BlockApiPostBlockOwnersRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockApiPostBlockOwnersRequest) AcceptLanguage(acceptLanguage string) BlockApiPostBlockOwnersRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockApiPostBlockOwnersRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostBlockOwnersExecute(r)
}

/*
PostBlockOwners Assign a Block owner

Use this API to assign block owners. <p><strong>OperationId:</strong>postBlockOwners</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockId Block Id
 @return BlockApiPostBlockOwnersRequest
*/
func (a *BlockApiService) PostBlockOwners(ctx context.Context, blockId string) BlockApiPostBlockOwnersRequest {
	return BlockApiPostBlockOwnersRequest{
		ApiService: a,
		ctx: ctx,
		blockId: blockId,
	}
}

// Execute executes the request
//  @return Status
func (a *BlockApiService) PostBlockOwnersExecute(r BlockApiPostBlockOwnersRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockApiService.PostBlockOwners")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blocks/{blockId}/owners"
	localVarPath = strings.Replace(localVarPath, "{"+"blockId"+"}", url.PathEscape(parameterValueToString(r.blockId, "blockId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.blockId) < 1 {
		return localVarReturnValue, nil, reportError("blockId must have at least 1 elements")
	}
	if strlen(r.blockId) > 2000 {
		return localVarReturnValue, nil, reportError("blockId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.blockOwnersToAssign
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockApiPostBlockPostingMasterRequest struct {
	ctx context.Context
	ApiService *BlockApiService
	blockId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	blockPostingMaster *PostBlockPostingMasterRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockApiPostBlockPostingMasterRequest) Authorization(authorization string) BlockApiPostBlockPostingMasterRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r BlockApiPostBlockPostingMasterRequest) XAppKey(xAppKey string) BlockApiPostBlockPostingMasterRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockApiPostBlockPostingMasterRequest) XHotelid(xHotelid string) BlockApiPostBlockPostingMasterRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating a new Posting Master Reservation.
func (r BlockApiPostBlockPostingMasterRequest) BlockPostingMaster(blockPostingMaster PostBlockPostingMasterRequest) BlockApiPostBlockPostingMasterRequest {
	r.blockPostingMaster = &blockPostingMaster
	return r
}

// External system code.
func (r BlockApiPostBlockPostingMasterRequest) XExternalsystem(xExternalsystem string) BlockApiPostBlockPostingMasterRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockApiPostBlockPostingMasterRequest) AcceptLanguage(acceptLanguage string) BlockApiPostBlockPostingMasterRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockApiPostBlockPostingMasterRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostBlockPostingMasterExecute(r)
}

/*
PostBlockPostingMaster Create Block posting master

Use this API to create a new posting Master reservation against a block in OPERA.  The block status in OPERA needs to be 'Open for Pick up' to successfully post a BlockPostingMaster reservation. <p><strong>OperationId:</strong>postBlockPostingMaster</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockId Block Id
 @param hotelId Hotel Id
 @return BlockApiPostBlockPostingMasterRequest
*/
func (a *BlockApiService) PostBlockPostingMaster(ctx context.Context, blockId string, hotelId string) BlockApiPostBlockPostingMasterRequest {
	return BlockApiPostBlockPostingMasterRequest{
		ApiService: a,
		ctx: ctx,
		blockId: blockId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *BlockApiService) PostBlockPostingMasterExecute(r BlockApiPostBlockPostingMasterRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockApiService.PostBlockPostingMaster")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/blocks/{blockId}/postingMaster"
	localVarPath = strings.Replace(localVarPath, "{"+"blockId"+"}", url.PathEscape(parameterValueToString(r.blockId, "blockId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.blockId) < 1 {
		return localVarReturnValue, nil, reportError("blockId must have at least 1 elements")
	}
	if strlen(r.blockId) > 2000 {
		return localVarReturnValue, nil, reportError("blockId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.blockPostingMaster
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockApiPostBlockRestrictionRequest struct {
	ctx context.Context
	ApiService *BlockApiService
	blockId string
	authorization *string
	xAppKey *string
	xHotelid *string
	blockRestriction *PostBlockRestrictionRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockApiPostBlockRestrictionRequest) Authorization(authorization string) BlockApiPostBlockRestrictionRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r BlockApiPostBlockRestrictionRequest) XAppKey(xAppKey string) BlockApiPostBlockRestrictionRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockApiPostBlockRestrictionRequest) XHotelid(xHotelid string) BlockApiPostBlockRestrictionRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request for CreateBlockRestriction operation.
func (r BlockApiPostBlockRestrictionRequest) BlockRestriction(blockRestriction PostBlockRestrictionRequest) BlockApiPostBlockRestrictionRequest {
	r.blockRestriction = &blockRestriction
	return r
}

// External system code.
func (r BlockApiPostBlockRestrictionRequest) XExternalsystem(xExternalsystem string) BlockApiPostBlockRestrictionRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockApiPostBlockRestrictionRequest) AcceptLanguage(acceptLanguage string) BlockApiPostBlockRestrictionRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockApiPostBlockRestrictionRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostBlockRestrictionExecute(r)
}

/*
PostBlockRestriction Create Block Restriction

Use this API to create block restrictions. <p><strong>OperationId:</strong>postBlockRestriction</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockId Block Id
 @return BlockApiPostBlockRestrictionRequest
*/
func (a *BlockApiService) PostBlockRestriction(ctx context.Context, blockId string) BlockApiPostBlockRestrictionRequest {
	return BlockApiPostBlockRestrictionRequest{
		ApiService: a,
		ctx: ctx,
		blockId: blockId,
	}
}

// Execute executes the request
//  @return Status
func (a *BlockApiService) PostBlockRestrictionExecute(r BlockApiPostBlockRestrictionRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockApiService.PostBlockRestriction")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blocks/{blockId}/restrictions"
	localVarPath = strings.Replace(localVarPath, "{"+"blockId"+"}", url.PathEscape(parameterValueToString(r.blockId, "blockId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.blockId) < 1 {
		return localVarReturnValue, nil, reportError("blockId must have at least 1 elements")
	}
	if strlen(r.blockId) > 2000 {
		return localVarReturnValue, nil, reportError("blockId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.blockRestriction
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockApiPostBlockValidateRequest struct {
	ctx context.Context
	ApiService *BlockApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	blockValidate *PostBlockValidateRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockApiPostBlockValidateRequest) Authorization(authorization string) BlockApiPostBlockValidateRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r BlockApiPostBlockValidateRequest) XAppKey(xAppKey string) BlockApiPostBlockValidateRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockApiPostBlockValidateRequest) XHotelid(xHotelid string) BlockApiPostBlockValidateRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for validating creation of blocks only. Block is not created. This object contains block details with unique identifiers for each block. The standard optional Opera Context element is also included.
func (r BlockApiPostBlockValidateRequest) BlockValidate(blockValidate PostBlockValidateRequest) BlockApiPostBlockValidateRequest {
	r.blockValidate = &blockValidate
	return r
}

// External system code.
func (r BlockApiPostBlockValidateRequest) XExternalsystem(xExternalsystem string) BlockApiPostBlockValidateRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockApiPostBlockValidateRequest) AcceptLanguage(acceptLanguage string) BlockApiPostBlockValidateRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockApiPostBlockValidateRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostBlockValidateExecute(r)
}

/*
PostBlockValidate Validate Block

Use this API to validate if block rate code has overlapping blocks and also validates and creates block details. <p><strong>OperationId:</strong>postBlockValidate</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return BlockApiPostBlockValidateRequest
*/
func (a *BlockApiService) PostBlockValidate(ctx context.Context) BlockApiPostBlockValidateRequest {
	return BlockApiPostBlockValidateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *BlockApiService) PostBlockValidateExecute(r BlockApiPostBlockValidateRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockApiService.PostBlockValidate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blocks/actions/validate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.blockValidate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockApiPostBlockWashSchedulesRequest struct {
	ctx context.Context
	ApiService *BlockApiService
	blockId string
	authorization *string
	xAppKey *string
	xHotelid *string
	blockWashSchedulesInfo *PutBlockWashSchedulesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockApiPostBlockWashSchedulesRequest) Authorization(authorization string) BlockApiPostBlockWashSchedulesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r BlockApiPostBlockWashSchedulesRequest) XAppKey(xAppKey string) BlockApiPostBlockWashSchedulesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockApiPostBlockWashSchedulesRequest) XHotelid(xHotelid string) BlockApiPostBlockWashSchedulesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to create multiple new Block Wash Schedules under the selected block.
func (r BlockApiPostBlockWashSchedulesRequest) BlockWashSchedulesInfo(blockWashSchedulesInfo PutBlockWashSchedulesRequest) BlockApiPostBlockWashSchedulesRequest {
	r.blockWashSchedulesInfo = &blockWashSchedulesInfo
	return r
}

// External system code.
func (r BlockApiPostBlockWashSchedulesRequest) XExternalsystem(xExternalsystem string) BlockApiPostBlockWashSchedulesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockApiPostBlockWashSchedulesRequest) AcceptLanguage(acceptLanguage string) BlockApiPostBlockWashSchedulesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockApiPostBlockWashSchedulesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostBlockWashSchedulesExecute(r)
}

/*
PostBlockWashSchedules Create Block Wash Schedules

This API creates new block wash schedules based on Wash Date, Room Type, Occupancy detail, Sell limit and Wash by percent value. <p><strong>OperationId:</strong>postBlockWashSchedules</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockId Block Id
 @return BlockApiPostBlockWashSchedulesRequest
*/
func (a *BlockApiService) PostBlockWashSchedules(ctx context.Context, blockId string) BlockApiPostBlockWashSchedulesRequest {
	return BlockApiPostBlockWashSchedulesRequest{
		ApiService: a,
		ctx: ctx,
		blockId: blockId,
	}
}

// Execute executes the request
//  @return Status
func (a *BlockApiService) PostBlockWashSchedulesExecute(r BlockApiPostBlockWashSchedulesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockApiService.PostBlockWashSchedules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blocks/{blockId}/washSchedules"
	localVarPath = strings.Replace(localVarPath, "{"+"blockId"+"}", url.PathEscape(parameterValueToString(r.blockId, "blockId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.blockId) < 1 {
		return localVarReturnValue, nil, reportError("blockId must have at least 1 elements")
	}
	if strlen(r.blockId) > 2000 {
		return localVarReturnValue, nil, reportError("blockId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.blockWashSchedulesInfo
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockApiPostCancelBlockRequest struct {
	ctx context.Context
	ApiService *BlockApiService
	blockId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	blockToCancel *PostCancelBlockRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockApiPostCancelBlockRequest) Authorization(authorization string) BlockApiPostCancelBlockRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r BlockApiPostCancelBlockRequest) XAppKey(xAppKey string) BlockApiPostCancelBlockRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockApiPostCancelBlockRequest) XHotelid(xHotelid string) BlockApiPostCancelBlockRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for block cancelation. This object contains unique identifiers (Block unique id, Block Code and Block Start Date ) to identify the block to be Canceled and the standard optional Opera Context element.
func (r BlockApiPostCancelBlockRequest) BlockToCancel(blockToCancel PostCancelBlockRequest) BlockApiPostCancelBlockRequest {
	r.blockToCancel = &blockToCancel
	return r
}

// External system code.
func (r BlockApiPostCancelBlockRequest) XExternalsystem(xExternalsystem string) BlockApiPostCancelBlockRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockApiPostCancelBlockRequest) AcceptLanguage(acceptLanguage string) BlockApiPostCancelBlockRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockApiPostCancelBlockRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostCancelBlockExecute(r)
}

/*
PostCancelBlock Cancel the Block

Use this API to complete a cancellation of the block. <p><strong>OperationId:</strong>postCancelBlock</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockId Block Id
 @param hotelId Hotel Id
 @return BlockApiPostCancelBlockRequest
*/
func (a *BlockApiService) PostCancelBlock(ctx context.Context, blockId string, hotelId string) BlockApiPostCancelBlockRequest {
	return BlockApiPostCancelBlockRequest{
		ApiService: a,
		ctx: ctx,
		blockId: blockId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *BlockApiService) PostCancelBlockExecute(r BlockApiPostCancelBlockRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockApiService.PostCancelBlock")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/blocks/{blockId}/cancellations"
	localVarPath = strings.Replace(localVarPath, "{"+"blockId"+"}", url.PathEscape(parameterValueToString(r.blockId, "blockId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.blockId) < 1 {
		return localVarReturnValue, nil, reportError("blockId must have at least 1 elements")
	}
	if strlen(r.blockId) > 2000 {
		return localVarReturnValue, nil, reportError("blockId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.blockToCancel
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockApiPostCopyBlockRequest struct {
	ctx context.Context
	ApiService *BlockApiService
	sourceBlockId string
	authorization *string
	xAppKey *string
	xHotelid *string
	blockCopy *PostCopyBlockRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockApiPostCopyBlockRequest) Authorization(authorization string) BlockApiPostCopyBlockRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r BlockApiPostCopyBlockRequest) XAppKey(xAppKey string) BlockApiPostCopyBlockRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockApiPostCopyBlockRequest) XHotelid(xHotelid string) BlockApiPostCopyBlockRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request for creating a copy of an existing block.
func (r BlockApiPostCopyBlockRequest) BlockCopy(blockCopy PostCopyBlockRequest) BlockApiPostCopyBlockRequest {
	r.blockCopy = &blockCopy
	return r
}

// External system code.
func (r BlockApiPostCopyBlockRequest) XExternalsystem(xExternalsystem string) BlockApiPostCopyBlockRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockApiPostCopyBlockRequest) AcceptLanguage(acceptLanguage string) BlockApiPostCopyBlockRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockApiPostCopyBlockRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostCopyBlockExecute(r)
}

/*
PostCopyBlock Copy a Block

Use this API to copy the a block. The block copied (Source block) will serve as a template for the new one. <p><strong>OperationId:</strong>postCopyBlock</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sourceBlockId Source Block Id
 @return BlockApiPostCopyBlockRequest
*/
func (a *BlockApiService) PostCopyBlock(ctx context.Context, sourceBlockId string) BlockApiPostCopyBlockRequest {
	return BlockApiPostCopyBlockRequest{
		ApiService: a,
		ctx: ctx,
		sourceBlockId: sourceBlockId,
	}
}

// Execute executes the request
//  @return Status
func (a *BlockApiService) PostCopyBlockExecute(r BlockApiPostCopyBlockRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockApiService.PostCopyBlock")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blocks/{sourceBlockId}/copy"
	localVarPath = strings.Replace(localVarPath, "{"+"sourceBlockId"+"}", url.PathEscape(parameterValueToString(r.sourceBlockId, "sourceBlockId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.sourceBlockId) < 1 {
		return localVarReturnValue, nil, reportError("sourceBlockId must have at least 1 elements")
	}
	if strlen(r.sourceBlockId) > 2000 {
		return localVarReturnValue, nil, reportError("sourceBlockId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.blockCopy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockApiPostRoomingListRequest struct {
	ctx context.Context
	ApiService *BlockApiService
	blockId string
	authorization *string
	xAppKey *string
	xHotelid *string
	roomingList *PostRoomingListRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockApiPostRoomingListRequest) Authorization(authorization string) BlockApiPostRoomingListRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r BlockApiPostRoomingListRequest) XAppKey(xAppKey string) BlockApiPostRoomingListRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockApiPostRoomingListRequest) XHotelid(xHotelid string) BlockApiPostRoomingListRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating rooming list reservations. The standard optional Opera Context element is also included.
func (r BlockApiPostRoomingListRequest) RoomingList(roomingList PostRoomingListRequest) BlockApiPostRoomingListRequest {
	r.roomingList = &roomingList
	return r
}

// External system code.
func (r BlockApiPostRoomingListRequest) XExternalsystem(xExternalsystem string) BlockApiPostRoomingListRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockApiPostRoomingListRequest) AcceptLanguage(acceptLanguage string) BlockApiPostRoomingListRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockApiPostRoomingListRequest) Execute() (*RoomingListDetails, *http.Response, error) {
	return r.ApiService.PostRoomingListExecute(r)
}

/*
PostRoomingList Create Block Rooming List Reservations

Use this API to create a Reservation Rooming List. <p><strong>OperationId:</strong>postRoomingList</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockId Block Id
 @return BlockApiPostRoomingListRequest
*/
func (a *BlockApiService) PostRoomingList(ctx context.Context, blockId string) BlockApiPostRoomingListRequest {
	return BlockApiPostRoomingListRequest{
		ApiService: a,
		ctx: ctx,
		blockId: blockId,
	}
}

// Execute executes the request
//  @return RoomingListDetails
func (a *BlockApiService) PostRoomingListExecute(r BlockApiPostRoomingListRequest) (*RoomingListDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RoomingListDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockApiService.PostRoomingList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blocks/{blockId}/roomingList"
	localVarPath = strings.Replace(localVarPath, "{"+"blockId"+"}", url.PathEscape(parameterValueToString(r.blockId, "blockId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.blockId) < 1 {
		return localVarReturnValue, nil, reportError("blockId must have at least 1 elements")
	}
	if strlen(r.blockId) > 2000 {
		return localVarReturnValue, nil, reportError("blockId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.roomingList
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockApiPostSubAllocationRequest struct {
	ctx context.Context
	ApiService *BlockApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	subAllocation *PostSubAllocationRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockApiPostSubAllocationRequest) Authorization(authorization string) BlockApiPostSubAllocationRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r BlockApiPostSubAllocationRequest) XAppKey(xAppKey string) BlockApiPostSubAllocationRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockApiPostSubAllocationRequest) XHotelid(xHotelid string) BlockApiPostSubAllocationRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creation of Sub Allocation. This object contains sub allocation details with unique identifiers for each sub allocation along with Master Allocation information. The standard optional Opera Context element is also included.
func (r BlockApiPostSubAllocationRequest) SubAllocation(subAllocation PostSubAllocationRequest) BlockApiPostSubAllocationRequest {
	r.subAllocation = &subAllocation
	return r
}

// External system code.
func (r BlockApiPostSubAllocationRequest) XExternalsystem(xExternalsystem string) BlockApiPostSubAllocationRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockApiPostSubAllocationRequest) AcceptLanguage(acceptLanguage string) BlockApiPostSubAllocationRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockApiPostSubAllocationRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostSubAllocationExecute(r)
}

/*
PostSubAllocation Create Sub allocation

Use this API to create sub allocation. <p><strong>OperationId:</strong>postSubAllocation</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return BlockApiPostSubAllocationRequest
*/
func (a *BlockApiService) PostSubAllocation(ctx context.Context) BlockApiPostSubAllocationRequest {
	return BlockApiPostSubAllocationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *BlockApiService) PostSubAllocationExecute(r BlockApiPostSubAllocationRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockApiService.PostSubAllocation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/allocation"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.subAllocation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockApiPostSubBlockRequest struct {
	ctx context.Context
	ApiService *BlockApiService
	blockId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	subBlock *PostSubBlockRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockApiPostSubBlockRequest) Authorization(authorization string) BlockApiPostSubBlockRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r BlockApiPostSubBlockRequest) XAppKey(xAppKey string) BlockApiPostSubBlockRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockApiPostSubBlockRequest) XHotelid(xHotelid string) BlockApiPostSubBlockRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to create new sub block.
func (r BlockApiPostSubBlockRequest) SubBlock(subBlock PostSubBlockRequest) BlockApiPostSubBlockRequest {
	r.subBlock = &subBlock
	return r
}

// External system code.
func (r BlockApiPostSubBlockRequest) XExternalsystem(xExternalsystem string) BlockApiPostSubBlockRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockApiPostSubBlockRequest) AcceptLanguage(acceptLanguage string) BlockApiPostSubBlockRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockApiPostSubBlockRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostSubBlockExecute(r)
}

/*
PostSubBlock Create a sub-Block

Use this when you want to create a sub block.You will need to know the OPERA Block ID, which you want this sub block to fall under. <p><strong>OperationId:</strong>postSubBlock</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockId Block Id
 @param hotelId Hotel Id
 @return BlockApiPostSubBlockRequest
*/
func (a *BlockApiService) PostSubBlock(ctx context.Context, blockId string, hotelId string) BlockApiPostSubBlockRequest {
	return BlockApiPostSubBlockRequest{
		ApiService: a,
		ctx: ctx,
		blockId: blockId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *BlockApiService) PostSubBlockExecute(r BlockApiPostSubBlockRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockApiService.PostSubBlock")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/blocks/{blockId}/subBlocks"
	localVarPath = strings.Replace(localVarPath, "{"+"blockId"+"}", url.PathEscape(parameterValueToString(r.blockId, "blockId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.blockId) < 1 {
		return localVarReturnValue, nil, reportError("blockId must have at least 1 elements")
	}
	if strlen(r.blockId) > 2000 {
		return localVarReturnValue, nil, reportError("blockId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.subBlock
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockApiPostSubBlockByExtIdRequest struct {
	ctx context.Context
	ApiService *BlockApiService
	blockExternalId string
	externalSystemCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	subBlock *PostSubBlockRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockApiPostSubBlockByExtIdRequest) Authorization(authorization string) BlockApiPostSubBlockByExtIdRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r BlockApiPostSubBlockByExtIdRequest) XAppKey(xAppKey string) BlockApiPostSubBlockByExtIdRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockApiPostSubBlockByExtIdRequest) XHotelid(xHotelid string) BlockApiPostSubBlockByExtIdRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to create new sub block.
func (r BlockApiPostSubBlockByExtIdRequest) SubBlock(subBlock PostSubBlockRequest) BlockApiPostSubBlockByExtIdRequest {
	r.subBlock = &subBlock
	return r
}

// External system code.
func (r BlockApiPostSubBlockByExtIdRequest) XExternalsystem(xExternalsystem string) BlockApiPostSubBlockByExtIdRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockApiPostSubBlockByExtIdRequest) AcceptLanguage(acceptLanguage string) BlockApiPostSubBlockByExtIdRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockApiPostSubBlockByExtIdRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostSubBlockByExtIdExecute(r)
}

/*
PostSubBlockByExtId Create a sub-Block

Use this when you want to create a sub block.You will need to know the OPERA Block ID, which you want this sub block to fall under. <p><strong>OperationId:</strong>postSubBlockByExtId</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockExternalId External Block Id
 @param externalSystemCode Code to identify the external system from which the request is coming. This is the ExternalSystem ID used to exchange information between OPERA and the external system.
 @param hotelId Hotel Id
 @return BlockApiPostSubBlockByExtIdRequest
*/
func (a *BlockApiService) PostSubBlockByExtId(ctx context.Context, blockExternalId string, externalSystemCode string, hotelId string) BlockApiPostSubBlockByExtIdRequest {
	return BlockApiPostSubBlockByExtIdRequest{
		ApiService: a,
		ctx: ctx,
		blockExternalId: blockExternalId,
		externalSystemCode: externalSystemCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *BlockApiService) PostSubBlockByExtIdExecute(r BlockApiPostSubBlockByExtIdRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockApiService.PostSubBlockByExtId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/externalSystems/{externalSystemCode}/blocks/{blockExternalId}/subBlocks"
	localVarPath = strings.Replace(localVarPath, "{"+"blockExternalId"+"}", url.PathEscape(parameterValueToString(r.blockExternalId, "blockExternalId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"externalSystemCode"+"}", url.PathEscape(parameterValueToString(r.externalSystemCode, "externalSystemCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.blockExternalId) < 1 {
		return localVarReturnValue, nil, reportError("blockExternalId must have at least 1 elements")
	}
	if strlen(r.blockExternalId) > 2000 {
		return localVarReturnValue, nil, reportError("blockExternalId must have less than 2000 elements")
	}
	if strlen(r.externalSystemCode) < 1 {
		return localVarReturnValue, nil, reportError("externalSystemCode must have at least 1 elements")
	}
	if strlen(r.externalSystemCode) > 2000 {
		return localVarReturnValue, nil, reportError("externalSystemCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.subBlock
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockApiPostTourSeriesRequest struct {
	ctx context.Context
	ApiService *BlockApiService
	blockId string
	authorization *string
	xAppKey *string
	xHotelid *string
	tourSeries *PostTourSeriesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockApiPostTourSeriesRequest) Authorization(authorization string) BlockApiPostTourSeriesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r BlockApiPostTourSeriesRequest) XAppKey(xAppKey string) BlockApiPostTourSeriesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockApiPostTourSeriesRequest) XHotelid(xHotelid string) BlockApiPostTourSeriesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request for creating a tour series based on an existing block.
func (r BlockApiPostTourSeriesRequest) TourSeries(tourSeries PostTourSeriesRequest) BlockApiPostTourSeriesRequest {
	r.tourSeries = &tourSeries
	return r
}

// External system code.
func (r BlockApiPostTourSeriesRequest) XExternalsystem(xExternalsystem string) BlockApiPostTourSeriesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockApiPostTourSeriesRequest) AcceptLanguage(acceptLanguage string) BlockApiPostTourSeriesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockApiPostTourSeriesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostTourSeriesExecute(r)
}

/*
PostTourSeries Create a Block tour series

Use this API to create a block tour series. <p><strong>OperationId:</strong>postTourSeries</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockId Block Id
 @return BlockApiPostTourSeriesRequest
*/
func (a *BlockApiService) PostTourSeries(ctx context.Context, blockId string) BlockApiPostTourSeriesRequest {
	return BlockApiPostTourSeriesRequest{
		ApiService: a,
		ctx: ctx,
		blockId: blockId,
	}
}

// Execute executes the request
//  @return Status
func (a *BlockApiService) PostTourSeriesExecute(r BlockApiPostTourSeriesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockApiService.PostTourSeries")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blocks/{blockId}/tourSeries"
	localVarPath = strings.Replace(localVarPath, "{"+"blockId"+"}", url.PathEscape(parameterValueToString(r.blockId, "blockId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.blockId) < 1 {
		return localVarReturnValue, nil, reportError("blockId must have at least 1 elements")
	}
	if strlen(r.blockId) > 2000 {
		return localVarReturnValue, nil, reportError("blockId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.tourSeries
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockApiPutAlternateDatesRequest struct {
	ctx context.Context
	ApiService *BlockApiService
	blockId string
	authorization *string
	xAppKey *string
	xHotelid *string
	blockAlternateDates *PutAlternateDatesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockApiPutAlternateDatesRequest) Authorization(authorization string) BlockApiPutAlternateDatesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r BlockApiPutAlternateDatesRequest) XAppKey(xAppKey string) BlockApiPutAlternateDatesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockApiPutAlternateDatesRequest) XHotelid(xHotelid string) BlockApiPutAlternateDatesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to change block alternate dates.
func (r BlockApiPutAlternateDatesRequest) BlockAlternateDates(blockAlternateDates PutAlternateDatesRequest) BlockApiPutAlternateDatesRequest {
	r.blockAlternateDates = &blockAlternateDates
	return r
}

// External system code.
func (r BlockApiPutAlternateDatesRequest) XExternalsystem(xExternalsystem string) BlockApiPutAlternateDatesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockApiPutAlternateDatesRequest) AcceptLanguage(acceptLanguage string) BlockApiPutAlternateDatesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockApiPutAlternateDatesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutAlternateDatesExecute(r)
}

/*
PutAlternateDates Change alternate dates for a Block

Use this API to change alternate dates for a block. <p><strong>OperationId:</strong>putAlternateDates</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockId Block Id
 @return BlockApiPutAlternateDatesRequest
*/
func (a *BlockApiService) PutAlternateDates(ctx context.Context, blockId string) BlockApiPutAlternateDatesRequest {
	return BlockApiPutAlternateDatesRequest{
		ApiService: a,
		ctx: ctx,
		blockId: blockId,
	}
}

// Execute executes the request
//  @return Status
func (a *BlockApiService) PutAlternateDatesExecute(r BlockApiPutAlternateDatesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockApiService.PutAlternateDates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blocks/{blockId}/alternateDates"
	localVarPath = strings.Replace(localVarPath, "{"+"blockId"+"}", url.PathEscape(parameterValueToString(r.blockId, "blockId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.blockId) < 1 {
		return localVarReturnValue, nil, reportError("blockId must have at least 1 elements")
	}
	if strlen(r.blockId) > 2000 {
		return localVarReturnValue, nil, reportError("blockId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.blockAlternateDates
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockApiPutBlockRequest struct {
	ctx context.Context
	ApiService *BlockApiService
	blockId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	blockToBeChanged *PutBlockRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockApiPutBlockRequest) Authorization(authorization string) BlockApiPutBlockRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r BlockApiPutBlockRequest) XAppKey(xAppKey string) BlockApiPutBlockRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockApiPutBlockRequest) XHotelid(xHotelid string) BlockApiPutBlockRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for change/modification of block details. This object contains modified block details with unique identifiers for each block. The standard optional Opera Context element is also included.
func (r BlockApiPutBlockRequest) BlockToBeChanged(blockToBeChanged PutBlockRequest) BlockApiPutBlockRequest {
	r.blockToBeChanged = &blockToBeChanged
	return r
}

// External system code.
func (r BlockApiPutBlockRequest) XExternalsystem(xExternalsystem string) BlockApiPutBlockRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockApiPutBlockRequest) AcceptLanguage(acceptLanguage string) BlockApiPutBlockRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockApiPutBlockRequest) Execute() (*BlockChanged, *http.Response, error) {
	return r.ApiService.PutBlockExecute(r)
}

/*
PutBlock Change a Block

Use this API to update an existing group block in OPERA Cloud. This API allows update of block header information, such as description, market segment, source code, rate code, and other details, but does not include updates for room grid or events, which have their own update API calls. <p><strong>OperationId:</strong>putBlock</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockId Block Id
 @param hotelId Hotel Id
 @return BlockApiPutBlockRequest
*/
func (a *BlockApiService) PutBlock(ctx context.Context, blockId string, hotelId string) BlockApiPutBlockRequest {
	return BlockApiPutBlockRequest{
		ApiService: a,
		ctx: ctx,
		blockId: blockId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return BlockChanged
func (a *BlockApiService) PutBlockExecute(r BlockApiPutBlockRequest) (*BlockChanged, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BlockChanged
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockApiService.PutBlock")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/blocks/{blockId}"
	localVarPath = strings.Replace(localVarPath, "{"+"blockId"+"}", url.PathEscape(parameterValueToString(r.blockId, "blockId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.blockId) < 1 {
		return localVarReturnValue, nil, reportError("blockId must have at least 1 elements")
	}
	if strlen(r.blockId) > 2000 {
		return localVarReturnValue, nil, reportError("blockId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.blockToBeChanged
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockApiPutBlockAccessExclusionRequest struct {
	ctx context.Context
	ApiService *BlockApiService
	blockId string
	authorization *string
	xAppKey *string
	xHotelid *string
	blockAccessExclusion *PutBlockAccessExclusionRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockApiPutBlockAccessExclusionRequest) Authorization(authorization string) BlockApiPutBlockAccessExclusionRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r BlockApiPutBlockAccessExclusionRequest) XAppKey(xAppKey string) BlockApiPutBlockAccessExclusionRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockApiPutBlockAccessExclusionRequest) XHotelid(xHotelid string) BlockApiPutBlockAccessExclusionRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating access exclusion permissions for a block.
func (r BlockApiPutBlockAccessExclusionRequest) BlockAccessExclusion(blockAccessExclusion PutBlockAccessExclusionRequest) BlockApiPutBlockAccessExclusionRequest {
	r.blockAccessExclusion = &blockAccessExclusion
	return r
}

// External system code.
func (r BlockApiPutBlockAccessExclusionRequest) XExternalsystem(xExternalsystem string) BlockApiPutBlockAccessExclusionRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockApiPutBlockAccessExclusionRequest) AcceptLanguage(acceptLanguage string) BlockApiPutBlockAccessExclusionRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockApiPutBlockAccessExclusionRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutBlockAccessExclusionExecute(r)
}

/*
PutBlockAccessExclusion Set Block Exclusion information

Us this API to create/change block access exclusion information. <p><strong>OperationId:</strong>putBlockAccessExclusion</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockId Block Id
 @return BlockApiPutBlockAccessExclusionRequest
*/
func (a *BlockApiService) PutBlockAccessExclusion(ctx context.Context, blockId string) BlockApiPutBlockAccessExclusionRequest {
	return BlockApiPutBlockAccessExclusionRequest{
		ApiService: a,
		ctx: ctx,
		blockId: blockId,
	}
}

// Execute executes the request
//  @return Status
func (a *BlockApiService) PutBlockAccessExclusionExecute(r BlockApiPutBlockAccessExclusionRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockApiService.PutBlockAccessExclusion")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blocks/{blockId}/blockAccessExclusion"
	localVarPath = strings.Replace(localVarPath, "{"+"blockId"+"}", url.PathEscape(parameterValueToString(r.blockId, "blockId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.blockId) < 1 {
		return localVarReturnValue, nil, reportError("blockId must have at least 1 elements")
	}
	if strlen(r.blockId) > 2000 {
		return localVarReturnValue, nil, reportError("blockId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.blockAccessExclusion
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockApiPutBlockAllocationRequest struct {
	ctx context.Context
	ApiService *BlockApiService
	blockId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	allocation *PutBlockAllocationRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockApiPutBlockAllocationRequest) Authorization(authorization string) BlockApiPutBlockAllocationRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r BlockApiPutBlockAllocationRequest) XAppKey(xAppKey string) BlockApiPutBlockAllocationRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockApiPutBlockAllocationRequest) XHotelid(xHotelid string) BlockApiPutBlockAllocationRequest {
	r.xHotelid = &xHotelid
	return r
}

// A Request message that sets the room allocations as a collection of room types and dates.
func (r BlockApiPutBlockAllocationRequest) Allocation(allocation PutBlockAllocationRequest) BlockApiPutBlockAllocationRequest {
	r.allocation = &allocation
	return r
}

// External system code.
func (r BlockApiPutBlockAllocationRequest) XExternalsystem(xExternalsystem string) BlockApiPutBlockAllocationRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockApiPutBlockAllocationRequest) AcceptLanguage(acceptLanguage string) BlockApiPutBlockAllocationRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockApiPutBlockAllocationRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutBlockAllocationExecute(r)
}

/*
PutBlockAllocation Set Block Allocation  

Use this API to add block room type allocations and rates to a specified Block. <p><strong>OperationId:</strong>putBlockAllocation</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockId Block Id
 @param hotelId Hotel Id
 @return BlockApiPutBlockAllocationRequest
*/
func (a *BlockApiService) PutBlockAllocation(ctx context.Context, blockId string, hotelId string) BlockApiPutBlockAllocationRequest {
	return BlockApiPutBlockAllocationRequest{
		ApiService: a,
		ctx: ctx,
		blockId: blockId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *BlockApiService) PutBlockAllocationExecute(r BlockApiPutBlockAllocationRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockApiService.PutBlockAllocation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/blocks/{blockId}/allocation"
	localVarPath = strings.Replace(localVarPath, "{"+"blockId"+"}", url.PathEscape(parameterValueToString(r.blockId, "blockId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.blockId) < 1 {
		return localVarReturnValue, nil, reportError("blockId must have at least 1 elements")
	}
	if strlen(r.blockId) > 2000 {
		return localVarReturnValue, nil, reportError("blockId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.allocation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockApiPutBlockAllocationByExtIdRequest struct {
	ctx context.Context
	ApiService *BlockApiService
	roomType string
	blockExternalId string
	externalSystemCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	allocation *PutBlockAllocationRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockApiPutBlockAllocationByExtIdRequest) Authorization(authorization string) BlockApiPutBlockAllocationByExtIdRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r BlockApiPutBlockAllocationByExtIdRequest) XAppKey(xAppKey string) BlockApiPutBlockAllocationByExtIdRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockApiPutBlockAllocationByExtIdRequest) XHotelid(xHotelid string) BlockApiPutBlockAllocationByExtIdRequest {
	r.xHotelid = &xHotelid
	return r
}

// A Request message that sets the room allocations as a collection of room types and dates.
func (r BlockApiPutBlockAllocationByExtIdRequest) Allocation(allocation PutBlockAllocationRequest) BlockApiPutBlockAllocationByExtIdRequest {
	r.allocation = &allocation
	return r
}

// External system code.
func (r BlockApiPutBlockAllocationByExtIdRequest) XExternalsystem(xExternalsystem string) BlockApiPutBlockAllocationByExtIdRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockApiPutBlockAllocationByExtIdRequest) AcceptLanguage(acceptLanguage string) BlockApiPutBlockAllocationByExtIdRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockApiPutBlockAllocationByExtIdRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutBlockAllocationByExtIdExecute(r)
}

/*
PutBlockAllocationByExtId Set Block Allocation  

Use this API to add block room type allocations and rates to a specified Block. <p><strong>OperationId:</strong>putBlockAllocationByExtId</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param roomType Room Type
 @param blockExternalId External Block Id
 @param externalSystemCode Code to identify the external system from which the request is coming. This is the ExternalSystem ID used to exchange information between OPERA and the external system.
 @param hotelId Hotel Id
 @return BlockApiPutBlockAllocationByExtIdRequest
*/
func (a *BlockApiService) PutBlockAllocationByExtId(ctx context.Context, roomType string, blockExternalId string, externalSystemCode string, hotelId string) BlockApiPutBlockAllocationByExtIdRequest {
	return BlockApiPutBlockAllocationByExtIdRequest{
		ApiService: a,
		ctx: ctx,
		roomType: roomType,
		blockExternalId: blockExternalId,
		externalSystemCode: externalSystemCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *BlockApiService) PutBlockAllocationByExtIdExecute(r BlockApiPutBlockAllocationByExtIdRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockApiService.PutBlockAllocationByExtId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/externalSystems/{externalSystemCode}/blocks/{blockExternalId}/allocation/roomTypes/{roomType}"
	localVarPath = strings.Replace(localVarPath, "{"+"roomType"+"}", url.PathEscape(parameterValueToString(r.roomType, "roomType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"blockExternalId"+"}", url.PathEscape(parameterValueToString(r.blockExternalId, "blockExternalId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"externalSystemCode"+"}", url.PathEscape(parameterValueToString(r.externalSystemCode, "externalSystemCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.roomType) < 1 {
		return localVarReturnValue, nil, reportError("roomType must have at least 1 elements")
	}
	if strlen(r.roomType) > 2000 {
		return localVarReturnValue, nil, reportError("roomType must have less than 2000 elements")
	}
	if strlen(r.blockExternalId) < 1 {
		return localVarReturnValue, nil, reportError("blockExternalId must have at least 1 elements")
	}
	if strlen(r.blockExternalId) > 2000 {
		return localVarReturnValue, nil, reportError("blockExternalId must have less than 2000 elements")
	}
	if strlen(r.externalSystemCode) < 1 {
		return localVarReturnValue, nil, reportError("externalSystemCode must have at least 1 elements")
	}
	if strlen(r.externalSystemCode) > 2000 {
		return localVarReturnValue, nil, reportError("externalSystemCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.allocation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockApiPutBlockAllocationRangeRequest struct {
	ctx context.Context
	ApiService *BlockApiService
	blockId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	blockAllocationRange *PutBlockAllocationRangeRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockApiPutBlockAllocationRangeRequest) Authorization(authorization string) BlockApiPutBlockAllocationRangeRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r BlockApiPutBlockAllocationRangeRequest) XAppKey(xAppKey string) BlockApiPutBlockAllocationRangeRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockApiPutBlockAllocationRangeRequest) XHotelid(xHotelid string) BlockApiPutBlockAllocationRangeRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request for updating block allocation for a range of dates.
func (r BlockApiPutBlockAllocationRangeRequest) BlockAllocationRange(blockAllocationRange PutBlockAllocationRangeRequest) BlockApiPutBlockAllocationRangeRequest {
	r.blockAllocationRange = &blockAllocationRange
	return r
}

// External system code.
func (r BlockApiPutBlockAllocationRangeRequest) XExternalsystem(xExternalsystem string) BlockApiPutBlockAllocationRangeRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockApiPutBlockAllocationRangeRequest) AcceptLanguage(acceptLanguage string) BlockApiPutBlockAllocationRangeRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockApiPutBlockAllocationRangeRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutBlockAllocationRangeExecute(r)
}

/*
PutBlockAllocationRange Set Block Allocation Range

Use this API to set block allocation for a range of dates for a list of room types. <p><strong>OperationId:</strong>putBlockAllocationRange</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockId Block Id
 @param hotelId Hotel Id
 @return BlockApiPutBlockAllocationRangeRequest
*/
func (a *BlockApiService) PutBlockAllocationRange(ctx context.Context, blockId string, hotelId string) BlockApiPutBlockAllocationRangeRequest {
	return BlockApiPutBlockAllocationRangeRequest{
		ApiService: a,
		ctx: ctx,
		blockId: blockId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *BlockApiService) PutBlockAllocationRangeExecute(r BlockApiPutBlockAllocationRangeRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockApiService.PutBlockAllocationRange")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/blocks/{blockId}/allocationRange"
	localVarPath = strings.Replace(localVarPath, "{"+"blockId"+"}", url.PathEscape(parameterValueToString(r.blockId, "blockId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.blockId) < 1 {
		return localVarReturnValue, nil, reportError("blockId must have at least 1 elements")
	}
	if strlen(r.blockId) > 2000 {
		return localVarReturnValue, nil, reportError("blockId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.blockAllocationRange
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockApiPutBlockAllocationRangeByExtIdRequest struct {
	ctx context.Context
	ApiService *BlockApiService
	blockExternalId string
	externalSystemCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	blockAllocationRange *PutBlockAllocationRangeRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockApiPutBlockAllocationRangeByExtIdRequest) Authorization(authorization string) BlockApiPutBlockAllocationRangeByExtIdRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r BlockApiPutBlockAllocationRangeByExtIdRequest) XAppKey(xAppKey string) BlockApiPutBlockAllocationRangeByExtIdRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockApiPutBlockAllocationRangeByExtIdRequest) XHotelid(xHotelid string) BlockApiPutBlockAllocationRangeByExtIdRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request for updating block allocation for a range of dates.
func (r BlockApiPutBlockAllocationRangeByExtIdRequest) BlockAllocationRange(blockAllocationRange PutBlockAllocationRangeRequest) BlockApiPutBlockAllocationRangeByExtIdRequest {
	r.blockAllocationRange = &blockAllocationRange
	return r
}

// External system code.
func (r BlockApiPutBlockAllocationRangeByExtIdRequest) XExternalsystem(xExternalsystem string) BlockApiPutBlockAllocationRangeByExtIdRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockApiPutBlockAllocationRangeByExtIdRequest) AcceptLanguage(acceptLanguage string) BlockApiPutBlockAllocationRangeByExtIdRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockApiPutBlockAllocationRangeByExtIdRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutBlockAllocationRangeByExtIdExecute(r)
}

/*
PutBlockAllocationRangeByExtId Set Block Allocation Range

Use this API to set block allocation for a range of dates for a list of room types. <p><strong>OperationId:</strong>putBlockAllocationRangeByExtId</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockExternalId External Block Id
 @param externalSystemCode Code to identify the external system from which the request is coming. This is the ExternalSystem ID used to exchange information between OPERA and the external system.
 @param hotelId Hotel Id
 @return BlockApiPutBlockAllocationRangeByExtIdRequest
*/
func (a *BlockApiService) PutBlockAllocationRangeByExtId(ctx context.Context, blockExternalId string, externalSystemCode string, hotelId string) BlockApiPutBlockAllocationRangeByExtIdRequest {
	return BlockApiPutBlockAllocationRangeByExtIdRequest{
		ApiService: a,
		ctx: ctx,
		blockExternalId: blockExternalId,
		externalSystemCode: externalSystemCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *BlockApiService) PutBlockAllocationRangeByExtIdExecute(r BlockApiPutBlockAllocationRangeByExtIdRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockApiService.PutBlockAllocationRangeByExtId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/externalSystems/{externalSystemCode}/blocks/{blockExternalId}/allocationRange"
	localVarPath = strings.Replace(localVarPath, "{"+"blockExternalId"+"}", url.PathEscape(parameterValueToString(r.blockExternalId, "blockExternalId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"externalSystemCode"+"}", url.PathEscape(parameterValueToString(r.externalSystemCode, "externalSystemCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.blockExternalId) < 1 {
		return localVarReturnValue, nil, reportError("blockExternalId must have at least 1 elements")
	}
	if strlen(r.blockExternalId) > 2000 {
		return localVarReturnValue, nil, reportError("blockExternalId must have less than 2000 elements")
	}
	if strlen(r.externalSystemCode) < 1 {
		return localVarReturnValue, nil, reportError("externalSystemCode must have at least 1 elements")
	}
	if strlen(r.externalSystemCode) > 2000 {
		return localVarReturnValue, nil, reportError("externalSystemCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.blockAllocationRange
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockApiPutBlockAllocationWashRequest struct {
	ctx context.Context
	ApiService *BlockApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	blockAllocationWash *PutBlockAllocationWashRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockApiPutBlockAllocationWashRequest) Authorization(authorization string) BlockApiPutBlockAllocationWashRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r BlockApiPutBlockAllocationWashRequest) XAppKey(xAppKey string) BlockApiPutBlockAllocationWashRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockApiPutBlockAllocationWashRequest) XHotelid(xHotelid string) BlockApiPutBlockAllocationWashRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for block wash operation.
func (r BlockApiPutBlockAllocationWashRequest) BlockAllocationWash(blockAllocationWash PutBlockAllocationWashRequest) BlockApiPutBlockAllocationWashRequest {
	r.blockAllocationWash = &blockAllocationWash
	return r
}

// External system code.
func (r BlockApiPutBlockAllocationWashRequest) XExternalsystem(xExternalsystem string) BlockApiPutBlockAllocationWashRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockApiPutBlockAllocationWashRequest) AcceptLanguage(acceptLanguage string) BlockApiPutBlockAllocationWashRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockApiPutBlockAllocationWashRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutBlockAllocationWashExecute(r)
}

/*
PutBlockAllocationWash Update Block Allocation Wash

This API removes block allocation to a range of dates for a set of room types. <p><strong>OperationId:</strong>putBlockAllocationWash</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return BlockApiPutBlockAllocationWashRequest
*/
func (a *BlockApiService) PutBlockAllocationWash(ctx context.Context) BlockApiPutBlockAllocationWashRequest {
	return BlockApiPutBlockAllocationWashRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *BlockApiService) PutBlockAllocationWashExecute(r BlockApiPutBlockAllocationWashRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockApiService.PutBlockAllocationWash")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blockWash"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.blockAllocationWash
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockApiPutBlockByExtIdRequest struct {
	ctx context.Context
	ApiService *BlockApiService
	blockExternalId string
	externalSystemCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	blockToBeChanged *PutBlockRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockApiPutBlockByExtIdRequest) Authorization(authorization string) BlockApiPutBlockByExtIdRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r BlockApiPutBlockByExtIdRequest) XAppKey(xAppKey string) BlockApiPutBlockByExtIdRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockApiPutBlockByExtIdRequest) XHotelid(xHotelid string) BlockApiPutBlockByExtIdRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for change/modification of block details. This object contains modified block details with unique identifiers for each block. The standard optional Opera Context element is also included.
func (r BlockApiPutBlockByExtIdRequest) BlockToBeChanged(blockToBeChanged PutBlockRequest) BlockApiPutBlockByExtIdRequest {
	r.blockToBeChanged = &blockToBeChanged
	return r
}

// External system code.
func (r BlockApiPutBlockByExtIdRequest) XExternalsystem(xExternalsystem string) BlockApiPutBlockByExtIdRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockApiPutBlockByExtIdRequest) AcceptLanguage(acceptLanguage string) BlockApiPutBlockByExtIdRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockApiPutBlockByExtIdRequest) Execute() (*BlockChanged, *http.Response, error) {
	return r.ApiService.PutBlockByExtIdExecute(r)
}

/*
PutBlockByExtId Change a Block

You can use this API to update an existing block.  You must know the block ID for the request message.  Use getBlocks if you dont already know the block ID. <p><strong>OperationId:</strong>putBlockByExtId</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockExternalId External Block Id
 @param externalSystemCode Code to identify the external system from which the request is coming. This is the ExternalSystem ID used to exchange information between OPERA and the external system.
 @param hotelId Hotel Id
 @return BlockApiPutBlockByExtIdRequest
*/
func (a *BlockApiService) PutBlockByExtId(ctx context.Context, blockExternalId string, externalSystemCode string, hotelId string) BlockApiPutBlockByExtIdRequest {
	return BlockApiPutBlockByExtIdRequest{
		ApiService: a,
		ctx: ctx,
		blockExternalId: blockExternalId,
		externalSystemCode: externalSystemCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return BlockChanged
func (a *BlockApiService) PutBlockByExtIdExecute(r BlockApiPutBlockByExtIdRequest) (*BlockChanged, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BlockChanged
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockApiService.PutBlockByExtId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/externalSystems/{externalSystemCode}/blocks/{blockExternalId}"
	localVarPath = strings.Replace(localVarPath, "{"+"blockExternalId"+"}", url.PathEscape(parameterValueToString(r.blockExternalId, "blockExternalId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"externalSystemCode"+"}", url.PathEscape(parameterValueToString(r.externalSystemCode, "externalSystemCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.blockExternalId) < 1 {
		return localVarReturnValue, nil, reportError("blockExternalId must have at least 1 elements")
	}
	if strlen(r.blockExternalId) > 2000 {
		return localVarReturnValue, nil, reportError("blockExternalId must have less than 2000 elements")
	}
	if strlen(r.externalSystemCode) < 1 {
		return localVarReturnValue, nil, reportError("externalSystemCode must have at least 1 elements")
	}
	if strlen(r.externalSystemCode) > 2000 {
		return localVarReturnValue, nil, reportError("externalSystemCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.blockToBeChanged
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockApiPutBlockCutoffRequest struct {
	ctx context.Context
	ApiService *BlockApiService
	blockId string
	authorization *string
	xAppKey *string
	xHotelid *string
	blockStatus *PutBlockCutoffRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockApiPutBlockCutoffRequest) Authorization(authorization string) BlockApiPutBlockCutoffRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r BlockApiPutBlockCutoffRequest) XAppKey(xAppKey string) BlockApiPutBlockCutoffRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockApiPutBlockCutoffRequest) XHotelid(xHotelid string) BlockApiPutBlockCutoffRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for cutoffBlock operation.
func (r BlockApiPutBlockCutoffRequest) BlockStatus(blockStatus PutBlockCutoffRequest) BlockApiPutBlockCutoffRequest {
	r.blockStatus = &blockStatus
	return r
}

// External system code.
func (r BlockApiPutBlockCutoffRequest) XExternalsystem(xExternalsystem string) BlockApiPutBlockCutoffRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockApiPutBlockCutoffRequest) AcceptLanguage(acceptLanguage string) BlockApiPutBlockCutoffRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockApiPutBlockCutoffRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutBlockCutoffExecute(r)
}

/*
PutBlockCutoff Block Cut Off

This API cuts off block allocation effective current date. <p><strong>OperationId:</strong>putBlockCutoff</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockId Block Id
 @return BlockApiPutBlockCutoffRequest
*/
func (a *BlockApiService) PutBlockCutoff(ctx context.Context, blockId string) BlockApiPutBlockCutoffRequest {
	return BlockApiPutBlockCutoffRequest{
		ApiService: a,
		ctx: ctx,
		blockId: blockId,
	}
}

// Execute executes the request
//  @return Status
func (a *BlockApiService) PutBlockCutoffExecute(r BlockApiPutBlockCutoffRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockApiService.PutBlockCutoff")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blocks/{blockId}/blockCutOff"
	localVarPath = strings.Replace(localVarPath, "{"+"blockId"+"}", url.PathEscape(parameterValueToString(r.blockId, "blockId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.blockId) < 1 {
		return localVarReturnValue, nil, reportError("blockId must have at least 1 elements")
	}
	if strlen(r.blockId) > 2000 {
		return localVarReturnValue, nil, reportError("blockId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.blockStatus
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockApiPutBlockOwnersRequest struct {
	ctx context.Context
	ApiService *BlockApiService
	blockId string
	authorization *string
	xAppKey *string
	xHotelid *string
	blockOwnersToChange *PutBlockOwnersRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockApiPutBlockOwnersRequest) Authorization(authorization string) BlockApiPutBlockOwnersRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r BlockApiPutBlockOwnersRequest) XAppKey(xAppKey string) BlockApiPutBlockOwnersRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockApiPutBlockOwnersRequest) XHotelid(xHotelid string) BlockApiPutBlockOwnersRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to change block owners.
func (r BlockApiPutBlockOwnersRequest) BlockOwnersToChange(blockOwnersToChange PutBlockOwnersRequest) BlockApiPutBlockOwnersRequest {
	r.blockOwnersToChange = &blockOwnersToChange
	return r
}

// External system code.
func (r BlockApiPutBlockOwnersRequest) XExternalsystem(xExternalsystem string) BlockApiPutBlockOwnersRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockApiPutBlockOwnersRequest) AcceptLanguage(acceptLanguage string) BlockApiPutBlockOwnersRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockApiPutBlockOwnersRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutBlockOwnersExecute(r)
}

/*
PutBlockOwners Change Block owners

Use this API to change block owners. <p><strong>OperationId:</strong>putBlockOwners</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockId Block Id
 @return BlockApiPutBlockOwnersRequest
*/
func (a *BlockApiService) PutBlockOwners(ctx context.Context, blockId string) BlockApiPutBlockOwnersRequest {
	return BlockApiPutBlockOwnersRequest{
		ApiService: a,
		ctx: ctx,
		blockId: blockId,
	}
}

// Execute executes the request
//  @return Status
func (a *BlockApiService) PutBlockOwnersExecute(r BlockApiPutBlockOwnersRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockApiService.PutBlockOwners")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blocks/{blockId}/owners"
	localVarPath = strings.Replace(localVarPath, "{"+"blockId"+"}", url.PathEscape(parameterValueToString(r.blockId, "blockId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.blockId) < 1 {
		return localVarReturnValue, nil, reportError("blockId must have at least 1 elements")
	}
	if strlen(r.blockId) > 2000 {
		return localVarReturnValue, nil, reportError("blockId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.blockOwnersToChange
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockApiPutBlockRatesRequest struct {
	ctx context.Context
	ApiService *BlockApiService
	blockId string
	authorization *string
	xAppKey *string
	xHotelid *string
	blockStatus *PutBlockCutoffRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockApiPutBlockRatesRequest) Authorization(authorization string) BlockApiPutBlockRatesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r BlockApiPutBlockRatesRequest) XAppKey(xAppKey string) BlockApiPutBlockRatesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockApiPutBlockRatesRequest) XHotelid(xHotelid string) BlockApiPutBlockRatesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object of refresh block rates operation.
func (r BlockApiPutBlockRatesRequest) BlockStatus(blockStatus PutBlockCutoffRequest) BlockApiPutBlockRatesRequest {
	r.blockStatus = &blockStatus
	return r
}

// External system code.
func (r BlockApiPutBlockRatesRequest) XExternalsystem(xExternalsystem string) BlockApiPutBlockRatesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockApiPutBlockRatesRequest) AcceptLanguage(acceptLanguage string) BlockApiPutBlockRatesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockApiPutBlockRatesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutBlockRatesExecute(r)
}

/*
PutBlockRates Refreshes Block rates

Use this API to refreshes block rates. <p><strong>OperationId:</strong>putBlockRates</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockId Block Id
 @return BlockApiPutBlockRatesRequest
*/
func (a *BlockApiService) PutBlockRates(ctx context.Context, blockId string) BlockApiPutBlockRatesRequest {
	return BlockApiPutBlockRatesRequest{
		ApiService: a,
		ctx: ctx,
		blockId: blockId,
	}
}

// Execute executes the request
//  @return Status
func (a *BlockApiService) PutBlockRatesExecute(r BlockApiPutBlockRatesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockApiService.PutBlockRates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blocks/{blockId}/rates"
	localVarPath = strings.Replace(localVarPath, "{"+"blockId"+"}", url.PathEscape(parameterValueToString(r.blockId, "blockId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.blockId) < 1 {
		return localVarReturnValue, nil, reportError("blockId must have at least 1 elements")
	}
	if strlen(r.blockId) > 2000 {
		return localVarReturnValue, nil, reportError("blockId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.blockStatus
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockApiPutBlockReservationsRequest struct {
	ctx context.Context
	ApiService *BlockApiService
	blockId string
	authorization *string
	xAppKey *string
	xHotelid *string
	blockReservationsToChange *PutBlockReservationsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockApiPutBlockReservationsRequest) Authorization(authorization string) BlockApiPutBlockReservationsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r BlockApiPutBlockReservationsRequest) XAppKey(xAppKey string) BlockApiPutBlockReservationsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockApiPutBlockReservationsRequest) XHotelid(xHotelid string) BlockApiPutBlockReservationsRequest {
	r.xHotelid = &xHotelid
	return r
}

// The request object to implement batch changes to block reservations based upon changes made to a reference reservation.
func (r BlockApiPutBlockReservationsRequest) BlockReservationsToChange(blockReservationsToChange PutBlockReservationsRequest) BlockApiPutBlockReservationsRequest {
	r.blockReservationsToChange = &blockReservationsToChange
	return r
}

// External system code.
func (r BlockApiPutBlockReservationsRequest) XExternalsystem(xExternalsystem string) BlockApiPutBlockReservationsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockApiPutBlockReservationsRequest) AcceptLanguage(acceptLanguage string) BlockApiPutBlockReservationsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockApiPutBlockReservationsRequest) Execute() (*ChangedBlockReservations, *http.Response, error) {
	return r.ApiService.PutBlockReservationsExecute(r)
}

/*
PutBlockReservations Change Block reservations

Use this API to make changes to block reservations. <p><strong>OperationId:</strong>putBlockReservations</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockId Block Id
 @return BlockApiPutBlockReservationsRequest
*/
func (a *BlockApiService) PutBlockReservations(ctx context.Context, blockId string) BlockApiPutBlockReservationsRequest {
	return BlockApiPutBlockReservationsRequest{
		ApiService: a,
		ctx: ctx,
		blockId: blockId,
	}
}

// Execute executes the request
//  @return ChangedBlockReservations
func (a *BlockApiService) PutBlockReservationsExecute(r BlockApiPutBlockReservationsRequest) (*ChangedBlockReservations, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChangedBlockReservations
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockApiService.PutBlockReservations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blocks/{blockId}/reservations"
	localVarPath = strings.Replace(localVarPath, "{"+"blockId"+"}", url.PathEscape(parameterValueToString(r.blockId, "blockId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.blockId) < 1 {
		return localVarReturnValue, nil, reportError("blockId must have at least 1 elements")
	}
	if strlen(r.blockId) > 2000 {
		return localVarReturnValue, nil, reportError("blockId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.blockReservationsToChange
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockApiPutBlockShiftRequest struct {
	ctx context.Context
	ApiService *BlockApiService
	blockId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	blockToShift *PutBlockShiftRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockApiPutBlockShiftRequest) Authorization(authorization string) BlockApiPutBlockShiftRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r BlockApiPutBlockShiftRequest) XAppKey(xAppKey string) BlockApiPutBlockShiftRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockApiPutBlockShiftRequest) XHotelid(xHotelid string) BlockApiPutBlockShiftRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to shift business block starting date.
func (r BlockApiPutBlockShiftRequest) BlockToShift(blockToShift PutBlockShiftRequest) BlockApiPutBlockShiftRequest {
	r.blockToShift = &blockToShift
	return r
}

// External system code.
func (r BlockApiPutBlockShiftRequest) XExternalsystem(xExternalsystem string) BlockApiPutBlockShiftRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockApiPutBlockShiftRequest) AcceptLanguage(acceptLanguage string) BlockApiPutBlockShiftRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockApiPutBlockShiftRequest) Execute() (*ShiftedBlock, *http.Response, error) {
	return r.ApiService.PutBlockShiftExecute(r)
}

/*
PutBlockShift Shifts the Block start date

Use this API to move or shift the dates of a block in OPERA.  <p><strong>OperationId:</strong>putBlockShift</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockId Block Id
 @param hotelId Hotel Id
 @return BlockApiPutBlockShiftRequest
*/
func (a *BlockApiService) PutBlockShift(ctx context.Context, blockId string, hotelId string) BlockApiPutBlockShiftRequest {
	return BlockApiPutBlockShiftRequest{
		ApiService: a,
		ctx: ctx,
		blockId: blockId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ShiftedBlock
func (a *BlockApiService) PutBlockShiftExecute(r BlockApiPutBlockShiftRequest) (*ShiftedBlock, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ShiftedBlock
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockApiService.PutBlockShift")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/blocks/{blockId}/shifts"
	localVarPath = strings.Replace(localVarPath, "{"+"blockId"+"}", url.PathEscape(parameterValueToString(r.blockId, "blockId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.blockId) < 1 {
		return localVarReturnValue, nil, reportError("blockId must have at least 1 elements")
	}
	if strlen(r.blockId) > 2000 {
		return localVarReturnValue, nil, reportError("blockId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.blockToShift
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockApiPutBlockStatusRequest struct {
	ctx context.Context
	ApiService *BlockApiService
	blockId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	blockStatusToChange *PutBlockStatusRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockApiPutBlockStatusRequest) Authorization(authorization string) BlockApiPutBlockStatusRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r BlockApiPutBlockStatusRequest) XAppKey(xAppKey string) BlockApiPutBlockStatusRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockApiPutBlockStatusRequest) XHotelid(xHotelid string) BlockApiPutBlockStatusRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing the booking status of the business block.
func (r BlockApiPutBlockStatusRequest) BlockStatusToChange(blockStatusToChange PutBlockStatusRequest) BlockApiPutBlockStatusRequest {
	r.blockStatusToChange = &blockStatusToChange
	return r
}

// External system code.
func (r BlockApiPutBlockStatusRequest) XExternalsystem(xExternalsystem string) BlockApiPutBlockStatusRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockApiPutBlockStatusRequest) AcceptLanguage(acceptLanguage string) BlockApiPutBlockStatusRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockApiPutBlockStatusRequest) Execute() (*ChangedBlockStatus, *http.Response, error) {
	return r.ApiService.PutBlockStatusExecute(r)
}

/*
PutBlockStatus Change the Status of a Block

Use this to change the status of a block in Opera.  To know a hotels Block status codes, use the List Of Values API - BlockStatuses.  Also note, you can only change the status in a particular order, for example INQ to DEF, but not DEF to INQ. <p><strong>OperationId:</strong>putBlockStatus</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockId Block Id
 @param hotelId Hotel Id
 @return BlockApiPutBlockStatusRequest
*/
func (a *BlockApiService) PutBlockStatus(ctx context.Context, blockId string, hotelId string) BlockApiPutBlockStatusRequest {
	return BlockApiPutBlockStatusRequest{
		ApiService: a,
		ctx: ctx,
		blockId: blockId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ChangedBlockStatus
func (a *BlockApiService) PutBlockStatusExecute(r BlockApiPutBlockStatusRequest) (*ChangedBlockStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChangedBlockStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockApiService.PutBlockStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/blocks/{blockId}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"blockId"+"}", url.PathEscape(parameterValueToString(r.blockId, "blockId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.blockId) < 1 {
		return localVarReturnValue, nil, reportError("blockId must have at least 1 elements")
	}
	if strlen(r.blockId) > 2000 {
		return localVarReturnValue, nil, reportError("blockId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.blockStatusToChange
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockApiPutBlockStatusByExtIdRequest struct {
	ctx context.Context
	ApiService *BlockApiService
	blockExternalId string
	externalSystemCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	blockStatusToChange *PutBlockStatusRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockApiPutBlockStatusByExtIdRequest) Authorization(authorization string) BlockApiPutBlockStatusByExtIdRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r BlockApiPutBlockStatusByExtIdRequest) XAppKey(xAppKey string) BlockApiPutBlockStatusByExtIdRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockApiPutBlockStatusByExtIdRequest) XHotelid(xHotelid string) BlockApiPutBlockStatusByExtIdRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing the booking status of the business block.
func (r BlockApiPutBlockStatusByExtIdRequest) BlockStatusToChange(blockStatusToChange PutBlockStatusRequest) BlockApiPutBlockStatusByExtIdRequest {
	r.blockStatusToChange = &blockStatusToChange
	return r
}

// External system code.
func (r BlockApiPutBlockStatusByExtIdRequest) XExternalsystem(xExternalsystem string) BlockApiPutBlockStatusByExtIdRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockApiPutBlockStatusByExtIdRequest) AcceptLanguage(acceptLanguage string) BlockApiPutBlockStatusByExtIdRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockApiPutBlockStatusByExtIdRequest) Execute() (*ChangedBlockStatus, *http.Response, error) {
	return r.ApiService.PutBlockStatusByExtIdExecute(r)
}

/*
PutBlockStatusByExtId Change the Status of a Block

Use this to change the status of a block in Opera.  To know a hotels Block status codes, use the List Of Values API - BlockStatuses.  Also note, you can only change the status in a particular order, for example INQ to DEF, but not DEF to INQ. <p><strong>OperationId:</strong>putBlockStatusByExtId</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockExternalId External Block Id
 @param externalSystemCode Code to identify the external system from which the request is coming. This is the ExternalSystem ID used to exchange information between OPERA and the external system.
 @param hotelId HotelId
 @return BlockApiPutBlockStatusByExtIdRequest
*/
func (a *BlockApiService) PutBlockStatusByExtId(ctx context.Context, blockExternalId string, externalSystemCode string, hotelId string) BlockApiPutBlockStatusByExtIdRequest {
	return BlockApiPutBlockStatusByExtIdRequest{
		ApiService: a,
		ctx: ctx,
		blockExternalId: blockExternalId,
		externalSystemCode: externalSystemCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ChangedBlockStatus
func (a *BlockApiService) PutBlockStatusByExtIdExecute(r BlockApiPutBlockStatusByExtIdRequest) (*ChangedBlockStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChangedBlockStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockApiService.PutBlockStatusByExtId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/externalSystems/{externalSystemCode}/blocks/{blockExternalId}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"blockExternalId"+"}", url.PathEscape(parameterValueToString(r.blockExternalId, "blockExternalId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"externalSystemCode"+"}", url.PathEscape(parameterValueToString(r.externalSystemCode, "externalSystemCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.blockExternalId) < 1 {
		return localVarReturnValue, nil, reportError("blockExternalId must have at least 1 elements")
	}
	if strlen(r.blockExternalId) > 2000 {
		return localVarReturnValue, nil, reportError("blockExternalId must have less than 2000 elements")
	}
	if strlen(r.externalSystemCode) < 1 {
		return localVarReturnValue, nil, reportError("externalSystemCode must have at least 1 elements")
	}
	if strlen(r.externalSystemCode) > 2000 {
		return localVarReturnValue, nil, reportError("externalSystemCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.blockStatusToChange
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockApiPutBlockStatusToOpenRequest struct {
	ctx context.Context
	ApiService *BlockApiService
	blockId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	blockStatus *PutBlockCutoffRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockApiPutBlockStatusToOpenRequest) Authorization(authorization string) BlockApiPutBlockStatusToOpenRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r BlockApiPutBlockStatusToOpenRequest) XAppKey(xAppKey string) BlockApiPutBlockStatusToOpenRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockApiPutBlockStatusToOpenRequest) XHotelid(xHotelid string) BlockApiPutBlockStatusToOpenRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to transition the block status to Open for Pickup. This object contains unique identifier ( Block unique id ) to identify the block to be transitioned and the standard optional Opera Context element.
func (r BlockApiPutBlockStatusToOpenRequest) BlockStatus(blockStatus PutBlockCutoffRequest) BlockApiPutBlockStatusToOpenRequest {
	r.blockStatus = &blockStatus
	return r
}

// External system code.
func (r BlockApiPutBlockStatusToOpenRequest) XExternalsystem(xExternalsystem string) BlockApiPutBlockStatusToOpenRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockApiPutBlockStatusToOpenRequest) AcceptLanguage(acceptLanguage string) BlockApiPutBlockStatusToOpenRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockApiPutBlockStatusToOpenRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutBlockStatusToOpenExecute(r)
}

/*
PutBlockStatusToOpen Change Block status to Open

Use this API to transition booking status in allotment header to an Open for Pickup Status, which ready to receive reservation bookings. <p><strong>OperationId:</strong>putBlockStatusToOpen</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockId Block Id
 @param hotelId Hotel Id
 @return BlockApiPutBlockStatusToOpenRequest
*/
func (a *BlockApiService) PutBlockStatusToOpen(ctx context.Context, blockId string, hotelId string) BlockApiPutBlockStatusToOpenRequest {
	return BlockApiPutBlockStatusToOpenRequest{
		ApiService: a,
		ctx: ctx,
		blockId: blockId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *BlockApiService) PutBlockStatusToOpenExecute(r BlockApiPutBlockStatusToOpenRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockApiService.PutBlockStatusToOpen")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/blocks/{blockId}/openStatus"
	localVarPath = strings.Replace(localVarPath, "{"+"blockId"+"}", url.PathEscape(parameterValueToString(r.blockId, "blockId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.blockId) < 1 {
		return localVarReturnValue, nil, reportError("blockId must have at least 1 elements")
	}
	if strlen(r.blockId) > 2000 {
		return localVarReturnValue, nil, reportError("blockId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.blockStatus
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockApiPutBlockWashSchedulesRequest struct {
	ctx context.Context
	ApiService *BlockApiService
	blockId string
	authorization *string
	xAppKey *string
	xHotelid *string
	blockWashSchedulesInfo *PutBlockWashSchedulesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockApiPutBlockWashSchedulesRequest) Authorization(authorization string) BlockApiPutBlockWashSchedulesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r BlockApiPutBlockWashSchedulesRequest) XAppKey(xAppKey string) BlockApiPutBlockWashSchedulesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockApiPutBlockWashSchedulesRequest) XHotelid(xHotelid string) BlockApiPutBlockWashSchedulesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to change multiple Block Wash Schedules under the selected block.
func (r BlockApiPutBlockWashSchedulesRequest) BlockWashSchedulesInfo(blockWashSchedulesInfo PutBlockWashSchedulesRequest) BlockApiPutBlockWashSchedulesRequest {
	r.blockWashSchedulesInfo = &blockWashSchedulesInfo
	return r
}

// External system code.
func (r BlockApiPutBlockWashSchedulesRequest) XExternalsystem(xExternalsystem string) BlockApiPutBlockWashSchedulesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockApiPutBlockWashSchedulesRequest) AcceptLanguage(acceptLanguage string) BlockApiPutBlockWashSchedulesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockApiPutBlockWashSchedulesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutBlockWashSchedulesExecute(r)
}

/*
PutBlockWashSchedules Change Block Wash Schedules

This API changes block wash schedules Wash Date, Room Type, Occupancy detail, Sell limit and Wash by percent value. <p><strong>OperationId:</strong>putBlockWashSchedules</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockId Block Id
 @return BlockApiPutBlockWashSchedulesRequest
*/
func (a *BlockApiService) PutBlockWashSchedules(ctx context.Context, blockId string) BlockApiPutBlockWashSchedulesRequest {
	return BlockApiPutBlockWashSchedulesRequest{
		ApiService: a,
		ctx: ctx,
		blockId: blockId,
	}
}

// Execute executes the request
//  @return Status
func (a *BlockApiService) PutBlockWashSchedulesExecute(r BlockApiPutBlockWashSchedulesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockApiService.PutBlockWashSchedules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blocks/{blockId}/washSchedules"
	localVarPath = strings.Replace(localVarPath, "{"+"blockId"+"}", url.PathEscape(parameterValueToString(r.blockId, "blockId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.blockId) < 1 {
		return localVarReturnValue, nil, reportError("blockId must have at least 1 elements")
	}
	if strlen(r.blockId) > 2000 {
		return localVarReturnValue, nil, reportError("blockId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.blockWashSchedulesInfo
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockApiPutCateringStatusRequest struct {
	ctx context.Context
	ApiService *BlockApiService
	eventId string
	authorization *string
	xAppKey *string
	xHotelid *string
	cateringStatusToChange *PutCateringStatusRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockApiPutCateringStatusRequest) Authorization(authorization string) BlockApiPutCateringStatusRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r BlockApiPutCateringStatusRequest) XAppKey(xAppKey string) BlockApiPutCateringStatusRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockApiPutCateringStatusRequest) XHotelid(xHotelid string) BlockApiPutCateringStatusRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing the catering status of the business block.
func (r BlockApiPutCateringStatusRequest) CateringStatusToChange(cateringStatusToChange PutCateringStatusRequest) BlockApiPutCateringStatusRequest {
	r.cateringStatusToChange = &cateringStatusToChange
	return r
}

// External system code.
func (r BlockApiPutCateringStatusRequest) XExternalsystem(xExternalsystem string) BlockApiPutCateringStatusRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockApiPutCateringStatusRequest) AcceptLanguage(acceptLanguage string) BlockApiPutCateringStatusRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockApiPutCateringStatusRequest) Execute() (*ChangedCateringStatus, *http.Response, error) {
	return r.ApiService.PutCateringStatusExecute(r)
}

/*
PutCateringStatus Change Catering Status

Use this API to update catering status. <p><strong>OperationId:</strong>putCateringStatus</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId Event Id
 @return BlockApiPutCateringStatusRequest
*/
func (a *BlockApiService) PutCateringStatus(ctx context.Context, eventId string) BlockApiPutCateringStatusRequest {
	return BlockApiPutCateringStatusRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return ChangedCateringStatus
func (a *BlockApiService) PutCateringStatusExecute(r BlockApiPutCateringStatusRequest) (*ChangedCateringStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChangedCateringStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockApiService.PutCateringStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/caterings/{eventId}/cateringStatus"
	localVarPath = strings.Replace(localVarPath, "{"+"eventId"+"}", url.PathEscape(parameterValueToString(r.eventId, "eventId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.eventId) < 1 {
		return localVarReturnValue, nil, reportError("eventId must have at least 1 elements")
	}
	if strlen(r.eventId) > 2000 {
		return localVarReturnValue, nil, reportError("eventId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.cateringStatusToChange
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockApiPutClearAllRestrictionsRequest struct {
	ctx context.Context
	ApiService *BlockApiService
	blockId string
	authorization *string
	xAppKey *string
	xHotelid *string
	allRestrictions *PutClearAllRestrictionsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockApiPutClearAllRestrictionsRequest) Authorization(authorization string) BlockApiPutClearAllRestrictionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r BlockApiPutClearAllRestrictionsRequest) XAppKey(xAppKey string) BlockApiPutClearAllRestrictionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockApiPutClearAllRestrictionsRequest) XHotelid(xHotelid string) BlockApiPutClearAllRestrictionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for clearing all restrictions based on date.
func (r BlockApiPutClearAllRestrictionsRequest) AllRestrictions(allRestrictions PutClearAllRestrictionsRequest) BlockApiPutClearAllRestrictionsRequest {
	r.allRestrictions = &allRestrictions
	return r
}

// External system code.
func (r BlockApiPutClearAllRestrictionsRequest) XExternalsystem(xExternalsystem string) BlockApiPutClearAllRestrictionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockApiPutClearAllRestrictionsRequest) AcceptLanguage(acceptLanguage string) BlockApiPutClearAllRestrictionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockApiPutClearAllRestrictionsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutClearAllRestrictionsExecute(r)
}

/*
PutClearAllRestrictions Clear-All Block Restrictions 

This API clears all block restrictions for a given date. <p><strong>OperationId:</strong>putClearAllRestrictions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockId Block Id
 @return BlockApiPutClearAllRestrictionsRequest
*/
func (a *BlockApiService) PutClearAllRestrictions(ctx context.Context, blockId string) BlockApiPutClearAllRestrictionsRequest {
	return BlockApiPutClearAllRestrictionsRequest{
		ApiService: a,
		ctx: ctx,
		blockId: blockId,
	}
}

// Execute executes the request
//  @return Status
func (a *BlockApiService) PutClearAllRestrictionsExecute(r BlockApiPutClearAllRestrictionsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockApiService.PutClearAllRestrictions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blocks/{blockId}/restrictions"
	localVarPath = strings.Replace(localVarPath, "{"+"blockId"+"}", url.PathEscape(parameterValueToString(r.blockId, "blockId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.blockId) < 1 {
		return localVarReturnValue, nil, reportError("blockId must have at least 1 elements")
	}
	if strlen(r.blockId) > 2000 {
		return localVarReturnValue, nil, reportError("blockId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.allRestrictions
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockApiPutContractDefaultsRequest struct {
	ctx context.Context
	ApiService *BlockApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	blockStatus *PutBlockCutoffRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockApiPutContractDefaultsRequest) Authorization(authorization string) BlockApiPutContractDefaultsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r BlockApiPutContractDefaultsRequest) XAppKey(xAppKey string) BlockApiPutContractDefaultsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockApiPutContractDefaultsRequest) XHotelid(xHotelid string) BlockApiPutContractDefaultsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for copying from Original or Current Grid to Contract Grid.
func (r BlockApiPutContractDefaultsRequest) BlockStatus(blockStatus PutBlockCutoffRequest) BlockApiPutContractDefaultsRequest {
	r.blockStatus = &blockStatus
	return r
}

// External system code.
func (r BlockApiPutContractDefaultsRequest) XExternalsystem(xExternalsystem string) BlockApiPutContractDefaultsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockApiPutContractDefaultsRequest) AcceptLanguage(acceptLanguage string) BlockApiPutContractDefaultsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockApiPutContractDefaultsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutContractDefaultsExecute(r)
}

/*
PutContractDefaults Set Contract Defaults

Use this API to set the contract defaults. <p><strong>OperationId:</strong>putContractDefaults</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return BlockApiPutContractDefaultsRequest
*/
func (a *BlockApiService) PutContractDefaults(ctx context.Context) BlockApiPutContractDefaultsRequest {
	return BlockApiPutContractDefaultsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *BlockApiService) PutContractDefaultsExecute(r BlockApiPutContractDefaultsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockApiService.PutContractDefaults")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/contractDefaults"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.blockStatus
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockApiPutInventoryRequest struct {
	ctx context.Context
	ApiService *BlockApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	inventoryToBorrow *PutInventoryRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockApiPutInventoryRequest) Authorization(authorization string) BlockApiPutInventoryRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r BlockApiPutInventoryRequest) XAppKey(xAppKey string) BlockApiPutInventoryRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockApiPutInventoryRequest) XHotelid(xHotelid string) BlockApiPutInventoryRequest {
	r.xHotelid = &xHotelid
	return r
}

// The standard optional Opera Context element is also included.
func (r BlockApiPutInventoryRequest) InventoryToBorrow(inventoryToBorrow PutInventoryRequest) BlockApiPutInventoryRequest {
	r.inventoryToBorrow = &inventoryToBorrow
	return r
}

// External system code.
func (r BlockApiPutInventoryRequest) XExternalsystem(xExternalsystem string) BlockApiPutInventoryRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockApiPutInventoryRequest) AcceptLanguage(acceptLanguage string) BlockApiPutInventoryRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockApiPutInventoryRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutInventoryExecute(r)
}

/*
PutInventory Borrow Inventory

Use this API to borrow inventory from the block or house when you encounter an insufficient number of rooms for block a reservation. <p><strong>OperationId:</strong>putInventory</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return BlockApiPutInventoryRequest
*/
func (a *BlockApiService) PutInventory(ctx context.Context) BlockApiPutInventoryRequest {
	return BlockApiPutInventoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *BlockApiService) PutInventoryExecute(r BlockApiPutInventoryRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockApiService.PutInventory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/inventory"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.inventoryToBorrow
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockApiPutReleasedInventoryRequest struct {
	ctx context.Context
	ApiService *BlockApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	borrowedInventoryToReturn *PutReleasedInventoryRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockApiPutReleasedInventoryRequest) Authorization(authorization string) BlockApiPutReleasedInventoryRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r BlockApiPutReleasedInventoryRequest) XAppKey(xAppKey string) BlockApiPutReleasedInventoryRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockApiPutReleasedInventoryRequest) XHotelid(xHotelid string) BlockApiPutReleasedInventoryRequest {
	r.xHotelid = &xHotelid
	return r
}

// The standard optional Opera Context element is also included.
func (r BlockApiPutReleasedInventoryRequest) BorrowedInventoryToReturn(borrowedInventoryToReturn PutReleasedInventoryRequest) BlockApiPutReleasedInventoryRequest {
	r.borrowedInventoryToReturn = &borrowedInventoryToReturn
	return r
}

// External system code.
func (r BlockApiPutReleasedInventoryRequest) XExternalsystem(xExternalsystem string) BlockApiPutReleasedInventoryRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockApiPutReleasedInventoryRequest) AcceptLanguage(acceptLanguage string) BlockApiPutReleasedInventoryRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockApiPutReleasedInventoryRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutReleasedInventoryExecute(r)
}

/*
PutReleasedInventory Return Borrowed Inventory

Use this API to return the previously borrowed inventory on the block back to the original source from which it was borrowed. The original source can be a room type or house inventory, as indicated in the request. <p><strong>OperationId:</strong>putReleasedInventory</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return BlockApiPutReleasedInventoryRequest
*/
func (a *BlockApiService) PutReleasedInventory(ctx context.Context) BlockApiPutReleasedInventoryRequest {
	return BlockApiPutReleasedInventoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *BlockApiService) PutReleasedInventoryExecute(r BlockApiPutReleasedInventoryRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockApiService.PutReleasedInventory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/inventoryReleased"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.borrowedInventoryToReturn
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockApiPutRoomTypeOrderRequest struct {
	ctx context.Context
	ApiService *BlockApiService
	blockId string
	authorization *string
	xAppKey *string
	xHotelid *string
	roomTypeOrder *PutRoomTypeOrderRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockApiPutRoomTypeOrderRequest) Authorization(authorization string) BlockApiPutRoomTypeOrderRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r BlockApiPutRoomTypeOrderRequest) XAppKey(xAppKey string) BlockApiPutRoomTypeOrderRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockApiPutRoomTypeOrderRequest) XHotelid(xHotelid string) BlockApiPutRoomTypeOrderRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for SetRoomTypeOrder operation.
func (r BlockApiPutRoomTypeOrderRequest) RoomTypeOrder(roomTypeOrder PutRoomTypeOrderRequest) BlockApiPutRoomTypeOrderRequest {
	r.roomTypeOrder = &roomTypeOrder
	return r
}

// External system code.
func (r BlockApiPutRoomTypeOrderRequest) XExternalsystem(xExternalsystem string) BlockApiPutRoomTypeOrderRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockApiPutRoomTypeOrderRequest) AcceptLanguage(acceptLanguage string) BlockApiPutRoomTypeOrderRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockApiPutRoomTypeOrderRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutRoomTypeOrderExecute(r)
}

/*
PutRoomTypeOrder Set room type order for a Block

Use this API to set room type order for a block. <p><strong>OperationId:</strong>putRoomTypeOrder</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockId Block Id
 @return BlockApiPutRoomTypeOrderRequest
*/
func (a *BlockApiService) PutRoomTypeOrder(ctx context.Context, blockId string) BlockApiPutRoomTypeOrderRequest {
	return BlockApiPutRoomTypeOrderRequest{
		ApiService: a,
		ctx: ctx,
		blockId: blockId,
	}
}

// Execute executes the request
//  @return Status
func (a *BlockApiService) PutRoomTypeOrderExecute(r BlockApiPutRoomTypeOrderRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockApiService.PutRoomTypeOrder")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blocks/{blockId}/roomTypeOrder"
	localVarPath = strings.Replace(localVarPath, "{"+"blockId"+"}", url.PathEscape(parameterValueToString(r.blockId, "blockId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.blockId) < 1 {
		return localVarReturnValue, nil, reportError("blockId must have at least 1 elements")
	}
	if strlen(r.blockId) > 2000 {
		return localVarReturnValue, nil, reportError("blockId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.roomTypeOrder
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockApiPutValidateBlockCodeRequest struct {
	ctx context.Context
	ApiService *BlockApiService
	blockCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	blockCodeToValidate *PutValidateBlockCodeRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockApiPutValidateBlockCodeRequest) Authorization(authorization string) BlockApiPutValidateBlockCodeRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r BlockApiPutValidateBlockCodeRequest) XAppKey(xAppKey string) BlockApiPutValidateBlockCodeRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockApiPutValidateBlockCodeRequest) XHotelid(xHotelid string) BlockApiPutValidateBlockCodeRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for validating blocks in a train. Block is not created. The standard optional Opera Context element is also included.
func (r BlockApiPutValidateBlockCodeRequest) BlockCodeToValidate(blockCodeToValidate PutValidateBlockCodeRequest) BlockApiPutValidateBlockCodeRequest {
	r.blockCodeToValidate = &blockCodeToValidate
	return r
}

// External system code.
func (r BlockApiPutValidateBlockCodeRequest) XExternalsystem(xExternalsystem string) BlockApiPutValidateBlockCodeRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockApiPutValidateBlockCodeRequest) AcceptLanguage(acceptLanguage string) BlockApiPutValidateBlockCodeRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockApiPutValidateBlockCodeRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutValidateBlockCodeExecute(r)
}

/*
PutValidateBlockCode Validate Block Code

This API validates the block code for the following if applicable - Unique block code/ Start of inventory week/ Block code template. <p><strong>OperationId:</strong>putValidateBlockCode</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockCode Block code
 @return BlockApiPutValidateBlockCodeRequest
*/
func (a *BlockApiService) PutValidateBlockCode(ctx context.Context, blockCode string) BlockApiPutValidateBlockCodeRequest {
	return BlockApiPutValidateBlockCodeRequest{
		ApiService: a,
		ctx: ctx,
		blockCode: blockCode,
	}
}

// Execute executes the request
//  @return Status
func (a *BlockApiService) PutValidateBlockCodeExecute(r BlockApiPutValidateBlockCodeRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockApiService.PutValidateBlockCode")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blocks/{blockCode}/actions/validate"
	localVarPath = strings.Replace(localVarPath, "{"+"blockCode"+"}", url.PathEscape(parameterValueToString(r.blockCode, "blockCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.blockCode) < 1 {
		return localVarReturnValue, nil, reportError("blockCode must have at least 1 elements")
	}
	if strlen(r.blockCode) > 2000 {
		return localVarReturnValue, nil, reportError("blockCode must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.blockCodeToValidate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
