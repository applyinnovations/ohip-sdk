/*
OPERA Cloud Front Desk Operations Service

APIs to cater for Front Desk Operations and Front Desk Statistic functionality in OPERA Cloud. <br /><br /> Front Desk features some of the most commonly used operations in OPERA Cloud, such as managing guest arrivals, managing in-house guests, and managing guest departures. Some additional tasks you can complete from the Front Desk menu are room searches, room assignments, and quick check outs as well as opening folios, creating registration cards, setting wake up calls, and sending messages to guests.<br /><br /> Compatible with OPERA Cloud release 22.3.<br /><br /><p> This document and all content within is available under the Universal Permissive License v 1.0 (https://oss.oracle.com/licenses/upl). Copyright (c) 2020, 2023 Oracle and/or its affiliates.</p>

API version: 22.3
Contact: hospitality_apis_ww_grp@oracle.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package fof

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// FrontDeskOperationsApiService FrontDeskOperationsApi service
type FrontDeskOperationsApiService service

type FrontDeskOperationsApiGetFulfillmentActivityLogRequest struct {
	ctx context.Context
	ApiService *FrontDeskOperationsApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	module *string
	parameterName *[]string
	parameterValue *[]string
	activityGroup *string
	activityType *string
	fromDate *string
	toDate *string
	searchText *string
	userByIds *[]int32
	userForIds *[]int32
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r FrontDeskOperationsApiGetFulfillmentActivityLogRequest) Authorization(authorization string) FrontDeskOperationsApiGetFulfillmentActivityLogRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r FrontDeskOperationsApiGetFulfillmentActivityLogRequest) XAppKey(xAppKey string) FrontDeskOperationsApiGetFulfillmentActivityLogRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r FrontDeskOperationsApiGetFulfillmentActivityLogRequest) XHotelid(xHotelid string) FrontDeskOperationsApiGetFulfillmentActivityLogRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r FrontDeskOperationsApiGetFulfillmentActivityLogRequest) Limit(limit int32) FrontDeskOperationsApiGetFulfillmentActivityLogRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r FrontDeskOperationsApiGetFulfillmentActivityLogRequest) Offset(offset int32) FrontDeskOperationsApiGetFulfillmentActivityLogRequest {
	r.offset = &offset
	return r
}

// Activity module.
func (r FrontDeskOperationsApiGetFulfillmentActivityLogRequest) Module(module string) FrontDeskOperationsApiGetFulfillmentActivityLogRequest {
	r.module = &module
	return r
}

// Name of the parameter.
func (r FrontDeskOperationsApiGetFulfillmentActivityLogRequest) ParameterName(parameterName []string) FrontDeskOperationsApiGetFulfillmentActivityLogRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r FrontDeskOperationsApiGetFulfillmentActivityLogRequest) ParameterValue(parameterValue []string) FrontDeskOperationsApiGetFulfillmentActivityLogRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r FrontDeskOperationsApiGetFulfillmentActivityLogRequest) ActivityGroup(activityGroup string) FrontDeskOperationsApiGetFulfillmentActivityLogRequest {
	r.activityGroup = &activityGroup
	return r
}

func (r FrontDeskOperationsApiGetFulfillmentActivityLogRequest) ActivityType(activityType string) FrontDeskOperationsApiGetFulfillmentActivityLogRequest {
	r.activityType = &activityType
	return r
}

// Search from date for the user activity log.
func (r FrontDeskOperationsApiGetFulfillmentActivityLogRequest) FromDate(fromDate string) FrontDeskOperationsApiGetFulfillmentActivityLogRequest {
	r.fromDate = &fromDate
	return r
}

// Search to date for the user activity log.
func (r FrontDeskOperationsApiGetFulfillmentActivityLogRequest) ToDate(toDate string) FrontDeskOperationsApiGetFulfillmentActivityLogRequest {
	r.toDate = &toDate
	return r
}

// Search text for the user activity log.
func (r FrontDeskOperationsApiGetFulfillmentActivityLogRequest) SearchText(searchText string) FrontDeskOperationsApiGetFulfillmentActivityLogRequest {
	r.searchText = &searchText
	return r
}

func (r FrontDeskOperationsApiGetFulfillmentActivityLogRequest) UserByIds(userByIds []int32) FrontDeskOperationsApiGetFulfillmentActivityLogRequest {
	r.userByIds = &userByIds
	return r
}

func (r FrontDeskOperationsApiGetFulfillmentActivityLogRequest) UserForIds(userForIds []int32) FrontDeskOperationsApiGetFulfillmentActivityLogRequest {
	r.userForIds = &userForIds
	return r
}

// External system code.
func (r FrontDeskOperationsApiGetFulfillmentActivityLogRequest) XExternalsystem(xExternalsystem string) FrontDeskOperationsApiGetFulfillmentActivityLogRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r FrontDeskOperationsApiGetFulfillmentActivityLogRequest) AcceptLanguage(acceptLanguage string) FrontDeskOperationsApiGetFulfillmentActivityLogRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r FrontDeskOperationsApiGetFulfillmentActivityLogRequest) Execute() (*ActivityLog, *http.Response, error) {
	return r.ApiService.GetFulfillmentActivityLogExecute(r)
}

/*
GetFulfillmentActivityLog Get the fullfillment activity log

You can use this API to get the fullfillment activity log. <p><strong>OperationId:</strong>getFulfillmentActivityLog</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId
 @return FrontDeskOperationsApiGetFulfillmentActivityLogRequest
*/
func (a *FrontDeskOperationsApiService) GetFulfillmentActivityLog(ctx context.Context, hotelId string) FrontDeskOperationsApiGetFulfillmentActivityLogRequest {
	return FrontDeskOperationsApiGetFulfillmentActivityLogRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ActivityLog
func (a *FrontDeskOperationsApiService) GetFulfillmentActivityLogExecute(r FrontDeskOperationsApiGetFulfillmentActivityLogRequest) (*ActivityLog, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActivityLog
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FrontDeskOperationsApiService.GetFulfillmentActivityLog")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/fulfillmentActivityLogs"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.module != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "module", r.module, "")
	}
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.activityGroup != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "activityGroup", r.activityGroup, "")
	}
	if r.activityType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "activityType", r.activityType, "")
	}
	if r.fromDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromDate", r.fromDate, "")
	}
	if r.toDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "toDate", r.toDate, "")
	}
	if r.searchText != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "searchText", r.searchText, "")
	}
	if r.userByIds != nil {
		t := *r.userByIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "userByIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "userByIds", t, "multi")
		}
	}
	if r.userForIds != nil {
		t := *r.userForIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "userForIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "userForIds", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FrontDeskOperationsApiGetHotelRoomsRequest struct {
	ctx context.Context
	ApiService *FrontDeskOperationsApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	roomNumberWildcard *string
	hotelRoomStatus *[]string
	hotelFORoomStatus *[]string
	fromRoomNumber *string
	toRoomNumber *string
	hotelRoomStartDate *string
	hotelRoomEndDate *string
	duration *string
	roomType *[]string
	roomClass *string
	floor *string
	includeDueOut *bool
	departureTime *string
	roomFeatureCode *[]string
	description *[]string
	orderSequence *[]float32
	quantity *[]int32
	smokingPreference *string
	includeAllRoomConditions *bool
	includeComponentRooms *bool
	includePseudoRooms *bool
	includeOORoomCheck *bool
	connectingRoomsOnly *bool
	reservationId *string
	reservationIdContext *string
	reservationIdType *string
	pseudoRoomsOnly *bool
	includeAttendentInRoom *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r FrontDeskOperationsApiGetHotelRoomsRequest) Authorization(authorization string) FrontDeskOperationsApiGetHotelRoomsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r FrontDeskOperationsApiGetHotelRoomsRequest) XAppKey(xAppKey string) FrontDeskOperationsApiGetHotelRoomsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r FrontDeskOperationsApiGetHotelRoomsRequest) XHotelid(xHotelid string) FrontDeskOperationsApiGetHotelRoomsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r FrontDeskOperationsApiGetHotelRoomsRequest) Limit(limit int32) FrontDeskOperationsApiGetHotelRoomsRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r FrontDeskOperationsApiGetHotelRoomsRequest) Offset(offset int32) FrontDeskOperationsApiGetHotelRoomsRequest {
	r.offset = &offset
	return r
}

func (r FrontDeskOperationsApiGetHotelRoomsRequest) RoomNumberWildcard(roomNumberWildcard string) FrontDeskOperationsApiGetHotelRoomsRequest {
	r.roomNumberWildcard = &roomNumberWildcard
	return r
}

// Simple type for room status instructions to be used in requests for fetching housekeeping rooms. Valid status values are Clean, Dirty, Pickup, Inspected, OutOfOrder, OutOfService.
func (r FrontDeskOperationsApiGetHotelRoomsRequest) HotelRoomStatus(hotelRoomStatus []string) FrontDeskOperationsApiGetHotelRoomsRequest {
	r.hotelRoomStatus = &hotelRoomStatus
	return r
}

// Simple type for front office room status instructions to be used in requests for fetching housekeeping rooms. Valid values are Vacant and Occupied.
func (r FrontDeskOperationsApiGetHotelRoomsRequest) HotelFORoomStatus(hotelFORoomStatus []string) FrontDeskOperationsApiGetHotelRoomsRequest {
	r.hotelFORoomStatus = &hotelFORoomStatus
	return r
}

func (r FrontDeskOperationsApiGetHotelRoomsRequest) FromRoomNumber(fromRoomNumber string) FrontDeskOperationsApiGetHotelRoomsRequest {
	r.fromRoomNumber = &fromRoomNumber
	return r
}

func (r FrontDeskOperationsApiGetHotelRoomsRequest) ToRoomNumber(toRoomNumber string) FrontDeskOperationsApiGetHotelRoomsRequest {
	r.toRoomNumber = &toRoomNumber
	return r
}

func (r FrontDeskOperationsApiGetHotelRoomsRequest) HotelRoomStartDate(hotelRoomStartDate string) FrontDeskOperationsApiGetHotelRoomsRequest {
	r.hotelRoomStartDate = &hotelRoomStartDate
	return r
}

func (r FrontDeskOperationsApiGetHotelRoomsRequest) HotelRoomEndDate(hotelRoomEndDate string) FrontDeskOperationsApiGetHotelRoomsRequest {
	r.hotelRoomEndDate = &hotelRoomEndDate
	return r
}

func (r FrontDeskOperationsApiGetHotelRoomsRequest) Duration(duration string) FrontDeskOperationsApiGetHotelRoomsRequest {
	r.duration = &duration
	return r
}

// The room types of hotel rooms to be fetched.
func (r FrontDeskOperationsApiGetHotelRoomsRequest) RoomType(roomType []string) FrontDeskOperationsApiGetHotelRoomsRequest {
	r.roomType = &roomType
	return r
}

// The room class of hotel rooms to be fetched.
func (r FrontDeskOperationsApiGetHotelRoomsRequest) RoomClass(roomClass string) FrontDeskOperationsApiGetHotelRoomsRequest {
	r.roomClass = &roomClass
	return r
}

// The floor of room to be fetched.
func (r FrontDeskOperationsApiGetHotelRoomsRequest) Floor(floor string) FrontDeskOperationsApiGetHotelRoomsRequest {
	r.floor = &floor
	return r
}

// This flag when set to true will include rooms assigned to due out reservations.
func (r FrontDeskOperationsApiGetHotelRoomsRequest) IncludeDueOut(includeDueOut bool) FrontDeskOperationsApiGetHotelRoomsRequest {
	r.includeDueOut = &includeDueOut
	return r
}

// When IncludeDueOut is enable,it is the departure time before which to search.
func (r FrontDeskOperationsApiGetHotelRoomsRequest) DepartureTime(departureTime string) FrontDeskOperationsApiGetHotelRoomsRequest {
	r.departureTime = &departureTime
	return r
}

// A code representing a room feature.
func (r FrontDeskOperationsApiGetHotelRoomsRequest) RoomFeatureCode(roomFeatureCode []string) FrontDeskOperationsApiGetHotelRoomsRequest {
	r.roomFeatureCode = &roomFeatureCode
	return r
}

// A code representing a room feature.
func (r FrontDeskOperationsApiGetHotelRoomsRequest) Description(description []string) FrontDeskOperationsApiGetHotelRoomsRequest {
	r.description = &description
	return r
}

// Display Order sequence.
func (r FrontDeskOperationsApiGetHotelRoomsRequest) OrderSequence(orderSequence []float32) FrontDeskOperationsApiGetHotelRoomsRequest {
	r.orderSequence = &orderSequence
	return r
}

// Indicates quantity.
func (r FrontDeskOperationsApiGetHotelRoomsRequest) Quantity(quantity []int32) FrontDeskOperationsApiGetHotelRoomsRequest {
	r.quantity = &quantity
	return r
}

// The smoking preference of room to be fetched.
func (r FrontDeskOperationsApiGetHotelRoomsRequest) SmokingPreference(smokingPreference string) FrontDeskOperationsApiGetHotelRoomsRequest {
	r.smokingPreference = &smokingPreference
	return r
}

// This flag when set to true will include all room conditions, when set to false then room with \&quot;General Assignment\&quot; condition type will be excluded from the result.
func (r FrontDeskOperationsApiGetHotelRoomsRequest) IncludeAllRoomConditions(includeAllRoomConditions bool) FrontDeskOperationsApiGetHotelRoomsRequest {
	r.includeAllRoomConditions = &includeAllRoomConditions
	return r
}

// This flag when set to true will include all component rooms
func (r FrontDeskOperationsApiGetHotelRoomsRequest) IncludeComponentRooms(includeComponentRooms bool) FrontDeskOperationsApiGetHotelRoomsRequest {
	r.includeComponentRooms = &includeComponentRooms
	return r
}

// This flag when set to true will include all pseudo rooms
func (r FrontDeskOperationsApiGetHotelRoomsRequest) IncludePseudoRooms(includePseudoRooms bool) FrontDeskOperationsApiGetHotelRoomsRequest {
	r.includePseudoRooms = &includePseudoRooms
	return r
}

// This flag when set to true will work for Available Rooms functionality
func (r FrontDeskOperationsApiGetHotelRoomsRequest) IncludeOORoomCheck(includeOORoomCheck bool) FrontDeskOperationsApiGetHotelRoomsRequest {
	r.includeOORoomCheck = &includeOORoomCheck
	return r
}

// This flag when set to true will include only connecting rooms.
func (r FrontDeskOperationsApiGetHotelRoomsRequest) ConnectingRoomsOnly(connectingRoomsOnly bool) FrontDeskOperationsApiGetHotelRoomsRequest {
	r.connectingRoomsOnly = &connectingRoomsOnly
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r FrontDeskOperationsApiGetHotelRoomsRequest) ReservationId(reservationId string) FrontDeskOperationsApiGetHotelRoomsRequest {
	r.reservationId = &reservationId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r FrontDeskOperationsApiGetHotelRoomsRequest) ReservationIdContext(reservationIdContext string) FrontDeskOperationsApiGetHotelRoomsRequest {
	r.reservationIdContext = &reservationIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r FrontDeskOperationsApiGetHotelRoomsRequest) ReservationIdType(reservationIdType string) FrontDeskOperationsApiGetHotelRoomsRequest {
	r.reservationIdType = &reservationIdType
	return r
}

// This flag when set to true will include only pseudo rooms
func (r FrontDeskOperationsApiGetHotelRoomsRequest) PseudoRoomsOnly(pseudoRoomsOnly bool) FrontDeskOperationsApiGetHotelRoomsRequest {
	r.pseudoRoomsOnly = &pseudoRoomsOnly
	return r
}

// This flag when set to true will includes attendent in Rooms
func (r FrontDeskOperationsApiGetHotelRoomsRequest) IncludeAttendentInRoom(includeAttendentInRoom bool) FrontDeskOperationsApiGetHotelRoomsRequest {
	r.includeAttendentInRoom = &includeAttendentInRoom
	return r
}

// External system code.
func (r FrontDeskOperationsApiGetHotelRoomsRequest) XExternalsystem(xExternalsystem string) FrontDeskOperationsApiGetHotelRoomsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r FrontDeskOperationsApiGetHotelRoomsRequest) AcceptLanguage(acceptLanguage string) FrontDeskOperationsApiGetHotelRoomsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r FrontDeskOperationsApiGetHotelRoomsRequest) Execute() (*HotelRooms, *http.Response, error) {
	return r.ApiService.GetHotelRoomsExecute(r)
}

/*
GetHotelRooms Get hotel available rooms

Use this API to return available rooms based on search criteria such as hotelId, hotelRoomStatus, roomType, roomFeatureCode,etc.<p><strong>OperationId:</strong>getHotelRooms</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId
 @return FrontDeskOperationsApiGetHotelRoomsRequest
*/
func (a *FrontDeskOperationsApiService) GetHotelRooms(ctx context.Context, hotelId string) FrontDeskOperationsApiGetHotelRoomsRequest {
	return FrontDeskOperationsApiGetHotelRoomsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return HotelRooms
func (a *FrontDeskOperationsApiService) GetHotelRoomsExecute(r FrontDeskOperationsApiGetHotelRoomsRequest) (*HotelRooms, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HotelRooms
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FrontDeskOperationsApiService.GetHotelRooms")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/rooms"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.roomNumberWildcard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomNumberWildcard", r.roomNumberWildcard, "")
	}
	if r.hotelRoomStatus != nil {
		t := *r.hotelRoomStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelRoomStatus", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelRoomStatus", t, "multi")
		}
	}
	if r.hotelFORoomStatus != nil {
		t := *r.hotelFORoomStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelFORoomStatus", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelFORoomStatus", t, "multi")
		}
	}
	if r.fromRoomNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromRoomNumber", r.fromRoomNumber, "")
	}
	if r.toRoomNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "toRoomNumber", r.toRoomNumber, "")
	}
	if r.hotelRoomStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelRoomStartDate", r.hotelRoomStartDate, "")
	}
	if r.hotelRoomEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelRoomEndDate", r.hotelRoomEndDate, "")
	}
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration", r.duration, "")
	}
	if r.roomType != nil {
		t := *r.roomType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomType", t, "multi")
		}
	}
	if r.roomClass != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomClass", r.roomClass, "")
	}
	if r.floor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "floor", r.floor, "")
	}
	if r.includeDueOut != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeDueOut", r.includeDueOut, "")
	}
	if r.departureTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "departureTime", r.departureTime, "")
	}
	if r.roomFeatureCode != nil {
		t := *r.roomFeatureCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomFeatureCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomFeatureCode", t, "multi")
		}
	}
	if r.description != nil {
		t := *r.description
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description", t, "multi")
		}
	}
	if r.orderSequence != nil {
		t := *r.orderSequence
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "orderSequence", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "orderSequence", t, "multi")
		}
	}
	if r.quantity != nil {
		t := *r.quantity
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "quantity", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "quantity", t, "multi")
		}
	}
	if r.smokingPreference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "smokingPreference", r.smokingPreference, "")
	}
	if r.includeAllRoomConditions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeAllRoomConditions", r.includeAllRoomConditions, "")
	}
	if r.includeComponentRooms != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeComponentRooms", r.includeComponentRooms, "")
	}
	if r.includePseudoRooms != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includePseudoRooms", r.includePseudoRooms, "")
	}
	if r.includeOORoomCheck != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeOORoomCheck", r.includeOORoomCheck, "")
	}
	if r.connectingRoomsOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectingRoomsOnly", r.connectingRoomsOnly, "")
	}
	if r.reservationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationId", r.reservationId, "")
	}
	if r.reservationIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIdContext", r.reservationIdContext, "")
	}
	if r.reservationIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIdType", r.reservationIdType, "")
	}
	if r.pseudoRoomsOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pseudoRoomsOnly", r.pseudoRoomsOnly, "")
	}
	if r.includeAttendentInRoom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeAttendentInRoom", r.includeAttendentInRoom, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FrontDeskOperationsApiGetReservationSummariesRequest struct {
	ctx context.Context
	ApiService *FrontDeskOperationsApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	searchType *string
	reservationId *[]string
	reservationIdContext *[]string
	reservationIdType *[]string
	blockId *[]string
	blockIdContext *[]string
	blockIdType *[]string
	arrivalEnd *string
	arrivalStart *string
	departureEnd *string
	departureStart *string
	stayOnEnd *string
	stayOnStart *string
	createdOnEnd *string
	createOnStart *string
	depositDateEnd *string
	depositDateStart *string
	dateCriteriaExpectedArrivalEndTime *string
	dateCriteriaExpectedArrivalStartTime *string
	depositDueDateEnd *string
	depositDueDateStart *string
	expectedReturnEndTime *string
	expectedReturnStartTime *string
	membershipNumber *string
	anyVIPStatus *bool
	vipStatusCodes *[]string
	roomId *string
	lastName *string
	firstName *string
	blockCode *string
	companyName *string
	travelAgentName *string
	creditCardNumber *string
	customReference *string
	externalReference *string
	attributeName *[]string
	orderType *[]string
	expectedArrivalEndTime *string
	expectedArrivalStartTime *string
	roomTypes *[]string
	roomStatuses *[]string
	paymentMethod *[]string
	indicator *[]string
	fetchSummaryInstructions *[]string
	allowedAction *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r FrontDeskOperationsApiGetReservationSummariesRequest) Authorization(authorization string) FrontDeskOperationsApiGetReservationSummariesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r FrontDeskOperationsApiGetReservationSummariesRequest) XAppKey(xAppKey string) FrontDeskOperationsApiGetReservationSummariesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r FrontDeskOperationsApiGetReservationSummariesRequest) XHotelid(xHotelid string) FrontDeskOperationsApiGetReservationSummariesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Represents Reservation search type Player Snapshot.
func (r FrontDeskOperationsApiGetReservationSummariesRequest) SearchType(searchType string) FrontDeskOperationsApiGetReservationSummariesRequest {
	r.searchType = &searchType
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r FrontDeskOperationsApiGetReservationSummariesRequest) ReservationId(reservationId []string) FrontDeskOperationsApiGetReservationSummariesRequest {
	r.reservationId = &reservationId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r FrontDeskOperationsApiGetReservationSummariesRequest) ReservationIdContext(reservationIdContext []string) FrontDeskOperationsApiGetReservationSummariesRequest {
	r.reservationIdContext = &reservationIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r FrontDeskOperationsApiGetReservationSummariesRequest) ReservationIdType(reservationIdType []string) FrontDeskOperationsApiGetReservationSummariesRequest {
	r.reservationIdType = &reservationIdType
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r FrontDeskOperationsApiGetReservationSummariesRequest) BlockId(blockId []string) FrontDeskOperationsApiGetReservationSummariesRequest {
	r.blockId = &blockId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r FrontDeskOperationsApiGetReservationSummariesRequest) BlockIdContext(blockIdContext []string) FrontDeskOperationsApiGetReservationSummariesRequest {
	r.blockIdContext = &blockIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r FrontDeskOperationsApiGetReservationSummariesRequest) BlockIdType(blockIdType []string) FrontDeskOperationsApiGetReservationSummariesRequest {
	r.blockIdType = &blockIdType
	return r
}

// The ending value of the date range.
func (r FrontDeskOperationsApiGetReservationSummariesRequest) ArrivalEnd(arrivalEnd string) FrontDeskOperationsApiGetReservationSummariesRequest {
	r.arrivalEnd = &arrivalEnd
	return r
}

// The starting value of the date range.
func (r FrontDeskOperationsApiGetReservationSummariesRequest) ArrivalStart(arrivalStart string) FrontDeskOperationsApiGetReservationSummariesRequest {
	r.arrivalStart = &arrivalStart
	return r
}

// The ending value of the date range.
func (r FrontDeskOperationsApiGetReservationSummariesRequest) DepartureEnd(departureEnd string) FrontDeskOperationsApiGetReservationSummariesRequest {
	r.departureEnd = &departureEnd
	return r
}

// The starting value of the date range.
func (r FrontDeskOperationsApiGetReservationSummariesRequest) DepartureStart(departureStart string) FrontDeskOperationsApiGetReservationSummariesRequest {
	r.departureStart = &departureStart
	return r
}

// The ending value of the date range.
func (r FrontDeskOperationsApiGetReservationSummariesRequest) StayOnEnd(stayOnEnd string) FrontDeskOperationsApiGetReservationSummariesRequest {
	r.stayOnEnd = &stayOnEnd
	return r
}

// The starting value of the date range.
func (r FrontDeskOperationsApiGetReservationSummariesRequest) StayOnStart(stayOnStart string) FrontDeskOperationsApiGetReservationSummariesRequest {
	r.stayOnStart = &stayOnStart
	return r
}

// The ending value of the date range.
func (r FrontDeskOperationsApiGetReservationSummariesRequest) CreatedOnEnd(createdOnEnd string) FrontDeskOperationsApiGetReservationSummariesRequest {
	r.createdOnEnd = &createdOnEnd
	return r
}

// The starting value of the date range.
func (r FrontDeskOperationsApiGetReservationSummariesRequest) CreateOnStart(createOnStart string) FrontDeskOperationsApiGetReservationSummariesRequest {
	r.createOnStart = &createOnStart
	return r
}

// The ending value of the date range.
func (r FrontDeskOperationsApiGetReservationSummariesRequest) DepositDateEnd(depositDateEnd string) FrontDeskOperationsApiGetReservationSummariesRequest {
	r.depositDateEnd = &depositDateEnd
	return r
}

// The starting value of the date range.
func (r FrontDeskOperationsApiGetReservationSummariesRequest) DepositDateStart(depositDateStart string) FrontDeskOperationsApiGetReservationSummariesRequest {
	r.depositDateStart = &depositDateStart
	return r
}

// The ending value of the time span.
func (r FrontDeskOperationsApiGetReservationSummariesRequest) DateCriteriaExpectedArrivalEndTime(dateCriteriaExpectedArrivalEndTime string) FrontDeskOperationsApiGetReservationSummariesRequest {
	r.dateCriteriaExpectedArrivalEndTime = &dateCriteriaExpectedArrivalEndTime
	return r
}

// The starting value of the time span.
func (r FrontDeskOperationsApiGetReservationSummariesRequest) DateCriteriaExpectedArrivalStartTime(dateCriteriaExpectedArrivalStartTime string) FrontDeskOperationsApiGetReservationSummariesRequest {
	r.dateCriteriaExpectedArrivalStartTime = &dateCriteriaExpectedArrivalStartTime
	return r
}

// The ending value of the date range.
func (r FrontDeskOperationsApiGetReservationSummariesRequest) DepositDueDateEnd(depositDueDateEnd string) FrontDeskOperationsApiGetReservationSummariesRequest {
	r.depositDueDateEnd = &depositDueDateEnd
	return r
}

// The starting value of the date range.
func (r FrontDeskOperationsApiGetReservationSummariesRequest) DepositDueDateStart(depositDueDateStart string) FrontDeskOperationsApiGetReservationSummariesRequest {
	r.depositDueDateStart = &depositDueDateStart
	return r
}

// The ending value of the time span.
func (r FrontDeskOperationsApiGetReservationSummariesRequest) ExpectedReturnEndTime(expectedReturnEndTime string) FrontDeskOperationsApiGetReservationSummariesRequest {
	r.expectedReturnEndTime = &expectedReturnEndTime
	return r
}

// The starting value of the time span.
func (r FrontDeskOperationsApiGetReservationSummariesRequest) ExpectedReturnStartTime(expectedReturnStartTime string) FrontDeskOperationsApiGetReservationSummariesRequest {
	r.expectedReturnStartTime = &expectedReturnStartTime
	return r
}

// Lookup reservations with this membership number.
func (r FrontDeskOperationsApiGetReservationSummariesRequest) MembershipNumber(membershipNumber string) FrontDeskOperationsApiGetReservationSummariesRequest {
	r.membershipNumber = &membershipNumber
	return r
}

// VIP status of the customer.
func (r FrontDeskOperationsApiGetReservationSummariesRequest) AnyVIPStatus(anyVIPStatus bool) FrontDeskOperationsApiGetReservationSummariesRequest {
	r.anyVIPStatus = &anyVIPStatus
	return r
}

// VIP status of the customer.
func (r FrontDeskOperationsApiGetReservationSummariesRequest) VipStatusCodes(vipStatusCodes []string) FrontDeskOperationsApiGetReservationSummariesRequest {
	r.vipStatusCodes = &vipStatusCodes
	return r
}

// Wildcard Search value to lookup reservation with this room number.
func (r FrontDeskOperationsApiGetReservationSummariesRequest) RoomId(roomId string) FrontDeskOperationsApiGetReservationSummariesRequest {
	r.roomId = &roomId
	return r
}

// Wildcard Search value to lookup reservations with this Last Name.
func (r FrontDeskOperationsApiGetReservationSummariesRequest) LastName(lastName string) FrontDeskOperationsApiGetReservationSummariesRequest {
	r.lastName = &lastName
	return r
}

// Wildcard Search value to lookup reservations with this First Name.
func (r FrontDeskOperationsApiGetReservationSummariesRequest) FirstName(firstName string) FrontDeskOperationsApiGetReservationSummariesRequest {
	r.firstName = &firstName
	return r
}

// Wildcard Search value to lookup reservation with this block code.
func (r FrontDeskOperationsApiGetReservationSummariesRequest) BlockCode(blockCode string) FrontDeskOperationsApiGetReservationSummariesRequest {
	r.blockCode = &blockCode
	return r
}

// Lookup reservations with this company name.
func (r FrontDeskOperationsApiGetReservationSummariesRequest) CompanyName(companyName string) FrontDeskOperationsApiGetReservationSummariesRequest {
	r.companyName = &companyName
	return r
}

// Lookup reservations with this travel agent name.
func (r FrontDeskOperationsApiGetReservationSummariesRequest) TravelAgentName(travelAgentName string) FrontDeskOperationsApiGetReservationSummariesRequest {
	r.travelAgentName = &travelAgentName
	return r
}

// Lookup reservations which has this credit card attached.
func (r FrontDeskOperationsApiGetReservationSummariesRequest) CreditCardNumber(creditCardNumber string) FrontDeskOperationsApiGetReservationSummariesRequest {
	r.creditCardNumber = &creditCardNumber
	return r
}

// Lookup reservations with this custom reference number.
func (r FrontDeskOperationsApiGetReservationSummariesRequest) CustomReference(customReference string) FrontDeskOperationsApiGetReservationSummariesRequest {
	r.customReference = &customReference
	return r
}

// Lookup reservations with this external reference id.
func (r FrontDeskOperationsApiGetReservationSummariesRequest) ExternalReference(externalReference string) FrontDeskOperationsApiGetReservationSummariesRequest {
	r.externalReference = &externalReference
	return r
}

func (r FrontDeskOperationsApiGetReservationSummariesRequest) AttributeName(attributeName []string) FrontDeskOperationsApiGetReservationSummariesRequest {
	r.attributeName = &attributeName
	return r
}

func (r FrontDeskOperationsApiGetReservationSummariesRequest) OrderType(orderType []string) FrontDeskOperationsApiGetReservationSummariesRequest {
	r.orderType = &orderType
	return r
}

// The ending value of the date range.
func (r FrontDeskOperationsApiGetReservationSummariesRequest) ExpectedArrivalEndTime(expectedArrivalEndTime string) FrontDeskOperationsApiGetReservationSummariesRequest {
	r.expectedArrivalEndTime = &expectedArrivalEndTime
	return r
}

// The starting value of the date range.
func (r FrontDeskOperationsApiGetReservationSummariesRequest) ExpectedArrivalStartTime(expectedArrivalStartTime string) FrontDeskOperationsApiGetReservationSummariesRequest {
	r.expectedArrivalStartTime = &expectedArrivalStartTime
	return r
}

// Room Type.
func (r FrontDeskOperationsApiGetReservationSummariesRequest) RoomTypes(roomTypes []string) FrontDeskOperationsApiGetReservationSummariesRequest {
	r.roomTypes = &roomTypes
	return r
}

// Simple type for room status instructions to be used in requests for fetching housekeeping rooms. Valid status values are Clean, Dirty, Pickup, Inspected, OutOfOrder, OutOfService.
func (r FrontDeskOperationsApiGetReservationSummariesRequest) RoomStatuses(roomStatuses []string) FrontDeskOperationsApiGetReservationSummariesRequest {
	r.roomStatuses = &roomStatuses
	return r
}

// Payment Method to search the reservation.
func (r FrontDeskOperationsApiGetReservationSummariesRequest) PaymentMethod(paymentMethod []string) FrontDeskOperationsApiGetReservationSummariesRequest {
	r.paymentMethod = &paymentMethod
	return r
}

// Simple type that corresponds to reservation indicators.
func (r FrontDeskOperationsApiGetReservationSummariesRequest) Indicator(indicator []string) FrontDeskOperationsApiGetReservationSummariesRequest {
	r.indicator = &indicator
	return r
}

// Simple type for reservation summary instructions that can be used in requests to fetch summary.
func (r FrontDeskOperationsApiGetReservationSummariesRequest) FetchSummaryInstructions(fetchSummaryInstructions []string) FrontDeskOperationsApiGetReservationSummariesRequest {
	r.fetchSummaryInstructions = &fetchSummaryInstructions
	return r
}

// Flag indicating whether the Enrollment is in progress or not for the Profile associated with this Reservation.
func (r FrontDeskOperationsApiGetReservationSummariesRequest) AllowedAction(allowedAction []string) FrontDeskOperationsApiGetReservationSummariesRequest {
	r.allowedAction = &allowedAction
	return r
}

// External system code.
func (r FrontDeskOperationsApiGetReservationSummariesRequest) XExternalsystem(xExternalsystem string) FrontDeskOperationsApiGetReservationSummariesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r FrontDeskOperationsApiGetReservationSummariesRequest) AcceptLanguage(acceptLanguage string) FrontDeskOperationsApiGetReservationSummariesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r FrontDeskOperationsApiGetReservationSummariesRequest) Execute() (*ShortReservation, *http.Response, error) {
	return r.ApiService.GetReservationSummariesExecute(r)
}

/*
GetReservationSummaries Get hotel reservation summaries

Use this API to return reservation summaries for a specific property based on search criteria such as reservationId, blockId, arrivalStart, membershipNumber, roomId, etc.<p><strong>OperationId:</strong>getReservationSummaries</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId
 @return FrontDeskOperationsApiGetReservationSummariesRequest
*/
func (a *FrontDeskOperationsApiService) GetReservationSummaries(ctx context.Context, hotelId string) FrontDeskOperationsApiGetReservationSummariesRequest {
	return FrontDeskOperationsApiGetReservationSummariesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ShortReservation
func (a *FrontDeskOperationsApiService) GetReservationSummariesExecute(r FrontDeskOperationsApiGetReservationSummariesRequest) (*ShortReservation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ShortReservation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FrontDeskOperationsApiService.GetReservationSummaries")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservationSummaries"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.searchType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "searchType", r.searchType, "")
	}
	if r.reservationId != nil {
		t := *r.reservationId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "reservationId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "reservationId", t, "multi")
		}
	}
	if r.reservationIdContext != nil {
		t := *r.reservationIdContext
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIdContext", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIdContext", t, "multi")
		}
	}
	if r.reservationIdType != nil {
		t := *r.reservationIdType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIdType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIdType", t, "multi")
		}
	}
	if r.blockId != nil {
		t := *r.blockId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "blockId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "blockId", t, "multi")
		}
	}
	if r.blockIdContext != nil {
		t := *r.blockIdContext
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "blockIdContext", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "blockIdContext", t, "multi")
		}
	}
	if r.blockIdType != nil {
		t := *r.blockIdType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "blockIdType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "blockIdType", t, "multi")
		}
	}
	if r.arrivalEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "arrivalEnd", r.arrivalEnd, "")
	}
	if r.arrivalStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "arrivalStart", r.arrivalStart, "")
	}
	if r.departureEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "departureEnd", r.departureEnd, "")
	}
	if r.departureStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "departureStart", r.departureStart, "")
	}
	if r.stayOnEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stayOnEnd", r.stayOnEnd, "")
	}
	if r.stayOnStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stayOnStart", r.stayOnStart, "")
	}
	if r.createdOnEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createdOnEnd", r.createdOnEnd, "")
	}
	if r.createOnStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createOnStart", r.createOnStart, "")
	}
	if r.depositDateEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depositDateEnd", r.depositDateEnd, "")
	}
	if r.depositDateStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depositDateStart", r.depositDateStart, "")
	}
	if r.dateCriteriaExpectedArrivalEndTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dateCriteriaExpectedArrivalEndTime", r.dateCriteriaExpectedArrivalEndTime, "")
	}
	if r.dateCriteriaExpectedArrivalStartTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dateCriteriaExpectedArrivalStartTime", r.dateCriteriaExpectedArrivalStartTime, "")
	}
	if r.depositDueDateEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depositDueDateEnd", r.depositDueDateEnd, "")
	}
	if r.depositDueDateStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depositDueDateStart", r.depositDueDateStart, "")
	}
	if r.expectedReturnEndTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expectedReturnEndTime", r.expectedReturnEndTime, "")
	}
	if r.expectedReturnStartTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expectedReturnStartTime", r.expectedReturnStartTime, "")
	}
	if r.membershipNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "membershipNumber", r.membershipNumber, "")
	}
	if r.anyVIPStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "anyVIPStatus", r.anyVIPStatus, "")
	}
	if r.vipStatusCodes != nil {
		t := *r.vipStatusCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vipStatusCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vipStatusCodes", t, "multi")
		}
	}
	if r.roomId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomId", r.roomId, "")
	}
	if r.lastName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lastName", r.lastName, "")
	}
	if r.firstName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "firstName", r.firstName, "")
	}
	if r.blockCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blockCode", r.blockCode, "")
	}
	if r.companyName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "companyName", r.companyName, "")
	}
	if r.travelAgentName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "travelAgentName", r.travelAgentName, "")
	}
	if r.creditCardNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creditCardNumber", r.creditCardNumber, "")
	}
	if r.customReference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "customReference", r.customReference, "")
	}
	if r.externalReference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "externalReference", r.externalReference, "")
	}
	if r.attributeName != nil {
		t := *r.attributeName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "attributeName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "attributeName", t, "multi")
		}
	}
	if r.orderType != nil {
		t := *r.orderType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "orderType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "orderType", t, "multi")
		}
	}
	if r.expectedArrivalEndTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expectedArrivalEndTime", r.expectedArrivalEndTime, "")
	}
	if r.expectedArrivalStartTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expectedArrivalStartTime", r.expectedArrivalStartTime, "")
	}
	if r.roomTypes != nil {
		t := *r.roomTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomTypes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomTypes", t, "multi")
		}
	}
	if r.roomStatuses != nil {
		t := *r.roomStatuses
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomStatuses", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomStatuses", t, "multi")
		}
	}
	if r.paymentMethod != nil {
		t := *r.paymentMethod
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "paymentMethod", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "paymentMethod", t, "multi")
		}
	}
	if r.indicator != nil {
		t := *r.indicator
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "indicator", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "indicator", t, "multi")
		}
	}
	if r.fetchSummaryInstructions != nil {
		t := *r.fetchSummaryInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchSummaryInstructions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchSummaryInstructions", t, "multi")
		}
	}
	if r.allowedAction != nil {
		t := *r.allowedAction
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "allowedAction", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "allowedAction", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FrontDeskOperationsApiGetRoomKeysRequest struct {
	ctx context.Context
	ApiService *FrontDeskOperationsApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r FrontDeskOperationsApiGetRoomKeysRequest) Authorization(authorization string) FrontDeskOperationsApiGetRoomKeysRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r FrontDeskOperationsApiGetRoomKeysRequest) XAppKey(xAppKey string) FrontDeskOperationsApiGetRoomKeysRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r FrontDeskOperationsApiGetRoomKeysRequest) XHotelid(xHotelid string) FrontDeskOperationsApiGetRoomKeysRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r FrontDeskOperationsApiGetRoomKeysRequest) XExternalsystem(xExternalsystem string) FrontDeskOperationsApiGetRoomKeysRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r FrontDeskOperationsApiGetRoomKeysRequest) AcceptLanguage(acceptLanguage string) FrontDeskOperationsApiGetRoomKeysRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r FrontDeskOperationsApiGetRoomKeysRequest) Execute() (*RoomKeyInfo, *http.Response, error) {
	return r.ApiService.GetRoomKeysExecute(r)
}

/*
GetRoomKeys Fetch the room keys

You can use this API to retrieve any existing room key information for a reservation. <p><strong>OperationId:</strong>getRoomKeys</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId
 @param hotelId
 @return FrontDeskOperationsApiGetRoomKeysRequest
*/
func (a *FrontDeskOperationsApiService) GetRoomKeys(ctx context.Context, reservationId string, hotelId string) FrontDeskOperationsApiGetRoomKeysRequest {
	return FrontDeskOperationsApiGetRoomKeysRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return RoomKeyInfo
func (a *FrontDeskOperationsApiService) GetRoomKeysExecute(r FrontDeskOperationsApiGetRoomKeysRequest) (*RoomKeyInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RoomKeyInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FrontDeskOperationsApiService.GetRoomKeys")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/roomKeys"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FrontDeskOperationsApiPostCheckInRequest struct {
	ctx context.Context
	ApiService *FrontDeskOperationsApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	reservation *PostCheckInRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r FrontDeskOperationsApiPostCheckInRequest) Authorization(authorization string) FrontDeskOperationsApiPostCheckInRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r FrontDeskOperationsApiPostCheckInRequest) XAppKey(xAppKey string) FrontDeskOperationsApiPostCheckInRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r FrontDeskOperationsApiPostCheckInRequest) XHotelid(xHotelid string) FrontDeskOperationsApiPostCheckInRequest {
	r.xHotelid = &xHotelid
	return r
}

// Validation checks includes the following: - Reservation is not valid to be checked in. - Split is still required before the reservation can be checked in. - Room information is missing. - Payment information is missing. - The status of the room needs to be reviewed. - Sharers was impacted. The check-in process affected the reservation details of shared guests on the reservation. - Sharers was not impacted. The check-in process has not affected the reservation details of shared guests on the reservation.
func (r FrontDeskOperationsApiPostCheckInRequest) Reservation(reservation PostCheckInRequest) FrontDeskOperationsApiPostCheckInRequest {
	r.reservation = &reservation
	return r
}

// External system code.
func (r FrontDeskOperationsApiPostCheckInRequest) XExternalsystem(xExternalsystem string) FrontDeskOperationsApiPostCheckInRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r FrontDeskOperationsApiPostCheckInRequest) AcceptLanguage(acceptLanguage string) FrontDeskOperationsApiPostCheckInRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r FrontDeskOperationsApiPostCheckInRequest) Execute() (*CheckedinReservation, *http.Response, error) {
	return r.ApiService.PostCheckInExecute(r)
}

/*
PostCheckIn Checks in a guest

Use this API to check in a guest reservation.  The reservation needs to be 'due in' status.  The API also provides an option to select an available room. <p><strong>OperationId:</strong>postCheckIn</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is being booked
 @return FrontDeskOperationsApiPostCheckInRequest
*/
func (a *FrontDeskOperationsApiService) PostCheckIn(ctx context.Context, reservationId string, hotelId string) FrontDeskOperationsApiPostCheckInRequest {
	return FrontDeskOperationsApiPostCheckInRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CheckedinReservation
func (a *FrontDeskOperationsApiService) PostCheckInExecute(r FrontDeskOperationsApiPostCheckInRequest) (*CheckedinReservation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CheckedinReservation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FrontDeskOperationsApiService.PostCheckIn")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/checkIns"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.reservation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FrontDeskOperationsApiPostRoomKeyRequest struct {
	ctx context.Context
	ApiService *FrontDeskOperationsApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	roomKey *PostRoomKeyRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r FrontDeskOperationsApiPostRoomKeyRequest) Authorization(authorization string) FrontDeskOperationsApiPostRoomKeyRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r FrontDeskOperationsApiPostRoomKeyRequest) XAppKey(xAppKey string) FrontDeskOperationsApiPostRoomKeyRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r FrontDeskOperationsApiPostRoomKeyRequest) XHotelid(xHotelid string) FrontDeskOperationsApiPostRoomKeyRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request for generation of room key.
func (r FrontDeskOperationsApiPostRoomKeyRequest) RoomKey(roomKey PostRoomKeyRequest) FrontDeskOperationsApiPostRoomKeyRequest {
	r.roomKey = &roomKey
	return r
}

// External system code.
func (r FrontDeskOperationsApiPostRoomKeyRequest) XExternalsystem(xExternalsystem string) FrontDeskOperationsApiPostRoomKeyRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r FrontDeskOperationsApiPostRoomKeyRequest) AcceptLanguage(acceptLanguage string) FrontDeskOperationsApiPostRoomKeyRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r FrontDeskOperationsApiPostRoomKeyRequest) Execute() (*RoomKeyDetails, *http.Response, error) {
	return r.ApiService.PostRoomKeyExecute(r)
}

/*
PostRoomKey Requests room key(s)

You can use this API to create a room key request for a reservation to the active Door Locking System Property Interface. <p><strong>OperationId:</strong>postRoomKey</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId
 @param hotelId
 @return FrontDeskOperationsApiPostRoomKeyRequest
*/
func (a *FrontDeskOperationsApiService) PostRoomKey(ctx context.Context, reservationId string, hotelId string) FrontDeskOperationsApiPostRoomKeyRequest {
	return FrontDeskOperationsApiPostRoomKeyRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return RoomKeyDetails
func (a *FrontDeskOperationsApiService) PostRoomKeyExecute(r FrontDeskOperationsApiPostRoomKeyRequest) (*RoomKeyDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RoomKeyDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FrontDeskOperationsApiService.PostRoomKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/roomKeys"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.roomKey
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
