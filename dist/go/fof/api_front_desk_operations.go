/*
OPERA Cloud Front Desk Operations Service

APIs to cater for Front Desk Operations and Front Desk Statistic functionality in OPERA Cloud. <br /><br /> Front Desk features some of the most commonly used operations in OPERA Cloud, such as managing guest arrivals, managing in-house guests, and managing guest departures. Some additional tasks you can complete from the Front Desk menu are room searches, room assignments, and quick check outs as well as opening folios, creating registration cards, setting wake up calls, and sending messages to guests.<br /><br /> Compatible with OPERA Cloud release 23.2.<br /><br /><p> This document and all content within is available under the Universal Permissive License v 1.0 (https://oss.oracle.com/licenses/upl). Copyright (c) 2020, 2023 Oracle and/or its affiliates.</p>

API version: 23.2
Contact: hospitality-integrations_ww@oracle.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package fof

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// FrontDeskOperationsAPIService FrontDeskOperationsAPI service
type FrontDeskOperationsAPIService service

type FrontDeskOperationsAPIAddReservationToQueueRequest struct {
	ctx context.Context
	ApiService *FrontDeskOperationsAPIService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	queueReservation *QueueReservation
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r FrontDeskOperationsAPIAddReservationToQueueRequest) Authorization(authorization string) FrontDeskOperationsAPIAddReservationToQueueRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r FrontDeskOperationsAPIAddReservationToQueueRequest) XAppKey(xAppKey string) FrontDeskOperationsAPIAddReservationToQueueRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r FrontDeskOperationsAPIAddReservationToQueueRequest) XHotelid(xHotelid string) FrontDeskOperationsAPIAddReservationToQueueRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to add a reservation to the Queue for Check-In. A reservation can be added to the queue prior to Check-In on the day of arrival.
func (r FrontDeskOperationsAPIAddReservationToQueueRequest) QueueReservation(queueReservation QueueReservation) FrontDeskOperationsAPIAddReservationToQueueRequest {
	r.queueReservation = &queueReservation
	return r
}

// External system code.
func (r FrontDeskOperationsAPIAddReservationToQueueRequest) XExternalsystem(xExternalsystem string) FrontDeskOperationsAPIAddReservationToQueueRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r FrontDeskOperationsAPIAddReservationToQueueRequest) AcceptLanguage(acceptLanguage string) FrontDeskOperationsAPIAddReservationToQueueRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r FrontDeskOperationsAPIAddReservationToQueueRequest) Execute() (*ReservationQueuePriority, *http.Response, error) {
	return r.ApiService.AddReservationToQueueExecute(r)
}

/*
AddReservationToQueue Add reservation to queue

Using this API you can assign reservations to the reservation queue if the guest's room is not ready for assignment or if there are no available rooms of the room type attached to the reservation. Housekeeping staff can use the Queue Rooms functionality to determine if there are guests waiting to check in to a particular room or type of room; if there are, the queue list can provide guidance in determining which rooms need attention first. <p><strong>OperationId:</strong>addReservationToQueue</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId
 @param hotelId
 @return FrontDeskOperationsAPIAddReservationToQueueRequest
*/
func (a *FrontDeskOperationsAPIService) AddReservationToQueue(ctx context.Context, reservationId string, hotelId string) FrontDeskOperationsAPIAddReservationToQueueRequest {
	return FrontDeskOperationsAPIAddReservationToQueueRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ReservationQueuePriority
func (a *FrontDeskOperationsAPIService) AddReservationToQueueExecute(r FrontDeskOperationsAPIAddReservationToQueueRequest) (*ReservationQueuePriority, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReservationQueuePriority
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FrontDeskOperationsAPIService.AddReservationToQueue")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/queuedReservations/{reservationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.queueReservation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FrontDeskOperationsAPIAssignRoomsAIRequest struct {
	ctx context.Context
	ApiService *FrontDeskOperationsAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	roomsAI *RoomsAI
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r FrontDeskOperationsAPIAssignRoomsAIRequest) Authorization(authorization string) FrontDeskOperationsAPIAssignRoomsAIRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r FrontDeskOperationsAPIAssignRoomsAIRequest) XAppKey(xAppKey string) FrontDeskOperationsAPIAssignRoomsAIRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r FrontDeskOperationsAPIAssignRoomsAIRequest) XHotelid(xHotelid string) FrontDeskOperationsAPIAssignRoomsAIRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to run AI Room Assignment and allocate rooms to incoming reservations.
func (r FrontDeskOperationsAPIAssignRoomsAIRequest) RoomsAI(roomsAI RoomsAI) FrontDeskOperationsAPIAssignRoomsAIRequest {
	r.roomsAI = &roomsAI
	return r
}

// External system code.
func (r FrontDeskOperationsAPIAssignRoomsAIRequest) XExternalsystem(xExternalsystem string) FrontDeskOperationsAPIAssignRoomsAIRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r FrontDeskOperationsAPIAssignRoomsAIRequest) AcceptLanguage(acceptLanguage string) FrontDeskOperationsAPIAssignRoomsAIRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r FrontDeskOperationsAPIAssignRoomsAIRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.AssignRoomsAIExecute(r)
}

/*
AssignRoomsAI AI Assign Rooms

This API runs AI Room Assignment and allocates rooms to incoming reservations. <p><strong>OperationId:</strong>assignRoomsAI</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId
 @return FrontDeskOperationsAPIAssignRoomsAIRequest
*/
func (a *FrontDeskOperationsAPIService) AssignRoomsAI(ctx context.Context, hotelId string) FrontDeskOperationsAPIAssignRoomsAIRequest {
	return FrontDeskOperationsAPIAssignRoomsAIRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *FrontDeskOperationsAPIService) AssignRoomsAIExecute(r FrontDeskOperationsAPIAssignRoomsAIRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FrontDeskOperationsAPIService.AssignRoomsAI")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/ai/rooms"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.roomsAI
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FrontDeskOperationsAPIAutoAssignRoomRequest struct {
	ctx context.Context
	ApiService *FrontDeskOperationsAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	autoAssignRoom *AutoAssignRoom
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r FrontDeskOperationsAPIAutoAssignRoomRequest) Authorization(authorization string) FrontDeskOperationsAPIAutoAssignRoomRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r FrontDeskOperationsAPIAutoAssignRoomRequest) XAppKey(xAppKey string) FrontDeskOperationsAPIAutoAssignRoomRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r FrontDeskOperationsAPIAutoAssignRoomRequest) XHotelid(xHotelid string) FrontDeskOperationsAPIAutoAssignRoomRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request for auto assignment of rooms to reservations.
func (r FrontDeskOperationsAPIAutoAssignRoomRequest) AutoAssignRoom(autoAssignRoom AutoAssignRoom) FrontDeskOperationsAPIAutoAssignRoomRequest {
	r.autoAssignRoom = &autoAssignRoom
	return r
}

// External system code.
func (r FrontDeskOperationsAPIAutoAssignRoomRequest) XExternalsystem(xExternalsystem string) FrontDeskOperationsAPIAutoAssignRoomRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r FrontDeskOperationsAPIAutoAssignRoomRequest) AcceptLanguage(acceptLanguage string) FrontDeskOperationsAPIAutoAssignRoomRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r FrontDeskOperationsAPIAutoAssignRoomRequest) Execute() ([]AutoRoomAssignType, *http.Response, error) {
	return r.ApiService.AutoAssignRoomExecute(r)
}

/*
AutoAssignRoom Assign the room automatically

This API can be used to assign the room automatically. <p><strong>OperationId:</strong>autoAssignRoom</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId
 @return FrontDeskOperationsAPIAutoAssignRoomRequest
*/
func (a *FrontDeskOperationsAPIService) AutoAssignRoom(ctx context.Context, hotelId string) FrontDeskOperationsAPIAutoAssignRoomRequest {
	return FrontDeskOperationsAPIAutoAssignRoomRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return []AutoRoomAssignType
func (a *FrontDeskOperationsAPIService) AutoAssignRoomExecute(r FrontDeskOperationsAPIAutoAssignRoomRequest) ([]AutoRoomAssignType, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []AutoRoomAssignType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FrontDeskOperationsAPIService.AutoAssignRoom")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/autoRoomAssignments"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.autoAssignRoom
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FrontDeskOperationsAPIAutoUnAssignRoomRequest struct {
	ctx context.Context
	ApiService *FrontDeskOperationsAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	id *[]string
	idExtension *[]int32
	type_ *[]string
	includeDepartureRooms *bool
	limit *int32
	offset *int32
	roomNumberWildcard *string
	useAIRoomAssignment *bool
	useAssociatedProfilePreferences *bool
	hotelRoomStatus *[]string
	hotelFORoomStatus *[]string
	fromRoomNumber *string
	toRoomNumber *string
	startDate *string
	endDate *string
	duration *string
	roomType *[]string
	roomClass *string
	floor *string
	includeDueOut *bool
	departureTime *string
	code *[]string
	description *[]string
	orderSequence *[]float32
	quantity *[]int32
	smokingPreference *string
	includeAllRoomConditions *bool
	includeComponentRooms *bool
	includePseudoRooms *bool
	includeOORoomCheck *bool
	connectingRoomsOnly *bool
	reservationIdId *string
	reservationIdIdExtension *int32
	idContext *string
	reservationIdType *string
	pseudoRoomsOnly *bool
	includeAttendentInRoom *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r FrontDeskOperationsAPIAutoUnAssignRoomRequest) Authorization(authorization string) FrontDeskOperationsAPIAutoUnAssignRoomRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r FrontDeskOperationsAPIAutoUnAssignRoomRequest) XAppKey(xAppKey string) FrontDeskOperationsAPIAutoUnAssignRoomRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r FrontDeskOperationsAPIAutoUnAssignRoomRequest) XHotelid(xHotelid string) FrontDeskOperationsAPIAutoUnAssignRoomRequest {
	r.xHotelid = &xHotelid
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r FrontDeskOperationsAPIAutoUnAssignRoomRequest) Id(id []string) FrontDeskOperationsAPIAutoUnAssignRoomRequest {
	r.id = &id
	return r
}

// Additional identifying value assigned by the creating system.
func (r FrontDeskOperationsAPIAutoUnAssignRoomRequest) IdExtension(idExtension []int32) FrontDeskOperationsAPIAutoUnAssignRoomRequest {
	r.idExtension = &idExtension
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r FrontDeskOperationsAPIAutoUnAssignRoomRequest) Type_(type_ []string) FrontDeskOperationsAPIAutoUnAssignRoomRequest {
	r.type_ = &type_
	return r
}

// Indicates if departure rooms are to be included in the auto unassignment.
func (r FrontDeskOperationsAPIAutoUnAssignRoomRequest) IncludeDepartureRooms(includeDepartureRooms bool) FrontDeskOperationsAPIAutoUnAssignRoomRequest {
	r.includeDepartureRooms = &includeDepartureRooms
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r FrontDeskOperationsAPIAutoUnAssignRoomRequest) Limit(limit int32) FrontDeskOperationsAPIAutoUnAssignRoomRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r FrontDeskOperationsAPIAutoUnAssignRoomRequest) Offset(offset int32) FrontDeskOperationsAPIAutoUnAssignRoomRequest {
	r.offset = &offset
	return r
}

func (r FrontDeskOperationsAPIAutoUnAssignRoomRequest) RoomNumberWildcard(roomNumberWildcard string) FrontDeskOperationsAPIAutoUnAssignRoomRequest {
	r.roomNumberWildcard = &roomNumberWildcard
	return r
}

// If the AI ROOM ASSIGNMENT application parameter is set to Y, this flag when set to true will use the AI Room Assignment algorithm to fetch the results in order of suitability.
func (r FrontDeskOperationsAPIAutoUnAssignRoomRequest) UseAIRoomAssignment(useAIRoomAssignment bool) FrontDeskOperationsAPIAutoUnAssignRoomRequest {
	r.useAIRoomAssignment = &useAIRoomAssignment
	return r
}

// Indicates if preferences on the profile associated to the reservation should be used to determine the room type. The preferences for FLOOR, SMOKING and ROOM FEATURES will be used.
func (r FrontDeskOperationsAPIAutoUnAssignRoomRequest) UseAssociatedProfilePreferences(useAssociatedProfilePreferences bool) FrontDeskOperationsAPIAutoUnAssignRoomRequest {
	r.useAssociatedProfilePreferences = &useAssociatedProfilePreferences
	return r
}

// Simple type for room status instructions to be used in requests for fetching housekeeping rooms. Valid status values are Clean, Dirty, Pickup, Inspected, OutOfOrder, OutOfService.
func (r FrontDeskOperationsAPIAutoUnAssignRoomRequest) HotelRoomStatus(hotelRoomStatus []string) FrontDeskOperationsAPIAutoUnAssignRoomRequest {
	r.hotelRoomStatus = &hotelRoomStatus
	return r
}

// Simple type for front office room status instructions to be used in requests for fetching housekeeping rooms. Valid values are Vacant and Occupied.
func (r FrontDeskOperationsAPIAutoUnAssignRoomRequest) HotelFORoomStatus(hotelFORoomStatus []string) FrontDeskOperationsAPIAutoUnAssignRoomRequest {
	r.hotelFORoomStatus = &hotelFORoomStatus
	return r
}

func (r FrontDeskOperationsAPIAutoUnAssignRoomRequest) FromRoomNumber(fromRoomNumber string) FrontDeskOperationsAPIAutoUnAssignRoomRequest {
	r.fromRoomNumber = &fromRoomNumber
	return r
}

func (r FrontDeskOperationsAPIAutoUnAssignRoomRequest) ToRoomNumber(toRoomNumber string) FrontDeskOperationsAPIAutoUnAssignRoomRequest {
	r.toRoomNumber = &toRoomNumber
	return r
}

func (r FrontDeskOperationsAPIAutoUnAssignRoomRequest) StartDate(startDate string) FrontDeskOperationsAPIAutoUnAssignRoomRequest {
	r.startDate = &startDate
	return r
}

func (r FrontDeskOperationsAPIAutoUnAssignRoomRequest) EndDate(endDate string) FrontDeskOperationsAPIAutoUnAssignRoomRequest {
	r.endDate = &endDate
	return r
}

func (r FrontDeskOperationsAPIAutoUnAssignRoomRequest) Duration(duration string) FrontDeskOperationsAPIAutoUnAssignRoomRequest {
	r.duration = &duration
	return r
}

// The room types of hotel rooms to be fetched.
func (r FrontDeskOperationsAPIAutoUnAssignRoomRequest) RoomType(roomType []string) FrontDeskOperationsAPIAutoUnAssignRoomRequest {
	r.roomType = &roomType
	return r
}

// The room class of hotel rooms to be fetched.
func (r FrontDeskOperationsAPIAutoUnAssignRoomRequest) RoomClass(roomClass string) FrontDeskOperationsAPIAutoUnAssignRoomRequest {
	r.roomClass = &roomClass
	return r
}

// The floor of room to be fetched.
func (r FrontDeskOperationsAPIAutoUnAssignRoomRequest) Floor(floor string) FrontDeskOperationsAPIAutoUnAssignRoomRequest {
	r.floor = &floor
	return r
}

// This flag when set to true will include rooms assigned to due out reservations.
func (r FrontDeskOperationsAPIAutoUnAssignRoomRequest) IncludeDueOut(includeDueOut bool) FrontDeskOperationsAPIAutoUnAssignRoomRequest {
	r.includeDueOut = &includeDueOut
	return r
}

// When IncludeDueOut is enable,it is the departure time before which to search.
func (r FrontDeskOperationsAPIAutoUnAssignRoomRequest) DepartureTime(departureTime string) FrontDeskOperationsAPIAutoUnAssignRoomRequest {
	r.departureTime = &departureTime
	return r
}

// A code representing a room feature.
func (r FrontDeskOperationsAPIAutoUnAssignRoomRequest) Code(code []string) FrontDeskOperationsAPIAutoUnAssignRoomRequest {
	r.code = &code
	return r
}

// A code representing a room feature.
func (r FrontDeskOperationsAPIAutoUnAssignRoomRequest) Description(description []string) FrontDeskOperationsAPIAutoUnAssignRoomRequest {
	r.description = &description
	return r
}

// Display Order sequence.
func (r FrontDeskOperationsAPIAutoUnAssignRoomRequest) OrderSequence(orderSequence []float32) FrontDeskOperationsAPIAutoUnAssignRoomRequest {
	r.orderSequence = &orderSequence
	return r
}

// Indicates quantity.
func (r FrontDeskOperationsAPIAutoUnAssignRoomRequest) Quantity(quantity []int32) FrontDeskOperationsAPIAutoUnAssignRoomRequest {
	r.quantity = &quantity
	return r
}

// The smoking preference of room to be fetched.
func (r FrontDeskOperationsAPIAutoUnAssignRoomRequest) SmokingPreference(smokingPreference string) FrontDeskOperationsAPIAutoUnAssignRoomRequest {
	r.smokingPreference = &smokingPreference
	return r
}

// This flag when set to true will include all room conditions, when set to false then room with \&quot;General Assignment\&quot; condition type will be excluded from the result.
func (r FrontDeskOperationsAPIAutoUnAssignRoomRequest) IncludeAllRoomConditions(includeAllRoomConditions bool) FrontDeskOperationsAPIAutoUnAssignRoomRequest {
	r.includeAllRoomConditions = &includeAllRoomConditions
	return r
}

// This flag when set to true will include all component rooms
func (r FrontDeskOperationsAPIAutoUnAssignRoomRequest) IncludeComponentRooms(includeComponentRooms bool) FrontDeskOperationsAPIAutoUnAssignRoomRequest {
	r.includeComponentRooms = &includeComponentRooms
	return r
}

// This flag when set to true will include all pseudo rooms
func (r FrontDeskOperationsAPIAutoUnAssignRoomRequest) IncludePseudoRooms(includePseudoRooms bool) FrontDeskOperationsAPIAutoUnAssignRoomRequest {
	r.includePseudoRooms = &includePseudoRooms
	return r
}

// This flag when set to true will work for Available Rooms functionality
func (r FrontDeskOperationsAPIAutoUnAssignRoomRequest) IncludeOORoomCheck(includeOORoomCheck bool) FrontDeskOperationsAPIAutoUnAssignRoomRequest {
	r.includeOORoomCheck = &includeOORoomCheck
	return r
}

// This flag when set to true will include only connecting rooms.
func (r FrontDeskOperationsAPIAutoUnAssignRoomRequest) ConnectingRoomsOnly(connectingRoomsOnly bool) FrontDeskOperationsAPIAutoUnAssignRoomRequest {
	r.connectingRoomsOnly = &connectingRoomsOnly
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r FrontDeskOperationsAPIAutoUnAssignRoomRequest) ReservationIdId(reservationIdId string) FrontDeskOperationsAPIAutoUnAssignRoomRequest {
	r.reservationIdId = &reservationIdId
	return r
}

// Additional identifying value assigned by the creating system.
func (r FrontDeskOperationsAPIAutoUnAssignRoomRequest) ReservationIdIdExtension(reservationIdIdExtension int32) FrontDeskOperationsAPIAutoUnAssignRoomRequest {
	r.reservationIdIdExtension = &reservationIdIdExtension
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r FrontDeskOperationsAPIAutoUnAssignRoomRequest) IdContext(idContext string) FrontDeskOperationsAPIAutoUnAssignRoomRequest {
	r.idContext = &idContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r FrontDeskOperationsAPIAutoUnAssignRoomRequest) ReservationIdType(reservationIdType string) FrontDeskOperationsAPIAutoUnAssignRoomRequest {
	r.reservationIdType = &reservationIdType
	return r
}

// This flag when set to true will include only pseudo rooms
func (r FrontDeskOperationsAPIAutoUnAssignRoomRequest) PseudoRoomsOnly(pseudoRoomsOnly bool) FrontDeskOperationsAPIAutoUnAssignRoomRequest {
	r.pseudoRoomsOnly = &pseudoRoomsOnly
	return r
}

// This flag when set to true will includes attendent in Rooms
func (r FrontDeskOperationsAPIAutoUnAssignRoomRequest) IncludeAttendentInRoom(includeAttendentInRoom bool) FrontDeskOperationsAPIAutoUnAssignRoomRequest {
	r.includeAttendentInRoom = &includeAttendentInRoom
	return r
}

// External system code.
func (r FrontDeskOperationsAPIAutoUnAssignRoomRequest) XExternalsystem(xExternalsystem string) FrontDeskOperationsAPIAutoUnAssignRoomRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r FrontDeskOperationsAPIAutoUnAssignRoomRequest) AcceptLanguage(acceptLanguage string) FrontDeskOperationsAPIAutoUnAssignRoomRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r FrontDeskOperationsAPIAutoUnAssignRoomRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.AutoUnAssignRoomExecute(r)
}

/*
AutoUnAssignRoom Auto unassign room

This API can be used to auto unassign a room. <p><strong>OperationId:</strong>autoUnAssignRoom</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId
 @return FrontDeskOperationsAPIAutoUnAssignRoomRequest
*/
func (a *FrontDeskOperationsAPIService) AutoUnAssignRoom(ctx context.Context, hotelId string) FrontDeskOperationsAPIAutoUnAssignRoomRequest {
	return FrontDeskOperationsAPIAutoUnAssignRoomRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *FrontDeskOperationsAPIService) AutoUnAssignRoomExecute(r FrontDeskOperationsAPIAutoUnAssignRoomRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FrontDeskOperationsAPIService.AutoUnAssignRoom")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/autoRoomAssignments"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "multi")
		}
  }
	if r.idExtension != nil {
		t := *r.idExtension
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "idExtension", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "idExtension", t, "multi")
		}
  }
	if r.type_ != nil {
		t := *r.type_
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type", t, "multi")
		}
  }
	if r.includeDepartureRooms != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeDepartureRooms", r.includeDepartureRooms, "")
  }
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
  }
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
  }
	if r.roomNumberWildcard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomNumberWildcard", r.roomNumberWildcard, "")
  }
	if r.useAIRoomAssignment != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "useAIRoomAssignment", r.useAIRoomAssignment, "")
  }
	if r.useAssociatedProfilePreferences != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "useAssociatedProfilePreferences", r.useAssociatedProfilePreferences, "")
  }
	if r.hotelRoomStatus != nil {
		t := *r.hotelRoomStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelRoomStatus", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelRoomStatus", t, "multi")
		}
  }
	if r.hotelFORoomStatus != nil {
		t := *r.hotelFORoomStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelFORoomStatus", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelFORoomStatus", t, "multi")
		}
  }
	if r.fromRoomNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromRoomNumber", r.fromRoomNumber, "")
  }
	if r.toRoomNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "toRoomNumber", r.toRoomNumber, "")
  }
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
  }
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
  }
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration", r.duration, "")
  }
	if r.roomType != nil {
		t := *r.roomType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomType", t, "multi")
		}
  }
	if r.roomClass != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomClass", r.roomClass, "")
  }
	if r.floor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "floor", r.floor, "")
  }
	if r.includeDueOut != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeDueOut", r.includeDueOut, "")
  }
	if r.departureTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "departureTime", r.departureTime, "")
  }
	if r.code != nil {
		t := *r.code
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "code", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "code", t, "multi")
		}
  }
	if r.description != nil {
		t := *r.description
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description", t, "multi")
		}
  }
	if r.orderSequence != nil {
		t := *r.orderSequence
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "orderSequence", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "orderSequence", t, "multi")
		}
  }
	if r.quantity != nil {
		t := *r.quantity
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "quantity", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "quantity", t, "multi")
		}
  }
	if r.smokingPreference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "smokingPreference", r.smokingPreference, "")
  }
	if r.includeAllRoomConditions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeAllRoomConditions", r.includeAllRoomConditions, "")
  }
	if r.includeComponentRooms != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeComponentRooms", r.includeComponentRooms, "")
  }
	if r.includePseudoRooms != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includePseudoRooms", r.includePseudoRooms, "")
  }
	if r.includeOORoomCheck != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeOORoomCheck", r.includeOORoomCheck, "")
  }
	if r.connectingRoomsOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectingRoomsOnly", r.connectingRoomsOnly, "")
  }
	if r.reservationIdId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIdId", r.reservationIdId, "")
  }
	if r.reservationIdIdExtension != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIdIdExtension", r.reservationIdIdExtension, "")
  }
	if r.idContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", r.idContext, "")
  }
	if r.reservationIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIdType", r.reservationIdType, "")
  }
	if r.pseudoRoomsOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pseudoRoomsOnly", r.pseudoRoomsOnly, "")
  }
	if r.includeAttendentInRoom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeAttendentInRoom", r.includeAttendentInRoom, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FrontDeskOperationsAPIDeleteAdvanceCheckInRequest struct {
	ctx context.Context
	ApiService *FrontDeskOperationsAPIService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r FrontDeskOperationsAPIDeleteAdvanceCheckInRequest) Authorization(authorization string) FrontDeskOperationsAPIDeleteAdvanceCheckInRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r FrontDeskOperationsAPIDeleteAdvanceCheckInRequest) XAppKey(xAppKey string) FrontDeskOperationsAPIDeleteAdvanceCheckInRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r FrontDeskOperationsAPIDeleteAdvanceCheckInRequest) XHotelid(xHotelid string) FrontDeskOperationsAPIDeleteAdvanceCheckInRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r FrontDeskOperationsAPIDeleteAdvanceCheckInRequest) XExternalsystem(xExternalsystem string) FrontDeskOperationsAPIDeleteAdvanceCheckInRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r FrontDeskOperationsAPIDeleteAdvanceCheckInRequest) AcceptLanguage(acceptLanguage string) FrontDeskOperationsAPIDeleteAdvanceCheckInRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r FrontDeskOperationsAPIDeleteAdvanceCheckInRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteAdvanceCheckInExecute(r)
}

/*
DeleteAdvanceCheckIn Reverse Advance Checkin 

Reverse an advance check in for a reservation. <p><strong>OperationId:</strong>deleteAdvanceCheckIn</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId
 @param hotelId
 @return FrontDeskOperationsAPIDeleteAdvanceCheckInRequest
*/
func (a *FrontDeskOperationsAPIService) DeleteAdvanceCheckIn(ctx context.Context, reservationId string, hotelId string) FrontDeskOperationsAPIDeleteAdvanceCheckInRequest {
	return FrontDeskOperationsAPIDeleteAdvanceCheckInRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *FrontDeskOperationsAPIService) DeleteAdvanceCheckInExecute(r FrontDeskOperationsAPIDeleteAdvanceCheckInRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FrontDeskOperationsAPIService.DeleteAdvanceCheckIn")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/advanceCheckIns"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FrontDeskOperationsAPIDeleteAssignRoomRequest struct {
	ctx context.Context
	ApiService *FrontDeskOperationsAPIService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	unAssignRoomCriteria *UnAssignRoomCriteria
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r FrontDeskOperationsAPIDeleteAssignRoomRequest) Authorization(authorization string) FrontDeskOperationsAPIDeleteAssignRoomRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r FrontDeskOperationsAPIDeleteAssignRoomRequest) XAppKey(xAppKey string) FrontDeskOperationsAPIDeleteAssignRoomRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r FrontDeskOperationsAPIDeleteAssignRoomRequest) XHotelid(xHotelid string) FrontDeskOperationsAPIDeleteAssignRoomRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to the remove a room(unassign) from a reserved reservation.
func (r FrontDeskOperationsAPIDeleteAssignRoomRequest) UnAssignRoomCriteria(unAssignRoomCriteria UnAssignRoomCriteria) FrontDeskOperationsAPIDeleteAssignRoomRequest {
	r.unAssignRoomCriteria = &unAssignRoomCriteria
	return r
}

// External system code.
func (r FrontDeskOperationsAPIDeleteAssignRoomRequest) XExternalsystem(xExternalsystem string) FrontDeskOperationsAPIDeleteAssignRoomRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r FrontDeskOperationsAPIDeleteAssignRoomRequest) AcceptLanguage(acceptLanguage string) FrontDeskOperationsAPIDeleteAssignRoomRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r FrontDeskOperationsAPIDeleteAssignRoomRequest) Execute() (*UnAssignedRoom, *http.Response, error) {
	return r.ApiService.DeleteAssignRoomExecute(r)
}

/*
DeleteAssignRoom Remove an assigned room

This API will allow you to remove an assigned room from a reservation in reserved status. <p><strong>OperationId:</strong>deleteAssignRoom</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId
 @param hotelId
 @return FrontDeskOperationsAPIDeleteAssignRoomRequest
*/
func (a *FrontDeskOperationsAPIService) DeleteAssignRoom(ctx context.Context, reservationId string, hotelId string) FrontDeskOperationsAPIDeleteAssignRoomRequest {
	return FrontDeskOperationsAPIDeleteAssignRoomRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return UnAssignedRoom
func (a *FrontDeskOperationsAPIService) DeleteAssignRoomExecute(r FrontDeskOperationsAPIDeleteAssignRoomRequest) (*UnAssignedRoom, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UnAssignedRoom
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FrontDeskOperationsAPIService.DeleteAssignRoom")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/rooms"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.unAssignRoomCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FrontDeskOperationsAPIDeleteCheckinRequest struct {
	ctx context.Context
	ApiService *FrontDeskOperationsAPIService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	roomStatus *string
	unassignRoom *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r FrontDeskOperationsAPIDeleteCheckinRequest) Authorization(authorization string) FrontDeskOperationsAPIDeleteCheckinRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r FrontDeskOperationsAPIDeleteCheckinRequest) XAppKey(xAppKey string) FrontDeskOperationsAPIDeleteCheckinRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r FrontDeskOperationsAPIDeleteCheckinRequest) XHotelid(xHotelid string) FrontDeskOperationsAPIDeleteCheckinRequest {
	r.xHotelid = &xHotelid
	return r
}

// Simple type for room status instructions to be used in requests for fetching housekeeping rooms. Valid status values are Clean, Dirty, Pickup, Inspected, OutOfOrder, OutOfService.
func (r FrontDeskOperationsAPIDeleteCheckinRequest) RoomStatus(roomStatus string) FrontDeskOperationsAPIDeleteCheckinRequest {
	r.roomStatus = &roomStatus
	return r
}

// This option is used when all reservation check-in is reversed and the user wants to choose if the room is to be blocked. If all check-ins are not reversed, this is ignored and a default value false is used.
func (r FrontDeskOperationsAPIDeleteCheckinRequest) UnassignRoom(unassignRoom bool) FrontDeskOperationsAPIDeleteCheckinRequest {
	r.unassignRoom = &unassignRoom
	return r
}

// External system code.
func (r FrontDeskOperationsAPIDeleteCheckinRequest) XExternalsystem(xExternalsystem string) FrontDeskOperationsAPIDeleteCheckinRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r FrontDeskOperationsAPIDeleteCheckinRequest) AcceptLanguage(acceptLanguage string) FrontDeskOperationsAPIDeleteCheckinRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r FrontDeskOperationsAPIDeleteCheckinRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteCheckinExecute(r)
}

/*
DeleteCheckin Revert a checked-in Reservation

Use this API to revert a reservation that has been checked in.  This will return the reservation to a Due in/Arrival status. <p><strong>OperationId:</strong>deleteCheckin</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId
 @param hotelId
 @return FrontDeskOperationsAPIDeleteCheckinRequest
*/
func (a *FrontDeskOperationsAPIService) DeleteCheckin(ctx context.Context, reservationId string, hotelId string) FrontDeskOperationsAPIDeleteCheckinRequest {
	return FrontDeskOperationsAPIDeleteCheckinRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *FrontDeskOperationsAPIService) DeleteCheckinExecute(r FrontDeskOperationsAPIDeleteCheckinRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FrontDeskOperationsAPIService.DeleteCheckin")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/checkIns"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.roomStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomStatus", r.roomStatus, "")
  }
	if r.unassignRoom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unassignRoom", r.unassignRoom, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FrontDeskOperationsAPIDeleteDailyDocketRequest struct {
	ctx context.Context
	ApiService *FrontDeskOperationsAPIService
	docketId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r FrontDeskOperationsAPIDeleteDailyDocketRequest) Authorization(authorization string) FrontDeskOperationsAPIDeleteDailyDocketRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r FrontDeskOperationsAPIDeleteDailyDocketRequest) XAppKey(xAppKey string) FrontDeskOperationsAPIDeleteDailyDocketRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r FrontDeskOperationsAPIDeleteDailyDocketRequest) XHotelid(xHotelid string) FrontDeskOperationsAPIDeleteDailyDocketRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r FrontDeskOperationsAPIDeleteDailyDocketRequest) XExternalsystem(xExternalsystem string) FrontDeskOperationsAPIDeleteDailyDocketRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r FrontDeskOperationsAPIDeleteDailyDocketRequest) AcceptLanguage(acceptLanguage string) FrontDeskOperationsAPIDeleteDailyDocketRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r FrontDeskOperationsAPIDeleteDailyDocketRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteDailyDocketExecute(r)
}

/*
DeleteDailyDocket Delete Daily Docket 

Use this API to delete a Daily Docket. <p><strong>OperationId:</strong>deleteDailyDocket</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param docketId
 @param hotelId
 @return FrontDeskOperationsAPIDeleteDailyDocketRequest
*/
func (a *FrontDeskOperationsAPIService) DeleteDailyDocket(ctx context.Context, docketId string, hotelId string) FrontDeskOperationsAPIDeleteDailyDocketRequest {
	return FrontDeskOperationsAPIDeleteDailyDocketRequest{
		ApiService: a,
		ctx: ctx,
		docketId: docketId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *FrontDeskOperationsAPIService) DeleteDailyDocketExecute(r FrontDeskOperationsAPIDeleteDailyDocketRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FrontDeskOperationsAPIService.DeleteDailyDocket")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/dailyDocket/{docketId}"
	localVarPath = strings.Replace(localVarPath, "{"+"docketId"+"}", url.PathEscape(parameterValueToString(r.docketId, "docketId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.docketId) < 1 {
		return localVarReturnValue, nil, reportError("docketId must have at least 1 elements")
	}
	if strlen(r.docketId) > 2000 {
		return localVarReturnValue, nil, reportError("docketId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FrontDeskOperationsAPIDeleteReservationFromQueueRequest struct {
	ctx context.Context
	ApiService *FrontDeskOperationsAPIService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r FrontDeskOperationsAPIDeleteReservationFromQueueRequest) Authorization(authorization string) FrontDeskOperationsAPIDeleteReservationFromQueueRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r FrontDeskOperationsAPIDeleteReservationFromQueueRequest) XAppKey(xAppKey string) FrontDeskOperationsAPIDeleteReservationFromQueueRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r FrontDeskOperationsAPIDeleteReservationFromQueueRequest) XHotelid(xHotelid string) FrontDeskOperationsAPIDeleteReservationFromQueueRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r FrontDeskOperationsAPIDeleteReservationFromQueueRequest) XExternalsystem(xExternalsystem string) FrontDeskOperationsAPIDeleteReservationFromQueueRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r FrontDeskOperationsAPIDeleteReservationFromQueueRequest) AcceptLanguage(acceptLanguage string) FrontDeskOperationsAPIDeleteReservationFromQueueRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r FrontDeskOperationsAPIDeleteReservationFromQueueRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteReservationFromQueueExecute(r)
}

/*
DeleteReservationFromQueue Delete reservation from queue

Use this API to remove a reservation that is already set as a Queued Reservation. <p><strong>OperationId:</strong>deleteReservationFromQueue</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId
 @param hotelId
 @return FrontDeskOperationsAPIDeleteReservationFromQueueRequest
*/
func (a *FrontDeskOperationsAPIService) DeleteReservationFromQueue(ctx context.Context, reservationId string, hotelId string) FrontDeskOperationsAPIDeleteReservationFromQueueRequest {
	return FrontDeskOperationsAPIDeleteReservationFromQueueRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *FrontDeskOperationsAPIService) DeleteReservationFromQueueExecute(r FrontDeskOperationsAPIDeleteReservationFromQueueRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FrontDeskOperationsAPIService.DeleteReservationFromQueue")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/queuedReservations/{reservationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FrontDeskOperationsAPIDeleteRoomKeyRequest struct {
	ctx context.Context
	ApiService *FrontDeskOperationsAPIService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r FrontDeskOperationsAPIDeleteRoomKeyRequest) Authorization(authorization string) FrontDeskOperationsAPIDeleteRoomKeyRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r FrontDeskOperationsAPIDeleteRoomKeyRequest) XAppKey(xAppKey string) FrontDeskOperationsAPIDeleteRoomKeyRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r FrontDeskOperationsAPIDeleteRoomKeyRequest) XHotelid(xHotelid string) FrontDeskOperationsAPIDeleteRoomKeyRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r FrontDeskOperationsAPIDeleteRoomKeyRequest) XExternalsystem(xExternalsystem string) FrontDeskOperationsAPIDeleteRoomKeyRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r FrontDeskOperationsAPIDeleteRoomKeyRequest) AcceptLanguage(acceptLanguage string) FrontDeskOperationsAPIDeleteRoomKeyRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r FrontDeskOperationsAPIDeleteRoomKeyRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteRoomKeyExecute(r)
}

/*
DeleteRoomKey Delete room key

This API will delete room keys on a reservation. <p><strong>OperationId:</strong>deleteRoomKey</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId
 @param hotelId
 @return FrontDeskOperationsAPIDeleteRoomKeyRequest
*/
func (a *FrontDeskOperationsAPIService) DeleteRoomKey(ctx context.Context, reservationId string, hotelId string) FrontDeskOperationsAPIDeleteRoomKeyRequest {
	return FrontDeskOperationsAPIDeleteRoomKeyRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *FrontDeskOperationsAPIService) DeleteRoomKeyExecute(r FrontDeskOperationsAPIDeleteRoomKeyRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FrontDeskOperationsAPIService.DeleteRoomKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/roomKeys"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FrontDeskOperationsAPIDeleteServiceRequestsRequest struct {
	ctx context.Context
	ApiService *FrontDeskOperationsAPIService
	serviceRequestId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r FrontDeskOperationsAPIDeleteServiceRequestsRequest) Authorization(authorization string) FrontDeskOperationsAPIDeleteServiceRequestsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r FrontDeskOperationsAPIDeleteServiceRequestsRequest) XAppKey(xAppKey string) FrontDeskOperationsAPIDeleteServiceRequestsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r FrontDeskOperationsAPIDeleteServiceRequestsRequest) XHotelid(xHotelid string) FrontDeskOperationsAPIDeleteServiceRequestsRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r FrontDeskOperationsAPIDeleteServiceRequestsRequest) XExternalsystem(xExternalsystem string) FrontDeskOperationsAPIDeleteServiceRequestsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r FrontDeskOperationsAPIDeleteServiceRequestsRequest) AcceptLanguage(acceptLanguage string) FrontDeskOperationsAPIDeleteServiceRequestsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r FrontDeskOperationsAPIDeleteServiceRequestsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteServiceRequestsExecute(r)
}

/*
DeleteServiceRequests Delete Service Requests

Use this API to delete any service requests that exist on a reservation. <p><strong>OperationId:</strong>deleteServiceRequests</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serviceRequestId
 @param hotelId
 @return FrontDeskOperationsAPIDeleteServiceRequestsRequest
*/
func (a *FrontDeskOperationsAPIService) DeleteServiceRequests(ctx context.Context, serviceRequestId string, hotelId string) FrontDeskOperationsAPIDeleteServiceRequestsRequest {
	return FrontDeskOperationsAPIDeleteServiceRequestsRequest{
		ApiService: a,
		ctx: ctx,
		serviceRequestId: serviceRequestId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *FrontDeskOperationsAPIService) DeleteServiceRequestsExecute(r FrontDeskOperationsAPIDeleteServiceRequestsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FrontDeskOperationsAPIService.DeleteServiceRequests")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/serviceRequests/{serviceRequestId}"
	localVarPath = strings.Replace(localVarPath, "{"+"serviceRequestId"+"}", url.PathEscape(parameterValueToString(r.serviceRequestId, "serviceRequestId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.serviceRequestId) < 1 {
		return localVarReturnValue, nil, reportError("serviceRequestId must have at least 1 elements")
	}
	if strlen(r.serviceRequestId) > 2000 {
		return localVarReturnValue, nil, reportError("serviceRequestId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FrontDeskOperationsAPIDeleteWakeUpCallRequest struct {
	ctx context.Context
	ApiService *FrontDeskOperationsAPIService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	callTime *[]string
	followUpCallTime *[]string
	startDate *string
	newCallTime *[]string
	newFollowUpCallTime *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r FrontDeskOperationsAPIDeleteWakeUpCallRequest) Authorization(authorization string) FrontDeskOperationsAPIDeleteWakeUpCallRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r FrontDeskOperationsAPIDeleteWakeUpCallRequest) XAppKey(xAppKey string) FrontDeskOperationsAPIDeleteWakeUpCallRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r FrontDeskOperationsAPIDeleteWakeUpCallRequest) XHotelid(xHotelid string) FrontDeskOperationsAPIDeleteWakeUpCallRequest {
	r.xHotelid = &xHotelid
	return r
}

// Time on which wake up call is set.
func (r FrontDeskOperationsAPIDeleteWakeUpCallRequest) CallTime(callTime []string) FrontDeskOperationsAPIDeleteWakeUpCallRequest {
	r.callTime = &callTime
	return r
}

// Follow up call time.
func (r FrontDeskOperationsAPIDeleteWakeUpCallRequest) FollowUpCallTime(followUpCallTime []string) FrontDeskOperationsAPIDeleteWakeUpCallRequest {
	r.followUpCallTime = &followUpCallTime
	return r
}

func (r FrontDeskOperationsAPIDeleteWakeUpCallRequest) StartDate(startDate string) FrontDeskOperationsAPIDeleteWakeUpCallRequest {
	r.startDate = &startDate
	return r
}

// New Time on which wake up call is set. Used to change the Followup Call time
func (r FrontDeskOperationsAPIDeleteWakeUpCallRequest) NewCallTime(newCallTime []string) FrontDeskOperationsAPIDeleteWakeUpCallRequest {
	r.newCallTime = &newCallTime
	return r
}

// New Follow up call time.Used to change the Followup Call time.
func (r FrontDeskOperationsAPIDeleteWakeUpCallRequest) NewFollowUpCallTime(newFollowUpCallTime []string) FrontDeskOperationsAPIDeleteWakeUpCallRequest {
	r.newFollowUpCallTime = &newFollowUpCallTime
	return r
}

// External system code.
func (r FrontDeskOperationsAPIDeleteWakeUpCallRequest) XExternalsystem(xExternalsystem string) FrontDeskOperationsAPIDeleteWakeUpCallRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r FrontDeskOperationsAPIDeleteWakeUpCallRequest) AcceptLanguage(acceptLanguage string) FrontDeskOperationsAPIDeleteWakeUpCallRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r FrontDeskOperationsAPIDeleteWakeUpCallRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteWakeUpCallExecute(r)
}

/*
DeleteWakeUpCall Delete Wake Up Call

Use this API to cancel a wake up call on a reservation. <p><strong>OperationId:</strong>deleteWakeUpCall</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId
 @param hotelId
 @return FrontDeskOperationsAPIDeleteWakeUpCallRequest
*/
func (a *FrontDeskOperationsAPIService) DeleteWakeUpCall(ctx context.Context, reservationId string, hotelId string) FrontDeskOperationsAPIDeleteWakeUpCallRequest {
	return FrontDeskOperationsAPIDeleteWakeUpCallRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *FrontDeskOperationsAPIService) DeleteWakeUpCallExecute(r FrontDeskOperationsAPIDeleteWakeUpCallRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FrontDeskOperationsAPIService.DeleteWakeUpCall")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/wakeUpCalls"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.callTime != nil {
		t := *r.callTime
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "callTime", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "callTime", t, "multi")
		}
  }
	if r.followUpCallTime != nil {
		t := *r.followUpCallTime
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "followUpCallTime", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "followUpCallTime", t, "multi")
		}
  }
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
  }
	if r.newCallTime != nil {
		t := *r.newCallTime
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "newCallTime", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "newCallTime", t, "multi")
		}
  }
	if r.newFollowUpCallTime != nil {
		t := *r.newFollowUpCallTime
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "newFollowUpCallTime", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "newFollowUpCallTime", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FrontDeskOperationsAPIDeliverQueueRoomsTextMessageRequest struct {
	ctx context.Context
	ApiService *FrontDeskOperationsAPIService
	messageType string
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	deliverQueueRoomsTextMessage *DeliverQueueRoomsTextMessage
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r FrontDeskOperationsAPIDeliverQueueRoomsTextMessageRequest) Authorization(authorization string) FrontDeskOperationsAPIDeliverQueueRoomsTextMessageRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r FrontDeskOperationsAPIDeliverQueueRoomsTextMessageRequest) XAppKey(xAppKey string) FrontDeskOperationsAPIDeliverQueueRoomsTextMessageRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r FrontDeskOperationsAPIDeliverQueueRoomsTextMessageRequest) XHotelid(xHotelid string) FrontDeskOperationsAPIDeliverQueueRoomsTextMessageRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to deliver a text message via Queue Reservations (for a guest) or Queue Rush (for housekeeping).
func (r FrontDeskOperationsAPIDeliverQueueRoomsTextMessageRequest) DeliverQueueRoomsTextMessage(deliverQueueRoomsTextMessage DeliverQueueRoomsTextMessage) FrontDeskOperationsAPIDeliverQueueRoomsTextMessageRequest {
	r.deliverQueueRoomsTextMessage = &deliverQueueRoomsTextMessage
	return r
}

// External system code.
func (r FrontDeskOperationsAPIDeliverQueueRoomsTextMessageRequest) XExternalsystem(xExternalsystem string) FrontDeskOperationsAPIDeliverQueueRoomsTextMessageRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r FrontDeskOperationsAPIDeliverQueueRoomsTextMessageRequest) AcceptLanguage(acceptLanguage string) FrontDeskOperationsAPIDeliverQueueRoomsTextMessageRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r FrontDeskOperationsAPIDeliverQueueRoomsTextMessageRequest) Execute() (*QueueRoomsTextMessage, *http.Response, error) {
	return r.ApiService.DeliverQueueRoomsTextMessageExecute(r)
}

/*
DeliverQueueRoomsTextMessage Deliver Queue rooms text message

This API will deliver Queue rooms text message. <p><strong>OperationId:</strong>deliverQueueRoomsTextMessage</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param messageType
 @param reservationId
 @param hotelId
 @return FrontDeskOperationsAPIDeliverQueueRoomsTextMessageRequest
*/
func (a *FrontDeskOperationsAPIService) DeliverQueueRoomsTextMessage(ctx context.Context, messageType string, reservationId string, hotelId string) FrontDeskOperationsAPIDeliverQueueRoomsTextMessageRequest {
	return FrontDeskOperationsAPIDeliverQueueRoomsTextMessageRequest{
		ApiService: a,
		ctx: ctx,
		messageType: messageType,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return QueueRoomsTextMessage
func (a *FrontDeskOperationsAPIService) DeliverQueueRoomsTextMessageExecute(r FrontDeskOperationsAPIDeliverQueueRoomsTextMessageRequest) (*QueueRoomsTextMessage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QueueRoomsTextMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FrontDeskOperationsAPIService.DeliverQueueRoomsTextMessage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/textMessages/{messageType}"
	localVarPath = strings.Replace(localVarPath, "{"+"messageType"+"}", url.PathEscape(parameterValueToString(r.messageType, "messageType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.messageType) < 1 {
		return localVarReturnValue, nil, reportError("messageType must have at least 1 elements")
	}
	if strlen(r.messageType) > 2000 {
		return localVarReturnValue, nil, reportError("messageType must have less than 2000 elements")
	}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.deliverQueueRoomsTextMessage
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FrontDeskOperationsAPIFetchAiraLastRunStatusRequest struct {
	ctx context.Context
	ApiService *FrontDeskOperationsAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r FrontDeskOperationsAPIFetchAiraLastRunStatusRequest) Authorization(authorization string) FrontDeskOperationsAPIFetchAiraLastRunStatusRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r FrontDeskOperationsAPIFetchAiraLastRunStatusRequest) XAppKey(xAppKey string) FrontDeskOperationsAPIFetchAiraLastRunStatusRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r FrontDeskOperationsAPIFetchAiraLastRunStatusRequest) XHotelid(xHotelid string) FrontDeskOperationsAPIFetchAiraLastRunStatusRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r FrontDeskOperationsAPIFetchAiraLastRunStatusRequest) XExternalsystem(xExternalsystem string) FrontDeskOperationsAPIFetchAiraLastRunStatusRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r FrontDeskOperationsAPIFetchAiraLastRunStatusRequest) AcceptLanguage(acceptLanguage string) FrontDeskOperationsAPIFetchAiraLastRunStatusRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r FrontDeskOperationsAPIFetchAiraLastRunStatusRequest) Execute() (*AiraLastRunStatusInfo, *http.Response, error) {
	return r.ApiService.FetchAiraLastRunStatusExecute(r)
}

/*
FetchAiraLastRunStatus Automated Intelligence Room Assignment last run status

This API fetches the last run status of an Automated Intelligence Room Assignment. <p><strong>OperationId:</strong>fetchAiraLastRunStatus</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId
 @return FrontDeskOperationsAPIFetchAiraLastRunStatusRequest
*/
func (a *FrontDeskOperationsAPIService) FetchAiraLastRunStatus(ctx context.Context, hotelId string) FrontDeskOperationsAPIFetchAiraLastRunStatusRequest {
	return FrontDeskOperationsAPIFetchAiraLastRunStatusRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return AiraLastRunStatusInfo
func (a *FrontDeskOperationsAPIService) FetchAiraLastRunStatusExecute(r FrontDeskOperationsAPIFetchAiraLastRunStatusRequest) (*AiraLastRunStatusInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AiraLastRunStatusInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FrontDeskOperationsAPIService.FetchAiraLastRunStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/ai/rooms"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FrontDeskOperationsAPIGetDailyDocketRequest struct {
	ctx context.Context
	ApiService *FrontDeskOperationsAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	docketDate *string
	department *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r FrontDeskOperationsAPIGetDailyDocketRequest) Authorization(authorization string) FrontDeskOperationsAPIGetDailyDocketRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r FrontDeskOperationsAPIGetDailyDocketRequest) XAppKey(xAppKey string) FrontDeskOperationsAPIGetDailyDocketRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r FrontDeskOperationsAPIGetDailyDocketRequest) XHotelid(xHotelid string) FrontDeskOperationsAPIGetDailyDocketRequest {
	r.xHotelid = &xHotelid
	return r
}

// log book date.
func (r FrontDeskOperationsAPIGetDailyDocketRequest) DocketDate(docketDate string) FrontDeskOperationsAPIGetDailyDocketRequest {
	r.docketDate = &docketDate
	return r
}

// Department code the log book entries belong to.
func (r FrontDeskOperationsAPIGetDailyDocketRequest) Department(department string) FrontDeskOperationsAPIGetDailyDocketRequest {
	r.department = &department
	return r
}

// External system code.
func (r FrontDeskOperationsAPIGetDailyDocketRequest) XExternalsystem(xExternalsystem string) FrontDeskOperationsAPIGetDailyDocketRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r FrontDeskOperationsAPIGetDailyDocketRequest) AcceptLanguage(acceptLanguage string) FrontDeskOperationsAPIGetDailyDocketRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r FrontDeskOperationsAPIGetDailyDocketRequest) Execute() (*DailyDocket, *http.Response, error) {
	return r.ApiService.GetDailyDocketExecute(r)
}

/*
GetDailyDocket Get Daily Docket

Use this API to fetch Daily Dockets. <p><strong>OperationId:</strong>getDailyDocket</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId
 @return FrontDeskOperationsAPIGetDailyDocketRequest
*/
func (a *FrontDeskOperationsAPIService) GetDailyDocket(ctx context.Context, hotelId string) FrontDeskOperationsAPIGetDailyDocketRequest {
	return FrontDeskOperationsAPIGetDailyDocketRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return DailyDocket
func (a *FrontDeskOperationsAPIService) GetDailyDocketExecute(r FrontDeskOperationsAPIGetDailyDocketRequest) (*DailyDocket, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DailyDocket
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FrontDeskOperationsAPIService.GetDailyDocket")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/dailyDocket"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.docketDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "docketDate", r.docketDate, "")
  }
	if r.department != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "department", r.department, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FrontDeskOperationsAPIGetFloorPlansRequest struct {
	ctx context.Context
	ApiService *FrontDeskOperationsAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	room *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r FrontDeskOperationsAPIGetFloorPlansRequest) Authorization(authorization string) FrontDeskOperationsAPIGetFloorPlansRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r FrontDeskOperationsAPIGetFloorPlansRequest) XAppKey(xAppKey string) FrontDeskOperationsAPIGetFloorPlansRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r FrontDeskOperationsAPIGetFloorPlansRequest) XHotelid(xHotelid string) FrontDeskOperationsAPIGetFloorPlansRequest {
	r.xHotelid = &xHotelid
	return r
}

// Room filter.
func (r FrontDeskOperationsAPIGetFloorPlansRequest) Room(room string) FrontDeskOperationsAPIGetFloorPlansRequest {
	r.room = &room
	return r
}

// External system code.
func (r FrontDeskOperationsAPIGetFloorPlansRequest) XExternalsystem(xExternalsystem string) FrontDeskOperationsAPIGetFloorPlansRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r FrontDeskOperationsAPIGetFloorPlansRequest) AcceptLanguage(acceptLanguage string) FrontDeskOperationsAPIGetFloorPlansRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r FrontDeskOperationsAPIGetFloorPlansRequest) Execute() (*FloorPlans, *http.Response, error) {
	return r.ApiService.GetFloorPlansExecute(r)
}

/*
GetFloorPlans Get floor plans

Use this API to get Floor Plans for a property. Floor Plans provide a graphical layout of floors, rooms, and other physical features such as stairways, HVAC closets, elevators, and more <p><strong>OperationId:</strong>getFloorPlans</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId
 @return FrontDeskOperationsAPIGetFloorPlansRequest
*/
func (a *FrontDeskOperationsAPIService) GetFloorPlans(ctx context.Context, hotelId string) FrontDeskOperationsAPIGetFloorPlansRequest {
	return FrontDeskOperationsAPIGetFloorPlansRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return FloorPlans
func (a *FrontDeskOperationsAPIService) GetFloorPlansExecute(r FrontDeskOperationsAPIGetFloorPlansRequest) (*FloorPlans, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FloorPlans
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FrontDeskOperationsAPIService.GetFloorPlans")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/floorPlans"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.room != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "room", r.room, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FrontDeskOperationsAPIGetFulfillmentActivityLogRequest struct {
	ctx context.Context
	ApiService *FrontDeskOperationsAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	module *string
	parameterName *[]string
	parameterValue *[]string
	activityGroup *string
	activityType *string
	fromDate *string
	toDate *string
	searchText *string
	userByIds *[]int32
	userForIds *[]int32
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r FrontDeskOperationsAPIGetFulfillmentActivityLogRequest) Authorization(authorization string) FrontDeskOperationsAPIGetFulfillmentActivityLogRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r FrontDeskOperationsAPIGetFulfillmentActivityLogRequest) XAppKey(xAppKey string) FrontDeskOperationsAPIGetFulfillmentActivityLogRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r FrontDeskOperationsAPIGetFulfillmentActivityLogRequest) XHotelid(xHotelid string) FrontDeskOperationsAPIGetFulfillmentActivityLogRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r FrontDeskOperationsAPIGetFulfillmentActivityLogRequest) Limit(limit int32) FrontDeskOperationsAPIGetFulfillmentActivityLogRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r FrontDeskOperationsAPIGetFulfillmentActivityLogRequest) Offset(offset int32) FrontDeskOperationsAPIGetFulfillmentActivityLogRequest {
	r.offset = &offset
	return r
}

// Activity module.
func (r FrontDeskOperationsAPIGetFulfillmentActivityLogRequest) Module(module string) FrontDeskOperationsAPIGetFulfillmentActivityLogRequest {
	r.module = &module
	return r
}

// Name of the parameter.
func (r FrontDeskOperationsAPIGetFulfillmentActivityLogRequest) ParameterName(parameterName []string) FrontDeskOperationsAPIGetFulfillmentActivityLogRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r FrontDeskOperationsAPIGetFulfillmentActivityLogRequest) ParameterValue(parameterValue []string) FrontDeskOperationsAPIGetFulfillmentActivityLogRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r FrontDeskOperationsAPIGetFulfillmentActivityLogRequest) ActivityGroup(activityGroup string) FrontDeskOperationsAPIGetFulfillmentActivityLogRequest {
	r.activityGroup = &activityGroup
	return r
}

func (r FrontDeskOperationsAPIGetFulfillmentActivityLogRequest) ActivityType(activityType string) FrontDeskOperationsAPIGetFulfillmentActivityLogRequest {
	r.activityType = &activityType
	return r
}

// Search from date for the user activity log.
func (r FrontDeskOperationsAPIGetFulfillmentActivityLogRequest) FromDate(fromDate string) FrontDeskOperationsAPIGetFulfillmentActivityLogRequest {
	r.fromDate = &fromDate
	return r
}

// Search to date for the user activity log.
func (r FrontDeskOperationsAPIGetFulfillmentActivityLogRequest) ToDate(toDate string) FrontDeskOperationsAPIGetFulfillmentActivityLogRequest {
	r.toDate = &toDate
	return r
}

// Search text for the user activity log.
func (r FrontDeskOperationsAPIGetFulfillmentActivityLogRequest) SearchText(searchText string) FrontDeskOperationsAPIGetFulfillmentActivityLogRequest {
	r.searchText = &searchText
	return r
}

func (r FrontDeskOperationsAPIGetFulfillmentActivityLogRequest) UserByIds(userByIds []int32) FrontDeskOperationsAPIGetFulfillmentActivityLogRequest {
	r.userByIds = &userByIds
	return r
}

func (r FrontDeskOperationsAPIGetFulfillmentActivityLogRequest) UserForIds(userForIds []int32) FrontDeskOperationsAPIGetFulfillmentActivityLogRequest {
	r.userForIds = &userForIds
	return r
}

// External system code.
func (r FrontDeskOperationsAPIGetFulfillmentActivityLogRequest) XExternalsystem(xExternalsystem string) FrontDeskOperationsAPIGetFulfillmentActivityLogRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r FrontDeskOperationsAPIGetFulfillmentActivityLogRequest) AcceptLanguage(acceptLanguage string) FrontDeskOperationsAPIGetFulfillmentActivityLogRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r FrontDeskOperationsAPIGetFulfillmentActivityLogRequest) Execute() (*ActivityLog, *http.Response, error) {
	return r.ApiService.GetFulfillmentActivityLogExecute(r)
}

/*
GetFulfillmentActivityLog Get the fullfillment activity log

You can use this API to get the fullfillment activity log. <p><strong>OperationId:</strong>getFulfillmentActivityLog</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId
 @return FrontDeskOperationsAPIGetFulfillmentActivityLogRequest
*/
func (a *FrontDeskOperationsAPIService) GetFulfillmentActivityLog(ctx context.Context, hotelId string) FrontDeskOperationsAPIGetFulfillmentActivityLogRequest {
	return FrontDeskOperationsAPIGetFulfillmentActivityLogRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ActivityLog
func (a *FrontDeskOperationsAPIService) GetFulfillmentActivityLogExecute(r FrontDeskOperationsAPIGetFulfillmentActivityLogRequest) (*ActivityLog, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActivityLog
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FrontDeskOperationsAPIService.GetFulfillmentActivityLog")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/fulfillmentActivityLogs"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
  }
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
  }
	if r.module != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "module", r.module, "")
  }
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
  }
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
  }
	if r.activityGroup != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "activityGroup", r.activityGroup, "")
  }
	if r.activityType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "activityType", r.activityType, "")
  }
	if r.fromDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromDate", r.fromDate, "")
  }
	if r.toDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "toDate", r.toDate, "")
  }
	if r.searchText != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "searchText", r.searchText, "")
  }
	if r.userByIds != nil {
		t := *r.userByIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "userByIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "userByIds", t, "multi")
		}
  }
	if r.userForIds != nil {
		t := *r.userForIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "userForIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "userForIds", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FrontDeskOperationsAPIGetHotelRoomsRequest struct {
	ctx context.Context
	ApiService *FrontDeskOperationsAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	roomNumberWildcard *string
	hotelRoomStatus *[]string
	hotelFORoomStatus *[]string
	fromRoomNumber *string
	toRoomNumber *string
	hotelRoomStartDate *string
	hotelRoomEndDate *string
	duration *string
	roomType *[]string
	roomClass *string
	floor *string
	includeDueOut *bool
	departureTime *string
	roomFeatureCode *[]string
	description *[]string
	orderSequence *[]float32
	quantity *[]int32
	smokingPreference *string
	includeAllRoomConditions *bool
	includeComponentRooms *bool
	includePseudoRooms *bool
	includeOORoomCheck *bool
	connectingRoomsOnly *bool
	reservationId *string
	reservationIdContext *string
	reservationIdType *string
	pseudoRoomsOnly *bool
	includeAttendentInRoom *bool
	includeRotationRoom *bool
	ownerRoomsOnly *bool
	ownerExclusiveRoomsOnly *bool
	perfectFitRoomsOnly *bool
	orderBy *string
	unitGradeCodes *[]string
	ownerExclusiveRoomProfileId *string
	excludeRoomFeatures *[]string
	excludeFloorPreferences *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r FrontDeskOperationsAPIGetHotelRoomsRequest) Authorization(authorization string) FrontDeskOperationsAPIGetHotelRoomsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r FrontDeskOperationsAPIGetHotelRoomsRequest) XAppKey(xAppKey string) FrontDeskOperationsAPIGetHotelRoomsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r FrontDeskOperationsAPIGetHotelRoomsRequest) XHotelid(xHotelid string) FrontDeskOperationsAPIGetHotelRoomsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r FrontDeskOperationsAPIGetHotelRoomsRequest) Limit(limit int32) FrontDeskOperationsAPIGetHotelRoomsRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r FrontDeskOperationsAPIGetHotelRoomsRequest) Offset(offset int32) FrontDeskOperationsAPIGetHotelRoomsRequest {
	r.offset = &offset
	return r
}

func (r FrontDeskOperationsAPIGetHotelRoomsRequest) RoomNumberWildcard(roomNumberWildcard string) FrontDeskOperationsAPIGetHotelRoomsRequest {
	r.roomNumberWildcard = &roomNumberWildcard
	return r
}

// Simple type for room status instructions to be used in requests for fetching housekeeping rooms. Valid status values are Clean, Dirty, Pickup, Inspected, OutOfOrder, OutOfService.
func (r FrontDeskOperationsAPIGetHotelRoomsRequest) HotelRoomStatus(hotelRoomStatus []string) FrontDeskOperationsAPIGetHotelRoomsRequest {
	r.hotelRoomStatus = &hotelRoomStatus
	return r
}

// Simple type for front office room status instructions to be used in requests for fetching housekeeping rooms. Valid values are Vacant and Occupied.
func (r FrontDeskOperationsAPIGetHotelRoomsRequest) HotelFORoomStatus(hotelFORoomStatus []string) FrontDeskOperationsAPIGetHotelRoomsRequest {
	r.hotelFORoomStatus = &hotelFORoomStatus
	return r
}

func (r FrontDeskOperationsAPIGetHotelRoomsRequest) FromRoomNumber(fromRoomNumber string) FrontDeskOperationsAPIGetHotelRoomsRequest {
	r.fromRoomNumber = &fromRoomNumber
	return r
}

func (r FrontDeskOperationsAPIGetHotelRoomsRequest) ToRoomNumber(toRoomNumber string) FrontDeskOperationsAPIGetHotelRoomsRequest {
	r.toRoomNumber = &toRoomNumber
	return r
}

func (r FrontDeskOperationsAPIGetHotelRoomsRequest) HotelRoomStartDate(hotelRoomStartDate string) FrontDeskOperationsAPIGetHotelRoomsRequest {
	r.hotelRoomStartDate = &hotelRoomStartDate
	return r
}

func (r FrontDeskOperationsAPIGetHotelRoomsRequest) HotelRoomEndDate(hotelRoomEndDate string) FrontDeskOperationsAPIGetHotelRoomsRequest {
	r.hotelRoomEndDate = &hotelRoomEndDate
	return r
}

func (r FrontDeskOperationsAPIGetHotelRoomsRequest) Duration(duration string) FrontDeskOperationsAPIGetHotelRoomsRequest {
	r.duration = &duration
	return r
}

// The room types of hotel rooms to be fetched.
func (r FrontDeskOperationsAPIGetHotelRoomsRequest) RoomType(roomType []string) FrontDeskOperationsAPIGetHotelRoomsRequest {
	r.roomType = &roomType
	return r
}

// The room class of hotel rooms to be fetched.
func (r FrontDeskOperationsAPIGetHotelRoomsRequest) RoomClass(roomClass string) FrontDeskOperationsAPIGetHotelRoomsRequest {
	r.roomClass = &roomClass
	return r
}

// The floor of room to be fetched.
func (r FrontDeskOperationsAPIGetHotelRoomsRequest) Floor(floor string) FrontDeskOperationsAPIGetHotelRoomsRequest {
	r.floor = &floor
	return r
}

// This flag when set to true will include rooms assigned to due out reservations.
func (r FrontDeskOperationsAPIGetHotelRoomsRequest) IncludeDueOut(includeDueOut bool) FrontDeskOperationsAPIGetHotelRoomsRequest {
	r.includeDueOut = &includeDueOut
	return r
}

// When IncludeDueOut is enable,it is the departure time before which to search.
func (r FrontDeskOperationsAPIGetHotelRoomsRequest) DepartureTime(departureTime string) FrontDeskOperationsAPIGetHotelRoomsRequest {
	r.departureTime = &departureTime
	return r
}

// A code representing a room feature.
func (r FrontDeskOperationsAPIGetHotelRoomsRequest) RoomFeatureCode(roomFeatureCode []string) FrontDeskOperationsAPIGetHotelRoomsRequest {
	r.roomFeatureCode = &roomFeatureCode
	return r
}

// A code representing a room feature.
func (r FrontDeskOperationsAPIGetHotelRoomsRequest) Description(description []string) FrontDeskOperationsAPIGetHotelRoomsRequest {
	r.description = &description
	return r
}

// Display Order sequence.
func (r FrontDeskOperationsAPIGetHotelRoomsRequest) OrderSequence(orderSequence []float32) FrontDeskOperationsAPIGetHotelRoomsRequest {
	r.orderSequence = &orderSequence
	return r
}

// Indicates quantity.
func (r FrontDeskOperationsAPIGetHotelRoomsRequest) Quantity(quantity []int32) FrontDeskOperationsAPIGetHotelRoomsRequest {
	r.quantity = &quantity
	return r
}

// The smoking preference of room to be fetched.
func (r FrontDeskOperationsAPIGetHotelRoomsRequest) SmokingPreference(smokingPreference string) FrontDeskOperationsAPIGetHotelRoomsRequest {
	r.smokingPreference = &smokingPreference
	return r
}

// This flag when set to true will include all room conditions, when set to false then room with \&quot;General Assignment\&quot; condition type will be excluded from the result.
func (r FrontDeskOperationsAPIGetHotelRoomsRequest) IncludeAllRoomConditions(includeAllRoomConditions bool) FrontDeskOperationsAPIGetHotelRoomsRequest {
	r.includeAllRoomConditions = &includeAllRoomConditions
	return r
}

// This flag when set to true will include all component rooms
func (r FrontDeskOperationsAPIGetHotelRoomsRequest) IncludeComponentRooms(includeComponentRooms bool) FrontDeskOperationsAPIGetHotelRoomsRequest {
	r.includeComponentRooms = &includeComponentRooms
	return r
}

// This flag when set to true will include all pseudo rooms
func (r FrontDeskOperationsAPIGetHotelRoomsRequest) IncludePseudoRooms(includePseudoRooms bool) FrontDeskOperationsAPIGetHotelRoomsRequest {
	r.includePseudoRooms = &includePseudoRooms
	return r
}

// This flag when set to true will work for Available Rooms functionality
func (r FrontDeskOperationsAPIGetHotelRoomsRequest) IncludeOORoomCheck(includeOORoomCheck bool) FrontDeskOperationsAPIGetHotelRoomsRequest {
	r.includeOORoomCheck = &includeOORoomCheck
	return r
}

// This flag when set to true will include only connecting rooms.
func (r FrontDeskOperationsAPIGetHotelRoomsRequest) ConnectingRoomsOnly(connectingRoomsOnly bool) FrontDeskOperationsAPIGetHotelRoomsRequest {
	r.connectingRoomsOnly = &connectingRoomsOnly
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r FrontDeskOperationsAPIGetHotelRoomsRequest) ReservationId(reservationId string) FrontDeskOperationsAPIGetHotelRoomsRequest {
	r.reservationId = &reservationId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r FrontDeskOperationsAPIGetHotelRoomsRequest) ReservationIdContext(reservationIdContext string) FrontDeskOperationsAPIGetHotelRoomsRequest {
	r.reservationIdContext = &reservationIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r FrontDeskOperationsAPIGetHotelRoomsRequest) ReservationIdType(reservationIdType string) FrontDeskOperationsAPIGetHotelRoomsRequest {
	r.reservationIdType = &reservationIdType
	return r
}

// This flag when set to true will include only pseudo rooms
func (r FrontDeskOperationsAPIGetHotelRoomsRequest) PseudoRoomsOnly(pseudoRoomsOnly bool) FrontDeskOperationsAPIGetHotelRoomsRequest {
	r.pseudoRoomsOnly = &pseudoRoomsOnly
	return r
}

// This flag when set to true will includes attendent in Rooms
func (r FrontDeskOperationsAPIGetHotelRoomsRequest) IncludeAttendentInRoom(includeAttendentInRoom bool) FrontDeskOperationsAPIGetHotelRoomsRequest {
	r.includeAttendentInRoom = &includeAttendentInRoom
	return r
}

// This flag when set to true will return the rotation room when room roation parameter is active and the room type is configured for rotation.
func (r FrontDeskOperationsAPIGetHotelRoomsRequest) IncludeRotationRoom(includeRotationRoom bool) FrontDeskOperationsAPIGetHotelRoomsRequest {
	r.includeRotationRoom = &includeRotationRoom
	return r
}

// When this flag is set to true, this API will fetch rooms which are contracted with owner profiles. This is supported when OPERA Control Room Rotation is active.
func (r FrontDeskOperationsAPIGetHotelRoomsRequest) OwnerRoomsOnly(ownerRoomsOnly bool) FrontDeskOperationsAPIGetHotelRoomsRequest {
	r.ownerRoomsOnly = &ownerRoomsOnly
	return r
}

// When this flag is set to true, this API will fetch rooms can only be used by the reservation&#39;s profile (owner) of the room. This is supported when OPERA Control Room Rotation is active.
func (r FrontDeskOperationsAPIGetHotelRoomsRequest) OwnerExclusiveRoomsOnly(ownerExclusiveRoomsOnly bool) FrontDeskOperationsAPIGetHotelRoomsRequest {
	r.ownerExclusiveRoomsOnly = &ownerExclusiveRoomsOnly
	return r
}

// When this flag is set to true, this API will fetch only those rooms that have exactly Y nights free with the reservation guest?s points. This query parameter is supported when OPERA Control Room Rotation and Forecast Rotation Points are active.
func (r FrontDeskOperationsAPIGetHotelRoomsRequest) PerfectFitRoomsOnly(perfectFitRoomsOnly bool) FrontDeskOperationsAPIGetHotelRoomsRequest {
	r.perfectFitRoomsOnly = &perfectFitRoomsOnly
	return r
}

// A collection of supported sorting for available rooms search results.
func (r FrontDeskOperationsAPIGetHotelRoomsRequest) OrderBy(orderBy string) FrontDeskOperationsAPIGetHotelRoomsRequest {
	r.orderBy = &orderBy
	return r
}

// Fetches rooms that matches requested unit grade codes. Only returns when Room Rotation and Unit Grade are active.
func (r FrontDeskOperationsAPIGetHotelRoomsRequest) UnitGradeCodes(unitGradeCodes []string) FrontDeskOperationsAPIGetHotelRoomsRequest {
	r.unitGradeCodes = &unitGradeCodes
	return r
}

// : This OPERA profile?s internal Id will be used with ownerExclusiveRoomOnly flag to return the room which own by this profile. This query parameter is supported when OPERA Control Room Rotation is active.
func (r FrontDeskOperationsAPIGetHotelRoomsRequest) OwnerExclusiveRoomProfileId(ownerExclusiveRoomProfileId string) FrontDeskOperationsAPIGetHotelRoomsRequest {
	r.ownerExclusiveRoomProfileId = &ownerExclusiveRoomProfileId
	return r
}

// It indicates to exclude rooms with the selected Room Feature(s).It allows alphanumeric values(e.g.,TUB,BOLCONY,MV)
func (r FrontDeskOperationsAPIGetHotelRoomsRequest) ExcludeRoomFeatures(excludeRoomFeatures []string) FrontDeskOperationsAPIGetHotelRoomsRequest {
	r.excludeRoomFeatures = &excludeRoomFeatures
	return r
}

// It indicates to exclude rooms with the selected Floor(s) which are comma separated values.It allows alphanumeric values(e.g.,01,02,03,GROUND,five)
func (r FrontDeskOperationsAPIGetHotelRoomsRequest) ExcludeFloorPreferences(excludeFloorPreferences []string) FrontDeskOperationsAPIGetHotelRoomsRequest {
	r.excludeFloorPreferences = &excludeFloorPreferences
	return r
}

// External system code.
func (r FrontDeskOperationsAPIGetHotelRoomsRequest) XExternalsystem(xExternalsystem string) FrontDeskOperationsAPIGetHotelRoomsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r FrontDeskOperationsAPIGetHotelRoomsRequest) AcceptLanguage(acceptLanguage string) FrontDeskOperationsAPIGetHotelRoomsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r FrontDeskOperationsAPIGetHotelRoomsRequest) Execute() (*HotelRooms, *http.Response, error) {
	return r.ApiService.GetHotelRoomsExecute(r)
}

/*
GetHotelRooms Get hotel available rooms

Use this API to return available rooms based on search criteria such as hotelId, hotelRoomStatus, roomType, roomFeatureCode,etc.<p><strong>OperationId:</strong>getHotelRooms</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId
 @return FrontDeskOperationsAPIGetHotelRoomsRequest
*/
func (a *FrontDeskOperationsAPIService) GetHotelRooms(ctx context.Context, hotelId string) FrontDeskOperationsAPIGetHotelRoomsRequest {
	return FrontDeskOperationsAPIGetHotelRoomsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return HotelRooms
func (a *FrontDeskOperationsAPIService) GetHotelRoomsExecute(r FrontDeskOperationsAPIGetHotelRoomsRequest) (*HotelRooms, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HotelRooms
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FrontDeskOperationsAPIService.GetHotelRooms")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/rooms"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
  }
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
  }
	if r.roomNumberWildcard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomNumberWildcard", r.roomNumberWildcard, "")
  }
	if r.hotelRoomStatus != nil {
		t := *r.hotelRoomStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelRoomStatus", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelRoomStatus", t, "multi")
		}
  }
	if r.hotelFORoomStatus != nil {
		t := *r.hotelFORoomStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelFORoomStatus", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelFORoomStatus", t, "multi")
		}
  }
	if r.fromRoomNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromRoomNumber", r.fromRoomNumber, "")
  }
	if r.toRoomNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "toRoomNumber", r.toRoomNumber, "")
  }
	if r.hotelRoomStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelRoomStartDate", r.hotelRoomStartDate, "")
  }
	if r.hotelRoomEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelRoomEndDate", r.hotelRoomEndDate, "")
  }
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration", r.duration, "")
  }
	if r.roomType != nil {
		t := *r.roomType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomType", t, "multi")
		}
  }
	if r.roomClass != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomClass", r.roomClass, "")
  }
	if r.floor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "floor", r.floor, "")
  }
	if r.includeDueOut != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeDueOut", r.includeDueOut, "")
  }
	if r.departureTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "departureTime", r.departureTime, "")
  }
	if r.roomFeatureCode != nil {
		t := *r.roomFeatureCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomFeatureCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomFeatureCode", t, "multi")
		}
  }
	if r.description != nil {
		t := *r.description
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description", t, "multi")
		}
  }
	if r.orderSequence != nil {
		t := *r.orderSequence
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "orderSequence", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "orderSequence", t, "multi")
		}
  }
	if r.quantity != nil {
		t := *r.quantity
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "quantity", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "quantity", t, "multi")
		}
  }
	if r.smokingPreference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "smokingPreference", r.smokingPreference, "")
  }
	if r.includeAllRoomConditions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeAllRoomConditions", r.includeAllRoomConditions, "")
  }
	if r.includeComponentRooms != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeComponentRooms", r.includeComponentRooms, "")
  }
	if r.includePseudoRooms != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includePseudoRooms", r.includePseudoRooms, "")
  }
	if r.includeOORoomCheck != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeOORoomCheck", r.includeOORoomCheck, "")
  }
	if r.connectingRoomsOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectingRoomsOnly", r.connectingRoomsOnly, "")
  }
	if r.reservationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationId", r.reservationId, "")
  }
	if r.reservationIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIdContext", r.reservationIdContext, "")
  }
	if r.reservationIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIdType", r.reservationIdType, "")
  }
	if r.pseudoRoomsOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pseudoRoomsOnly", r.pseudoRoomsOnly, "")
  }
	if r.includeAttendentInRoom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeAttendentInRoom", r.includeAttendentInRoom, "")
  }
	if r.includeRotationRoom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeRotationRoom", r.includeRotationRoom, "")
  }
	if r.ownerRoomsOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ownerRoomsOnly", r.ownerRoomsOnly, "")
  }
	if r.ownerExclusiveRoomsOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ownerExclusiveRoomsOnly", r.ownerExclusiveRoomsOnly, "")
  }
	if r.perfectFitRoomsOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "perfectFitRoomsOnly", r.perfectFitRoomsOnly, "")
  }
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy", r.orderBy, "")
  }
	if r.unitGradeCodes != nil {
		t := *r.unitGradeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "unitGradeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "unitGradeCodes", t, "multi")
		}
  }
	if r.ownerExclusiveRoomProfileId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ownerExclusiveRoomProfileId", r.ownerExclusiveRoomProfileId, "")
  }
	if r.excludeRoomFeatures != nil {
		t := *r.excludeRoomFeatures
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeRoomFeatures", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeRoomFeatures", t, "multi")
		}
  }
	if r.excludeFloorPreferences != nil {
		t := *r.excludeFloorPreferences
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeFloorPreferences", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeFloorPreferences", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FrontDeskOperationsAPIGetLinkedReservationsRequest struct {
	ctx context.Context
	ApiService *FrontDeskOperationsAPIService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	additionalReservationId *[]string
	additionalReservationIdContext *[]string
	additionalReservationIdType *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r FrontDeskOperationsAPIGetLinkedReservationsRequest) Authorization(authorization string) FrontDeskOperationsAPIGetLinkedReservationsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r FrontDeskOperationsAPIGetLinkedReservationsRequest) XAppKey(xAppKey string) FrontDeskOperationsAPIGetLinkedReservationsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r FrontDeskOperationsAPIGetLinkedReservationsRequest) XHotelid(xHotelid string) FrontDeskOperationsAPIGetLinkedReservationsRequest {
	r.xHotelid = &xHotelid
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r FrontDeskOperationsAPIGetLinkedReservationsRequest) AdditionalReservationId(additionalReservationId []string) FrontDeskOperationsAPIGetLinkedReservationsRequest {
	r.additionalReservationId = &additionalReservationId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r FrontDeskOperationsAPIGetLinkedReservationsRequest) AdditionalReservationIdContext(additionalReservationIdContext []string) FrontDeskOperationsAPIGetLinkedReservationsRequest {
	r.additionalReservationIdContext = &additionalReservationIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r FrontDeskOperationsAPIGetLinkedReservationsRequest) AdditionalReservationIdType(additionalReservationIdType []string) FrontDeskOperationsAPIGetLinkedReservationsRequest {
	r.additionalReservationIdType = &additionalReservationIdType
	return r
}

// External system code.
func (r FrontDeskOperationsAPIGetLinkedReservationsRequest) XExternalsystem(xExternalsystem string) FrontDeskOperationsAPIGetLinkedReservationsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r FrontDeskOperationsAPIGetLinkedReservationsRequest) AcceptLanguage(acceptLanguage string) FrontDeskOperationsAPIGetLinkedReservationsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r FrontDeskOperationsAPIGetLinkedReservationsRequest) Execute() (*LinkedReservations, *http.Response, error) {
	return r.ApiService.GetLinkedReservationsExecute(r)
}

/*
GetLinkedReservations Get linked reservations

Use this API to view the reservations  that are linked to the specified reservation. <p><strong>OperationId:</strong>getLinkedReservations</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId
 @param hotelId
 @return FrontDeskOperationsAPIGetLinkedReservationsRequest
*/
func (a *FrontDeskOperationsAPIService) GetLinkedReservations(ctx context.Context, reservationId string, hotelId string) FrontDeskOperationsAPIGetLinkedReservationsRequest {
	return FrontDeskOperationsAPIGetLinkedReservationsRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return LinkedReservations
func (a *FrontDeskOperationsAPIService) GetLinkedReservationsExecute(r FrontDeskOperationsAPIGetLinkedReservationsRequest) (*LinkedReservations, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LinkedReservations
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FrontDeskOperationsAPIService.GetLinkedReservations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/linked"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.additionalReservationId != nil {
		t := *r.additionalReservationId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "additionalReservationId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "additionalReservationId", t, "multi")
		}
  }
	if r.additionalReservationIdContext != nil {
		t := *r.additionalReservationIdContext
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "additionalReservationIdContext", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "additionalReservationIdContext", t, "multi")
		}
  }
	if r.additionalReservationIdType != nil {
		t := *r.additionalReservationIdType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "additionalReservationIdType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "additionalReservationIdType", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FrontDeskOperationsAPIGetQueueRoomsTextMessageRequest struct {
	ctx context.Context
	ApiService *FrontDeskOperationsAPIService
	messageType string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	reservationId *string
	reservationIdContext *string
	reservationIdType *string
	mobileNumber *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r FrontDeskOperationsAPIGetQueueRoomsTextMessageRequest) Authorization(authorization string) FrontDeskOperationsAPIGetQueueRoomsTextMessageRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r FrontDeskOperationsAPIGetQueueRoomsTextMessageRequest) XAppKey(xAppKey string) FrontDeskOperationsAPIGetQueueRoomsTextMessageRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r FrontDeskOperationsAPIGetQueueRoomsTextMessageRequest) XHotelid(xHotelid string) FrontDeskOperationsAPIGetQueueRoomsTextMessageRequest {
	r.xHotelid = &xHotelid
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r FrontDeskOperationsAPIGetQueueRoomsTextMessageRequest) ReservationId(reservationId string) FrontDeskOperationsAPIGetQueueRoomsTextMessageRequest {
	r.reservationId = &reservationId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r FrontDeskOperationsAPIGetQueueRoomsTextMessageRequest) ReservationIdContext(reservationIdContext string) FrontDeskOperationsAPIGetQueueRoomsTextMessageRequest {
	r.reservationIdContext = &reservationIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r FrontDeskOperationsAPIGetQueueRoomsTextMessageRequest) ReservationIdType(reservationIdType string) FrontDeskOperationsAPIGetQueueRoomsTextMessageRequest {
	r.reservationIdType = &reservationIdType
	return r
}

// Mobile number that the text message will be delivered to.
func (r FrontDeskOperationsAPIGetQueueRoomsTextMessageRequest) MobileNumber(mobileNumber string) FrontDeskOperationsAPIGetQueueRoomsTextMessageRequest {
	r.mobileNumber = &mobileNumber
	return r
}

// External system code.
func (r FrontDeskOperationsAPIGetQueueRoomsTextMessageRequest) XExternalsystem(xExternalsystem string) FrontDeskOperationsAPIGetQueueRoomsTextMessageRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r FrontDeskOperationsAPIGetQueueRoomsTextMessageRequest) AcceptLanguage(acceptLanguage string) FrontDeskOperationsAPIGetQueueRoomsTextMessageRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r FrontDeskOperationsAPIGetQueueRoomsTextMessageRequest) Execute() (*QueuedRoomsTextMessage, *http.Response, error) {
	return r.ApiService.GetQueueRoomsTextMessageExecute(r)
}

/*
GetQueueRoomsTextMessage Get Queue room text message

You can use this API to get Queue room text message. <p><strong>OperationId:</strong>getQueueRoomsTextMessage</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param messageType
 @param hotelId
 @return FrontDeskOperationsAPIGetQueueRoomsTextMessageRequest
*/
func (a *FrontDeskOperationsAPIService) GetQueueRoomsTextMessage(ctx context.Context, messageType string, hotelId string) FrontDeskOperationsAPIGetQueueRoomsTextMessageRequest {
	return FrontDeskOperationsAPIGetQueueRoomsTextMessageRequest{
		ApiService: a,
		ctx: ctx,
		messageType: messageType,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return QueuedRoomsTextMessage
func (a *FrontDeskOperationsAPIService) GetQueueRoomsTextMessageExecute(r FrontDeskOperationsAPIGetQueueRoomsTextMessageRequest) (*QueuedRoomsTextMessage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QueuedRoomsTextMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FrontDeskOperationsAPIService.GetQueueRoomsTextMessage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/textMessages/{messageType}"
	localVarPath = strings.Replace(localVarPath, "{"+"messageType"+"}", url.PathEscape(parameterValueToString(r.messageType, "messageType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.messageType) < 1 {
		return localVarReturnValue, nil, reportError("messageType must have at least 1 elements")
	}
	if strlen(r.messageType) > 2000 {
		return localVarReturnValue, nil, reportError("messageType must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.reservationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationId", r.reservationId, "")
  }
	if r.reservationIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIdContext", r.reservationIdContext, "")
  }
	if r.reservationIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIdType", r.reservationIdType, "")
  }
	if r.mobileNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mobileNumber", r.mobileNumber, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FrontDeskOperationsAPIGetReservationSummariesRequest struct {
	ctx context.Context
	ApiService *FrontDeskOperationsAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	searchType *string
	reservationId *[]string
	reservationIdContext *[]string
	reservationIdType *[]string
	blockId *[]string
	blockIdContext *[]string
	blockIdType *[]string
	arrivalEnd *string
	arrivalStart *string
	departureEnd *string
	departureStart *string
	stayOnEnd *string
	stayOnStart *string
	createdOnEnd *string
	createOnStart *string
	depositDateEnd *string
	depositDateStart *string
	dateCriteriaExpectedArrivalEndTime *string
	dateCriteriaExpectedArrivalStartTime *string
	depositDueDateEnd *string
	depositDueDateStart *string
	expectedReturnEndTime *string
	expectedReturnStartTime *string
	membershipNumber *string
	anyVIPStatus *bool
	vipStatusCodes *[]string
	roomId *string
	lastName *string
	firstName *string
	blockCode *string
	companyName *string
	travelAgentName *string
	creditCardNumber *string
	customReference *string
	externalReference *string
	attributeName *[]string
	orderType *[]string
	expectedArrivalEndTime *string
	expectedArrivalStartTime *string
	roomTypes *[]string
	roomStatuses *[]string
	paymentMethod *[]string
	indicator *[]string
	fetchSummaryInstructions *[]string
	allowedAction *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r FrontDeskOperationsAPIGetReservationSummariesRequest) Authorization(authorization string) FrontDeskOperationsAPIGetReservationSummariesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r FrontDeskOperationsAPIGetReservationSummariesRequest) XAppKey(xAppKey string) FrontDeskOperationsAPIGetReservationSummariesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r FrontDeskOperationsAPIGetReservationSummariesRequest) XHotelid(xHotelid string) FrontDeskOperationsAPIGetReservationSummariesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Represents Reservation search type Player Snapshot.
func (r FrontDeskOperationsAPIGetReservationSummariesRequest) SearchType(searchType string) FrontDeskOperationsAPIGetReservationSummariesRequest {
	r.searchType = &searchType
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r FrontDeskOperationsAPIGetReservationSummariesRequest) ReservationId(reservationId []string) FrontDeskOperationsAPIGetReservationSummariesRequest {
	r.reservationId = &reservationId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r FrontDeskOperationsAPIGetReservationSummariesRequest) ReservationIdContext(reservationIdContext []string) FrontDeskOperationsAPIGetReservationSummariesRequest {
	r.reservationIdContext = &reservationIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r FrontDeskOperationsAPIGetReservationSummariesRequest) ReservationIdType(reservationIdType []string) FrontDeskOperationsAPIGetReservationSummariesRequest {
	r.reservationIdType = &reservationIdType
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r FrontDeskOperationsAPIGetReservationSummariesRequest) BlockId(blockId []string) FrontDeskOperationsAPIGetReservationSummariesRequest {
	r.blockId = &blockId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r FrontDeskOperationsAPIGetReservationSummariesRequest) BlockIdContext(blockIdContext []string) FrontDeskOperationsAPIGetReservationSummariesRequest {
	r.blockIdContext = &blockIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r FrontDeskOperationsAPIGetReservationSummariesRequest) BlockIdType(blockIdType []string) FrontDeskOperationsAPIGetReservationSummariesRequest {
	r.blockIdType = &blockIdType
	return r
}

// The ending value of the date range.
func (r FrontDeskOperationsAPIGetReservationSummariesRequest) ArrivalEnd(arrivalEnd string) FrontDeskOperationsAPIGetReservationSummariesRequest {
	r.arrivalEnd = &arrivalEnd
	return r
}

// The starting value of the date range.
func (r FrontDeskOperationsAPIGetReservationSummariesRequest) ArrivalStart(arrivalStart string) FrontDeskOperationsAPIGetReservationSummariesRequest {
	r.arrivalStart = &arrivalStart
	return r
}

// The ending value of the date range.
func (r FrontDeskOperationsAPIGetReservationSummariesRequest) DepartureEnd(departureEnd string) FrontDeskOperationsAPIGetReservationSummariesRequest {
	r.departureEnd = &departureEnd
	return r
}

// The starting value of the date range.
func (r FrontDeskOperationsAPIGetReservationSummariesRequest) DepartureStart(departureStart string) FrontDeskOperationsAPIGetReservationSummariesRequest {
	r.departureStart = &departureStart
	return r
}

// The ending value of the date range.
func (r FrontDeskOperationsAPIGetReservationSummariesRequest) StayOnEnd(stayOnEnd string) FrontDeskOperationsAPIGetReservationSummariesRequest {
	r.stayOnEnd = &stayOnEnd
	return r
}

// The starting value of the date range.
func (r FrontDeskOperationsAPIGetReservationSummariesRequest) StayOnStart(stayOnStart string) FrontDeskOperationsAPIGetReservationSummariesRequest {
	r.stayOnStart = &stayOnStart
	return r
}

// The ending value of the date range.
func (r FrontDeskOperationsAPIGetReservationSummariesRequest) CreatedOnEnd(createdOnEnd string) FrontDeskOperationsAPIGetReservationSummariesRequest {
	r.createdOnEnd = &createdOnEnd
	return r
}

// The starting value of the date range.
func (r FrontDeskOperationsAPIGetReservationSummariesRequest) CreateOnStart(createOnStart string) FrontDeskOperationsAPIGetReservationSummariesRequest {
	r.createOnStart = &createOnStart
	return r
}

// The ending value of the date range.
func (r FrontDeskOperationsAPIGetReservationSummariesRequest) DepositDateEnd(depositDateEnd string) FrontDeskOperationsAPIGetReservationSummariesRequest {
	r.depositDateEnd = &depositDateEnd
	return r
}

// The starting value of the date range.
func (r FrontDeskOperationsAPIGetReservationSummariesRequest) DepositDateStart(depositDateStart string) FrontDeskOperationsAPIGetReservationSummariesRequest {
	r.depositDateStart = &depositDateStart
	return r
}

// The ending value of the time span.
func (r FrontDeskOperationsAPIGetReservationSummariesRequest) DateCriteriaExpectedArrivalEndTime(dateCriteriaExpectedArrivalEndTime string) FrontDeskOperationsAPIGetReservationSummariesRequest {
	r.dateCriteriaExpectedArrivalEndTime = &dateCriteriaExpectedArrivalEndTime
	return r
}

// The starting value of the time span.
func (r FrontDeskOperationsAPIGetReservationSummariesRequest) DateCriteriaExpectedArrivalStartTime(dateCriteriaExpectedArrivalStartTime string) FrontDeskOperationsAPIGetReservationSummariesRequest {
	r.dateCriteriaExpectedArrivalStartTime = &dateCriteriaExpectedArrivalStartTime
	return r
}

// The ending value of the date range.
func (r FrontDeskOperationsAPIGetReservationSummariesRequest) DepositDueDateEnd(depositDueDateEnd string) FrontDeskOperationsAPIGetReservationSummariesRequest {
	r.depositDueDateEnd = &depositDueDateEnd
	return r
}

// The starting value of the date range.
func (r FrontDeskOperationsAPIGetReservationSummariesRequest) DepositDueDateStart(depositDueDateStart string) FrontDeskOperationsAPIGetReservationSummariesRequest {
	r.depositDueDateStart = &depositDueDateStart
	return r
}

// The ending value of the time span.
func (r FrontDeskOperationsAPIGetReservationSummariesRequest) ExpectedReturnEndTime(expectedReturnEndTime string) FrontDeskOperationsAPIGetReservationSummariesRequest {
	r.expectedReturnEndTime = &expectedReturnEndTime
	return r
}

// The starting value of the time span.
func (r FrontDeskOperationsAPIGetReservationSummariesRequest) ExpectedReturnStartTime(expectedReturnStartTime string) FrontDeskOperationsAPIGetReservationSummariesRequest {
	r.expectedReturnStartTime = &expectedReturnStartTime
	return r
}

// Lookup reservations with this membership number.
func (r FrontDeskOperationsAPIGetReservationSummariesRequest) MembershipNumber(membershipNumber string) FrontDeskOperationsAPIGetReservationSummariesRequest {
	r.membershipNumber = &membershipNumber
	return r
}

// VIP status of the customer.
func (r FrontDeskOperationsAPIGetReservationSummariesRequest) AnyVIPStatus(anyVIPStatus bool) FrontDeskOperationsAPIGetReservationSummariesRequest {
	r.anyVIPStatus = &anyVIPStatus
	return r
}

// VIP status of the customer.
func (r FrontDeskOperationsAPIGetReservationSummariesRequest) VipStatusCodes(vipStatusCodes []string) FrontDeskOperationsAPIGetReservationSummariesRequest {
	r.vipStatusCodes = &vipStatusCodes
	return r
}

// Wildcard Search value to lookup reservation with this room number.
func (r FrontDeskOperationsAPIGetReservationSummariesRequest) RoomId(roomId string) FrontDeskOperationsAPIGetReservationSummariesRequest {
	r.roomId = &roomId
	return r
}

// Wildcard Search value to lookup reservations with this Last Name.
func (r FrontDeskOperationsAPIGetReservationSummariesRequest) LastName(lastName string) FrontDeskOperationsAPIGetReservationSummariesRequest {
	r.lastName = &lastName
	return r
}

// Wildcard Search value to lookup reservations with this First Name.
func (r FrontDeskOperationsAPIGetReservationSummariesRequest) FirstName(firstName string) FrontDeskOperationsAPIGetReservationSummariesRequest {
	r.firstName = &firstName
	return r
}

// Wildcard Search value to lookup reservation with this block code.
func (r FrontDeskOperationsAPIGetReservationSummariesRequest) BlockCode(blockCode string) FrontDeskOperationsAPIGetReservationSummariesRequest {
	r.blockCode = &blockCode
	return r
}

// Lookup reservations with this company name.
func (r FrontDeskOperationsAPIGetReservationSummariesRequest) CompanyName(companyName string) FrontDeskOperationsAPIGetReservationSummariesRequest {
	r.companyName = &companyName
	return r
}

// Lookup reservations with this travel agent name.
func (r FrontDeskOperationsAPIGetReservationSummariesRequest) TravelAgentName(travelAgentName string) FrontDeskOperationsAPIGetReservationSummariesRequest {
	r.travelAgentName = &travelAgentName
	return r
}

// Lookup reservations which has this credit card attached.
func (r FrontDeskOperationsAPIGetReservationSummariesRequest) CreditCardNumber(creditCardNumber string) FrontDeskOperationsAPIGetReservationSummariesRequest {
	r.creditCardNumber = &creditCardNumber
	return r
}

// Lookup reservations with this custom reference number.
func (r FrontDeskOperationsAPIGetReservationSummariesRequest) CustomReference(customReference string) FrontDeskOperationsAPIGetReservationSummariesRequest {
	r.customReference = &customReference
	return r
}

// Lookup reservations with this external reference id.
func (r FrontDeskOperationsAPIGetReservationSummariesRequest) ExternalReference(externalReference string) FrontDeskOperationsAPIGetReservationSummariesRequest {
	r.externalReference = &externalReference
	return r
}

func (r FrontDeskOperationsAPIGetReservationSummariesRequest) AttributeName(attributeName []string) FrontDeskOperationsAPIGetReservationSummariesRequest {
	r.attributeName = &attributeName
	return r
}

func (r FrontDeskOperationsAPIGetReservationSummariesRequest) OrderType(orderType []string) FrontDeskOperationsAPIGetReservationSummariesRequest {
	r.orderType = &orderType
	return r
}

// The ending value of the date range.
func (r FrontDeskOperationsAPIGetReservationSummariesRequest) ExpectedArrivalEndTime(expectedArrivalEndTime string) FrontDeskOperationsAPIGetReservationSummariesRequest {
	r.expectedArrivalEndTime = &expectedArrivalEndTime
	return r
}

// The starting value of the date range.
func (r FrontDeskOperationsAPIGetReservationSummariesRequest) ExpectedArrivalStartTime(expectedArrivalStartTime string) FrontDeskOperationsAPIGetReservationSummariesRequest {
	r.expectedArrivalStartTime = &expectedArrivalStartTime
	return r
}

// Room Type.
func (r FrontDeskOperationsAPIGetReservationSummariesRequest) RoomTypes(roomTypes []string) FrontDeskOperationsAPIGetReservationSummariesRequest {
	r.roomTypes = &roomTypes
	return r
}

// Simple type for room status instructions to be used in requests for fetching housekeeping rooms. Valid status values are Clean, Dirty, Pickup, Inspected, OutOfOrder, OutOfService.
func (r FrontDeskOperationsAPIGetReservationSummariesRequest) RoomStatuses(roomStatuses []string) FrontDeskOperationsAPIGetReservationSummariesRequest {
	r.roomStatuses = &roomStatuses
	return r
}

// Payment Method to search the reservation.
func (r FrontDeskOperationsAPIGetReservationSummariesRequest) PaymentMethod(paymentMethod []string) FrontDeskOperationsAPIGetReservationSummariesRequest {
	r.paymentMethod = &paymentMethod
	return r
}

// Simple type that corresponds to reservation indicators.
func (r FrontDeskOperationsAPIGetReservationSummariesRequest) Indicator(indicator []string) FrontDeskOperationsAPIGetReservationSummariesRequest {
	r.indicator = &indicator
	return r
}

// Simple type for reservation summary instructions that can be used in requests to fetch summary.
func (r FrontDeskOperationsAPIGetReservationSummariesRequest) FetchSummaryInstructions(fetchSummaryInstructions []string) FrontDeskOperationsAPIGetReservationSummariesRequest {
	r.fetchSummaryInstructions = &fetchSummaryInstructions
	return r
}

// Flag indicating whether the Enrollment is in progress or not for the Profile associated with this Reservation.
func (r FrontDeskOperationsAPIGetReservationSummariesRequest) AllowedAction(allowedAction []string) FrontDeskOperationsAPIGetReservationSummariesRequest {
	r.allowedAction = &allowedAction
	return r
}

// External system code.
func (r FrontDeskOperationsAPIGetReservationSummariesRequest) XExternalsystem(xExternalsystem string) FrontDeskOperationsAPIGetReservationSummariesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r FrontDeskOperationsAPIGetReservationSummariesRequest) AcceptLanguage(acceptLanguage string) FrontDeskOperationsAPIGetReservationSummariesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r FrontDeskOperationsAPIGetReservationSummariesRequest) Execute() (*ShortReservation, *http.Response, error) {
	return r.ApiService.GetReservationSummariesExecute(r)
}

/*
GetReservationSummaries Get hotel reservation summaries

Use this API to return reservation summaries for a specific property based on search criteria such as reservationId, blockId, arrivalStart, membershipNumber, roomId, etc.<p><strong>OperationId:</strong>getReservationSummaries</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId
 @return FrontDeskOperationsAPIGetReservationSummariesRequest
*/
func (a *FrontDeskOperationsAPIService) GetReservationSummaries(ctx context.Context, hotelId string) FrontDeskOperationsAPIGetReservationSummariesRequest {
	return FrontDeskOperationsAPIGetReservationSummariesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ShortReservation
func (a *FrontDeskOperationsAPIService) GetReservationSummariesExecute(r FrontDeskOperationsAPIGetReservationSummariesRequest) (*ShortReservation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ShortReservation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FrontDeskOperationsAPIService.GetReservationSummaries")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservationSummaries"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.searchType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "searchType", r.searchType, "")
  }
	if r.reservationId != nil {
		t := *r.reservationId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "reservationId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "reservationId", t, "multi")
		}
  }
	if r.reservationIdContext != nil {
		t := *r.reservationIdContext
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIdContext", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIdContext", t, "multi")
		}
  }
	if r.reservationIdType != nil {
		t := *r.reservationIdType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIdType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIdType", t, "multi")
		}
  }
	if r.blockId != nil {
		t := *r.blockId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "blockId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "blockId", t, "multi")
		}
  }
	if r.blockIdContext != nil {
		t := *r.blockIdContext
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "blockIdContext", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "blockIdContext", t, "multi")
		}
  }
	if r.blockIdType != nil {
		t := *r.blockIdType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "blockIdType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "blockIdType", t, "multi")
		}
  }
	if r.arrivalEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "arrivalEnd", r.arrivalEnd, "")
  }
	if r.arrivalStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "arrivalStart", r.arrivalStart, "")
  }
	if r.departureEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "departureEnd", r.departureEnd, "")
  }
	if r.departureStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "departureStart", r.departureStart, "")
  }
	if r.stayOnEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stayOnEnd", r.stayOnEnd, "")
  }
	if r.stayOnStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stayOnStart", r.stayOnStart, "")
  }
	if r.createdOnEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createdOnEnd", r.createdOnEnd, "")
  }
	if r.createOnStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createOnStart", r.createOnStart, "")
  }
	if r.depositDateEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depositDateEnd", r.depositDateEnd, "")
  }
	if r.depositDateStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depositDateStart", r.depositDateStart, "")
  }
	if r.dateCriteriaExpectedArrivalEndTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dateCriteriaExpectedArrivalEndTime", r.dateCriteriaExpectedArrivalEndTime, "")
  }
	if r.dateCriteriaExpectedArrivalStartTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dateCriteriaExpectedArrivalStartTime", r.dateCriteriaExpectedArrivalStartTime, "")
  }
	if r.depositDueDateEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depositDueDateEnd", r.depositDueDateEnd, "")
  }
	if r.depositDueDateStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depositDueDateStart", r.depositDueDateStart, "")
  }
	if r.expectedReturnEndTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expectedReturnEndTime", r.expectedReturnEndTime, "")
  }
	if r.expectedReturnStartTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expectedReturnStartTime", r.expectedReturnStartTime, "")
  }
	if r.membershipNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "membershipNumber", r.membershipNumber, "")
  }
	if r.anyVIPStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "anyVIPStatus", r.anyVIPStatus, "")
  }
	if r.vipStatusCodes != nil {
		t := *r.vipStatusCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vipStatusCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vipStatusCodes", t, "multi")
		}
  }
	if r.roomId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomId", r.roomId, "")
  }
	if r.lastName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lastName", r.lastName, "")
  }
	if r.firstName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "firstName", r.firstName, "")
  }
	if r.blockCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blockCode", r.blockCode, "")
  }
	if r.companyName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "companyName", r.companyName, "")
  }
	if r.travelAgentName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "travelAgentName", r.travelAgentName, "")
  }
	if r.creditCardNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creditCardNumber", r.creditCardNumber, "")
  }
	if r.customReference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "customReference", r.customReference, "")
  }
	if r.externalReference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "externalReference", r.externalReference, "")
  }
	if r.attributeName != nil {
		t := *r.attributeName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "attributeName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "attributeName", t, "multi")
		}
  }
	if r.orderType != nil {
		t := *r.orderType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "orderType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "orderType", t, "multi")
		}
  }
	if r.expectedArrivalEndTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expectedArrivalEndTime", r.expectedArrivalEndTime, "")
  }
	if r.expectedArrivalStartTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expectedArrivalStartTime", r.expectedArrivalStartTime, "")
  }
	if r.roomTypes != nil {
		t := *r.roomTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomTypes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomTypes", t, "multi")
		}
  }
	if r.roomStatuses != nil {
		t := *r.roomStatuses
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomStatuses", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomStatuses", t, "multi")
		}
  }
	if r.paymentMethod != nil {
		t := *r.paymentMethod
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "paymentMethod", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "paymentMethod", t, "multi")
		}
  }
	if r.indicator != nil {
		t := *r.indicator
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "indicator", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "indicator", t, "multi")
		}
  }
	if r.fetchSummaryInstructions != nil {
		t := *r.fetchSummaryInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchSummaryInstructions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchSummaryInstructions", t, "multi")
		}
  }
	if r.allowedAction != nil {
		t := *r.allowedAction
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "allowedAction", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "allowedAction", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FrontDeskOperationsAPIGetReservationsForBillingRequest struct {
	ctx context.Context
	ApiService *FrontDeskOperationsAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	searchType *string
	multipleHotelsSearchList *[]string
	superSearch *string
	reservationId *[]string
	reservationIdContext *[]string
	reservationIdType *[]string
	nights *int32
	arrivalEnd *string
	arrivalStart *string
	departureEnd *string
	departureStart *string
	reservationProfileType *[]string
	attachedProfileName *[]string
	attachedProfileId *[]string
	attachedProfileIdContext *[]string
	attachedProfileIdType *[]string
	resGuestId *string
	resGuestIdContext *string
	resGuestIdType *string
	membershipId *string
	membershipLevelCodes *[]string
	membershipTypeCodes *[]string
	surname *string
	givenName *string
	cityName *string
	postalCode *string
	state *string
	countryCode *string
	streetAddress *string
	bookingChannelCode *string
	blockHotelId *string
	blockId *[]string
	blockIdContext *[]string
	blockIdType *[]string
	recordLocator *string
	orderByAttributeName *[]string
	orderType *[]string
	roomId *string
	roomType *[]string
	fetchInstructions *[]string
	excludeNoPost *bool
	excludePMRooms *bool
	hasOpenFolio *bool
	excludedReservationIds *[]string
	excludedReservationIdsContext *[]string
	excludedReservationIdsType *[]string
	advanceCheckedIn *bool
	searchTypesSearchType *[]string
	reservationStatus *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r FrontDeskOperationsAPIGetReservationsForBillingRequest) Authorization(authorization string) FrontDeskOperationsAPIGetReservationsForBillingRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r FrontDeskOperationsAPIGetReservationsForBillingRequest) XAppKey(xAppKey string) FrontDeskOperationsAPIGetReservationsForBillingRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r FrontDeskOperationsAPIGetReservationsForBillingRequest) XHotelid(xHotelid string) FrontDeskOperationsAPIGetReservationsForBillingRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r FrontDeskOperationsAPIGetReservationsForBillingRequest) Limit(limit int32) FrontDeskOperationsAPIGetReservationsForBillingRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r FrontDeskOperationsAPIGetReservationsForBillingRequest) Offset(offset int32) FrontDeskOperationsAPIGetReservationsForBillingRequest {
	r.offset = &offset
	return r
}

// Represents Reservation search type Player Snapshot.
func (r FrontDeskOperationsAPIGetReservationsForBillingRequest) SearchType(searchType string) FrontDeskOperationsAPIGetReservationsForBillingRequest {
	r.searchType = &searchType
	return r
}

// Hotel code.
func (r FrontDeskOperationsAPIGetReservationsForBillingRequest) MultipleHotelsSearchList(multipleHotelsSearchList []string) FrontDeskOperationsAPIGetReservationsForBillingRequest {
	r.multipleHotelsSearchList = &multipleHotelsSearchList
	return r
}

// Free form text field for searching all reservation fields
func (r FrontDeskOperationsAPIGetReservationsForBillingRequest) SuperSearch(superSearch string) FrontDeskOperationsAPIGetReservationsForBillingRequest {
	r.superSearch = &superSearch
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r FrontDeskOperationsAPIGetReservationsForBillingRequest) ReservationId(reservationId []string) FrontDeskOperationsAPIGetReservationsForBillingRequest {
	r.reservationId = &reservationId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r FrontDeskOperationsAPIGetReservationsForBillingRequest) ReservationIdContext(reservationIdContext []string) FrontDeskOperationsAPIGetReservationsForBillingRequest {
	r.reservationIdContext = &reservationIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r FrontDeskOperationsAPIGetReservationsForBillingRequest) ReservationIdType(reservationIdType []string) FrontDeskOperationsAPIGetReservationsForBillingRequest {
	r.reservationIdType = &reservationIdType
	return r
}

// The number of nights on a reservation.
func (r FrontDeskOperationsAPIGetReservationsForBillingRequest) Nights(nights int32) FrontDeskOperationsAPIGetReservationsForBillingRequest {
	r.nights = &nights
	return r
}

// The ending value of the date range.
func (r FrontDeskOperationsAPIGetReservationsForBillingRequest) ArrivalEnd(arrivalEnd string) FrontDeskOperationsAPIGetReservationsForBillingRequest {
	r.arrivalEnd = &arrivalEnd
	return r
}

// The starting value of the date range.
func (r FrontDeskOperationsAPIGetReservationsForBillingRequest) ArrivalStart(arrivalStart string) FrontDeskOperationsAPIGetReservationsForBillingRequest {
	r.arrivalStart = &arrivalStart
	return r
}

// The ending value of the date range.
func (r FrontDeskOperationsAPIGetReservationsForBillingRequest) DepartureEnd(departureEnd string) FrontDeskOperationsAPIGetReservationsForBillingRequest {
	r.departureEnd = &departureEnd
	return r
}

// The starting value of the date range.
func (r FrontDeskOperationsAPIGetReservationsForBillingRequest) DepartureStart(departureStart string) FrontDeskOperationsAPIGetReservationsForBillingRequest {
	r.departureStart = &departureStart
	return r
}

func (r FrontDeskOperationsAPIGetReservationsForBillingRequest) ReservationProfileType(reservationProfileType []string) FrontDeskOperationsAPIGetReservationsForBillingRequest {
	r.reservationProfileType = &reservationProfileType
	return r
}

// Attached profile name
func (r FrontDeskOperationsAPIGetReservationsForBillingRequest) AttachedProfileName(attachedProfileName []string) FrontDeskOperationsAPIGetReservationsForBillingRequest {
	r.attachedProfileName = &attachedProfileName
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r FrontDeskOperationsAPIGetReservationsForBillingRequest) AttachedProfileId(attachedProfileId []string) FrontDeskOperationsAPIGetReservationsForBillingRequest {
	r.attachedProfileId = &attachedProfileId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r FrontDeskOperationsAPIGetReservationsForBillingRequest) AttachedProfileIdContext(attachedProfileIdContext []string) FrontDeskOperationsAPIGetReservationsForBillingRequest {
	r.attachedProfileIdContext = &attachedProfileIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r FrontDeskOperationsAPIGetReservationsForBillingRequest) AttachedProfileIdType(attachedProfileIdType []string) FrontDeskOperationsAPIGetReservationsForBillingRequest {
	r.attachedProfileIdType = &attachedProfileIdType
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r FrontDeskOperationsAPIGetReservationsForBillingRequest) ResGuestId(resGuestId string) FrontDeskOperationsAPIGetReservationsForBillingRequest {
	r.resGuestId = &resGuestId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r FrontDeskOperationsAPIGetReservationsForBillingRequest) ResGuestIdContext(resGuestIdContext string) FrontDeskOperationsAPIGetReservationsForBillingRequest {
	r.resGuestIdContext = &resGuestIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r FrontDeskOperationsAPIGetReservationsForBillingRequest) ResGuestIdType(resGuestIdType string) FrontDeskOperationsAPIGetReservationsForBillingRequest {
	r.resGuestIdType = &resGuestIdType
	return r
}

// Membership ID criteria.
func (r FrontDeskOperationsAPIGetReservationsForBillingRequest) MembershipId(membershipId string) FrontDeskOperationsAPIGetReservationsForBillingRequest {
	r.membershipId = &membershipId
	return r
}

func (r FrontDeskOperationsAPIGetReservationsForBillingRequest) MembershipLevelCodes(membershipLevelCodes []string) FrontDeskOperationsAPIGetReservationsForBillingRequest {
	r.membershipLevelCodes = &membershipLevelCodes
	return r
}

func (r FrontDeskOperationsAPIGetReservationsForBillingRequest) MembershipTypeCodes(membershipTypeCodes []string) FrontDeskOperationsAPIGetReservationsForBillingRequest {
	r.membershipTypeCodes = &membershipTypeCodes
	return r
}

// Family name, last name.
func (r FrontDeskOperationsAPIGetReservationsForBillingRequest) Surname(surname string) FrontDeskOperationsAPIGetReservationsForBillingRequest {
	r.surname = &surname
	return r
}

// Given name, first name or names
func (r FrontDeskOperationsAPIGetReservationsForBillingRequest) GivenName(givenName string) FrontDeskOperationsAPIGetReservationsForBillingRequest {
	r.givenName = &givenName
	return r
}

// City (e.g., Dublin), town, or postal station (i.e., a postal service territory, often used in a military address).
func (r FrontDeskOperationsAPIGetReservationsForBillingRequest) CityName(cityName string) FrontDeskOperationsAPIGetReservationsForBillingRequest {
	r.cityName = &cityName
	return r
}

// Post Office Code number.
func (r FrontDeskOperationsAPIGetReservationsForBillingRequest) PostalCode(postalCode string) FrontDeskOperationsAPIGetReservationsForBillingRequest {
	r.postalCode = &postalCode
	return r
}

// State or Province name (e.g., Texas).
func (r FrontDeskOperationsAPIGetReservationsForBillingRequest) State(state string) FrontDeskOperationsAPIGetReservationsForBillingRequest {
	r.state = &state
	return r
}

// Code for a country or a nationality.
func (r FrontDeskOperationsAPIGetReservationsForBillingRequest) CountryCode(countryCode string) FrontDeskOperationsAPIGetReservationsForBillingRequest {
	r.countryCode = &countryCode
	return r
}

// First Line of Street Address. For profile search it matches the first Address line.
func (r FrontDeskOperationsAPIGetReservationsForBillingRequest) StreetAddress(streetAddress string) FrontDeskOperationsAPIGetReservationsForBillingRequest {
	r.streetAddress = &streetAddress
	return r
}

// Booking Channel Code
func (r FrontDeskOperationsAPIGetReservationsForBillingRequest) BookingChannelCode(bookingChannelCode string) FrontDeskOperationsAPIGetReservationsForBillingRequest {
	r.bookingChannelCode = &bookingChannelCode
	return r
}

// The Hotel Code of the Block.
func (r FrontDeskOperationsAPIGetReservationsForBillingRequest) BlockHotelId(blockHotelId string) FrontDeskOperationsAPIGetReservationsForBillingRequest {
	r.blockHotelId = &blockHotelId
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r FrontDeskOperationsAPIGetReservationsForBillingRequest) BlockId(blockId []string) FrontDeskOperationsAPIGetReservationsForBillingRequest {
	r.blockId = &blockId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r FrontDeskOperationsAPIGetReservationsForBillingRequest) BlockIdContext(blockIdContext []string) FrontDeskOperationsAPIGetReservationsForBillingRequest {
	r.blockIdContext = &blockIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r FrontDeskOperationsAPIGetReservationsForBillingRequest) BlockIdType(blockIdType []string) FrontDeskOperationsAPIGetReservationsForBillingRequest {
	r.blockIdType = &blockIdType
	return r
}

// GDS Record Locator for reservation.
func (r FrontDeskOperationsAPIGetReservationsForBillingRequest) RecordLocator(recordLocator string) FrontDeskOperationsAPIGetReservationsForBillingRequest {
	r.recordLocator = &recordLocator
	return r
}

func (r FrontDeskOperationsAPIGetReservationsForBillingRequest) OrderByAttributeName(orderByAttributeName []string) FrontDeskOperationsAPIGetReservationsForBillingRequest {
	r.orderByAttributeName = &orderByAttributeName
	return r
}

func (r FrontDeskOperationsAPIGetReservationsForBillingRequest) OrderType(orderType []string) FrontDeskOperationsAPIGetReservationsForBillingRequest {
	r.orderType = &orderType
	return r
}

// Room number of the reservation to search by.
func (r FrontDeskOperationsAPIGetReservationsForBillingRequest) RoomId(roomId string) FrontDeskOperationsAPIGetReservationsForBillingRequest {
	r.roomId = &roomId
	return r
}

// Room Type.
func (r FrontDeskOperationsAPIGetReservationsForBillingRequest) RoomType(roomType []string) FrontDeskOperationsAPIGetReservationsForBillingRequest {
	r.roomType = &roomType
	return r
}

// Instruction to fetch whether the room was assigned/upgraded by AI. This will also include Reservation instruction.
func (r FrontDeskOperationsAPIGetReservationsForBillingRequest) FetchInstructions(fetchInstructions []string) FrontDeskOperationsAPIGetReservationsForBillingRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// Indicates that reservations with No Post flag should not be expected from the result.
func (r FrontDeskOperationsAPIGetReservationsForBillingRequest) ExcludeNoPost(excludeNoPost bool) FrontDeskOperationsAPIGetReservationsForBillingRequest {
	r.excludeNoPost = &excludeNoPost
	return r
}

// Indicates that reservations with PM room type should not be expected from the result.
func (r FrontDeskOperationsAPIGetReservationsForBillingRequest) ExcludePMRooms(excludePMRooms bool) FrontDeskOperationsAPIGetReservationsForBillingRequest {
	r.excludePMRooms = &excludePMRooms
	return r
}

// Indicates that only reservations with open folio should be expected from the result.
func (r FrontDeskOperationsAPIGetReservationsForBillingRequest) HasOpenFolio(hasOpenFolio bool) FrontDeskOperationsAPIGetReservationsForBillingRequest {
	r.hasOpenFolio = &hasOpenFolio
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r FrontDeskOperationsAPIGetReservationsForBillingRequest) ExcludedReservationIds(excludedReservationIds []string) FrontDeskOperationsAPIGetReservationsForBillingRequest {
	r.excludedReservationIds = &excludedReservationIds
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r FrontDeskOperationsAPIGetReservationsForBillingRequest) ExcludedReservationIdsContext(excludedReservationIdsContext []string) FrontDeskOperationsAPIGetReservationsForBillingRequest {
	r.excludedReservationIdsContext = &excludedReservationIdsContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r FrontDeskOperationsAPIGetReservationsForBillingRequest) ExcludedReservationIdsType(excludedReservationIdsType []string) FrontDeskOperationsAPIGetReservationsForBillingRequest {
	r.excludedReservationIdsType = &excludedReservationIdsType
	return r
}

// Indicates to exclude Advance Checked In Reservations from search result.
func (r FrontDeskOperationsAPIGetReservationsForBillingRequest) AdvanceCheckedIn(advanceCheckedIn bool) FrontDeskOperationsAPIGetReservationsForBillingRequest {
	r.advanceCheckedIn = &advanceCheckedIn
	return r
}

// Represents Reservation search type Player Snapshot.
func (r FrontDeskOperationsAPIGetReservationsForBillingRequest) SearchTypesSearchType(searchTypesSearchType []string) FrontDeskOperationsAPIGetReservationsForBillingRequest {
	r.searchTypesSearchType = &searchTypesSearchType
	return r
}

// Reservation status type for reservations search.
func (r FrontDeskOperationsAPIGetReservationsForBillingRequest) ReservationStatus(reservationStatus []string) FrontDeskOperationsAPIGetReservationsForBillingRequest {
	r.reservationStatus = &reservationStatus
	return r
}

// External system code.
func (r FrontDeskOperationsAPIGetReservationsForBillingRequest) XExternalsystem(xExternalsystem string) FrontDeskOperationsAPIGetReservationsForBillingRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r FrontDeskOperationsAPIGetReservationsForBillingRequest) AcceptLanguage(acceptLanguage string) FrontDeskOperationsAPIGetReservationsForBillingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r FrontDeskOperationsAPIGetReservationsForBillingRequest) Execute() (*ReservationsInfo, *http.Response, error) {
	return r.ApiService.GetReservationsForBillingExecute(r)
}

/*
GetReservationsForBilling Get Reservations for billing

You can use this API to fetch the reservations for billing. <p><strong>OperationId:</strong>getReservationsForBilling</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId
 @return FrontDeskOperationsAPIGetReservationsForBillingRequest
*/
func (a *FrontDeskOperationsAPIService) GetReservationsForBilling(ctx context.Context, hotelId string) FrontDeskOperationsAPIGetReservationsForBillingRequest {
	return FrontDeskOperationsAPIGetReservationsForBillingRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ReservationsInfo
func (a *FrontDeskOperationsAPIService) GetReservationsForBillingExecute(r FrontDeskOperationsAPIGetReservationsForBillingRequest) (*ReservationsInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReservationsInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FrontDeskOperationsAPIService.GetReservationsForBilling")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/billingReservations"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
  }
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
  }
	if r.searchType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "searchType", r.searchType, "")
  }
	if r.multipleHotelsSearchList != nil {
		t := *r.multipleHotelsSearchList
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "multipleHotelsSearchList", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "multipleHotelsSearchList", t, "multi")
		}
  }
	if r.superSearch != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "superSearch", r.superSearch, "")
  }
	if r.reservationId != nil {
		t := *r.reservationId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "reservationId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "reservationId", t, "multi")
		}
  }
	if r.reservationIdContext != nil {
		t := *r.reservationIdContext
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIdContext", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIdContext", t, "multi")
		}
  }
	if r.reservationIdType != nil {
		t := *r.reservationIdType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIdType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIdType", t, "multi")
		}
  }
	if r.nights != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nights", r.nights, "")
  }
	if r.arrivalEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "arrivalEnd", r.arrivalEnd, "")
  }
	if r.arrivalStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "arrivalStart", r.arrivalStart, "")
  }
	if r.departureEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "departureEnd", r.departureEnd, "")
  }
	if r.departureStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "departureStart", r.departureStart, "")
  }
	if r.reservationProfileType != nil {
		t := *r.reservationProfileType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "reservationProfileType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "reservationProfileType", t, "multi")
		}
  }
	if r.attachedProfileName != nil {
		t := *r.attachedProfileName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "attachedProfileName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "attachedProfileName", t, "multi")
		}
  }
	if r.attachedProfileId != nil {
		t := *r.attachedProfileId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "attachedProfileId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "attachedProfileId", t, "multi")
		}
  }
	if r.attachedProfileIdContext != nil {
		t := *r.attachedProfileIdContext
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "attachedProfileIdContext", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "attachedProfileIdContext", t, "multi")
		}
  }
	if r.attachedProfileIdType != nil {
		t := *r.attachedProfileIdType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "attachedProfileIdType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "attachedProfileIdType", t, "multi")
		}
  }
	if r.resGuestId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resGuestId", r.resGuestId, "")
  }
	if r.resGuestIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resGuestIdContext", r.resGuestIdContext, "")
  }
	if r.resGuestIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resGuestIdType", r.resGuestIdType, "")
  }
	if r.membershipId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "membershipId", r.membershipId, "")
  }
	if r.membershipLevelCodes != nil {
		t := *r.membershipLevelCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "membershipLevelCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "membershipLevelCodes", t, "multi")
		}
  }
	if r.membershipTypeCodes != nil {
		t := *r.membershipTypeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "membershipTypeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "membershipTypeCodes", t, "multi")
		}
  }
	if r.surname != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "surname", r.surname, "")
  }
	if r.givenName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "givenName", r.givenName, "")
  }
	if r.cityName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cityName", r.cityName, "")
  }
	if r.postalCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "postalCode", r.postalCode, "")
  }
	if r.state != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state", r.state, "")
  }
	if r.countryCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "countryCode", r.countryCode, "")
  }
	if r.streetAddress != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "streetAddress", r.streetAddress, "")
  }
	if r.bookingChannelCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bookingChannelCode", r.bookingChannelCode, "")
  }
	if r.blockHotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blockHotelId", r.blockHotelId, "")
  }
	if r.blockId != nil {
		t := *r.blockId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "blockId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "blockId", t, "multi")
		}
  }
	if r.blockIdContext != nil {
		t := *r.blockIdContext
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "blockIdContext", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "blockIdContext", t, "multi")
		}
  }
	if r.blockIdType != nil {
		t := *r.blockIdType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "blockIdType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "blockIdType", t, "multi")
		}
  }
	if r.recordLocator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recordLocator", r.recordLocator, "")
  }
	if r.orderByAttributeName != nil {
		t := *r.orderByAttributeName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "orderByAttributeName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "orderByAttributeName", t, "multi")
		}
  }
	if r.orderType != nil {
		t := *r.orderType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "orderType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "orderType", t, "multi")
		}
  }
	if r.roomId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomId", r.roomId, "")
  }
	if r.roomType != nil {
		t := *r.roomType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomType", t, "multi")
		}
  }
	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
  }
	if r.excludeNoPost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excludeNoPost", r.excludeNoPost, "")
  }
	if r.excludePMRooms != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excludePMRooms", r.excludePMRooms, "")
  }
	if r.hasOpenFolio != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hasOpenFolio", r.hasOpenFolio, "")
  }
	if r.excludedReservationIds != nil {
		t := *r.excludedReservationIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludedReservationIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludedReservationIds", t, "multi")
		}
  }
	if r.excludedReservationIdsContext != nil {
		t := *r.excludedReservationIdsContext
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludedReservationIdsContext", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludedReservationIdsContext", t, "multi")
		}
  }
	if r.excludedReservationIdsType != nil {
		t := *r.excludedReservationIdsType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludedReservationIdsType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludedReservationIdsType", t, "multi")
		}
  }
	if r.advanceCheckedIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "advanceCheckedIn", r.advanceCheckedIn, "")
  }
	if r.searchTypesSearchType != nil {
		t := *r.searchTypesSearchType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "searchTypesSearchType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "searchTypesSearchType", t, "multi")
		}
  }
	if r.reservationStatus != nil {
		t := *r.reservationStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "reservationStatus", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "reservationStatus", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FrontDeskOperationsAPIGetReservationsInQueueRequest struct {
	ctx context.Context
	ApiService *FrontDeskOperationsAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	roomClassCodes *[]string
	roomTypeCodes *[]string
	roomNumberWildCard *string
	guestNameWildCard *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r FrontDeskOperationsAPIGetReservationsInQueueRequest) Authorization(authorization string) FrontDeskOperationsAPIGetReservationsInQueueRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r FrontDeskOperationsAPIGetReservationsInQueueRequest) XAppKey(xAppKey string) FrontDeskOperationsAPIGetReservationsInQueueRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r FrontDeskOperationsAPIGetReservationsInQueueRequest) XHotelid(xHotelid string) FrontDeskOperationsAPIGetReservationsInQueueRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r FrontDeskOperationsAPIGetReservationsInQueueRequest) RoomClassCodes(roomClassCodes []string) FrontDeskOperationsAPIGetReservationsInQueueRequest {
	r.roomClassCodes = &roomClassCodes
	return r
}

func (r FrontDeskOperationsAPIGetReservationsInQueueRequest) RoomTypeCodes(roomTypeCodes []string) FrontDeskOperationsAPIGetReservationsInQueueRequest {
	r.roomTypeCodes = &roomTypeCodes
	return r
}

// Wildcard search of reservations in queue by Room Number.
func (r FrontDeskOperationsAPIGetReservationsInQueueRequest) RoomNumberWildCard(roomNumberWildCard string) FrontDeskOperationsAPIGetReservationsInQueueRequest {
	r.roomNumberWildCard = &roomNumberWildCard
	return r
}

// Wildcard search of reservations in queue by Guest Name.
func (r FrontDeskOperationsAPIGetReservationsInQueueRequest) GuestNameWildCard(guestNameWildCard string) FrontDeskOperationsAPIGetReservationsInQueueRequest {
	r.guestNameWildCard = &guestNameWildCard
	return r
}

// External system code.
func (r FrontDeskOperationsAPIGetReservationsInQueueRequest) XExternalsystem(xExternalsystem string) FrontDeskOperationsAPIGetReservationsInQueueRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r FrontDeskOperationsAPIGetReservationsInQueueRequest) AcceptLanguage(acceptLanguage string) FrontDeskOperationsAPIGetReservationsInQueueRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r FrontDeskOperationsAPIGetReservationsInQueueRequest) Execute() (*ReservationsInQueue, *http.Response, error) {
	return r.ApiService.GetReservationsInQueueExecute(r)
}

/*
GetReservationsInQueue Get the reservation in queue

Fetch all current reservations that are Queued Reservations.  These reservations are guests that have arrived at the hotel, but their room isn't ready, so they're sitting in a queue.  <p><strong>OperationId:</strong>getReservationsInQueue</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId
 @return FrontDeskOperationsAPIGetReservationsInQueueRequest
*/
func (a *FrontDeskOperationsAPIService) GetReservationsInQueue(ctx context.Context, hotelId string) FrontDeskOperationsAPIGetReservationsInQueueRequest {
	return FrontDeskOperationsAPIGetReservationsInQueueRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ReservationsInQueue
func (a *FrontDeskOperationsAPIService) GetReservationsInQueueExecute(r FrontDeskOperationsAPIGetReservationsInQueueRequest) (*ReservationsInQueue, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReservationsInQueue
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FrontDeskOperationsAPIService.GetReservationsInQueue")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/queuedReservations"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.roomClassCodes != nil {
		t := *r.roomClassCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomClassCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomClassCodes", t, "multi")
		}
  }
	if r.roomTypeCodes != nil {
		t := *r.roomTypeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomTypeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomTypeCodes", t, "multi")
		}
  }
	if r.roomNumberWildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomNumberWildCard", r.roomNumberWildCard, "")
  }
	if r.guestNameWildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "guestNameWildCard", r.guestNameWildCard, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FrontDeskOperationsAPIGetResvForBatchCCAuthRequest struct {
	ctx context.Context
	ApiService *FrontDeskOperationsAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	guestName *string
	room *string
	cardType *[]string
	userDefinedCardType *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r FrontDeskOperationsAPIGetResvForBatchCCAuthRequest) Authorization(authorization string) FrontDeskOperationsAPIGetResvForBatchCCAuthRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r FrontDeskOperationsAPIGetResvForBatchCCAuthRequest) XAppKey(xAppKey string) FrontDeskOperationsAPIGetResvForBatchCCAuthRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r FrontDeskOperationsAPIGetResvForBatchCCAuthRequest) XHotelid(xHotelid string) FrontDeskOperationsAPIGetResvForBatchCCAuthRequest {
	r.xHotelid = &xHotelid
	return r
}

// Used for Character Strings, length 0 to 80.
func (r FrontDeskOperationsAPIGetResvForBatchCCAuthRequest) GuestName(guestName string) FrontDeskOperationsAPIGetResvForBatchCCAuthRequest {
	r.guestName = &guestName
	return r
}

// Used for codes in the OPERA Code tables. Possible values of this pattern are 1, 101, 101.EQP, or 101.EQP.X.
func (r FrontDeskOperationsAPIGetResvForBatchCCAuthRequest) Room(room string) FrontDeskOperationsAPIGetResvForBatchCCAuthRequest {
	r.room = &room
	return r
}

// This is required for Credit Card Payment Methods. This indicates the type of Credit Card associated with this payment method.
func (r FrontDeskOperationsAPIGetResvForBatchCCAuthRequest) CardType(cardType []string) FrontDeskOperationsAPIGetResvForBatchCCAuthRequest {
	r.cardType = &cardType
	return r
}

// Listing of user defined credit card types.
func (r FrontDeskOperationsAPIGetResvForBatchCCAuthRequest) UserDefinedCardType(userDefinedCardType []string) FrontDeskOperationsAPIGetResvForBatchCCAuthRequest {
	r.userDefinedCardType = &userDefinedCardType
	return r
}

// External system code.
func (r FrontDeskOperationsAPIGetResvForBatchCCAuthRequest) XExternalsystem(xExternalsystem string) FrontDeskOperationsAPIGetResvForBatchCCAuthRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r FrontDeskOperationsAPIGetResvForBatchCCAuthRequest) AcceptLanguage(acceptLanguage string) FrontDeskOperationsAPIGetResvForBatchCCAuthRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r FrontDeskOperationsAPIGetResvForBatchCCAuthRequest) Execute() (*ResvForBatchCCAut, *http.Response, error) {
	return r.ApiService.GetResvForBatchCCAuthExecute(r)
}

/*
GetResvForBatchCCAuth Get resrvation for batch CCAuth

This API is used to get reservations for batch CC Authorization. <p><strong>OperationId:</strong>getResvForBatchCCAuth</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId
 @return FrontDeskOperationsAPIGetResvForBatchCCAuthRequest
*/
func (a *FrontDeskOperationsAPIService) GetResvForBatchCCAuth(ctx context.Context, hotelId string) FrontDeskOperationsAPIGetResvForBatchCCAuthRequest {
	return FrontDeskOperationsAPIGetResvForBatchCCAuthRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ResvForBatchCCAut
func (a *FrontDeskOperationsAPIService) GetResvForBatchCCAuthExecute(r FrontDeskOperationsAPIGetResvForBatchCCAuthRequest) (*ResvForBatchCCAut, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResvForBatchCCAut
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FrontDeskOperationsAPIService.GetResvForBatchCCAuth")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/authorizationReservations"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.guestName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "guestName", r.guestName, "")
  }
	if r.room != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "room", r.room, "")
  }
	if r.cardType != nil {
		t := *r.cardType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "cardType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "cardType", t, "multi")
		}
  }
	if r.userDefinedCardType != nil {
		t := *r.userDefinedCardType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "userDefinedCardType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "userDefinedCardType", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FrontDeskOperationsAPIGetRoomInterfaceStatusRequest struct {
	ctx context.Context
	ApiService *FrontDeskOperationsAPIService
	interfaceId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	interfaceName *string
	interfaceType *string
	logo *string
	machineName *string
	status *string
	activeFlag *bool
	code *[]string
	blockId *string
	blockIdContext *string
	blockIdType *string
	roomId *string
	lastName *string
	firstName *string
	reservationIds *[]string
	reservationIdsContext *[]string
	reservationIdsType *[]string
	arrivalEnd *string
	arrivalStart *string
	expectedArrivalEndTime *string
	expectedArrivalStartTime *string
	specialCodes *[]string
	floorCodes *[]string
	roomFeatureCodes *[]string
	roomClassCodes *[]string
	roomStatus *[]string
	guaranteeCode *string
	reservationStatus *[]string
	includeLinkedReservations *bool
	includeBlocks *bool
	orderBy *string
	orderType *string
	expectedReturnEndTime *string
	expectedReturnStartTime *string
	advanceCheckedIn *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r FrontDeskOperationsAPIGetRoomInterfaceStatusRequest) Authorization(authorization string) FrontDeskOperationsAPIGetRoomInterfaceStatusRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r FrontDeskOperationsAPIGetRoomInterfaceStatusRequest) XAppKey(xAppKey string) FrontDeskOperationsAPIGetRoomInterfaceStatusRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r FrontDeskOperationsAPIGetRoomInterfaceStatusRequest) XHotelid(xHotelid string) FrontDeskOperationsAPIGetRoomInterfaceStatusRequest {
	r.xHotelid = &xHotelid
	return r
}

// Name of the Hotel Interface
func (r FrontDeskOperationsAPIGetRoomInterfaceStatusRequest) InterfaceName(interfaceName string) FrontDeskOperationsAPIGetRoomInterfaceStatusRequest {
	r.interfaceName = &interfaceName
	return r
}

// XML Posting Interface
func (r FrontDeskOperationsAPIGetRoomInterfaceStatusRequest) InterfaceType(interfaceType string) FrontDeskOperationsAPIGetRoomInterfaceStatusRequest {
	r.interfaceType = &interfaceType
	return r
}

// Hotel Interface Logo. On the database, this is also referred as DBF Logo. This is a three letter code followed by an underscore(_). This tells us which DBF files and log files with the prefix that IFC7 is going to create.
func (r FrontDeskOperationsAPIGetRoomInterfaceStatusRequest) Logo(logo string) FrontDeskOperationsAPIGetRoomInterfaceStatusRequest {
	r.logo = &logo
	return r
}

// Unique machine name of the running IFC.
func (r FrontDeskOperationsAPIGetRoomInterfaceStatusRequest) MachineName(machineName string) FrontDeskOperationsAPIGetRoomInterfaceStatusRequest {
	r.machineName = &machineName
	return r
}

// Status of the Hotel Interface either STOPPED or RUNNING.
func (r FrontDeskOperationsAPIGetRoomInterfaceStatusRequest) Status(status string) FrontDeskOperationsAPIGetRoomInterfaceStatusRequest {
	r.status = &status
	return r
}

// Indicator if the Hotel Interface is active or not. This is different from the Interface Status, which is either STOPPED or RUNNING.
func (r FrontDeskOperationsAPIGetRoomInterfaceStatusRequest) ActiveFlag(activeFlag bool) FrontDeskOperationsAPIGetRoomInterfaceStatusRequest {
	r.activeFlag = &activeFlag
	return r
}

func (r FrontDeskOperationsAPIGetRoomInterfaceStatusRequest) Code(code []string) FrontDeskOperationsAPIGetRoomInterfaceStatusRequest {
	r.code = &code
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r FrontDeskOperationsAPIGetRoomInterfaceStatusRequest) BlockId(blockId string) FrontDeskOperationsAPIGetRoomInterfaceStatusRequest {
	r.blockId = &blockId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r FrontDeskOperationsAPIGetRoomInterfaceStatusRequest) BlockIdContext(blockIdContext string) FrontDeskOperationsAPIGetRoomInterfaceStatusRequest {
	r.blockIdContext = &blockIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r FrontDeskOperationsAPIGetRoomInterfaceStatusRequest) BlockIdType(blockIdType string) FrontDeskOperationsAPIGetRoomInterfaceStatusRequest {
	r.blockIdType = &blockIdType
	return r
}

// Wild card search value for Room number
func (r FrontDeskOperationsAPIGetRoomInterfaceStatusRequest) RoomId(roomId string) FrontDeskOperationsAPIGetRoomInterfaceStatusRequest {
	r.roomId = &roomId
	return r
}

// Wild card search value to lookup reservations with this last name
func (r FrontDeskOperationsAPIGetRoomInterfaceStatusRequest) LastName(lastName string) FrontDeskOperationsAPIGetRoomInterfaceStatusRequest {
	r.lastName = &lastName
	return r
}

// Wild card search value to lookup reservations with this first name
func (r FrontDeskOperationsAPIGetRoomInterfaceStatusRequest) FirstName(firstName string) FrontDeskOperationsAPIGetRoomInterfaceStatusRequest {
	r.firstName = &firstName
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r FrontDeskOperationsAPIGetRoomInterfaceStatusRequest) ReservationIds(reservationIds []string) FrontDeskOperationsAPIGetRoomInterfaceStatusRequest {
	r.reservationIds = &reservationIds
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r FrontDeskOperationsAPIGetRoomInterfaceStatusRequest) ReservationIdsContext(reservationIdsContext []string) FrontDeskOperationsAPIGetRoomInterfaceStatusRequest {
	r.reservationIdsContext = &reservationIdsContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r FrontDeskOperationsAPIGetRoomInterfaceStatusRequest) ReservationIdsType(reservationIdsType []string) FrontDeskOperationsAPIGetRoomInterfaceStatusRequest {
	r.reservationIdsType = &reservationIdsType
	return r
}

// The ending value of the date range.
func (r FrontDeskOperationsAPIGetRoomInterfaceStatusRequest) ArrivalEnd(arrivalEnd string) FrontDeskOperationsAPIGetRoomInterfaceStatusRequest {
	r.arrivalEnd = &arrivalEnd
	return r
}

// The starting value of the date range.
func (r FrontDeskOperationsAPIGetRoomInterfaceStatusRequest) ArrivalStart(arrivalStart string) FrontDeskOperationsAPIGetRoomInterfaceStatusRequest {
	r.arrivalStart = &arrivalStart
	return r
}

// The ending value of the time span.
func (r FrontDeskOperationsAPIGetRoomInterfaceStatusRequest) ExpectedArrivalEndTime(expectedArrivalEndTime string) FrontDeskOperationsAPIGetRoomInterfaceStatusRequest {
	r.expectedArrivalEndTime = &expectedArrivalEndTime
	return r
}

// The starting value of the time span.
func (r FrontDeskOperationsAPIGetRoomInterfaceStatusRequest) ExpectedArrivalStartTime(expectedArrivalStartTime string) FrontDeskOperationsAPIGetRoomInterfaceStatusRequest {
	r.expectedArrivalStartTime = &expectedArrivalStartTime
	return r
}

func (r FrontDeskOperationsAPIGetRoomInterfaceStatusRequest) SpecialCodes(specialCodes []string) FrontDeskOperationsAPIGetRoomInterfaceStatusRequest {
	r.specialCodes = &specialCodes
	return r
}

func (r FrontDeskOperationsAPIGetRoomInterfaceStatusRequest) FloorCodes(floorCodes []string) FrontDeskOperationsAPIGetRoomInterfaceStatusRequest {
	r.floorCodes = &floorCodes
	return r
}

func (r FrontDeskOperationsAPIGetRoomInterfaceStatusRequest) RoomFeatureCodes(roomFeatureCodes []string) FrontDeskOperationsAPIGetRoomInterfaceStatusRequest {
	r.roomFeatureCodes = &roomFeatureCodes
	return r
}

func (r FrontDeskOperationsAPIGetRoomInterfaceStatusRequest) RoomClassCodes(roomClassCodes []string) FrontDeskOperationsAPIGetRoomInterfaceStatusRequest {
	r.roomClassCodes = &roomClassCodes
	return r
}

// Simple type for room status instructions to be used in requests for fetching housekeeping rooms. Valid status values are Clean, Dirty, Pickup, Inspected, OutOfOrder, OutOfService.
func (r FrontDeskOperationsAPIGetRoomInterfaceStatusRequest) RoomStatus(roomStatus []string) FrontDeskOperationsAPIGetRoomInterfaceStatusRequest {
	r.roomStatus = &roomStatus
	return r
}

// Include reservations that have Guarantee Code(Reservation Type) only.
func (r FrontDeskOperationsAPIGetRoomInterfaceStatusRequest) GuaranteeCode(guaranteeCode string) FrontDeskOperationsAPIGetRoomInterfaceStatusRequest {
	r.guaranteeCode = &guaranteeCode
	return r
}

// Reservation status type for reservations search.
func (r FrontDeskOperationsAPIGetRoomInterfaceStatusRequest) ReservationStatus(reservationStatus []string) FrontDeskOperationsAPIGetRoomInterfaceStatusRequest {
	r.reservationStatus = &reservationStatus
	return r
}

// Include linked reservations.
func (r FrontDeskOperationsAPIGetRoomInterfaceStatusRequest) IncludeLinkedReservations(includeLinkedReservations bool) FrontDeskOperationsAPIGetRoomInterfaceStatusRequest {
	r.includeLinkedReservations = &includeLinkedReservations
	return r
}

// Include reservations attached to a block.
func (r FrontDeskOperationsAPIGetRoomInterfaceStatusRequest) IncludeBlocks(includeBlocks bool) FrontDeskOperationsAPIGetRoomInterfaceStatusRequest {
	r.includeBlocks = &includeBlocks
	return r
}

// A collection of supported sorting for Room Interface Status search results.
func (r FrontDeskOperationsAPIGetRoomInterfaceStatusRequest) OrderBy(orderBy string) FrontDeskOperationsAPIGetRoomInterfaceStatusRequest {
	r.orderBy = &orderBy
	return r
}

func (r FrontDeskOperationsAPIGetRoomInterfaceStatusRequest) OrderType(orderType string) FrontDeskOperationsAPIGetRoomInterfaceStatusRequest {
	r.orderType = &orderType
	return r
}

// The ending value of the time span.
func (r FrontDeskOperationsAPIGetRoomInterfaceStatusRequest) ExpectedReturnEndTime(expectedReturnEndTime string) FrontDeskOperationsAPIGetRoomInterfaceStatusRequest {
	r.expectedReturnEndTime = &expectedReturnEndTime
	return r
}

// The starting value of the time span.
func (r FrontDeskOperationsAPIGetRoomInterfaceStatusRequest) ExpectedReturnStartTime(expectedReturnStartTime string) FrontDeskOperationsAPIGetRoomInterfaceStatusRequest {
	r.expectedReturnStartTime = &expectedReturnStartTime
	return r
}

// Shows whether reservation is in Advance CheckIn state.
func (r FrontDeskOperationsAPIGetRoomInterfaceStatusRequest) AdvanceCheckedIn(advanceCheckedIn bool) FrontDeskOperationsAPIGetRoomInterfaceStatusRequest {
	r.advanceCheckedIn = &advanceCheckedIn
	return r
}

// External system code.
func (r FrontDeskOperationsAPIGetRoomInterfaceStatusRequest) XExternalsystem(xExternalsystem string) FrontDeskOperationsAPIGetRoomInterfaceStatusRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r FrontDeskOperationsAPIGetRoomInterfaceStatusRequest) AcceptLanguage(acceptLanguage string) FrontDeskOperationsAPIGetRoomInterfaceStatusRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r FrontDeskOperationsAPIGetRoomInterfaceStatusRequest) Execute() (*RoomInterfaceStatus, *http.Response, error) {
	return r.ApiService.GetRoomInterfaceStatusExecute(r)
}

/*
GetRoomInterfaceStatus Get room interface status

This Api will getch the room interface status. <p><strong>OperationId:</strong>getRoomInterfaceStatus</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param interfaceId
 @param hotelId
 @return FrontDeskOperationsAPIGetRoomInterfaceStatusRequest
*/
func (a *FrontDeskOperationsAPIService) GetRoomInterfaceStatus(ctx context.Context, interfaceId string, hotelId string) FrontDeskOperationsAPIGetRoomInterfaceStatusRequest {
	return FrontDeskOperationsAPIGetRoomInterfaceStatusRequest{
		ApiService: a,
		ctx: ctx,
		interfaceId: interfaceId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return RoomInterfaceStatus
func (a *FrontDeskOperationsAPIService) GetRoomInterfaceStatusExecute(r FrontDeskOperationsAPIGetRoomInterfaceStatusRequest) (*RoomInterfaceStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RoomInterfaceStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FrontDeskOperationsAPIService.GetRoomInterfaceStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/interfaces/{interfaceId}/roomStatuses"
	localVarPath = strings.Replace(localVarPath, "{"+"interfaceId"+"}", url.PathEscape(parameterValueToString(r.interfaceId, "interfaceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.interfaceId) < 1 {
		return localVarReturnValue, nil, reportError("interfaceId must have at least 1 elements")
	}
	if strlen(r.interfaceId) > 2000 {
		return localVarReturnValue, nil, reportError("interfaceId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.interfaceName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "interfaceName", r.interfaceName, "")
  }
	if r.interfaceType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "interfaceType", r.interfaceType, "")
  }
	if r.logo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "logo", r.logo, "")
  }
	if r.machineName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "machineName", r.machineName, "")
  }
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "")
  }
	if r.activeFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "activeFlag", r.activeFlag, "")
  }
	if r.code != nil {
		t := *r.code
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "code", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "code", t, "multi")
		}
  }
	if r.blockId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blockId", r.blockId, "")
  }
	if r.blockIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blockIdContext", r.blockIdContext, "")
  }
	if r.blockIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blockIdType", r.blockIdType, "")
  }
	if r.roomId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomId", r.roomId, "")
  }
	if r.lastName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lastName", r.lastName, "")
  }
	if r.firstName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "firstName", r.firstName, "")
  }
	if r.reservationIds != nil {
		t := *r.reservationIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIds", t, "multi")
		}
  }
	if r.reservationIdsContext != nil {
		t := *r.reservationIdsContext
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIdsContext", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIdsContext", t, "multi")
		}
  }
	if r.reservationIdsType != nil {
		t := *r.reservationIdsType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIdsType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIdsType", t, "multi")
		}
  }
	if r.arrivalEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "arrivalEnd", r.arrivalEnd, "")
  }
	if r.arrivalStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "arrivalStart", r.arrivalStart, "")
  }
	if r.expectedArrivalEndTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expectedArrivalEndTime", r.expectedArrivalEndTime, "")
  }
	if r.expectedArrivalStartTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expectedArrivalStartTime", r.expectedArrivalStartTime, "")
  }
	if r.specialCodes != nil {
		t := *r.specialCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "specialCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "specialCodes", t, "multi")
		}
  }
	if r.floorCodes != nil {
		t := *r.floorCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "floorCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "floorCodes", t, "multi")
		}
  }
	if r.roomFeatureCodes != nil {
		t := *r.roomFeatureCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomFeatureCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomFeatureCodes", t, "multi")
		}
  }
	if r.roomClassCodes != nil {
		t := *r.roomClassCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomClassCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomClassCodes", t, "multi")
		}
  }
	if r.roomStatus != nil {
		t := *r.roomStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomStatus", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomStatus", t, "multi")
		}
  }
	if r.guaranteeCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "guaranteeCode", r.guaranteeCode, "")
  }
	if r.reservationStatus != nil {
		t := *r.reservationStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "reservationStatus", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "reservationStatus", t, "multi")
		}
  }
	if r.includeLinkedReservations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeLinkedReservations", r.includeLinkedReservations, "")
  }
	if r.includeBlocks != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeBlocks", r.includeBlocks, "")
  }
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy", r.orderBy, "")
  }
	if r.orderType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderType", r.orderType, "")
  }
	if r.expectedReturnEndTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expectedReturnEndTime", r.expectedReturnEndTime, "")
  }
	if r.expectedReturnStartTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expectedReturnStartTime", r.expectedReturnStartTime, "")
  }
	if r.advanceCheckedIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "advanceCheckedIn", r.advanceCheckedIn, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FrontDeskOperationsAPIGetRoomKeyInterfaceDetailsRequest struct {
	ctx context.Context
	ApiService *FrontDeskOperationsAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	roomNumbersCode *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r FrontDeskOperationsAPIGetRoomKeyInterfaceDetailsRequest) Authorization(authorization string) FrontDeskOperationsAPIGetRoomKeyInterfaceDetailsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r FrontDeskOperationsAPIGetRoomKeyInterfaceDetailsRequest) XAppKey(xAppKey string) FrontDeskOperationsAPIGetRoomKeyInterfaceDetailsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r FrontDeskOperationsAPIGetRoomKeyInterfaceDetailsRequest) XHotelid(xHotelid string) FrontDeskOperationsAPIGetRoomKeyInterfaceDetailsRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r FrontDeskOperationsAPIGetRoomKeyInterfaceDetailsRequest) RoomNumbersCode(roomNumbersCode []string) FrontDeskOperationsAPIGetRoomKeyInterfaceDetailsRequest {
	r.roomNumbersCode = &roomNumbersCode
	return r
}

// External system code.
func (r FrontDeskOperationsAPIGetRoomKeyInterfaceDetailsRequest) XExternalsystem(xExternalsystem string) FrontDeskOperationsAPIGetRoomKeyInterfaceDetailsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r FrontDeskOperationsAPIGetRoomKeyInterfaceDetailsRequest) AcceptLanguage(acceptLanguage string) FrontDeskOperationsAPIGetRoomKeyInterfaceDetailsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r FrontDeskOperationsAPIGetRoomKeyInterfaceDetailsRequest) Execute() (*RoomKeyInterfaceDetails, *http.Response, error) {
	return r.ApiService.GetRoomKeyInterfaceDetailsExecute(r)
}

/*
GetRoomKeyInterfaceDetails Get key encoder interface configuration details

You can use thie API to get key encoder interface configuration details. <p><strong>OperationId:</strong>getRoomKeyInterfaceDetails</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId
 @return FrontDeskOperationsAPIGetRoomKeyInterfaceDetailsRequest
*/
func (a *FrontDeskOperationsAPIService) GetRoomKeyInterfaceDetails(ctx context.Context, hotelId string) FrontDeskOperationsAPIGetRoomKeyInterfaceDetailsRequest {
	return FrontDeskOperationsAPIGetRoomKeyInterfaceDetailsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return RoomKeyInterfaceDetails
func (a *FrontDeskOperationsAPIService) GetRoomKeyInterfaceDetailsExecute(r FrontDeskOperationsAPIGetRoomKeyInterfaceDetailsRequest) (*RoomKeyInterfaceDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RoomKeyInterfaceDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FrontDeskOperationsAPIService.GetRoomKeyInterfaceDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/keyInterfaces"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.roomNumbersCode != nil {
		t := *r.roomNumbersCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomNumbersCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomNumbersCode", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FrontDeskOperationsAPIGetRoomKeysRequest struct {
	ctx context.Context
	ApiService *FrontDeskOperationsAPIService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r FrontDeskOperationsAPIGetRoomKeysRequest) Authorization(authorization string) FrontDeskOperationsAPIGetRoomKeysRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r FrontDeskOperationsAPIGetRoomKeysRequest) XAppKey(xAppKey string) FrontDeskOperationsAPIGetRoomKeysRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r FrontDeskOperationsAPIGetRoomKeysRequest) XHotelid(xHotelid string) FrontDeskOperationsAPIGetRoomKeysRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r FrontDeskOperationsAPIGetRoomKeysRequest) XExternalsystem(xExternalsystem string) FrontDeskOperationsAPIGetRoomKeysRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r FrontDeskOperationsAPIGetRoomKeysRequest) AcceptLanguage(acceptLanguage string) FrontDeskOperationsAPIGetRoomKeysRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r FrontDeskOperationsAPIGetRoomKeysRequest) Execute() (*RoomKeyInfo, *http.Response, error) {
	return r.ApiService.GetRoomKeysExecute(r)
}

/*
GetRoomKeys Fetch the room keys

You can use this API to retrieve any existing room key information for a reservation. <p><strong>OperationId:</strong>getRoomKeys</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId
 @param hotelId
 @return FrontDeskOperationsAPIGetRoomKeysRequest
*/
func (a *FrontDeskOperationsAPIService) GetRoomKeys(ctx context.Context, reservationId string, hotelId string) FrontDeskOperationsAPIGetRoomKeysRequest {
	return FrontDeskOperationsAPIGetRoomKeysRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return RoomKeyInfo
func (a *FrontDeskOperationsAPIService) GetRoomKeysExecute(r FrontDeskOperationsAPIGetRoomKeysRequest) (*RoomKeyInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RoomKeyInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FrontDeskOperationsAPIService.GetRoomKeys")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/roomKeys"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FrontDeskOperationsAPIGetRoomMoveHistoryRequest struct {
	ctx context.Context
	ApiService *FrontDeskOperationsAPIService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	reservationIdContext *string
	reservationIdType *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r FrontDeskOperationsAPIGetRoomMoveHistoryRequest) Authorization(authorization string) FrontDeskOperationsAPIGetRoomMoveHistoryRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r FrontDeskOperationsAPIGetRoomMoveHistoryRequest) XAppKey(xAppKey string) FrontDeskOperationsAPIGetRoomMoveHistoryRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r FrontDeskOperationsAPIGetRoomMoveHistoryRequest) XHotelid(xHotelid string) FrontDeskOperationsAPIGetRoomMoveHistoryRequest {
	r.xHotelid = &xHotelid
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r FrontDeskOperationsAPIGetRoomMoveHistoryRequest) ReservationIdContext(reservationIdContext string) FrontDeskOperationsAPIGetRoomMoveHistoryRequest {
	r.reservationIdContext = &reservationIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r FrontDeskOperationsAPIGetRoomMoveHistoryRequest) ReservationIdType(reservationIdType string) FrontDeskOperationsAPIGetRoomMoveHistoryRequest {
	r.reservationIdType = &reservationIdType
	return r
}

// External system code.
func (r FrontDeskOperationsAPIGetRoomMoveHistoryRequest) XExternalsystem(xExternalsystem string) FrontDeskOperationsAPIGetRoomMoveHistoryRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r FrontDeskOperationsAPIGetRoomMoveHistoryRequest) AcceptLanguage(acceptLanguage string) FrontDeskOperationsAPIGetRoomMoveHistoryRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r FrontDeskOperationsAPIGetRoomMoveHistoryRequest) Execute() (*RoomMoveHistory, *http.Response, error) {
	return r.ApiService.GetRoomMoveHistoryExecute(r)
}

/*
GetRoomMoveHistory Get room move history of a reservation

This API will return the history of room change/room moves for a specified reservation. <p><strong>OperationId:</strong>getRoomMoveHistory</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId
 @param hotelId
 @return FrontDeskOperationsAPIGetRoomMoveHistoryRequest
*/
func (a *FrontDeskOperationsAPIService) GetRoomMoveHistory(ctx context.Context, reservationId string, hotelId string) FrontDeskOperationsAPIGetRoomMoveHistoryRequest {
	return FrontDeskOperationsAPIGetRoomMoveHistoryRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return RoomMoveHistory
func (a *FrontDeskOperationsAPIService) GetRoomMoveHistoryExecute(r FrontDeskOperationsAPIGetRoomMoveHistoryRequest) (*RoomMoveHistory, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RoomMoveHistory
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FrontDeskOperationsAPIService.GetRoomMoveHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/roomMoveHistory"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.reservationIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIdContext", r.reservationIdContext, "")
  }
	if r.reservationIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIdType", r.reservationIdType, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FrontDeskOperationsAPIGetServiceRequestsRequest struct {
	ctx context.Context
	ApiService *FrontDeskOperationsAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelIds *[]string
	code *[]string
	status *[]string
	priorityCodes *[]string
	departmentCodes *[]string
	reservationId *string
	reservationIdContext *string
	reservationIdType *string
	profileId *string
	profileIdContext *string
	profileIdType *string
	room *string
	creationEndDate *string
	creationStartDate *string
	closedEndDate *string
	closedStartDate *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r FrontDeskOperationsAPIGetServiceRequestsRequest) Authorization(authorization string) FrontDeskOperationsAPIGetServiceRequestsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r FrontDeskOperationsAPIGetServiceRequestsRequest) XAppKey(xAppKey string) FrontDeskOperationsAPIGetServiceRequestsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r FrontDeskOperationsAPIGetServiceRequestsRequest) XHotelid(xHotelid string) FrontDeskOperationsAPIGetServiceRequestsRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r FrontDeskOperationsAPIGetServiceRequestsRequest) HotelIds(hotelIds []string) FrontDeskOperationsAPIGetServiceRequestsRequest {
	r.hotelIds = &hotelIds
	return r
}

func (r FrontDeskOperationsAPIGetServiceRequestsRequest) Code(code []string) FrontDeskOperationsAPIGetServiceRequestsRequest {
	r.code = &code
	return r
}

func (r FrontDeskOperationsAPIGetServiceRequestsRequest) Status(status []string) FrontDeskOperationsAPIGetServiceRequestsRequest {
	r.status = &status
	return r
}

func (r FrontDeskOperationsAPIGetServiceRequestsRequest) PriorityCodes(priorityCodes []string) FrontDeskOperationsAPIGetServiceRequestsRequest {
	r.priorityCodes = &priorityCodes
	return r
}

func (r FrontDeskOperationsAPIGetServiceRequestsRequest) DepartmentCodes(departmentCodes []string) FrontDeskOperationsAPIGetServiceRequestsRequest {
	r.departmentCodes = &departmentCodes
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r FrontDeskOperationsAPIGetServiceRequestsRequest) ReservationId(reservationId string) FrontDeskOperationsAPIGetServiceRequestsRequest {
	r.reservationId = &reservationId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r FrontDeskOperationsAPIGetServiceRequestsRequest) ReservationIdContext(reservationIdContext string) FrontDeskOperationsAPIGetServiceRequestsRequest {
	r.reservationIdContext = &reservationIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r FrontDeskOperationsAPIGetServiceRequestsRequest) ReservationIdType(reservationIdType string) FrontDeskOperationsAPIGetServiceRequestsRequest {
	r.reservationIdType = &reservationIdType
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r FrontDeskOperationsAPIGetServiceRequestsRequest) ProfileId(profileId string) FrontDeskOperationsAPIGetServiceRequestsRequest {
	r.profileId = &profileId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r FrontDeskOperationsAPIGetServiceRequestsRequest) ProfileIdContext(profileIdContext string) FrontDeskOperationsAPIGetServiceRequestsRequest {
	r.profileIdContext = &profileIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r FrontDeskOperationsAPIGetServiceRequestsRequest) ProfileIdType(profileIdType string) FrontDeskOperationsAPIGetServiceRequestsRequest {
	r.profileIdType = &profileIdType
	return r
}

// The room number in which the service request was created.
func (r FrontDeskOperationsAPIGetServiceRequestsRequest) Room(room string) FrontDeskOperationsAPIGetServiceRequestsRequest {
	r.room = &room
	return r
}

// The ending value of the date range.
func (r FrontDeskOperationsAPIGetServiceRequestsRequest) CreationEndDate(creationEndDate string) FrontDeskOperationsAPIGetServiceRequestsRequest {
	r.creationEndDate = &creationEndDate
	return r
}

// The starting value of the date range.
func (r FrontDeskOperationsAPIGetServiceRequestsRequest) CreationStartDate(creationStartDate string) FrontDeskOperationsAPIGetServiceRequestsRequest {
	r.creationStartDate = &creationStartDate
	return r
}

// The ending value of the date range.
func (r FrontDeskOperationsAPIGetServiceRequestsRequest) ClosedEndDate(closedEndDate string) FrontDeskOperationsAPIGetServiceRequestsRequest {
	r.closedEndDate = &closedEndDate
	return r
}

// The starting value of the date range.
func (r FrontDeskOperationsAPIGetServiceRequestsRequest) ClosedStartDate(closedStartDate string) FrontDeskOperationsAPIGetServiceRequestsRequest {
	r.closedStartDate = &closedStartDate
	return r
}

// External system code.
func (r FrontDeskOperationsAPIGetServiceRequestsRequest) XExternalsystem(xExternalsystem string) FrontDeskOperationsAPIGetServiceRequestsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r FrontDeskOperationsAPIGetServiceRequestsRequest) AcceptLanguage(acceptLanguage string) FrontDeskOperationsAPIGetServiceRequestsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r FrontDeskOperationsAPIGetServiceRequestsRequest) Execute() (*ServiceRequestsInfo, *http.Response, error) {
	return r.ApiService.GetServiceRequestsExecute(r)
}

/*
GetServiceRequests Get Service Requests

Use this API to retrieve any service requests that exist on a reservation. <p><strong>OperationId:</strong>getServiceRequests</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId
 @return FrontDeskOperationsAPIGetServiceRequestsRequest
*/
func (a *FrontDeskOperationsAPIService) GetServiceRequests(ctx context.Context, hotelId string) FrontDeskOperationsAPIGetServiceRequestsRequest {
	return FrontDeskOperationsAPIGetServiceRequestsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ServiceRequestsInfo
func (a *FrontDeskOperationsAPIService) GetServiceRequestsExecute(r FrontDeskOperationsAPIGetServiceRequestsRequest) (*ServiceRequestsInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServiceRequestsInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FrontDeskOperationsAPIService.GetServiceRequests")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/serviceRequests"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.hotelIds != nil {
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
  }
	if r.code != nil {
		t := *r.code
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "code", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "code", t, "multi")
		}
  }
	if r.status != nil {
		t := *r.status
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status", t, "multi")
		}
  }
	if r.priorityCodes != nil {
		t := *r.priorityCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "priorityCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "priorityCodes", t, "multi")
		}
  }
	if r.departmentCodes != nil {
		t := *r.departmentCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "departmentCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "departmentCodes", t, "multi")
		}
  }
	if r.reservationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationId", r.reservationId, "")
  }
	if r.reservationIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIdContext", r.reservationIdContext, "")
  }
	if r.reservationIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIdType", r.reservationIdType, "")
  }
	if r.profileId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileId", r.profileId, "")
  }
	if r.profileIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileIdContext", r.profileIdContext, "")
  }
	if r.profileIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileIdType", r.profileIdType, "")
  }
	if r.room != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "room", r.room, "")
  }
	if r.creationEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creationEndDate", r.creationEndDate, "")
  }
	if r.creationStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creationStartDate", r.creationStartDate, "")
  }
	if r.closedEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "closedEndDate", r.closedEndDate, "")
  }
	if r.closedStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "closedStartDate", r.closedStartDate, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FrontDeskOperationsAPIGetSuggestedRoomsRequest struct {
	ctx context.Context
	ApiService *FrontDeskOperationsAPIService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	roomType *string
	startDate *string
	nights *int32
	suggestedRoomsInstructions *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r FrontDeskOperationsAPIGetSuggestedRoomsRequest) Authorization(authorization string) FrontDeskOperationsAPIGetSuggestedRoomsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r FrontDeskOperationsAPIGetSuggestedRoomsRequest) XAppKey(xAppKey string) FrontDeskOperationsAPIGetSuggestedRoomsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r FrontDeskOperationsAPIGetSuggestedRoomsRequest) XHotelid(xHotelid string) FrontDeskOperationsAPIGetSuggestedRoomsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Used for codes in the OPERA Code tables. Possible values of this pattern are 1, 101, 101.EQP, or 101.EQP.X.
func (r FrontDeskOperationsAPIGetSuggestedRoomsRequest) RoomType(roomType string) FrontDeskOperationsAPIGetSuggestedRoomsRequest {
	r.roomType = &roomType
	return r
}

// Date of arrival.
func (r FrontDeskOperationsAPIGetSuggestedRoomsRequest) StartDate(startDate string) FrontDeskOperationsAPIGetSuggestedRoomsRequest {
	r.startDate = &startDate
	return r
}

// Number of nights that guest will be staying.
func (r FrontDeskOperationsAPIGetSuggestedRoomsRequest) Nights(nights int32) FrontDeskOperationsAPIGetSuggestedRoomsRequest {
	r.nights = &nights
	return r
}

// Instruction to include commponent room.
func (r FrontDeskOperationsAPIGetSuggestedRoomsRequest) SuggestedRoomsInstructions(suggestedRoomsInstructions []string) FrontDeskOperationsAPIGetSuggestedRoomsRequest {
	r.suggestedRoomsInstructions = &suggestedRoomsInstructions
	return r
}

// External system code.
func (r FrontDeskOperationsAPIGetSuggestedRoomsRequest) XExternalsystem(xExternalsystem string) FrontDeskOperationsAPIGetSuggestedRoomsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r FrontDeskOperationsAPIGetSuggestedRoomsRequest) AcceptLanguage(acceptLanguage string) FrontDeskOperationsAPIGetSuggestedRoomsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r FrontDeskOperationsAPIGetSuggestedRoomsRequest) Execute() (*SuggestedRooms, *http.Response, error) {
	return r.ApiService.GetSuggestedRoomsExecute(r)
}

/*
GetSuggestedRooms Get Suggested Rooms

You can use this API to fetch the suggested rooms. <p><strong>OperationId:</strong>getSuggestedRooms</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique reservation identifier for the reservation.
 @param hotelId Property where the reservation exists.
 @return FrontDeskOperationsAPIGetSuggestedRoomsRequest
*/
func (a *FrontDeskOperationsAPIService) GetSuggestedRooms(ctx context.Context, reservationId string, hotelId string) FrontDeskOperationsAPIGetSuggestedRoomsRequest {
	return FrontDeskOperationsAPIGetSuggestedRoomsRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return SuggestedRooms
func (a *FrontDeskOperationsAPIService) GetSuggestedRoomsExecute(r FrontDeskOperationsAPIGetSuggestedRoomsRequest) (*SuggestedRooms, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SuggestedRooms
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FrontDeskOperationsAPIService.GetSuggestedRooms")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/suggestedRooms"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.roomType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomType", r.roomType, "")
  }
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
  }
	if r.nights != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nights", r.nights, "")
  }
	if r.suggestedRoomsInstructions != nil {
		t := *r.suggestedRoomsInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "suggestedRoomsInstructions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "suggestedRoomsInstructions", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FrontDeskOperationsAPIGetWakeUpCallRequest struct {
	ctx context.Context
	ApiService *FrontDeskOperationsAPIService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	fetchCancelled *bool
	fetchCompleted *bool
	fetchNoAnswer *bool
	fetchPending *bool
	idExtension *int32
	reservationIdContext *string
	reservationIdType *string
	beginDate *string
	endDate *string
	beginTime *string
	endTime *string
	room *[]string
	blockId *string
	guestName *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r FrontDeskOperationsAPIGetWakeUpCallRequest) Authorization(authorization string) FrontDeskOperationsAPIGetWakeUpCallRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r FrontDeskOperationsAPIGetWakeUpCallRequest) XAppKey(xAppKey string) FrontDeskOperationsAPIGetWakeUpCallRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r FrontDeskOperationsAPIGetWakeUpCallRequest) XHotelid(xHotelid string) FrontDeskOperationsAPIGetWakeUpCallRequest {
	r.xHotelid = &xHotelid
	return r
}

// Specifies whether we should fetch wake up calls with pending status.
func (r FrontDeskOperationsAPIGetWakeUpCallRequest) FetchCancelled(fetchCancelled bool) FrontDeskOperationsAPIGetWakeUpCallRequest {
	r.fetchCancelled = &fetchCancelled
	return r
}

// Specifies whether we should fetch wake up calls with pending status.
func (r FrontDeskOperationsAPIGetWakeUpCallRequest) FetchCompleted(fetchCompleted bool) FrontDeskOperationsAPIGetWakeUpCallRequest {
	r.fetchCompleted = &fetchCompleted
	return r
}

// Specifies whether we should fetch wake up calls with pending status.
func (r FrontDeskOperationsAPIGetWakeUpCallRequest) FetchNoAnswer(fetchNoAnswer bool) FrontDeskOperationsAPIGetWakeUpCallRequest {
	r.fetchNoAnswer = &fetchNoAnswer
	return r
}

// Specifies whether we should fetch wake up calls with pending status.
func (r FrontDeskOperationsAPIGetWakeUpCallRequest) FetchPending(fetchPending bool) FrontDeskOperationsAPIGetWakeUpCallRequest {
	r.fetchPending = &fetchPending
	return r
}

// Additional identifying value assigned by the creating system.
func (r FrontDeskOperationsAPIGetWakeUpCallRequest) IdExtension(idExtension int32) FrontDeskOperationsAPIGetWakeUpCallRequest {
	r.idExtension = &idExtension
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r FrontDeskOperationsAPIGetWakeUpCallRequest) ReservationIdContext(reservationIdContext string) FrontDeskOperationsAPIGetWakeUpCallRequest {
	r.reservationIdContext = &reservationIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r FrontDeskOperationsAPIGetWakeUpCallRequest) ReservationIdType(reservationIdType string) FrontDeskOperationsAPIGetWakeUpCallRequest {
	r.reservationIdType = &reservationIdType
	return r
}

// Begin date from which to start fetching wake up calls.
func (r FrontDeskOperationsAPIGetWakeUpCallRequest) BeginDate(beginDate string) FrontDeskOperationsAPIGetWakeUpCallRequest {
	r.beginDate = &beginDate
	return r
}

// End date from which to start fetching wake up calls.
func (r FrontDeskOperationsAPIGetWakeUpCallRequest) EndDate(endDate string) FrontDeskOperationsAPIGetWakeUpCallRequest {
	r.endDate = &endDate
	return r
}

// Begin time from which to start fetching wake up calls.
func (r FrontDeskOperationsAPIGetWakeUpCallRequest) BeginTime(beginTime string) FrontDeskOperationsAPIGetWakeUpCallRequest {
	r.beginTime = &beginTime
	return r
}

// End time from which to start fetching wake up calls.
func (r FrontDeskOperationsAPIGetWakeUpCallRequest) EndTime(endTime string) FrontDeskOperationsAPIGetWakeUpCallRequest {
	r.endTime = &endTime
	return r
}

// Hotel room(s) for which wake up calls are to be fetched.
func (r FrontDeskOperationsAPIGetWakeUpCallRequest) Room(room []string) FrontDeskOperationsAPIGetWakeUpCallRequest {
	r.room = &room
	return r
}

// Block code for which wake up calls are to be fetched.
func (r FrontDeskOperationsAPIGetWakeUpCallRequest) BlockId(blockId string) FrontDeskOperationsAPIGetWakeUpCallRequest {
	r.blockId = &blockId
	return r
}

// Name with which wake up call may be associated.
func (r FrontDeskOperationsAPIGetWakeUpCallRequest) GuestName(guestName string) FrontDeskOperationsAPIGetWakeUpCallRequest {
	r.guestName = &guestName
	return r
}

// External system code.
func (r FrontDeskOperationsAPIGetWakeUpCallRequest) XExternalsystem(xExternalsystem string) FrontDeskOperationsAPIGetWakeUpCallRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r FrontDeskOperationsAPIGetWakeUpCallRequest) AcceptLanguage(acceptLanguage string) FrontDeskOperationsAPIGetWakeUpCallRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r FrontDeskOperationsAPIGetWakeUpCallRequest) Execute() (*WakeUpCalls, *http.Response, error) {
	return r.ApiService.GetWakeUpCallExecute(r)
}

/*
GetWakeUpCall Get Wake Up Call

Use thisAPI to get existing wake up call on an in-house reservation. <p><strong>OperationId:</strong>getWakeUpCall</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId
 @param hotelId
 @return FrontDeskOperationsAPIGetWakeUpCallRequest
*/
func (a *FrontDeskOperationsAPIService) GetWakeUpCall(ctx context.Context, reservationId string, hotelId string) FrontDeskOperationsAPIGetWakeUpCallRequest {
	return FrontDeskOperationsAPIGetWakeUpCallRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return WakeUpCalls
func (a *FrontDeskOperationsAPIService) GetWakeUpCallExecute(r FrontDeskOperationsAPIGetWakeUpCallRequest) (*WakeUpCalls, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WakeUpCalls
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FrontDeskOperationsAPIService.GetWakeUpCall")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/wakeUpCalls"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.fetchCancelled != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetchCancelled", r.fetchCancelled, "")
  }
	if r.fetchCompleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetchCompleted", r.fetchCompleted, "")
  }
	if r.fetchNoAnswer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetchNoAnswer", r.fetchNoAnswer, "")
  }
	if r.fetchPending != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetchPending", r.fetchPending, "")
  }
	if r.idExtension != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idExtension", r.idExtension, "")
  }
	if r.reservationIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIdContext", r.reservationIdContext, "")
  }
	if r.reservationIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIdType", r.reservationIdType, "")
  }
	if r.beginDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "beginDate", r.beginDate, "")
  }
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
  }
	if r.beginTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "beginTime", r.beginTime, "")
  }
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "")
  }
	if r.room != nil {
		t := *r.room
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "room", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "room", t, "multi")
		}
  }
	if r.blockId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blockId", r.blockId, "")
  }
	if r.guestName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "guestName", r.guestName, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FrontDeskOperationsAPIMoveInHouseGuestRequest struct {
	ctx context.Context
	ApiService *FrontDeskOperationsAPIService
	roomId string
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	moveInHouseGuest *MoveInHouseGuest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r FrontDeskOperationsAPIMoveInHouseGuestRequest) Authorization(authorization string) FrontDeskOperationsAPIMoveInHouseGuestRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r FrontDeskOperationsAPIMoveInHouseGuestRequest) XAppKey(xAppKey string) FrontDeskOperationsAPIMoveInHouseGuestRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r FrontDeskOperationsAPIMoveInHouseGuestRequest) XHotelid(xHotelid string) FrontDeskOperationsAPIMoveInHouseGuestRequest {
	r.xHotelid = &xHotelid
	return r
}

// To move a reservation, the reservation needs to be in Checked-In state.
func (r FrontDeskOperationsAPIMoveInHouseGuestRequest) MoveInHouseGuest(moveInHouseGuest MoveInHouseGuest) FrontDeskOperationsAPIMoveInHouseGuestRequest {
	r.moveInHouseGuest = &moveInHouseGuest
	return r
}

// External system code.
func (r FrontDeskOperationsAPIMoveInHouseGuestRequest) XExternalsystem(xExternalsystem string) FrontDeskOperationsAPIMoveInHouseGuestRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r FrontDeskOperationsAPIMoveInHouseGuestRequest) AcceptLanguage(acceptLanguage string) FrontDeskOperationsAPIMoveInHouseGuestRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r FrontDeskOperationsAPIMoveInHouseGuestRequest) Execute() (*MovedInHouseGuest, *http.Response, error) {
	return r.ApiService.MoveInHouseGuestExecute(r)
}

/*
MoveInHouseGuest Move in-house guest

This API will allow you to change rooms for an in-house guest. <p><strong>OperationId:</strong>moveInHouseGuest</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param roomId
 @param reservationId
 @param hotelId
 @return FrontDeskOperationsAPIMoveInHouseGuestRequest
*/
func (a *FrontDeskOperationsAPIService) MoveInHouseGuest(ctx context.Context, roomId string, reservationId string, hotelId string) FrontDeskOperationsAPIMoveInHouseGuestRequest {
	return FrontDeskOperationsAPIMoveInHouseGuestRequest{
		ApiService: a,
		ctx: ctx,
		roomId: roomId,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return MovedInHouseGuest
func (a *FrontDeskOperationsAPIService) MoveInHouseGuestExecute(r FrontDeskOperationsAPIMoveInHouseGuestRequest) (*MovedInHouseGuest, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MovedInHouseGuest
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FrontDeskOperationsAPIService.MoveInHouseGuest")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/rooms/{roomId}/roomMoves"
	localVarPath = strings.Replace(localVarPath, "{"+"roomId"+"}", url.PathEscape(parameterValueToString(r.roomId, "roomId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.roomId) < 1 {
		return localVarReturnValue, nil, reportError("roomId must have at least 1 elements")
	}
	if strlen(r.roomId) > 2000 {
		return localVarReturnValue, nil, reportError("roomId must have less than 2000 elements")
	}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.moveInHouseGuest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FrontDeskOperationsAPIPlaceRoomsOnHoldRequest struct {
	ctx context.Context
	ApiService *FrontDeskOperationsAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	holdRooms *HoldRooms
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r FrontDeskOperationsAPIPlaceRoomsOnHoldRequest) Authorization(authorization string) FrontDeskOperationsAPIPlaceRoomsOnHoldRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r FrontDeskOperationsAPIPlaceRoomsOnHoldRequest) XAppKey(xAppKey string) FrontDeskOperationsAPIPlaceRoomsOnHoldRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r FrontDeskOperationsAPIPlaceRoomsOnHoldRequest) XHotelid(xHotelid string) FrontDeskOperationsAPIPlaceRoomsOnHoldRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to place rooms on hold.
func (r FrontDeskOperationsAPIPlaceRoomsOnHoldRequest) HoldRooms(holdRooms HoldRooms) FrontDeskOperationsAPIPlaceRoomsOnHoldRequest {
	r.holdRooms = &holdRooms
	return r
}

// External system code.
func (r FrontDeskOperationsAPIPlaceRoomsOnHoldRequest) XExternalsystem(xExternalsystem string) FrontDeskOperationsAPIPlaceRoomsOnHoldRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r FrontDeskOperationsAPIPlaceRoomsOnHoldRequest) AcceptLanguage(acceptLanguage string) FrontDeskOperationsAPIPlaceRoomsOnHoldRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r FrontDeskOperationsAPIPlaceRoomsOnHoldRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PlaceRoomsOnHoldExecute(r)
}

/*
PlaceRoomsOnHold Place Rooms On Hold

You can use this API to place Rooms On Hold. <p><strong>OperationId:</strong>placeRoomsOnHold</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId
 @return FrontDeskOperationsAPIPlaceRoomsOnHoldRequest
*/
func (a *FrontDeskOperationsAPIService) PlaceRoomsOnHold(ctx context.Context, hotelId string) FrontDeskOperationsAPIPlaceRoomsOnHoldRequest {
	return FrontDeskOperationsAPIPlaceRoomsOnHoldRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *FrontDeskOperationsAPIService) PlaceRoomsOnHoldExecute(r FrontDeskOperationsAPIPlaceRoomsOnHoldRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FrontDeskOperationsAPIService.PlaceRoomsOnHold")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/rooms/onHold"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.holdRooms
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FrontDeskOperationsAPIPostAdvanceCheckInRequest struct {
	ctx context.Context
	ApiService *FrontDeskOperationsAPIService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	advanceCheckInReservation *AdvanceCheckInReservation
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r FrontDeskOperationsAPIPostAdvanceCheckInRequest) Authorization(authorization string) FrontDeskOperationsAPIPostAdvanceCheckInRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r FrontDeskOperationsAPIPostAdvanceCheckInRequest) XAppKey(xAppKey string) FrontDeskOperationsAPIPostAdvanceCheckInRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r FrontDeskOperationsAPIPostAdvanceCheckInRequest) XHotelid(xHotelid string) FrontDeskOperationsAPIPostAdvanceCheckInRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to perform Advance Check In of a Reservation.
func (r FrontDeskOperationsAPIPostAdvanceCheckInRequest) AdvanceCheckInReservation(advanceCheckInReservation AdvanceCheckInReservation) FrontDeskOperationsAPIPostAdvanceCheckInRequest {
	r.advanceCheckInReservation = &advanceCheckInReservation
	return r
}

// External system code.
func (r FrontDeskOperationsAPIPostAdvanceCheckInRequest) XExternalsystem(xExternalsystem string) FrontDeskOperationsAPIPostAdvanceCheckInRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r FrontDeskOperationsAPIPostAdvanceCheckInRequest) AcceptLanguage(acceptLanguage string) FrontDeskOperationsAPIPostAdvanceCheckInRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r FrontDeskOperationsAPIPostAdvanceCheckInRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostAdvanceCheckInExecute(r)
}

/*
PostAdvanceCheckIn Advance checkin a reservation

At times, when guests arrive to the property prior to a room being ready, you can flag a reservation as Advance Checked In for arrivals due in on the current business date. This enables guests to post charges to their reservation folio prior to check in, and helps the rooms management team prioritize room cleaning and assignment. Individual reservations (including Walk In reservations, Pre Registered reservations, and reservations that are in Queue) and group block reservations can be Advance Checked In. <p><strong>OperationId:</strong>postAdvanceCheckIn</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId
 @param hotelId
 @return FrontDeskOperationsAPIPostAdvanceCheckInRequest
*/
func (a *FrontDeskOperationsAPIService) PostAdvanceCheckIn(ctx context.Context, reservationId string, hotelId string) FrontDeskOperationsAPIPostAdvanceCheckInRequest {
	return FrontDeskOperationsAPIPostAdvanceCheckInRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *FrontDeskOperationsAPIService) PostAdvanceCheckInExecute(r FrontDeskOperationsAPIPostAdvanceCheckInRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FrontDeskOperationsAPIService.PostAdvanceCheckIn")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/advanceCheckIns"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.advanceCheckInReservation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FrontDeskOperationsAPIPostCheckInRequest struct {
	ctx context.Context
	ApiService *FrontDeskOperationsAPIService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	reservation *PostCheckInRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r FrontDeskOperationsAPIPostCheckInRequest) Authorization(authorization string) FrontDeskOperationsAPIPostCheckInRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r FrontDeskOperationsAPIPostCheckInRequest) XAppKey(xAppKey string) FrontDeskOperationsAPIPostCheckInRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r FrontDeskOperationsAPIPostCheckInRequest) XHotelid(xHotelid string) FrontDeskOperationsAPIPostCheckInRequest {
	r.xHotelid = &xHotelid
	return r
}

// Validation checks includes the following: - Reservation is not valid to be checked in. - Split is still required before the reservation can be checked in. - Room information is missing. - Payment information is missing. - The status of the room needs to be reviewed. - Sharers was impacted. The check-in process affected the reservation details of shared guests on the reservation. - Sharers was not impacted. The check-in process has not affected the reservation details of shared guests on the reservation.
func (r FrontDeskOperationsAPIPostCheckInRequest) Reservation(reservation PostCheckInRequest) FrontDeskOperationsAPIPostCheckInRequest {
	r.reservation = &reservation
	return r
}

// External system code.
func (r FrontDeskOperationsAPIPostCheckInRequest) XExternalsystem(xExternalsystem string) FrontDeskOperationsAPIPostCheckInRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r FrontDeskOperationsAPIPostCheckInRequest) AcceptLanguage(acceptLanguage string) FrontDeskOperationsAPIPostCheckInRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r FrontDeskOperationsAPIPostCheckInRequest) Execute() (*CheckedinReservation, *http.Response, error) {
	return r.ApiService.PostCheckInExecute(r)
}

/*
PostCheckIn Checks in a guest

Use this API to check in a guest reservation.  The reservation needs to be 'due in' status.  The API also provides an option to select an available room. <p><strong>OperationId:</strong>postCheckIn</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel where reservation is being booked
 @return FrontDeskOperationsAPIPostCheckInRequest
*/
func (a *FrontDeskOperationsAPIService) PostCheckIn(ctx context.Context, reservationId string, hotelId string) FrontDeskOperationsAPIPostCheckInRequest {
	return FrontDeskOperationsAPIPostCheckInRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CheckedinReservation
func (a *FrontDeskOperationsAPIService) PostCheckInExecute(r FrontDeskOperationsAPIPostCheckInRequest) (*CheckedinReservation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CheckedinReservation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FrontDeskOperationsAPIService.PostCheckIn")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/checkIns"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.reservation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FrontDeskOperationsAPIPostDailyDocketRequest struct {
	ctx context.Context
	ApiService *FrontDeskOperationsAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	dailyDocket *DailyDocket
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r FrontDeskOperationsAPIPostDailyDocketRequest) Authorization(authorization string) FrontDeskOperationsAPIPostDailyDocketRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r FrontDeskOperationsAPIPostDailyDocketRequest) XAppKey(xAppKey string) FrontDeskOperationsAPIPostDailyDocketRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r FrontDeskOperationsAPIPostDailyDocketRequest) XHotelid(xHotelid string) FrontDeskOperationsAPIPostDailyDocketRequest {
	r.xHotelid = &xHotelid
	return r
}

// Add log book entries.
func (r FrontDeskOperationsAPIPostDailyDocketRequest) DailyDocket(dailyDocket DailyDocket) FrontDeskOperationsAPIPostDailyDocketRequest {
	r.dailyDocket = &dailyDocket
	return r
}

// External system code.
func (r FrontDeskOperationsAPIPostDailyDocketRequest) XExternalsystem(xExternalsystem string) FrontDeskOperationsAPIPostDailyDocketRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r FrontDeskOperationsAPIPostDailyDocketRequest) AcceptLanguage(acceptLanguage string) FrontDeskOperationsAPIPostDailyDocketRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r FrontDeskOperationsAPIPostDailyDocketRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostDailyDocketExecute(r)
}

/*
PostDailyDocket Create Daily Docket 

Use this API to create a Daily Docket. <p><strong>OperationId:</strong>postDailyDocket</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId
 @return FrontDeskOperationsAPIPostDailyDocketRequest
*/
func (a *FrontDeskOperationsAPIService) PostDailyDocket(ctx context.Context, hotelId string) FrontDeskOperationsAPIPostDailyDocketRequest {
	return FrontDeskOperationsAPIPostDailyDocketRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *FrontDeskOperationsAPIService) PostDailyDocketExecute(r FrontDeskOperationsAPIPostDailyDocketRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FrontDeskOperationsAPIService.PostDailyDocket")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/dailyDocket"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.dailyDocket
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FrontDeskOperationsAPIPostMassAdvanceCheckInRequest struct {
	ctx context.Context
	ApiService *FrontDeskOperationsAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	massAdvanceCheckInReservations *MassAdvanceCheckInReservations
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r FrontDeskOperationsAPIPostMassAdvanceCheckInRequest) Authorization(authorization string) FrontDeskOperationsAPIPostMassAdvanceCheckInRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r FrontDeskOperationsAPIPostMassAdvanceCheckInRequest) XAppKey(xAppKey string) FrontDeskOperationsAPIPostMassAdvanceCheckInRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r FrontDeskOperationsAPIPostMassAdvanceCheckInRequest) XHotelid(xHotelid string) FrontDeskOperationsAPIPostMassAdvanceCheckInRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to Submit Batch job for Mass Advance Check In of Reservations.
func (r FrontDeskOperationsAPIPostMassAdvanceCheckInRequest) MassAdvanceCheckInReservations(massAdvanceCheckInReservations MassAdvanceCheckInReservations) FrontDeskOperationsAPIPostMassAdvanceCheckInRequest {
	r.massAdvanceCheckInReservations = &massAdvanceCheckInReservations
	return r
}

// External system code.
func (r FrontDeskOperationsAPIPostMassAdvanceCheckInRequest) XExternalsystem(xExternalsystem string) FrontDeskOperationsAPIPostMassAdvanceCheckInRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r FrontDeskOperationsAPIPostMassAdvanceCheckInRequest) AcceptLanguage(acceptLanguage string) FrontDeskOperationsAPIPostMassAdvanceCheckInRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r FrontDeskOperationsAPIPostMassAdvanceCheckInRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostMassAdvanceCheckInExecute(r)
}

/*
PostMassAdvanceCheckIn Mass Advance Check in Reservations

Use this API to perform a mass advance checkin for reservations. <p><strong>OperationId:</strong>postMassAdvanceCheckIn</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId
 @return FrontDeskOperationsAPIPostMassAdvanceCheckInRequest
*/
func (a *FrontDeskOperationsAPIService) PostMassAdvanceCheckIn(ctx context.Context, hotelId string) FrontDeskOperationsAPIPostMassAdvanceCheckInRequest {
	return FrontDeskOperationsAPIPostMassAdvanceCheckInRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *FrontDeskOperationsAPIService) PostMassAdvanceCheckInExecute(r FrontDeskOperationsAPIPostMassAdvanceCheckInRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FrontDeskOperationsAPIService.PostMassAdvanceCheckIn")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/massAdvanceCheckIns"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.massAdvanceCheckInReservations
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FrontDeskOperationsAPIPostMassCheckInRequest struct {
	ctx context.Context
	ApiService *FrontDeskOperationsAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	massCheckInReservations *MassCheckInReservations
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r FrontDeskOperationsAPIPostMassCheckInRequest) Authorization(authorization string) FrontDeskOperationsAPIPostMassCheckInRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r FrontDeskOperationsAPIPostMassCheckInRequest) XAppKey(xAppKey string) FrontDeskOperationsAPIPostMassCheckInRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r FrontDeskOperationsAPIPostMassCheckInRequest) XHotelid(xHotelid string) FrontDeskOperationsAPIPostMassCheckInRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to Submit Batch job for Mass Checkin of Reservations.
func (r FrontDeskOperationsAPIPostMassCheckInRequest) MassCheckInReservations(massCheckInReservations MassCheckInReservations) FrontDeskOperationsAPIPostMassCheckInRequest {
	r.massCheckInReservations = &massCheckInReservations
	return r
}

// External system code.
func (r FrontDeskOperationsAPIPostMassCheckInRequest) XExternalsystem(xExternalsystem string) FrontDeskOperationsAPIPostMassCheckInRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r FrontDeskOperationsAPIPostMassCheckInRequest) AcceptLanguage(acceptLanguage string) FrontDeskOperationsAPIPostMassCheckInRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r FrontDeskOperationsAPIPostMassCheckInRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostMassCheckInExecute(r)
}

/*
PostMassCheckIn Mass checkin reservations

Use this API to perform a mass Checkin for reservations. <p><strong>OperationId:</strong>postMassCheckIn</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId
 @return FrontDeskOperationsAPIPostMassCheckInRequest
*/
func (a *FrontDeskOperationsAPIService) PostMassCheckIn(ctx context.Context, hotelId string) FrontDeskOperationsAPIPostMassCheckInRequest {
	return FrontDeskOperationsAPIPostMassCheckInRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *FrontDeskOperationsAPIService) PostMassCheckInExecute(r FrontDeskOperationsAPIPostMassCheckInRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FrontDeskOperationsAPIService.PostMassCheckIn")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/massCheckIns"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.massCheckInReservations
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FrontDeskOperationsAPIPostRoomAssignmentRequest struct {
	ctx context.Context
	ApiService *FrontDeskOperationsAPIService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	room *Room
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r FrontDeskOperationsAPIPostRoomAssignmentRequest) Authorization(authorization string) FrontDeskOperationsAPIPostRoomAssignmentRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r FrontDeskOperationsAPIPostRoomAssignmentRequest) XAppKey(xAppKey string) FrontDeskOperationsAPIPostRoomAssignmentRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r FrontDeskOperationsAPIPostRoomAssignmentRequest) XHotelid(xHotelid string) FrontDeskOperationsAPIPostRoomAssignmentRequest {
	r.xHotelid = &xHotelid
	return r
}

// The reservation must still be reserved to use this operation.
func (r FrontDeskOperationsAPIPostRoomAssignmentRequest) Room(room Room) FrontDeskOperationsAPIPostRoomAssignmentRequest {
	r.room = &room
	return r
}

// External system code.
func (r FrontDeskOperationsAPIPostRoomAssignmentRequest) XExternalsystem(xExternalsystem string) FrontDeskOperationsAPIPostRoomAssignmentRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r FrontDeskOperationsAPIPostRoomAssignmentRequest) AcceptLanguage(acceptLanguage string) FrontDeskOperationsAPIPostRoomAssignmentRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r FrontDeskOperationsAPIPostRoomAssignmentRequest) Execute() (*AssignedRoom, *http.Response, error) {
	return r.ApiService.PostRoomAssignmentExecute(r)
}

/*
PostRoomAssignment Assign a Room to a Reservation

This API will allow you to assign a room to a reservation in reserved status. Override instructions are available to assign a room despite warnings returned in the response message. <p><strong>OperationId:</strong>postRoomAssignment</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId
 @param hotelId
 @return FrontDeskOperationsAPIPostRoomAssignmentRequest
*/
func (a *FrontDeskOperationsAPIService) PostRoomAssignment(ctx context.Context, reservationId string, hotelId string) FrontDeskOperationsAPIPostRoomAssignmentRequest {
	return FrontDeskOperationsAPIPostRoomAssignmentRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return AssignedRoom
func (a *FrontDeskOperationsAPIService) PostRoomAssignmentExecute(r FrontDeskOperationsAPIPostRoomAssignmentRequest) (*AssignedRoom, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AssignedRoom
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FrontDeskOperationsAPIService.PostRoomAssignment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/roomAssignments"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.room
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FrontDeskOperationsAPIPostRoomKeyRequest struct {
	ctx context.Context
	ApiService *FrontDeskOperationsAPIService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	roomKey *RoomKey
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r FrontDeskOperationsAPIPostRoomKeyRequest) Authorization(authorization string) FrontDeskOperationsAPIPostRoomKeyRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r FrontDeskOperationsAPIPostRoomKeyRequest) XAppKey(xAppKey string) FrontDeskOperationsAPIPostRoomKeyRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r FrontDeskOperationsAPIPostRoomKeyRequest) XHotelid(xHotelid string) FrontDeskOperationsAPIPostRoomKeyRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request for generation of room key.
func (r FrontDeskOperationsAPIPostRoomKeyRequest) RoomKey(roomKey RoomKey) FrontDeskOperationsAPIPostRoomKeyRequest {
	r.roomKey = &roomKey
	return r
}

// External system code.
func (r FrontDeskOperationsAPIPostRoomKeyRequest) XExternalsystem(xExternalsystem string) FrontDeskOperationsAPIPostRoomKeyRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r FrontDeskOperationsAPIPostRoomKeyRequest) AcceptLanguage(acceptLanguage string) FrontDeskOperationsAPIPostRoomKeyRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r FrontDeskOperationsAPIPostRoomKeyRequest) Execute() (*RoomKeyDetails, *http.Response, error) {
	return r.ApiService.PostRoomKeyExecute(r)
}

/*
PostRoomKey Requests room key(s)

You can use this API to create a room key request for a reservation to the active Door Locking System Property Interface. <p><strong>OperationId:</strong>postRoomKey</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId
 @param hotelId
 @return FrontDeskOperationsAPIPostRoomKeyRequest
*/
func (a *FrontDeskOperationsAPIService) PostRoomKey(ctx context.Context, reservationId string, hotelId string) FrontDeskOperationsAPIPostRoomKeyRequest {
	return FrontDeskOperationsAPIPostRoomKeyRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return RoomKeyDetails
func (a *FrontDeskOperationsAPIService) PostRoomKeyExecute(r FrontDeskOperationsAPIPostRoomKeyRequest) (*RoomKeyDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RoomKeyDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FrontDeskOperationsAPIService.PostRoomKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/roomKeys"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.roomKey
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FrontDeskOperationsAPIPostServiceRequestsRequest struct {
	ctx context.Context
	ApiService *FrontDeskOperationsAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	serviceRequestsInfo *ServiceRequestsInfo
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r FrontDeskOperationsAPIPostServiceRequestsRequest) Authorization(authorization string) FrontDeskOperationsAPIPostServiceRequestsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r FrontDeskOperationsAPIPostServiceRequestsRequest) XAppKey(xAppKey string) FrontDeskOperationsAPIPostServiceRequestsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r FrontDeskOperationsAPIPostServiceRequestsRequest) XHotelid(xHotelid string) FrontDeskOperationsAPIPostServiceRequestsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Add new service request.
func (r FrontDeskOperationsAPIPostServiceRequestsRequest) ServiceRequestsInfo(serviceRequestsInfo ServiceRequestsInfo) FrontDeskOperationsAPIPostServiceRequestsRequest {
	r.serviceRequestsInfo = &serviceRequestsInfo
	return r
}

// External system code.
func (r FrontDeskOperationsAPIPostServiceRequestsRequest) XExternalsystem(xExternalsystem string) FrontDeskOperationsAPIPostServiceRequestsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r FrontDeskOperationsAPIPostServiceRequestsRequest) AcceptLanguage(acceptLanguage string) FrontDeskOperationsAPIPostServiceRequestsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r FrontDeskOperationsAPIPostServiceRequestsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostServiceRequestsExecute(r)
}

/*
PostServiceRequests Create Service Requests

Service Request functionality provides the ability to define, track and report Service Requests on a reservation.  They go through a preset flow including creating the request, completing it and then following up on the resolution with the guest. <p><strong>OperationId:</strong>postServiceRequests</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId
 @return FrontDeskOperationsAPIPostServiceRequestsRequest
*/
func (a *FrontDeskOperationsAPIService) PostServiceRequests(ctx context.Context, hotelId string) FrontDeskOperationsAPIPostServiceRequestsRequest {
	return FrontDeskOperationsAPIPostServiceRequestsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *FrontDeskOperationsAPIService) PostServiceRequestsExecute(r FrontDeskOperationsAPIPostServiceRequestsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FrontDeskOperationsAPIService.PostServiceRequests")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/serviceRequests"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.serviceRequestsInfo
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FrontDeskOperationsAPIPostWakeUpCallRequest struct {
	ctx context.Context
	ApiService *FrontDeskOperationsAPIService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	wakeUpCalls *WakeUpCalls
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r FrontDeskOperationsAPIPostWakeUpCallRequest) Authorization(authorization string) FrontDeskOperationsAPIPostWakeUpCallRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r FrontDeskOperationsAPIPostWakeUpCallRequest) XAppKey(xAppKey string) FrontDeskOperationsAPIPostWakeUpCallRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r FrontDeskOperationsAPIPostWakeUpCallRequest) XHotelid(xHotelid string) FrontDeskOperationsAPIPostWakeUpCallRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to create a wake up call.
func (r FrontDeskOperationsAPIPostWakeUpCallRequest) WakeUpCalls(wakeUpCalls WakeUpCalls) FrontDeskOperationsAPIPostWakeUpCallRequest {
	r.wakeUpCalls = &wakeUpCalls
	return r
}

// External system code.
func (r FrontDeskOperationsAPIPostWakeUpCallRequest) XExternalsystem(xExternalsystem string) FrontDeskOperationsAPIPostWakeUpCallRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r FrontDeskOperationsAPIPostWakeUpCallRequest) AcceptLanguage(acceptLanguage string) FrontDeskOperationsAPIPostWakeUpCallRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r FrontDeskOperationsAPIPostWakeUpCallRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostWakeUpCallExecute(r)
}

/*
PostWakeUpCall Create Wake Up Call

You can set, view, and cancel wake up call for individual reservations. The reservation must be in-house (checked-in) status to set a wake up call. <p><strong>OperationId:</strong>postWakeUpCall</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId
 @param hotelId
 @return FrontDeskOperationsAPIPostWakeUpCallRequest
*/
func (a *FrontDeskOperationsAPIService) PostWakeUpCall(ctx context.Context, reservationId string, hotelId string) FrontDeskOperationsAPIPostWakeUpCallRequest {
	return FrontDeskOperationsAPIPostWakeUpCallRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *FrontDeskOperationsAPIService) PostWakeUpCallExecute(r FrontDeskOperationsAPIPostWakeUpCallRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FrontDeskOperationsAPIService.PostWakeUpCall")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/wakeUpCalls"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.wakeUpCalls
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FrontDeskOperationsAPIProcessBatchCCAuthRequest struct {
	ctx context.Context
	ApiService *FrontDeskOperationsAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	batchCCAuth *BatchCCAuth
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r FrontDeskOperationsAPIProcessBatchCCAuthRequest) Authorization(authorization string) FrontDeskOperationsAPIProcessBatchCCAuthRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r FrontDeskOperationsAPIProcessBatchCCAuthRequest) XAppKey(xAppKey string) FrontDeskOperationsAPIProcessBatchCCAuthRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r FrontDeskOperationsAPIProcessBatchCCAuthRequest) XHotelid(xHotelid string) FrontDeskOperationsAPIProcessBatchCCAuthRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to start a batch job that will process a list of reservation, and their associated payment methods, that require credit card authorizations.
func (r FrontDeskOperationsAPIProcessBatchCCAuthRequest) BatchCCAuth(batchCCAuth BatchCCAuth) FrontDeskOperationsAPIProcessBatchCCAuthRequest {
	r.batchCCAuth = &batchCCAuth
	return r
}

// External system code.
func (r FrontDeskOperationsAPIProcessBatchCCAuthRequest) XExternalsystem(xExternalsystem string) FrontDeskOperationsAPIProcessBatchCCAuthRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r FrontDeskOperationsAPIProcessBatchCCAuthRequest) AcceptLanguage(acceptLanguage string) FrontDeskOperationsAPIProcessBatchCCAuthRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r FrontDeskOperationsAPIProcessBatchCCAuthRequest) Execute() (*BatchCCAuthToProcess, *http.Response, error) {
	return r.ApiService.ProcessBatchCCAuthExecute(r)
}

/*
ProcessBatchCCAuth Process batch CC Auth

This API is used to process batch CC Authorization. <p><strong>OperationId:</strong>processBatchCCAuth</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId
 @return FrontDeskOperationsAPIProcessBatchCCAuthRequest
*/
func (a *FrontDeskOperationsAPIService) ProcessBatchCCAuth(ctx context.Context, hotelId string) FrontDeskOperationsAPIProcessBatchCCAuthRequest {
	return FrontDeskOperationsAPIProcessBatchCCAuthRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return BatchCCAuthToProcess
func (a *FrontDeskOperationsAPIService) ProcessBatchCCAuthExecute(r FrontDeskOperationsAPIProcessBatchCCAuthRequest) (*BatchCCAuthToProcess, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BatchCCAuthToProcess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FrontDeskOperationsAPIService.ProcessBatchCCAuth")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/batchReservationAuthorizations"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.batchCCAuth
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FrontDeskOperationsAPIPutDailyDocketRequest struct {
	ctx context.Context
	ApiService *FrontDeskOperationsAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	dailyDocket *DailyDocket
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r FrontDeskOperationsAPIPutDailyDocketRequest) Authorization(authorization string) FrontDeskOperationsAPIPutDailyDocketRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r FrontDeskOperationsAPIPutDailyDocketRequest) XAppKey(xAppKey string) FrontDeskOperationsAPIPutDailyDocketRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r FrontDeskOperationsAPIPutDailyDocketRequest) XHotelid(xHotelid string) FrontDeskOperationsAPIPutDailyDocketRequest {
	r.xHotelid = &xHotelid
	return r
}

// Change log book entries.
func (r FrontDeskOperationsAPIPutDailyDocketRequest) DailyDocket(dailyDocket DailyDocket) FrontDeskOperationsAPIPutDailyDocketRequest {
	r.dailyDocket = &dailyDocket
	return r
}

// External system code.
func (r FrontDeskOperationsAPIPutDailyDocketRequest) XExternalsystem(xExternalsystem string) FrontDeskOperationsAPIPutDailyDocketRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r FrontDeskOperationsAPIPutDailyDocketRequest) AcceptLanguage(acceptLanguage string) FrontDeskOperationsAPIPutDailyDocketRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r FrontDeskOperationsAPIPutDailyDocketRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutDailyDocketExecute(r)
}

/*
PutDailyDocket Change Daily Docket 

Use this API to change Daily Docket. <p><strong>OperationId:</strong>putDailyDocket</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId
 @return FrontDeskOperationsAPIPutDailyDocketRequest
*/
func (a *FrontDeskOperationsAPIService) PutDailyDocket(ctx context.Context, hotelId string) FrontDeskOperationsAPIPutDailyDocketRequest {
	return FrontDeskOperationsAPIPutDailyDocketRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *FrontDeskOperationsAPIService) PutDailyDocketExecute(r FrontDeskOperationsAPIPutDailyDocketRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FrontDeskOperationsAPIService.PutDailyDocket")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/dailyDocket"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.dailyDocket
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FrontDeskOperationsAPIPutReservationQueuePriorityRequest struct {
	ctx context.Context
	ApiService *FrontDeskOperationsAPIService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	reservationQueuePriorityNumber *ReservationQueuePriorityNumber
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r FrontDeskOperationsAPIPutReservationQueuePriorityRequest) Authorization(authorization string) FrontDeskOperationsAPIPutReservationQueuePriorityRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r FrontDeskOperationsAPIPutReservationQueuePriorityRequest) XAppKey(xAppKey string) FrontDeskOperationsAPIPutReservationQueuePriorityRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r FrontDeskOperationsAPIPutReservationQueuePriorityRequest) XHotelid(xHotelid string) FrontDeskOperationsAPIPutReservationQueuePriorityRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to change the current priority of a reservation in Queue for Check-In.
func (r FrontDeskOperationsAPIPutReservationQueuePriorityRequest) ReservationQueuePriorityNumber(reservationQueuePriorityNumber ReservationQueuePriorityNumber) FrontDeskOperationsAPIPutReservationQueuePriorityRequest {
	r.reservationQueuePriorityNumber = &reservationQueuePriorityNumber
	return r
}

// External system code.
func (r FrontDeskOperationsAPIPutReservationQueuePriorityRequest) XExternalsystem(xExternalsystem string) FrontDeskOperationsAPIPutReservationQueuePriorityRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r FrontDeskOperationsAPIPutReservationQueuePriorityRequest) AcceptLanguage(acceptLanguage string) FrontDeskOperationsAPIPutReservationQueuePriorityRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r FrontDeskOperationsAPIPutReservationQueuePriorityRequest) Execute() (*ReservationQueuePriority, *http.Response, error) {
	return r.ApiService.PutReservationQueuePriorityExecute(r)
}

/*
PutReservationQueuePriority Change the reservation queue priority

This API can be used to change the resrevations Queue Priority. <p><strong>OperationId:</strong>putReservationQueuePriority</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId
 @param hotelId
 @return FrontDeskOperationsAPIPutReservationQueuePriorityRequest
*/
func (a *FrontDeskOperationsAPIService) PutReservationQueuePriority(ctx context.Context, reservationId string, hotelId string) FrontDeskOperationsAPIPutReservationQueuePriorityRequest {
	return FrontDeskOperationsAPIPutReservationQueuePriorityRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ReservationQueuePriority
func (a *FrontDeskOperationsAPIService) PutReservationQueuePriorityExecute(r FrontDeskOperationsAPIPutReservationQueuePriorityRequest) (*ReservationQueuePriority, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReservationQueuePriority
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FrontDeskOperationsAPIService.PutReservationQueuePriority")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/priority"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.reservationQueuePriorityNumber
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FrontDeskOperationsAPIPutRoomInterfaceStatusRequest struct {
	ctx context.Context
	ApiService *FrontDeskOperationsAPIService
	interfaceId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	reservationInterface *ReservationInterface
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r FrontDeskOperationsAPIPutRoomInterfaceStatusRequest) Authorization(authorization string) FrontDeskOperationsAPIPutRoomInterfaceStatusRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r FrontDeskOperationsAPIPutRoomInterfaceStatusRequest) XAppKey(xAppKey string) FrontDeskOperationsAPIPutRoomInterfaceStatusRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r FrontDeskOperationsAPIPutRoomInterfaceStatusRequest) XHotelid(xHotelid string) FrontDeskOperationsAPIPutRoomInterfaceStatusRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to change the interface status for a reservation.
func (r FrontDeskOperationsAPIPutRoomInterfaceStatusRequest) ReservationInterface(reservationInterface ReservationInterface) FrontDeskOperationsAPIPutRoomInterfaceStatusRequest {
	r.reservationInterface = &reservationInterface
	return r
}

// External system code.
func (r FrontDeskOperationsAPIPutRoomInterfaceStatusRequest) XExternalsystem(xExternalsystem string) FrontDeskOperationsAPIPutRoomInterfaceStatusRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r FrontDeskOperationsAPIPutRoomInterfaceStatusRequest) AcceptLanguage(acceptLanguage string) FrontDeskOperationsAPIPutRoomInterfaceStatusRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r FrontDeskOperationsAPIPutRoomInterfaceStatusRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutRoomInterfaceStatusExecute(r)
}

/*
PutRoomInterfaceStatus Change room interface status

You can use this API to change room interface status. <p><strong>OperationId:</strong>putRoomInterfaceStatus</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param interfaceId
 @param hotelId
 @return FrontDeskOperationsAPIPutRoomInterfaceStatusRequest
*/
func (a *FrontDeskOperationsAPIService) PutRoomInterfaceStatus(ctx context.Context, interfaceId string, hotelId string) FrontDeskOperationsAPIPutRoomInterfaceStatusRequest {
	return FrontDeskOperationsAPIPutRoomInterfaceStatusRequest{
		ApiService: a,
		ctx: ctx,
		interfaceId: interfaceId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *FrontDeskOperationsAPIService) PutRoomInterfaceStatusExecute(r FrontDeskOperationsAPIPutRoomInterfaceStatusRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FrontDeskOperationsAPIService.PutRoomInterfaceStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/interfaces/{interfaceId}/roomStatuses"
	localVarPath = strings.Replace(localVarPath, "{"+"interfaceId"+"}", url.PathEscape(parameterValueToString(r.interfaceId, "interfaceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.interfaceId) < 1 {
		return localVarReturnValue, nil, reportError("interfaceId must have at least 1 elements")
	}
	if strlen(r.interfaceId) > 2000 {
		return localVarReturnValue, nil, reportError("interfaceId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.reservationInterface
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FrontDeskOperationsAPIPutRoomKeysRequest struct {
	ctx context.Context
	ApiService *FrontDeskOperationsAPIService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	roomKeys *RoomKeyMultipleGuests
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r FrontDeskOperationsAPIPutRoomKeysRequest) Authorization(authorization string) FrontDeskOperationsAPIPutRoomKeysRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r FrontDeskOperationsAPIPutRoomKeysRequest) XAppKey(xAppKey string) FrontDeskOperationsAPIPutRoomKeysRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r FrontDeskOperationsAPIPutRoomKeysRequest) XHotelid(xHotelid string) FrontDeskOperationsAPIPutRoomKeysRequest {
	r.xHotelid = &xHotelid
	return r
}

// Room key information
func (r FrontDeskOperationsAPIPutRoomKeysRequest) RoomKeys(roomKeys RoomKeyMultipleGuests) FrontDeskOperationsAPIPutRoomKeysRequest {
	r.roomKeys = &roomKeys
	return r
}

// External system code.
func (r FrontDeskOperationsAPIPutRoomKeysRequest) XExternalsystem(xExternalsystem string) FrontDeskOperationsAPIPutRoomKeysRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r FrontDeskOperationsAPIPutRoomKeysRequest) AcceptLanguage(acceptLanguage string) FrontDeskOperationsAPIPutRoomKeysRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r FrontDeskOperationsAPIPutRoomKeysRequest) Execute() (*UpdateRoomKeys, *http.Response, error) {
	return r.ApiService.PutRoomKeysExecute(r)
}

/*
PutRoomKeys Update room keys.

When MUTIPLE_GUEST_KEY is active this methods can be used to update information on the room keys such as balance amount and keyOptions. reservationId and hotelId are required path parameters. The body parameter roomKeys includes information about the encoder, room, key type, key validity, key options  and   guests information for multiple keys

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId
 @param hotelId
 @return FrontDeskOperationsAPIPutRoomKeysRequest
*/
func (a *FrontDeskOperationsAPIService) PutRoomKeys(ctx context.Context, reservationId string, hotelId string) FrontDeskOperationsAPIPutRoomKeysRequest {
	return FrontDeskOperationsAPIPutRoomKeysRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return UpdateRoomKeys
func (a *FrontDeskOperationsAPIService) PutRoomKeysExecute(r FrontDeskOperationsAPIPutRoomKeysRequest) (*UpdateRoomKeys, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateRoomKeys
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FrontDeskOperationsAPIService.PutRoomKeys")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/roomKeys"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.roomKeys
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FrontDeskOperationsAPIPutServiceRequestsRequest struct {
	ctx context.Context
	ApiService *FrontDeskOperationsAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	serviceRequestsInfo *ServiceRequestsInfo
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r FrontDeskOperationsAPIPutServiceRequestsRequest) Authorization(authorization string) FrontDeskOperationsAPIPutServiceRequestsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r FrontDeskOperationsAPIPutServiceRequestsRequest) XAppKey(xAppKey string) FrontDeskOperationsAPIPutServiceRequestsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r FrontDeskOperationsAPIPutServiceRequestsRequest) XHotelid(xHotelid string) FrontDeskOperationsAPIPutServiceRequestsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Change service requests.
func (r FrontDeskOperationsAPIPutServiceRequestsRequest) ServiceRequestsInfo(serviceRequestsInfo ServiceRequestsInfo) FrontDeskOperationsAPIPutServiceRequestsRequest {
	r.serviceRequestsInfo = &serviceRequestsInfo
	return r
}

// External system code.
func (r FrontDeskOperationsAPIPutServiceRequestsRequest) XExternalsystem(xExternalsystem string) FrontDeskOperationsAPIPutServiceRequestsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r FrontDeskOperationsAPIPutServiceRequestsRequest) AcceptLanguage(acceptLanguage string) FrontDeskOperationsAPIPutServiceRequestsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r FrontDeskOperationsAPIPutServiceRequestsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutServiceRequestsExecute(r)
}

/*
PutServiceRequests Change Service Requests

Use this API to modify any service requests that exist on a reservation. <p><strong>OperationId:</strong>putServiceRequests</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId
 @return FrontDeskOperationsAPIPutServiceRequestsRequest
*/
func (a *FrontDeskOperationsAPIService) PutServiceRequests(ctx context.Context, hotelId string) FrontDeskOperationsAPIPutServiceRequestsRequest {
	return FrontDeskOperationsAPIPutServiceRequestsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *FrontDeskOperationsAPIService) PutServiceRequestsExecute(r FrontDeskOperationsAPIPutServiceRequestsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FrontDeskOperationsAPIService.PutServiceRequests")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/serviceRequests"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.serviceRequestsInfo
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FrontDeskOperationsAPIPutWakeUpCallRequest struct {
	ctx context.Context
	ApiService *FrontDeskOperationsAPIService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	wakeUpCalls *WakeUpCalls
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r FrontDeskOperationsAPIPutWakeUpCallRequest) Authorization(authorization string) FrontDeskOperationsAPIPutWakeUpCallRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r FrontDeskOperationsAPIPutWakeUpCallRequest) XAppKey(xAppKey string) FrontDeskOperationsAPIPutWakeUpCallRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r FrontDeskOperationsAPIPutWakeUpCallRequest) XHotelid(xHotelid string) FrontDeskOperationsAPIPutWakeUpCallRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to change a wake up call.
func (r FrontDeskOperationsAPIPutWakeUpCallRequest) WakeUpCalls(wakeUpCalls WakeUpCalls) FrontDeskOperationsAPIPutWakeUpCallRequest {
	r.wakeUpCalls = &wakeUpCalls
	return r
}

// External system code.
func (r FrontDeskOperationsAPIPutWakeUpCallRequest) XExternalsystem(xExternalsystem string) FrontDeskOperationsAPIPutWakeUpCallRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r FrontDeskOperationsAPIPutWakeUpCallRequest) AcceptLanguage(acceptLanguage string) FrontDeskOperationsAPIPutWakeUpCallRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r FrontDeskOperationsAPIPutWakeUpCallRequest) Execute() (*ChangedWakeUpCalls, *http.Response, error) {
	return r.ApiService.PutWakeUpCallExecute(r)
}

/*
PutWakeUpCall Change Wake Up Call

Update an existing wake up call.  Wake up call can only be added to in-house reservations. <p><strong>OperationId:</strong>putWakeUpCall</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId
 @param hotelId
 @return FrontDeskOperationsAPIPutWakeUpCallRequest
*/
func (a *FrontDeskOperationsAPIService) PutWakeUpCall(ctx context.Context, reservationId string, hotelId string) FrontDeskOperationsAPIPutWakeUpCallRequest {
	return FrontDeskOperationsAPIPutWakeUpCallRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ChangedWakeUpCalls
func (a *FrontDeskOperationsAPIService) PutWakeUpCallExecute(r FrontDeskOperationsAPIPutWakeUpCallRequest) (*ChangedWakeUpCalls, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChangedWakeUpCalls
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FrontDeskOperationsAPIService.PutWakeUpCall")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/wakeUpCalls"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.wakeUpCalls
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FrontDeskOperationsAPIReadRoomKeyRequest struct {
	ctx context.Context
	ApiService *FrontDeskOperationsAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	encoderTerminal *string
	encoderId *string
	encoderIdContext *string
	encoderIdType *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r FrontDeskOperationsAPIReadRoomKeyRequest) Authorization(authorization string) FrontDeskOperationsAPIReadRoomKeyRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r FrontDeskOperationsAPIReadRoomKeyRequest) XAppKey(xAppKey string) FrontDeskOperationsAPIReadRoomKeyRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r FrontDeskOperationsAPIReadRoomKeyRequest) XHotelid(xHotelid string) FrontDeskOperationsAPIReadRoomKeyRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r FrontDeskOperationsAPIReadRoomKeyRequest) EncoderTerminal(encoderTerminal string) FrontDeskOperationsAPIReadRoomKeyRequest {
	r.encoderTerminal = &encoderTerminal
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r FrontDeskOperationsAPIReadRoomKeyRequest) EncoderId(encoderId string) FrontDeskOperationsAPIReadRoomKeyRequest {
	r.encoderId = &encoderId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r FrontDeskOperationsAPIReadRoomKeyRequest) EncoderIdContext(encoderIdContext string) FrontDeskOperationsAPIReadRoomKeyRequest {
	r.encoderIdContext = &encoderIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r FrontDeskOperationsAPIReadRoomKeyRequest) EncoderIdType(encoderIdType string) FrontDeskOperationsAPIReadRoomKeyRequest {
	r.encoderIdType = &encoderIdType
	return r
}

// External system code.
func (r FrontDeskOperationsAPIReadRoomKeyRequest) XExternalsystem(xExternalsystem string) FrontDeskOperationsAPIReadRoomKeyRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r FrontDeskOperationsAPIReadRoomKeyRequest) AcceptLanguage(acceptLanguage string) FrontDeskOperationsAPIReadRoomKeyRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r FrontDeskOperationsAPIReadRoomKeyRequest) Execute() (*RoomKeyStatus, *http.Response, error) {
	return r.ApiService.ReadRoomKeyExecute(r)
}

/*
ReadRoomKey Read room key

This API can be used to read the Room Key. <p><strong>OperationId:</strong>readRoomKey</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId
 @return FrontDeskOperationsAPIReadRoomKeyRequest
*/
func (a *FrontDeskOperationsAPIService) ReadRoomKey(ctx context.Context, hotelId string) FrontDeskOperationsAPIReadRoomKeyRequest {
	return FrontDeskOperationsAPIReadRoomKeyRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return RoomKeyStatus
func (a *FrontDeskOperationsAPIService) ReadRoomKeyExecute(r FrontDeskOperationsAPIReadRoomKeyRequest) (*RoomKeyStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RoomKeyStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FrontDeskOperationsAPIService.ReadRoomKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/roomKeysDetails"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.encoderTerminal != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "encoderTerminal", r.encoderTerminal, "")
  }
	if r.encoderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "encoderId", r.encoderId, "")
  }
	if r.encoderIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "encoderIdContext", r.encoderIdContext, "")
  }
	if r.encoderIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "encoderIdType", r.encoderIdType, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FrontDeskOperationsAPIReleaseRoomsOnHoldRequest struct {
	ctx context.Context
	ApiService *FrontDeskOperationsAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	holdRooms *HoldRooms
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r FrontDeskOperationsAPIReleaseRoomsOnHoldRequest) Authorization(authorization string) FrontDeskOperationsAPIReleaseRoomsOnHoldRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r FrontDeskOperationsAPIReleaseRoomsOnHoldRequest) XAppKey(xAppKey string) FrontDeskOperationsAPIReleaseRoomsOnHoldRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r FrontDeskOperationsAPIReleaseRoomsOnHoldRequest) XHotelid(xHotelid string) FrontDeskOperationsAPIReleaseRoomsOnHoldRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to release rooms from being held.
func (r FrontDeskOperationsAPIReleaseRoomsOnHoldRequest) HoldRooms(holdRooms HoldRooms) FrontDeskOperationsAPIReleaseRoomsOnHoldRequest {
	r.holdRooms = &holdRooms
	return r
}

// External system code.
func (r FrontDeskOperationsAPIReleaseRoomsOnHoldRequest) XExternalsystem(xExternalsystem string) FrontDeskOperationsAPIReleaseRoomsOnHoldRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r FrontDeskOperationsAPIReleaseRoomsOnHoldRequest) AcceptLanguage(acceptLanguage string) FrontDeskOperationsAPIReleaseRoomsOnHoldRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r FrontDeskOperationsAPIReleaseRoomsOnHoldRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.ReleaseRoomsOnHoldExecute(r)
}

/*
ReleaseRoomsOnHold Release Rooms On Hold

You can use this API to release Rooms On Hold. <p><strong>OperationId:</strong>releaseRoomsOnHold</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId
 @return FrontDeskOperationsAPIReleaseRoomsOnHoldRequest
*/
func (a *FrontDeskOperationsAPIService) ReleaseRoomsOnHold(ctx context.Context, hotelId string) FrontDeskOperationsAPIReleaseRoomsOnHoldRequest {
	return FrontDeskOperationsAPIReleaseRoomsOnHoldRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *FrontDeskOperationsAPIService) ReleaseRoomsOnHoldExecute(r FrontDeskOperationsAPIReleaseRoomsOnHoldRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FrontDeskOperationsAPIService.ReleaseRoomsOnHold")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/rooms/onHold/release"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.holdRooms
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FrontDeskOperationsAPIShiftRoomsRequest struct {
	ctx context.Context
	ApiService *FrontDeskOperationsAPIService
	hotelId string
	sourceReservationId string
	targetReservationId string
	authorization *string
	xAppKey *string
	xHotelid *string
	shiftRooms *ShiftRooms
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r FrontDeskOperationsAPIShiftRoomsRequest) Authorization(authorization string) FrontDeskOperationsAPIShiftRoomsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r FrontDeskOperationsAPIShiftRoomsRequest) XAppKey(xAppKey string) FrontDeskOperationsAPIShiftRoomsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r FrontDeskOperationsAPIShiftRoomsRequest) XHotelid(xHotelid string) FrontDeskOperationsAPIShiftRoomsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to Shift Rooms between two selected reservations (from the same property), that are for the same arrival date and room type.
func (r FrontDeskOperationsAPIShiftRoomsRequest) ShiftRooms(shiftRooms ShiftRooms) FrontDeskOperationsAPIShiftRoomsRequest {
	r.shiftRooms = &shiftRooms
	return r
}

// External system code.
func (r FrontDeskOperationsAPIShiftRoomsRequest) XExternalsystem(xExternalsystem string) FrontDeskOperationsAPIShiftRoomsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r FrontDeskOperationsAPIShiftRoomsRequest) AcceptLanguage(acceptLanguage string) FrontDeskOperationsAPIShiftRoomsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r FrontDeskOperationsAPIShiftRoomsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.ShiftRoomsExecute(r)
}

/*
ShiftRooms Operation for Shift Rooms between two reservations

This API will allow you to quickly shift rooms for two reservations. <p><strong>OperationId:</strong>shiftRooms</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId
 @param sourceReservationId
 @param targetReservationId
 @return FrontDeskOperationsAPIShiftRoomsRequest
*/
func (a *FrontDeskOperationsAPIService) ShiftRooms(ctx context.Context, hotelId string, sourceReservationId string, targetReservationId string) FrontDeskOperationsAPIShiftRoomsRequest {
	return FrontDeskOperationsAPIShiftRoomsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
		sourceReservationId: sourceReservationId,
		targetReservationId: targetReservationId,
	}
}

// Execute executes the request
//  @return Status
func (a *FrontDeskOperationsAPIService) ShiftRoomsExecute(r FrontDeskOperationsAPIShiftRoomsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FrontDeskOperationsAPIService.ShiftRooms")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/sourceReservations/{sourceReservationId}/targetReservations/{targetReservationId}/shiftRooms"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sourceReservationId"+"}", url.PathEscape(parameterValueToString(r.sourceReservationId, "sourceReservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"targetReservationId"+"}", url.PathEscape(parameterValueToString(r.targetReservationId, "targetReservationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if strlen(r.sourceReservationId) < 1 {
		return localVarReturnValue, nil, reportError("sourceReservationId must have at least 1 elements")
	}
	if strlen(r.sourceReservationId) > 2000 {
		return localVarReturnValue, nil, reportError("sourceReservationId must have less than 2000 elements")
	}
	if strlen(r.targetReservationId) < 1 {
		return localVarReturnValue, nil, reportError("targetReservationId must have at least 1 elements")
	}
	if strlen(r.targetReservationId) > 2000 {
		return localVarReturnValue, nil, reportError("targetReservationId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.shiftRooms
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FrontDeskOperationsAPISwapRoomsRequest struct {
	ctx context.Context
	ApiService *FrontDeskOperationsAPIService
	hotelId string
	sourceReservationId string
	targetReservationId string
	authorization *string
	xAppKey *string
	xHotelid *string
	swapRooms *SwapRooms
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r FrontDeskOperationsAPISwapRoomsRequest) Authorization(authorization string) FrontDeskOperationsAPISwapRoomsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r FrontDeskOperationsAPISwapRoomsRequest) XAppKey(xAppKey string) FrontDeskOperationsAPISwapRoomsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r FrontDeskOperationsAPISwapRoomsRequest) XHotelid(xHotelid string) FrontDeskOperationsAPISwapRoomsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to Swap Rooms between two selected reservations (from the same property), that are for the same arrival date and room type.
func (r FrontDeskOperationsAPISwapRoomsRequest) SwapRooms(swapRooms SwapRooms) FrontDeskOperationsAPISwapRoomsRequest {
	r.swapRooms = &swapRooms
	return r
}

// External system code.
func (r FrontDeskOperationsAPISwapRoomsRequest) XExternalsystem(xExternalsystem string) FrontDeskOperationsAPISwapRoomsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r FrontDeskOperationsAPISwapRoomsRequest) AcceptLanguage(acceptLanguage string) FrontDeskOperationsAPISwapRoomsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r FrontDeskOperationsAPISwapRoomsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.SwapRoomsExecute(r)
}

/*
SwapRooms Operation for Swap/Shift Rooms between two reservations

This API will allow you to quickly swap rooms for two reservations. <p><strong>OperationId:</strong>swapRooms</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId
 @param sourceReservationId
 @param targetReservationId
 @return FrontDeskOperationsAPISwapRoomsRequest
*/
func (a *FrontDeskOperationsAPIService) SwapRooms(ctx context.Context, hotelId string, sourceReservationId string, targetReservationId string) FrontDeskOperationsAPISwapRoomsRequest {
	return FrontDeskOperationsAPISwapRoomsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
		sourceReservationId: sourceReservationId,
		targetReservationId: targetReservationId,
	}
}

// Execute executes the request
//  @return Status
func (a *FrontDeskOperationsAPIService) SwapRoomsExecute(r FrontDeskOperationsAPISwapRoomsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FrontDeskOperationsAPIService.SwapRooms")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/sourceReservations/{sourceReservationId}/targetReservations/{targetReservationId}/swapRooms"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sourceReservationId"+"}", url.PathEscape(parameterValueToString(r.sourceReservationId, "sourceReservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"targetReservationId"+"}", url.PathEscape(parameterValueToString(r.targetReservationId, "targetReservationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if strlen(r.sourceReservationId) < 1 {
		return localVarReturnValue, nil, reportError("sourceReservationId must have at least 1 elements")
	}
	if strlen(r.sourceReservationId) > 2000 {
		return localVarReturnValue, nil, reportError("sourceReservationId must have less than 2000 elements")
	}
	if strlen(r.targetReservationId) < 1 {
		return localVarReturnValue, nil, reportError("targetReservationId must have at least 1 elements")
	}
	if strlen(r.targetReservationId) > 2000 {
		return localVarReturnValue, nil, reportError("targetReservationId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.swapRooms
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FrontDeskOperationsAPIVerifyCheckinReservationRequest struct {
	ctx context.Context
	ApiService *FrontDeskOperationsAPIService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	verifyCheckinInstructions *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r FrontDeskOperationsAPIVerifyCheckinReservationRequest) Authorization(authorization string) FrontDeskOperationsAPIVerifyCheckinReservationRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r FrontDeskOperationsAPIVerifyCheckinReservationRequest) XAppKey(xAppKey string) FrontDeskOperationsAPIVerifyCheckinReservationRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r FrontDeskOperationsAPIVerifyCheckinReservationRequest) XHotelid(xHotelid string) FrontDeskOperationsAPIVerifyCheckinReservationRequest {
	r.xHotelid = &xHotelid
	return r
}

// Instruction to exclude suggested rooms.
func (r FrontDeskOperationsAPIVerifyCheckinReservationRequest) VerifyCheckinInstructions(verifyCheckinInstructions []string) FrontDeskOperationsAPIVerifyCheckinReservationRequest {
	r.verifyCheckinInstructions = &verifyCheckinInstructions
	return r
}

// External system code.
func (r FrontDeskOperationsAPIVerifyCheckinReservationRequest) XExternalsystem(xExternalsystem string) FrontDeskOperationsAPIVerifyCheckinReservationRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r FrontDeskOperationsAPIVerifyCheckinReservationRequest) AcceptLanguage(acceptLanguage string) FrontDeskOperationsAPIVerifyCheckinReservationRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r FrontDeskOperationsAPIVerifyCheckinReservationRequest) Execute() (*VerifiedCheckinReservation, *http.Response, error) {
	return r.ApiService.VerifyCheckinReservationExecute(r)
}

/*
VerifyCheckinReservation Verify checkin reservation

Use this API to verify checkin reservations. <p><strong>OperationId:</strong>verifyCheckinReservation</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId
 @param hotelId
 @return FrontDeskOperationsAPIVerifyCheckinReservationRequest
*/
func (a *FrontDeskOperationsAPIService) VerifyCheckinReservation(ctx context.Context, reservationId string, hotelId string) FrontDeskOperationsAPIVerifyCheckinReservationRequest {
	return FrontDeskOperationsAPIVerifyCheckinReservationRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return VerifiedCheckinReservation
func (a *FrontDeskOperationsAPIService) VerifyCheckinReservationExecute(r FrontDeskOperationsAPIVerifyCheckinReservationRequest) (*VerifiedCheckinReservation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VerifiedCheckinReservation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FrontDeskOperationsAPIService.VerifyCheckinReservation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/verifyCheckIns"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.verifyCheckinInstructions != nil {
		t := *r.verifyCheckinInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "verifyCheckinInstructions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "verifyCheckinInstructions", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
